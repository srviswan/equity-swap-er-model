

================================================================================
FILE: rosetta-source/src/main/rosetta/base-datetime-daycount-enum.rosetta
================================================================================

namespace cdm.base.datetime.daycount: <"Day count concepts:  Day count fraction, day count basis, year fraction">
version "${project.version}"

enum DayCountFractionEnum: <"The enumerated values to specify the day count fraction.">
    ACT_360 displayName "ACT/360" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (v), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (e) or Annex to the 2000 ISDA Definitions (June 2000 Version), Section 4.16. Day Count Fraction, paragraph (d).">
    ACT_365L displayName "ACT/365L" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (ix), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (i).">
    ACT_364 displayName "ACT/364" <"Per CFTC definitions.">
    ACT_365_FIXED displayName "ACT/365.FIXED" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (iv), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (d) or Annex to the 2000 ISDA Definitions (June 2000 Version), Section 4.16. Day Count Fraction, paragraph (c).">
    ACT_ACT_AFB displayName "ACT/ACT.AFB" <"The Fixed/Floating Amount will be calculated in accordance with the 'BASE EXACT/EXACT' day count fraction, as defined in the 'Definitions Communes plusieurs Additifs Techniques' published by the Association Francaise des Banques in September 1994.">
    ACT_ACT_ICMA displayName "ACT/ACT.ICMA" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (iii), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (c). This day count fraction code is applicable for transactions booked under the 2021 ISDA Definitions and the 2006 ISDA Definitions. Transactions under the 2000 ISDA Definitions should use the ACT/ACT.ISMA code instead.">
    ACT_ACT_ISDA displayName "ACT/ACT.ISDA" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (ii), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (b) or Annex to the 2000 ISDA Definitions (June 2000 Version), Section 4.16. Day Count Fraction, paragraph (b). Note that going from FpML 2.0 Recommendation to the FpML 3.0 Trial Recommendation the code in FpML 2.0 'ACT/365.ISDA' became 'ACT/ACT.ISDA'.">
    ACT_ACT_ISMA displayName "ACT/ACT.ISMA" <"The Fixed/Floating Amount will be calculated in accordance with Rule 251 of the statutes, by-laws, rules and recommendations of the International Securities Market Association, as published in April 1999, as applied to straight and convertible bonds issued after December 31, 1998, as though the Fixed/Floating Amount were the interest coupon on such a bond. This day count fraction code is applicable for transactions booked under the 2000 ISDA Definitions. Transactions under the 2021 ISDA Definitions and the 2006 ISDA Definitions should use the ACT/ACT.ICMA code instead.">
    CAL_252 displayName "CAL/252" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (x). Supercedes BUS/252, the number of Business Days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 252.">
    _1_1 displayName "1/1" <"Per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (a) or Annex to the 2000 ISDA Definitions (June 2000 Version), Section 4.16. Day Count Fraction, paragraph (a).">
    _30E_360 displayName "30E/360" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (vii), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (g) or Annex to the 2000 ISDA Definitions (June 2000 Version), Section 4.16. Day Count Fraction, paragraph (f). Note that the algorithm defined for this day count fraction has changed between the 2000 ISDA Definitions and 2006 ISDA Definitions. See Introduction to the 2006 ISDA Definitions for further information relating to this change.">
    _30E_360_ISDA displayName "30E/360.ISDA" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (viii), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (h). Note the algorithm for this day count fraction under the 2006 ISDA Definitions is designed to yield the same results in practice as the version of the 30E/360 day count fraction defined in the 2000 ISDA Definitions. See Introduction to the 2006 ISDA Definitions for further information relating to this change.">
    _30_360 displayName "30/360" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (vi), per 2006 ISDA Definitions, Section 4.16. Day Count Fraction, paragraph (f) or Annex to the 2000 ISDA Definitions (June 2000 Version), Section 4.16. Day Count Fraction, paragraph (e).">
    RBA_BOND_BASIS displayName "RBA Bond Basis" <"Per 2021 ISDA Definitions, Section 4.6.1 Day Count Fraction, paragraph (xi), the calculation mechanics are driven deterministically by the Calculation Period Frequency (i.e. 0.25 if it is three months, 0.5 if it is 6 months, 1 if it is a year), except that if the first Calculation Period or the final Calculation Period is less than the Calculation Period Frequency, Actual/Actual (ISDA) shall apply to that Calculation Period">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-datetime-daycount-func.rosetta
================================================================================

namespace cdm.base.datetime.daycount: <"Day count concepts:  Day count fraction, day count basis, year fraction">
version "${project.version}"

import cdm.base.datetime.*

// ** following is the new year fraction calculation logic, which is independent of the calculation period generation logic
func YearFraction: <"The fraction of a year represented by a date range">
    [codeImplementation]
    [calculation]
    inputs:
        dayCountFractionEnum DayCountFractionEnum (1..1) <"The day count fraction to use">
        startDate date (1..1) <"The start date of the range for which the year fraction is required">
        endDate date (1..1) <"The end date of the range for which the year fraction is required">
        terminationDate date (0..1) <"The termination date of the payout; this is needed for some day count fractions">
        periodsInYear int (0..1) <"The number of periods in a year in the payout; this is needed for some day count fractions">
    output:
        result number (1..1) <"The fraction of a year represented by period from the startDate to the endDate">

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _1_1): <"2006 ISDA Definition Article 4 section 4.16(a):	if '1/1' is specified, 1;.">
    [calculation]
    set result: 1.0

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_ACT_ISDA): <"'2021 ISDA Definitions Section 4.6.1(ii): if 'Actual/Actual', 'Actual/Actual(ISDA)', 'Act/Act' or 'Act/Act(ISDA)' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which the calculation is being made divided by 365 (or, if any portion of that Calculation Period or Compounding Period falls in a leap year, the sum of (1) the actual number of days in that portion of the Calculation Period or Compounding Period falling in a leap year divided by 366 and (2) the actual number of days in that portion of the Calculation Period or Compounding Period falling a non-leap year divided by 365), calculated as follows: (daysInNonLeapPeriod/365)+(daysInLeapYearPeriod/366)' '2006 ISDA Definition Article 4 section 4.16(b): if 'Actual/Actual', 'Actual/Actual(ISDA)', 'Act/Act' or 'Act/Act(ISDA)' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which the calculation is being made divided by 365 (or, if any portion of that Calculation Period or Compounding Period falls in a leap year, the sum of (1) the actual number of days in that portion of the Calculation Period or Compounding Period falling in a leap year divided by 366 and (2) the actual number of days in that portion of the Calculation Period or Compounding Period falling a non-leap year divided by 365).'">
    [calculation]
    alias daysInPeriod: DateDifference(startDate, endDate)
    alias daysInLeapYearPeriod: <"the actual number of days in that portion of the Calculation Period or Compounding Period falling in a leap year.">
        LeapYearDateDifference(startDate, endDate)
    alias daysInNonLeapPeriod: <"the actual number of days in that portion of the Calculation Period or Compounding Period falling in a non-leap year, equal to the difference between (a) the total days in the period and (b) the days in leap year period.">
        daysInPeriod - daysInLeapYearPeriod
    set result: (daysInNonLeapPeriod / 365) + (daysInLeapYearPeriod / 366)

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_ACT_ICMA): <"'2021 ISDA Definitions Section 4.6.1(iii): if 'Actual/Actual(ICMA)' or 'Act/Act(ICMA)'' is specified, a fraction calculated in accordance with Rule 251 of the statutes, by-laws, rules and recommendations of the International Capital Market Association (or any successor thereto), as applied to non-U.S. Dollar denominated straight and convertible bonds issued after December 31, 1998, as though the interest coupon on a bond were being calculated for a coupon period corresponding to the relevant Calculation Period or Compounding Period.' '2006 ISDA Definition Article 4 section 4.16(c):	(c)	if 'Actual/Actual (ICMA)' or 'Act/Act (ICMA)' is specified, a fraction equal to 'number of days accrued/number of days in year', as such terms are used in Rule 251 of the statutes, by-laws, rules and recommendations of the International Capital Market Association (the 'ICMA Rule Book'), calculated in accordance with Rule 251 of the ICMA Rule Book as applied to non US dollar denominated straight and convertible bonds issued after December 31, 1998, as though the interest coupon on a bond were being calculated for a coupon period corresponding to the Calculation Period or Compounding Period in respect of which payment is being made;.">
    [calculation]
    alias daysInPeriod: DateDifference(startDate, endDate)
    set result: daysInPeriod / (daysInPeriod * periodsInYear)

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_365_FIXED): <"'2021 ISDA Definitions Section 4.6.1(iv): if 'Actual/365(Fixed)', 'Act/365(Fixed)', 'A/365(Fixed)'or 'A/365F' is specified, the actual number of days in the relevant Calculation Period or Compounding Period divided by 365, calculated as follows: (daysInPeriod/365)' '2006 ISDA Definition Article 4 section 4.16(d): If 'Actual/365 (Fixed)', 'Act/365 (Fixed)', 'A/365 (Fixed)' or 'A/365F' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365.">
    [calculation]
    alias daysInPeriod: DateDifference(startDate, endDate)
    set result: daysInPeriod / 365

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_360): <"'2021 ISDA Definitions Section 4.6.1(v): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the relevant Calculation Period or Compounding Period divided by 360, calculated as follows: (daysInPeriod/360)' '2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.'">
    [calculation]
    alias daysInPeriod: DateDifference(startDate, endDate)
    set result: daysInPeriod / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30_360): <"'2021 ISDA Definitions Section 4.6.1(vi): if '30/360', '360/360' or 'Bond Basis' is specified, the number of days in the relevant Calculation Period or Compounding Period divided by 360, calculated as follows: [360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360' '2006 ISDA Definition Article 4 section 4.16(f): if '30/360', '360/360' or 'Bond Basis' is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows:[[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360.''">
    [calculation]

    alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
        startDate -> year

    alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
        endDate -> year

    alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
        startDate -> month

    alias endMonth: <"The calendar month, expressed as number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
        endDate -> month

    alias endDay: <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31 and D1, is greater than 29, in which case D2 will be 30.">
        if startDate -> day > 29
        then Min(endDate -> day, 30)
        else endDate -> day

    alias startDay: <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case, will be 30.">
        Min(startDate -> day, 30)
    set result:
        (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360): <"'2021 ISDA Definitions Section 4.6.1(vii): if '30E/360' or 'Eurobond Basis' is specified, the number of days in the relevant Calculation Period or Compounding Period divided by 360, calculated as follows: [[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360' '2006 ISDA Definition Article 4 section 4.16(e): if 'Actual/360', 'Act/360' or 'A/360' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360 calculated on a formula basis as follows:[[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360.'">
    [calculation]

    alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
        startDate -> year

    alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
        endDate -> year

    alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
        startDate -> month

    alias endMonth: <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
        endDate -> month

    alias endDay: <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30.">
        Min(endDate -> day, 30)

    alias startDay: <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30.">
        Min(startDate -> day, 30)
    set result:
        (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360_ISDA): <"2006 ISDA Definition Article 4 section 4.16(h): if '30E/360 (ISDA)' is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows: [[360 × (Y2 - Y1)]+[30 × (M2 - M1)] +(D2 - D1)]/360 .">
    [calculation]

    alias startDateIsInLeapYear: IsLeapYear(startDate -> year)

    alias endDateIsInLeapYear: IsLeapYear(endDate -> year)

    alias startYear: <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
        startDate -> year

    alias endYear: <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
        endDate -> year

    alias startMonth: <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls.">
        startDate -> month

    alias endMonth: <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls.">
        endDate -> month

    alias startDay:
        if startDateIsInLeapYear = False
                    and startDate -> month = 2
                    and startDate -> day = 28
                or startDateIsInLeapYear = True
                    and startDate -> month = 2
                    and startDate -> day = 29
                or startDate -> day = 31
        then 30
        else endDate -> day

    alias endDay:
        if endDateIsInLeapYear = False and endDate -> month = 2 and endDate -> day = 28
                or endDateIsInLeapYear = True
                    and endDate -> month = 2
                    and endDate -> day = 29
                or endDate -> day = 31
                or endDate = terminationDate
        then 30
        else endDate -> day
    set result:
        (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_364): <"the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 364.">
    [calculation]
    alias daysInPeriod: DateDifference(startDate, endDate)
    set result: daysInPeriod / 364

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> ACT_365L): <"'2021 ISDA Definitions Section 4.6.1(ix): if 'Act/365L' is specified, the actual number of days in the relevant Calculation Period or Compounding Period divided by 365 (or, if the later Period End Date of the Calculation Period or Compounding Date of the Compounding Period falls in a leap year, divided by 366)' 'The actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365 (or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366).'">
    [calculation]

    alias endDateIsInLeapYear: IsLeapYear(endDate -> year)

    alias daysInPeriod: DateDifference(startDate, endDate)

    alias daysInYear: <"365 or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366.">
        if (endDateIsInLeapYear = True) then 366 else 365

    set result: daysInPeriod / daysInYear

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> CAL_252): <"'2021 ISDA Definitions Section 4.6.1(x): if 'Calculation/252' is specified, the actual number of Calculation Days in the relevant Calculation Period or Compounding Period divided by 252, calculated as follows: [daysInPeriod/252], where 'daysInPeriod' is, unless otherwise specified in the Confirmation, in respect of the relevant Floating Amount or Fixed Amount to which this Day Count Fraction applies, the Business Days in the relevant Calculation Period or Compounding Period determined by reference to the Business Day and Business Day Convention applicable to the determination of such Floating Amount or Fixed Amount, as applicable.">
    [calculation]
    alias daysInPeriod: DateDifference(startDate, endDate)
    set result: daysInPeriod / 252

func YearFractionForOneDay: <"Return the year fraction represented by a single day, i.e 1 / dayCountBasis, where daycountBasis represents the denominator of the day count fraction. This perhaps should take into account leap years, though the ISDA compounding formulas do not cover ACT basis at the moment.">
    [calculation]
    inputs:
        dcf DayCountFractionEnum (1..1) <"Supplied Day count fraction.">
    output:
        yearFrac number (1..1) <"Corresponding year fraction.">
    // calculate and return the value from the DayCountBasis
    set yearFrac: 1 / DayCountBasis(dcf)

func DayCountBasis: <"Return the day count basis (the denominator of the day count fraction) for the day count fraction.">
    [codeImplementation]
    [calculation]
    inputs:
        dcf DayCountFractionEnum (1..1) <"Day count fraction.">
    output:
        basis int (1..1) <"The corresponding basis, typically 360 or 365.">

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_360):
    set basis: 360

func DayCountBasis(dcf: DayCountFractionEnum -> _30_360):
    set basis: 360

func DayCountBasis(dcf: DayCountFractionEnum -> _30E_360):
    set basis: 360

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_365L):
    set basis: 365

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_365_FIXED):
    set basis: 365

// the following day count bases are under review by ISDA Legal and may be updated in a future version of CDM
func DayCountBasis(dcf: DayCountFractionEnum -> ACT_ACT_AFB):
    set basis: 365 // Should this support 366 in leap years?  requires passing in the actual dates

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_ACT_ISDA):
    set basis: 365 // Should this support 366 in leap years?  requires passing in the actual dates

func DayCountBasis(dcf: DayCountFractionEnum -> ACT_ACT_ICMA):
    set basis: 365 // Should this support 366 in leap years? requires passing in the actual dates

func DayCountBasis(dcf: DayCountFractionEnum -> CAL_252):
    set basis: 252


================================================================================
FILE: rosetta-source/src/main/rosetta/base-datetime-enum.rosetta
================================================================================

namespace cdm.base.datetime : <"Basic date and time concepts: relative date, date range, offset, business centre etc.">
version "${project.version}"

import cdm.base.*

enum BusinessCenterEnum: <"The enumerated values to specify the business centers.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/business-center"]

    AEAB <"Abu Dhabi, Business Day (as defined in 2021 ISDA Definitions Section 2.1.10 (ii))">
    AEAD <"Abu Dhabi, Settlement Day (as defined in 2021 ISDA Definitions Section 2.1.10 (i))">
    AEDU <"Dubai, United Arab Emirates">
    AMYE <"Yerevan, Armenia">
    AOLU <"Luanda, Angola">
    ARBA <"Buenos Aires, Argentina">
    ATVI <"Vienna, Austria">
    AUAD <"Adelaide, Australia">
    AUBR <"Brisbane, Australia">
    AUCA <"Canberra, Australia">
    AUDA <"Darwin, Australia">
    AUME <"Melbourne, Australia">
    AUPE <"Perth, Australia">
    AUSY <"Sydney, Australia">
    AZBA <"Baku, Azerbaijan">
    BBBR <"Bridgetown, Barbados">
    BDDH <"Dhaka, Bangladesh">
    BEBR <"Brussels, Belgium">
    BGSO <"Sofia, Bulgaria">
    BHMA <"Manama, Bahrain">
    BMHA <"Hamilton, Bermuda">
    BNBS <"Bandar Seri Begawan, Brunei">
    BOLP <"La Paz, Bolivia">
    BRBD <"Brazil Business Day.">
    BRBR <"Brasilia, Brazil.">
    BRRJ <"Rio de Janeiro, Brazil.">
    BRSP <"Sao Paulo, Brazil.">
    BSNA <"Nassau, Bahamas">
    BWGA <"Gaborone, Botswana">
    BYMI <"Minsk, Belarus">
    CACL <"Calgary, Canada">
    CAFR <"Fredericton, Canada.">
    CAMO <"Montreal, Canada">
    CAOT <"Ottawa, Canada">
    CATO <"Toronto, Canada">
    CAVA <"Vancouver, Canada">
    CAWI <"Winnipeg, Canada">
    CHBA <"Basel, Switzerland">
    CHGE <"Geneva, Switzerland">
    CHZU <"Zurich, Switzerland">
    CIAB <"Abidjan, Cote d'Ivoire">
    CLSA <"Santiago, Chile">
    CMYA <"Yaounde, Cameroon">
    CNBE <"Beijing, China">
    CNSH <"Shanghai, China">
    COBO <"Bogota, Colombia">
    CRSJ <"San Jose, Costa Rica">
    CWWI <"Willemstad, Curacao">
    CYNI <"Nicosia, Cyprus">
    CZPR <"Prague, Czech Republic">
    DECO <"Cologne, Germany">
    DEDU <"Dusseldorf, Germany">
    DEFR <"Frankfurt, Germany">
    DEHA <"Hannover, Germany">
    DEHH <"Hamburg, Germany">
    DELE <"Leipzig, Germany">
    DEMA <"Mainz, Germany">
    DEMU <"Munich, Germany">
    DEST <"Stuttgart, Germany">
    DKCO <"Copenhagen, Denmark">
    DOSD <"Santo Domingo, Dominican Republic">
    DZAL <"Algiers, Algeria">
    ECGU <"Guayaquil, Ecuador">
    EETA <"Tallinn, Estonia">
    EGCA <"Cairo, Egypt">
    ESAS <"ESAS Settlement Day (as defined in 2006 ISDA Definitions Section 7.1 and Supplement Number 15 to the 2000 ISDA Definitions)">
    ESBA <"Barcelona, Spain">
    ESMA <"Madrid, Spain">
    ESSS <"San Sebastian, Spain">
    ETAA <"Addis Ababa, Ethiopia">
    EUR_ICESWAP displayName "EUR-ICESWAP" <"Publication dates for ICE Swap rates based on EUR-EURIBOR rates">
    EUTA <"TARGET Settlement Day">
    FIHE <"Helsinki, Finland">
    FRPA <"Paris, France">
    GBED <"Edinburgh, Scotland">
    GBLO <"London, United Kingdom">
    GBP_ICESWAP displayName "GBP-ICESWAP" <"Publication dates for GBP ICE Swap rates">
    GETB <"Tbilisi, Georgia">
    GGSP <"Saint Peter Port, Guernsey">
    GHAC <"Accra, Ghana">
    GIGI <"Gibraltar, Gibraltar">
    GMBA <"Banjul, Gambia">
    GNCO <"Conakry, Guinea">
    GRAT <"Athens, Greece">
    GTGC <"Guatemala City, Guatemala">
    GUGC <"Guatemala City, Guatemala [DEPRECATED, to be removed in 2024. Replaced by GTGC.]">
    HKHK <"Hong Kong, Hong Kong">
    HNTE <"Tegucigalpa, Honduras">
    HRZA <"Zagreb, Republic of Croatia">
    HUBU <"Budapest, Hungary">
    IDJA <"Jakarta, Indonesia">
    IEDU <"Dublin, Ireland">
    ILJE <"Jerusalem, Israel">
    ILS_SHIR displayName "ILS-SHIR" <"Publication dates of the ILS-SHIR index.">
    ILS_TELBOR displayName "ILS-TELBOR" <"Publication dates of the ILS-TELBOR index.">
    ILTA <"Tel Aviv, Israel">
    INAH <"Ahmedabad, India">
    INBA <"Bangalore, India">
    INCH <"Chennai, India">
    INHY <"Hyderabad, India">
    INKO <"Kolkata, India">
    INMU <"Mumbai, India">
    INND <"New Delhi, India">
    IQBA <"Baghdad, Iraq">
    IRTE <"Teheran, Iran">
    ISRE <"Reykjavik, Iceland">
    ITMI <"Milan, Italy">
    ITRO <"Rome, Italy">
    ITTU <"Turin, Italy">
    JESH <"St. Helier, Channel Islands, Jersey">
    JMKI <"Kingston, Jamaica">
    JOAM <"Amman, Jordan">
    JPTO <"Tokyo, Japan">
    KENA <"Nairobi, Kenya">
    KHPP <"Phnom Penh, Cambodia">
    KRSE <"Seoul, Republic of Korea">
    KWKC <"Kuwait City, Kuwait">
    KYGE <"George Town, Cayman Islands">
    KZAL <"Almaty, Kazakhstan">
    LAVI <"Vientiane, Laos">
    LBBE <"Beirut, Lebanon">
    LKCO <"Colombo, Sri Lanka">
    LULU <"Luxembourg, Luxembourg">
    LVRI <"Riga, Latvia">
    MACA <"Casablanca, Morocco">
    MARA <"Rabat, Morocco">
    MCMO <"Monaco, Monaco">
    MNUB <"Ulan Bator, Mongolia">
    MOMA <"Macau, Macao">
    MTVA <"Valletta, Malta">
    MUPL <"Port Louis, Mauritius">
    MVMA <"Male, Maldives">
    MWLI <"Lilongwe, Malawi">
    MXMC <"Mexico City, Mexico">
    MYKL <"Kuala Lumpur, Malaysia">
    MYLA <"Labuan, Malaysia">
    MZMA <"Maputo, Mozambique">
    NAWI <"Windhoek, Namibia">
    NGAB <"Abuja, Nigeria">
    NGLA <"Lagos, Nigeria">
    NLAM <"Amsterdam, Netherlands">
    NLRO <"Rotterdam, Netherlands">
    NOOS <"Oslo, Norway">
    NPKA <"Kathmandu, Nepal">
    NYFD <"New York Fed Business Day (as defined in 2006 ISDA Definitions Section 1.9, 2000 ISDA Definitions Section 1.9, and 2021 ISDA Definitions Section 2.1.7)">
    NYSE <"New York Stock Exchange Business Day (as defined in 2006 ISDA Definitions Section 1.10, 2000 ISDA Definitions Section 1.10, and 2021 ISDA Definitions Section 2.1.8)">
    NZAU <"Auckland, New Zealand">
    NZBD <"New Zealand Business Day (proposed effective date: 2025-10-06)">
    NZWE <"Wellington, New Zealand">
    OMMU <"Muscat, Oman">
    PAPC <"Panama City, Panama">
    PELI <"Lima, Peru">
    PHMA <"Manila, Philippines">
    PHMK <"Makati, Philippines">
    PKKA <"Karachi, Pakistan">
    PLWA <"Warsaw, Poland">
    PRSJ <"San Juan, Puerto Rico">
    PTLI <"Lisbon, Portugal">
    QADO <"Doha, Qatar">
    ROBU <"Bucharest, Romania">
    RSBE <"Belgrade, Serbia">
    RUMO <"Moscow, Russian Federation">
    SAAB <"Abha, Saudi Arabia">
    SAJE <"Jeddah, Saudi Arabia">
    SARI <"Riyadh, Saudi Arabia">
    SEST <"Stockholm, Sweden">
    SGSI <"Singapore, Singapore">
    SILJ <"Ljubljana, Slovenia">
    SKBR <"Bratislava, Slovakia">
    SLFR <"Freetown, Sierra Leone">
    SNDA <"Dakar, Senegal">
    SVSS <"San Salvador, El Salvador">
    THBA <"Bangkok, Thailand">
    TNTU <"Tunis, Tunisia">
    TRAN <"Ankara, Turkey">
    TRIS <"Istanbul, Turkey">
    TTPS <"Port of Spain, Trinidad and Tobago">
    TWTA <"Taipei, Taiwan">
    TZDA <"Dar es Salaam, Tanzania">
    TZDO <"Dodoma, Tanzania">
    UAKI <"Kiev, Ukraine">
    UGKA <"Kampala, Uganda">
    USBO <"Boston, Massachusetts, United States">
    USCH <"Chicago, United States">
    USCR <"Charlotte, North Carolina, United States">
    USDC <"Washington, District of Columbia, United States">
    USD_ICESWAP displayName "USD-ICESWAP" <"Publication dates for ICE Swap rates based on USD-LIBOR rates">
    USD_MUNI displayName "USD-MUNI" <"Publication dates for the USD-Municipal Swap Index">
    USDN <"Denver, United States">
    USDT <"Detroit, Michigan, United States">
    USGS <"U.S. Government Securities Business Day (as defined in 2006 ISDA Definitions Section 1.11 and 2000 ISDA Definitions Section 1.11)">
    USHL <"Honolulu, Hawaii, United States">
    USHO <"Houston, United States">
    USLA <"Los Angeles, United States">
    USMB <"Mobile, Alabama, United States">
    USMN <"Minneapolis, United States">
    USNY <"New York, United States">
    USPO <"Portland, Oregon, United States">
    USSA <"Sacramento, California, United States">
    USSE <"Seattle, United States">
    USSF <"San Francisco, United States">
    USWT <"Wichita, United States">
    UYMO <"Montevideo, Uruguay">
    UZTA <"Tashkent, Uzbekistan">
    VECA <"Caracas, Venezuela">
    VGRT <"Road Town, Virgin Islands (British)">
    VNHA <"Hanoi, Vietnam">
    VNHC <"Ho Chi Minh (formerly Saigon), Vietnam">
    YEAD <"Aden, Yemen">
    ZAJO <"Johannesburg, South Africa">
    ZMLU <"Lusaka, Zambia">
    ZWHA <"Harare, Zimbabwe">

enum CommodityBusinessCalendarEnum:
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/commodity-business-calendar"]

    ADSM <"Abu Dhabi Securities Exchange https://www.adx.ae/">
    AGRUS_FMB displayName "AGRUS-FMB" <"Argus Media Fertilizer Reports. http://www.argusmedia.com/Fertilizer">
    APPI <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ARGUS_CRUDE displayName "ARGUS-CRUDE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ARGUS_EUROPEAN_GAS displayName "ARGUS-EUROPEAN-GAS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ARGUS_EUROPEAN_PRODUCTS displayName "ARGUS-EUROPEAN-PRODUCTS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ARGUS_INTERNATIONAL_LPG displayName "ARGUS-INTERNATIONAL-LPG" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ARGUS_MCCLOSKEYS_COAL_REPORT displayName "ARGUS-MCCLOSKEYS-COAL-REPORT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ARGUS_US_PRODUCTS displayName "ARGUS-US-PRODUCTS" <"The Argus US Products report. http://www.argusmedia.com/Petroleum/Petroleum-Products/Argus-US-Products">
    ASX <"Australian Securities Exchange http://www.asx.com.au/">
    AWB <"Australian Wheat Board. www.awb.com.au">
    AWEX <"Australian Wool Exchange. http://www.awex.com.au/home.html">
    BALTIC_EXCHANGE displayName "BALTIC-EXCHANGE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    BANK_NEGARA_MALAYSIA_POLICY_COMMITTEE displayName "BANK-NEGARA-MALAYSIA-POLICY-COMMITTEE" <"The business calendar of the Bank Negara Malaysia Policy Committee.">
    BELPEX <"The business calendar for the Belpex power exchange (www.belpex.be).">
    BLUENEXT <"BlueNext Power Market.">
    BM_F displayName "BM&F" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    BURSA_MALAYSIA_SETTLEMENT displayName "BURSA-MALAYSIA-SETTLEMENT" <"The settlement business calendar for Bursa Malaysia.">
    BURSA_MALAYSIA_TRADING displayName "BURSA-MALAYSIA-TRADING" <"The trading business calendar for Bursa Malaysia.">
    CANADIAN_GAS_PRICE_REPORTER displayName "CANADIAN-GAS-PRICE-REPORTER" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    CBOT_SOFT displayName "CBOT-SOFT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    CMAI_AROMATICS_MARKET_REPORT displayName "CMAI-AROMATICS-MARKET-REPORT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    CMAI_GLOBAL_PLASTICS_AND_POLYMERS_MARKET_REPORT displayName "CMAI-GLOBAL-PLASTICS-AND-POLYMERS-MARKET-REPORT" <"CMAI Global Plastics and Polymers Market Report. http://www.ihs.com/products/chemical/index.aspx?pu=1&rd=cmai">
    CMAI_METHANOL_MARKET_REPORT displayName "CMAI-METHANOL-MARKET-REPORT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    CMAI_MONOMERS_MARKET_REPORT displayName "CMAI-MONOMERS-MARKET-REPORT" <"CMAI Monomers Market Report. http://www.ihs.com/products/chemical/index.aspx?pu=1&rd=cmai">
    CME_DAIRY displayName "CME-DAIRY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    CME_NON_DAIRY_SOFT displayName "CME-NON-DAIRY-SOFT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    COMEX <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    CRU <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    CRU_LONG displayName "CRU-LONG" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    DEPARTMENT_OF_ENERGY displayName "DEPARTMENT-OF-ENERGY" <"The business calendar for statistical publications by the by the United States Department of Energy (DOE).">
    DEWITT_BENZENE_DERIVATIVES displayName "DEWITT-BENZENE-DERIVATIVES" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    DME <"Dubai Mercantile Exchange. http://www.dubaimerc.com/">
    DOW_JONES displayName "DOW-JONES" <"Dow Jones US Calendar. http://www.dowjones.com/">
    DOW_JONES_ENERGY_SERVICE displayName "DOW-JONES-ENERGY-SERVICE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    DowJonesPower <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    EEX_COAL displayName "EEX-COAL" <"European Energy Exchange-Coal">
    EEX_EMISSIONS displayName "EEX-EMISSIONS" <"European Energy Exchange-Emissions Rights">
    EEX_GAS displayName "EEX-GAS" <"European Energy Exchange-Gas">
    EEX_POWER displayName "EEX-POWER" <"European Energy Exchange-Power">
    EURONEX_MATIF displayName "EURONEX-MATIF" <"TBD.">
    FERTECON <"FERTECON Limited Information Services. http://fertecon.com/current_information_services.asp">
    FERTILIZER_WEEK displayName "FERTILIZER-WEEK" <"Fertilizer Week. http://www.crugroup.com/market-analysis/products/fertilizerweek">
    GAS_DAILY displayName "GAS-DAILY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    GAS_DAILY_PRICE_GUIDE displayName "GAS-DAILY-PRICE-GUIDE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    GLOBALCOAL <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    HEREN_REPORT displayName "HEREN-REPORT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ICE_10X_DAILY displayName "ICE/10X-DAILY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ICE_10X_MONTHLY displayName "ICE/10X-MONTHLY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ICE_CANADA displayName "ICE-CANADA" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ICE_ECX displayName "ICE-ECX" <"European Climate Exchange.">
    ICE_GAS displayName "ICE-GAS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ICE_OIL displayName "ICE-OIL" <"The business calendar oil and refined product contracts on ICE Futures Europe.">
    ICE_US_AGRICULTURAL displayName "ICE-US-AGRICULTURAL" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    ICIS_PRICING_BENZENE__EUROPE_ displayName "ICIS-PRICING-BENZENE-(EUROPE)" <"The business calendar for publication of ICIS Benzene (Europe) data.">
    ICIS_PRICING_ETHYLENE__EUROPE_ displayName "ICIS-PRICING-ETHYLENE-(EUROPE)" <"The business calendar for publication of ICIS Ethylene (Europe) data.">
    ICIS_PRICING_POLYPROPYLENE__EUROPE_ displayName "ICIS-PRICING-POLYPROPYLENE-(EUROPE)" <"The business calendar for publication of ICIS Polyproylene (Europe) data.">
    INSIDE_FERC displayName "INSIDE-FERC" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    JAPAN_MOF_TSRR displayName "JAPAN-MOF-TSRR" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    KCBOT <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    KUALA_LUMPUR_BANK displayName "KUALA-LUMPUR-BANK" <"The banking business calendar in Kuala Lumpur.">
    LABUAN_BANK displayName "LABUAN-BANK" <"The business calendar for the Labuan Bank (Malaysia).">
    LIFFE_LONDON_SOFT displayName "LIFFE-LONDON-SOFT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    LME <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    LONDON_BULLION_MARKET displayName "LONDON-BULLION-MARKET" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    LONDON_BULLION_MARKET_GOLD_A_M_ONLY displayName "LONDON-BULLION-MARKET-GOLD-A.M-ONLY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    LONDON_PLATINUM_PALLADIUM_MARKET displayName "LONDON-PLATINUM-PALLADIUM-MARKET" <"The London Platinum and Palladium Market in London on which members quote prices for the buying and selling of Platinum and Palladium.">
    MGEX <"Minneapolis Grain Exchange http://www.mgex.com/">
    N2EX <"The business calendar for the N2EX UK power exchange (https://www.n2ex.com/aboutn2ex).">
    NASDAQ_OMX displayName "NASDAQ-OMX" <"NASDAQ-OMX (Formerly known as Nordpool). http://www.nasdaqomx.com/commodities">
    NATURAL_GAS_WEEK displayName "NATURAL-GAS-WEEK" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    NERC <"Per 2005 ISDA Commodity Definitions, Article XIV.">
    NGI <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    NGX <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    NUCLEAR_MARKET_REVIEW displayName "NUCLEAR-MARKET-REVIEW" <"The Nuclear Market Review report as published by Trade tech. http://www.uranium.info/nuclear_market_review.php">
    NYMEX_ELECTRICITY displayName "NYMEX-ELECTRICITY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    NYMEX_GAS displayName "NYMEX-GAS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    NYMEX_NATURAL_GAS displayName "NYMEX-NATURAL-GAS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    NYMEX_OIL displayName "NYMEX-OIL" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    OFFICIAL_BOARD_MARKETS displayName "OFFICIAL-BOARD-MARKETS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    OPIS_LP_GAS displayName "OPIS-LP-GAS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    OPIS_PROPANE displayName "OPIS-PROPANE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PAPER_PACKAGING_MONITOR displayName "PAPER-PACKAGING-MONITOR" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PAPER_TRADER displayName "PAPER-TRADER" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PERTAMINA <"Pertamina-Indonesia. http://www.pertamina.com/">
    PETROCHEMWIRE <"PetroChemWire Publication Calendar. http://www.petrochemwire.com/">
    PIX_PULP_BENCHMARK_INDICES displayName "PIX-PULP-BENCHMARK-INDICES" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_APAG_MARKETSCAN displayName "PLATTS-APAG-MARKETSCAN" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_BUNKERWIRE displayName "PLATTS-BUNKERWIRE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_CLEAN_TANKERWIRE displayName "PLATTS-CLEAN-TANKERWIRE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_CRUDE_OIL_MARKETWIRE displayName "PLATTS-CRUDE-OIL-MARKETWIRE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_DIRTY_TANKERWIRE displayName "PLATTS-DIRTY-TANKERWIRE" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_EUROPEAN_GAS displayName "PLATTS-EUROPEAN-GAS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_EUROPEAN_MARKETSCAN displayName "PLATTS-EUROPEAN-MARKETSCAN" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_METALS_ALERT displayName "PLATTS-METALS-ALERT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_OILGRAM displayName "PLATTS-OILGRAM" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PLATTS_TSI_IRON_ORE displayName "PLATTS-TSI-IRON-ORE" <"The Steel Index Iron Ore Service. http://www.thesteelindex.com/en/iron-ore">
    PLATTS_TSI_SCRAP displayName "PLATTS-TSI-SCRAP" <"The Steel Index Scrap Reference Prices. http://www.thesteelindex.com/en/scrapprices">
    PLATTS_TSI_STEEL displayName "PLATTS-TSI-STEEL" <"The Steel Index. http://www.thesteelindex.com/en/price-specifications">
    PLATTS_US_MARKETSCAN displayName "PLATTS-US-MARKETSCAN" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PULP_AND_PAPER_INTERNATIONAL displayName "PULP-AND-PAPER-INTERNATIONAL" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    PULP_AND_PAPER_WEEK displayName "PULP-AND-PAPER-WEEK" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    RIM_PRODUCTS_INTELLIGENCE_DAILY displayName "RIM-PRODUCTS-INTELLIGENCE-DAILY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    SAFEX_SOFT displayName "SAFEX-SOFT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    SFE_SOFT displayName "SFE-SOFT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    SGX <"Singapore Exchange. www.sgx.com">
    SICOM <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    SP_GSCI displayName "SP-GSCI" <"Standard and Poor's GSCI. http://us.spindices.com/index-family/commodities/sp-gsci">
    STATISTICHES_BUNDESAMT displayName "STATISTICHES-BUNDESAMT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    TGE <"Tokyo Grain Exchange. www.tge.or.jp">
    TOCOM_OIL displayName "TOCOM-OIL" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    TOCOM_PRECIOUS displayName "TOCOM-PRECIOUS" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    TOCOM_SOFT displayName "TOCOM-SOFT" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">
    UX_WEEKLY displayName "UX-WEEKLY" <"The Ux Consulting Company. http://www.uxc.com/products/uxw_overview.aspx">
    WORLD_PULP_MONTHLY displayName "WORLD-PULP-MONTHLY" <"Per 2005 ISDA Commodity Definitions, Section 7.2 Certain Definitions Relating To Commodity Reference Prices.">

enum BusinessDayConventionEnum: <"The enumerated values to specify the convention for adjusting any relevant date if it would otherwise fall on a day that is not a valid business day.">
    FOLLOWING <"The non-business date will be adjusted to the first following day that is a business day">
    FRN <"Per 2000 ISDA Definitions, Section 4.11. FRN Convention; Eurodollar Convention. FRN is included here as a type of business day convention although it does not strictly fall within ISDA's definition of a Business Day Convention and does not conform to the simple definition given above.">
    MODFOLLOWING <"The non-business date will be adjusted to the first following day that is a business day unless that day falls in the next calendar month, in which case that date will be the first preceding day that is a business day.">
    PRECEDING <"The non-business day will be adjusted to the first preceding day that is a business day.">
    MODPRECEDING <"The non-business date will be adjusted to the first preceding day that is a business day unless that day falls in the previous calendar month, in which case that date will be the first following day that us a business day.">
    NEAREST <"The non-business date will be adjusted to the nearest day that is a business day - i.e. if the non-business day falls on any day other than a Sunday or a Monday, it will be the first preceding day that is a business day, and will be the first following business day if it falls on a Sunday or a Monday.">
    NONE <"The date will not be adjusted if it falls on a day that is not a business day.">
    NotApplicable <"The date adjustments conventions are defined elsewhere, so it is not required to specify them here.">

enum DayOfWeekEnum: <"The enumerated values to specify a day of the seven-day week.">
    MON <"Monday">
    TUE <"Tuesday">
    WED <"Wednesday">
    THU <"Thursday">
    FRI <"Friday">
    SAT <"Saturday">
    SUN <"Sunday">

enum DayTypeEnum: <"Lists the enumerated values to specify the day type classification used in counting the number of days between two dates.">
    Business <"Applies when calculating the number of days between two dates the count includes only business days.">
    Calendar <"Applies when calculating the number of days between two dates the count includes all calendar days.">
    CurrencyBusiness <"Applies when calculating the number of days between two dates the count includes only currency business days.">
    ExchangeBusiness <"Applies when calculating the number of days between two dates the count includes only stock exchange business days.">
    ScheduledTradingDay <"Applies when calculating the number of days between two dates the count includes only scheduled trading days.">

enum PeriodEnum: <"The enumerated values to specify the period, e.g. day, week.">
    D <"Day">
    W <"Week">
    M <"Month">
    Y <"Year">

enum PeriodExtendedEnum /*extends PeriodEnum*/ : <"The enumerated values to specify a time period containing the additional value of Term.">
    H <"Hour">
    D <"Day">
    W <"Week">
    M <"Month">
    Y <"Year">
    T <"Term. The period commencing on the effective date and ending on the termination date. The T period always appears in association with periodMultiplier = 1, and the notation is intended for use in contexts where the interval thus qualified (e.g. accrual period, payment period, reset period, ...) spans the entire term of the trade.">
    C <"CalculationPeriod - the period corresponds to the calculation period   For example, used in the Commodity Markets to indicate that a reference contract is the one that corresponds to the period of the calculation period.">

// The next two should be rationalised with PeriodEnum into a single enum
enum PeriodTimeEnum: <"The enumeration values to specify a time period containing additional values such as Term.">
    Hour <"Period measured in hours.">
    Minute <"Period measured in minutes.">
    Second <"Period measured in seconds.">

enum TimeUnitEnum: <"The enumeration values to qualify the allowed units of time.">
    Second <"Second">
    Minute <"Minute">
    Hour <"Hour">
    Day <"Day">
    Week <"Week">
    Month <"Month">
    Year <"Year">

enum RollConventionEnum: <"The enumerated values to specify the period term as part of a periodic schedule, i.e. the calculation period end date within the regular part of the calculation period. The value could be a rule, e.g. IMM Settlement Dates, which is the 3rd Wednesday of the month, or it could be a specific day of the month, such as the first day of the applicable month.">
    EOM <"Rolls on month end dates irrespective of the length of the month and the previous roll day.">
    FRN <"Roll days are determined according to the FRN Convention or Euro-dollar Convention as described in ISDA 2000 definitions.">
    IMM <"IMM Settlement Dates. The third Wednesday of the (delivery) month.">
    IMMCAD <"The last trading day/expiration day of the Canadian Derivatives Exchange (Bourse de Montreal Inc) Three-month Canadian Bankers' Acceptance Futures (Ticker Symbol BAX). The second London banking day prior to the third Wednesday of the contract month. If the determined day is a Bourse or bank holiday in Montreal or Toronto, the last trading day shall be the previous bank business day. Per Canadian Derivatives Exchange BAX contract specification.">
    IMMAUD <"The last trading day of the Sydney Futures Exchange 90 Day Bank Accepted Bills Futures contract (see http://www.sfe.com.au/content/sfe/trading/con_specs.pdf). One Sydney business day preceding the second Friday of the relevant settlement.">
    IMMNZD <"The last trading day of the Sydney Futures Exchange NZ 90 Day Bank Bill Futures contract (see http://www.sfe.com.au/content/sfe/trading/con_specs.pdf). The first Wednesday after the ninth day of the relevant settlement month.">
    SFE <"Sydney Futures Exchange 90-Day Bank Accepted Bill Futures Settlement Dates. The second Friday of the (delivery) month">
    NONE <"The roll convention is not required. For example, in the case of a daily calculation frequency.">
    TBILL <"13-week and 26-week U.S. Treasury Bill Auction Dates. Each Monday except for U.S. (New York) holidays when it will occur on a Tuesday.">
    _1 displayName "1" <"Rolls on the 1st day of the month.">
    _2 displayName "2" <"Rolls on the 2nd day of the month.">
    _3 displayName "3" <"Rolls on the 3rd day of the month.">
    _4 displayName "4" <"Rolls on the 4th day of the month.">
    _5 displayName "5" <"Rolls on the 5th day of the month.">
    _6 displayName "6" <"Rolls on the 6th day of the month.">
    _7 displayName "7" <"Rolls on the 7th day of the month.">
    _8 displayName "8" <"Rolls on the 8th day of the month.">
    _9 displayName "9" <"Rolls on the 9th day of the month.">
    _10 displayName "10" <"Rolls on the 10th day of the month.">
    _11 displayName "11" <"Rolls on the 11th day of the month.">
    _12 displayName "12" <"Rolls on the 12th day of the month.">
    _13 displayName "13" <"Rolls on the 13th day of the month.">
    _14 displayName "14" <"Rolls on the 14th day of the month.">
    _15 displayName "15" <"Rolls on the 15th day of the month.">
    _16 displayName "16" <"Rolls on the 16th day of the month.">
    _17 displayName "17" <"Rolls on the 17th day of the month.">
    _18 displayName "18" <"Rolls on the 18th day of the month.">
    _19 displayName "19" <"Rolls on the 19th day of the month.">
    _20 displayName "20" <"Rolls on the 20th day of the month.">
    _21 displayName "21" <"Rolls on the 21st day of the month.">
    _22 displayName "22" <"Rolls on the 22nd day of the month.">
    _23 displayName "23" <"Rolls on the 23rd day of the month.">
    _24 displayName "24" <"Rolls on the 24th day of the month.">
    _25 displayName "25" <"Rolls on the 25th day of the month.">
    _26 displayName "26" <"Rolls on the 26th day of the month.">
    _27 displayName "27" <"Rolls on the 27th day of the month.">
    _28 displayName "28" <"Rolls on the 28th day of the month.">
    _29 displayName "29" <"Rolls on the 29th day of the month.">
    _30 displayName "30" <"Rolls on the 30th day of the month.">
    MON <"Rolling weekly on a Monday.">
    TUE <"Rolling weekly on a Tuesday">
    WED <"Rolling weekly on a Wednesday">
    THU <"Rolling weekly on a Thursday">
    FRI <"Rolling weekly on a Friday">
    SAT <"Rolling weekly on a Saturday">
    SUN <"Rolling weekly on a Sunday">

enum CompoundingTypeEnum: <"The enumerated values to specify how the compounding calculation is done">
    None <"Compounding is not applicable">
    Business <"Compounding is done only on business days, i.e. not compounded each day on weekends or holidays.">
    Calendar <"Compounding is done on each calendar day.">

enum RoundingFrequencyEnum: <"How often is rounding performed">
    Daily <"Rounding is done on each day">
    PeriodEnd <"Rounding is done only at the end of the period">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-datetime-func.rosetta
================================================================================

namespace cdm.base.datetime: <"Basic date and time concepts: relative date, date range, offset, business centre etc.">
version "${project.version}"

func TimeZoneFromBusinessCenterTime: <"Function to resolve a time passed as BusinessCenterTime into a TimeZone time.">
    [codeImplementation]
    inputs:
        time BusinessCenterTime (1..1)
    output:
        result TimeZone (1..1)

func ResolveAdjustableDate:
    [codeImplementation]
    inputs:
        adjustableOrRelativeDate AdjustableOrRelativeDate (1..1)
    output:
        adjustedDate date (0..1)

func ResolveAdjustableDates:
    [codeImplementation]
    inputs:
        adjustableRelativeOrPeriodicDates AdjustableRelativeOrPeriodicDates (1..1)
    output:
        adjustedDates date (0..*)

func ToDateTime: <"Creates a ZonedDateTime from the provided Date, and defaults the time to 00:00:00 and timezone to UTC.">
    inputs:
        date date (0..1)
    output:
        zonedDateTime zonedDateTime (0..1)

    set zonedDateTime:
        zonedDateTime {
            date: date,
            time: ToTime(0, 0, 0),
            timezone: "Z" // UTC
        }

func ToTime: <"Implemented by Java function.">
    [codeImplementation]
    inputs:
        hours int (1..1)
        minutes int (1..1)
        seconds int (1..1)
    output:
        time time (1..1)

func ConvertToAdjustableOrRelativeDate: <"Utility function to convert from AdjustableOrAdjustedOrRelativeDate to AdjustableOrRelativeDate">
    inputs:
        adjustableOrAdjustedOrRelativeDate AdjustableOrAdjustedOrRelativeDate (0..1)
    output:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)

    alias relativeDate: adjustableOrAdjustedOrRelativeDate -> relativeDate

    set adjustableOrRelativeDate -> adjustableDate -> adjustedDate:
        adjustableOrAdjustedOrRelativeDate -> adjustedDate

    set adjustableOrRelativeDate -> adjustableDate -> unadjustedDate:
        adjustableOrAdjustedOrRelativeDate -> unadjustedDate

    set adjustableOrRelativeDate -> adjustableDate -> dateAdjustments:
        adjustableOrAdjustedOrRelativeDate -> dateAdjustments

    set adjustableOrRelativeDate -> relativeDate -> adjustedDate:
        if relativeDate exists then relativeDate -> adjustedDate

    set adjustableOrRelativeDate -> relativeDate -> businessCenters:
        if relativeDate exists then relativeDate -> businessCenters

    set adjustableOrRelativeDate -> relativeDate -> businessDayConvention:
        if relativeDate exists
        then relativeDate -> businessDayConvention

    set adjustableOrRelativeDate -> relativeDate -> dateRelativeTo:
        if relativeDate exists then relativeDate -> dateRelativeTo

    set adjustableOrRelativeDate -> relativeDate -> dayType:
        if relativeDate exists then relativeDate -> dayType

    set adjustableOrRelativeDate -> relativeDate -> period:
        if relativeDate exists then relativeDate -> period

    set adjustableOrRelativeDate -> relativeDate -> periodMultiplier:
        if relativeDate exists then relativeDate -> periodMultiplier

func ConvertToAdjustableOrAdjustedOrRelativeDate: <"Utility function to convert from AdjustableOrAdjustedOrRelativeDate to AdjustableOrAdjustedOrRelativeDate">
    inputs:
        adjustableOrRelativeDate AdjustableOrRelativeDate (0..1)
    output:
        adjustableOrAdjustedOrRelativeDate AdjustableOrAdjustedOrRelativeDate (0..1)

    alias relativeDate: adjustableOrRelativeDate -> relativeDate

    set adjustableOrAdjustedOrRelativeDate -> adjustedDate:
        adjustableOrRelativeDate -> adjustableDate -> adjustedDate

    set adjustableOrAdjustedOrRelativeDate -> unadjustedDate:
        adjustableOrRelativeDate -> adjustableDate -> unadjustedDate

    set adjustableOrAdjustedOrRelativeDate -> dateAdjustments:
        adjustableOrRelativeDate -> adjustableDate -> dateAdjustments

    set adjustableOrAdjustedOrRelativeDate -> relativeDate -> adjustedDate:
        if relativeDate exists then relativeDate -> adjustedDate

    set adjustableOrAdjustedOrRelativeDate -> relativeDate -> businessCenters:
        if relativeDate exists then relativeDate -> businessCenters

    set adjustableOrAdjustedOrRelativeDate -> relativeDate -> businessDayConvention:
        if relativeDate exists
        then relativeDate -> businessDayConvention

    set adjustableOrAdjustedOrRelativeDate -> relativeDate -> dateRelativeTo:
        if relativeDate exists then relativeDate -> dateRelativeTo

    set adjustableOrAdjustedOrRelativeDate -> relativeDate -> dayType:
        if relativeDate exists then relativeDate -> dayType

    set adjustableOrAdjustedOrRelativeDate -> relativeDate -> period:
        if relativeDate exists then relativeDate -> period

    set adjustableOrAdjustedOrRelativeDate -> relativeDate -> periodMultiplier:
        if relativeDate exists then relativeDate -> periodMultiplier

func Now: <"Current date time.">
    [codeImplementation]
    output:
        now zonedDateTime (1..1)

func Today: <"Current date.">
    [codeImplementation]
    output:
        today date (1..1)

func GetAllBusinessCenters: <"Returns a merged list of BusinessCenterEnums for the supplied BusinessCenters.">
    inputs:
        businessCenters BusinessCenters (1..1)
    output:
        businessCenterEnums BusinessCenterEnum (0..*)

    add businessCenterEnums: <"Get list of BusinessCenterEnum.">
        businessCenters -> businessCenter

    add businessCenterEnums: <"Get list of BusinessCenterEnum from referenced BusinessCenters.">
        if businessCenters -> businessCentersReference exists
        then GetAllBusinessCenters(businessCenters -> businessCentersReference)

    set businessCenterEnums: <"Remove any duplicates from the list.">
        businessCenterEnums distinct

func BusinessCenterHolidaysMultiple: <"Returns a merged list of holidays for the supplied business centers.">
    inputs:
        businessCenters BusinessCenterEnum (0..*) <"The business centers for which the holiday list is required.">
    output:
        holidayDates date (0..*) <"The combined list of holidays in all of the supplied business centers.">

    add holidayDates:
        businessCenters
            extract BusinessCenterHolidays(item)
            then flatten
            then distinct
            then sort

func BusinessCenterHolidays:
    [codeImplementation]
    // data provider - implementation provides dates from data source
    inputs:
        businessCenter BusinessCenterEnum (1..1)
    output:
        holidayDates date (0..*)

func DayOfWeek: <"Returns the day of week corresponding to the supplied date.">
    [codeImplementation]
    inputs:
        date date (1..1) <"The date for which the weekday is needed.">
    output:
        dayOfWeek DayOfWeekEnum (1..1) <"The day of the week as an enumerated value.">

func AddDays: <"Adds the specified number of calendar days to the supplied date.  A negative number will generate a date before the supplied date.">
    [codeImplementation]
    inputs:
        inputDate date (1..1) <"The base date for the calculation.">
        numDays int (1..1) <"The number of days to add.">
    output:
        resultDate date (1..1) <"The date shifted by the specified number of days.">

func DateDifference: <"Subtracts the two supplied dates to return the number of calendar days between them.  A negative number implies first is after second.">
    [codeImplementation]
    inputs:
        firstDate date (1..1) <"The earlier date.">
        secondDate date (1..1) <"The later date.">
    output:
        difference int (1..1) <"The number of calendar days second date is after firstDate. Negative means secondDate is before firstDate.">

func LeapYearDateDifference: <"Subtracts the two supplied dates to return the number of leap year calendar days between them. A negative number implies firstDate is after secondDate.">
    [codeImplementation]
    inputs:
        firstDate date (1..1) <"The left side of the subtraction.">
        secondDate date (1..1) <"The right side of the subtraction.">
    output:
        difference int (1..1) <"The number of leap year calendar days secondDate is after firstDate. Negative means secondDate is before firstDate.">

func DateDifferenceYears: <"Computes the difference in years between two dates. A negative number implies firstDate is after secondDate.">
    inputs:
        firstDate date (1..1) <"The earlier date.">
        secondDate date (1..1) <"The later date.">
    output:
        difference number (1..1)

    alias totalDays: DateDifference(firstDate, secondDate)

    alias leapYearDays: LeapYearDateDifference(firstDate, secondDate)

    alias nonLeapYearDays: totalDays - leapYearDays

    set difference: (nonLeapYearDays / 365.0) + (leapYearDays / 366.0)

func AppendDateToList: <"Add a date to a list of dates.">
    inputs:
        origDates date (0..*) <"List of dates.">
        newDate date (1..1) <"Date to add to the list.">
    output:
        newList date (0..*) <"The newly increased list.">

    set newList: origDates
    add newList: newDate

func PopOffDateList: <"Remove last element from a list of dates.">
    [codeImplementation]
    inputs:
        dates date (0..*) <"List of dates.">
    output:
        newList date (0..*) <"The newly created list, omitting the last element of the original list.">

func IsWeekend: <"returns whether the supplied date is a weekend. This assumes a 5 day week with Saturday and Sunday as holidays. A more sophisticated implementation might use the business centers to determine which days are weekends, but most jurisdictions where derivatives are traded follow this convention.">
    inputs:
        date date (1..1) <"The date for which the weekday is needed">
        businessCenters BusinessCenterEnum (0..*) <"Not needed for the current implementation so ignored, but kept for future extensibility">
    output:
        isWeekend boolean (1..1)

    alias dayOfWeek: DayOfWeek(date) // determine the day of the week
    // output whether the date is on a weekend by comparing against SAT or SUN
    set isWeekend: dayOfWeek = DayOfWeekEnum -> SAT or dayOfWeek = DayOfWeekEnum -> SUN

func IsHoliday: <"Returns whether a day is a holiday for the specified business centers">
    inputs:
        checkDate date (1..1) <"The date being tested">
        businessCenters BusinessCenterEnum (0..*) <"The business centers for which the test is required">
    output:
        isHoliday boolean (1..1) <"true if the supplied date is a holiday">

    // get the combined list of holidays for the supplied business centers
    alias holidays: BusinessCenterHolidaysMultiple(businessCenters)

    // check if the supplied date is contained in the holiday list
    set isHoliday: holidays contains checkDate

func IsBusinessDay: <"returns an indicator of whether the supplied date is a good business date given the supplied business centers. True => good date, i.e. not a weekend or holiday. False means that it is either a weekend or a holiday">
    inputs:
        date date (1..1) <"The date for which we want to determine whether it's a good business day">
        businessCenters BusinessCenterEnum (0..*) <"The list of business centers to use">
    output:
        isGoodBusinessDay boolean (1..1) <"True if a good business day, false if a weekend or holiday">

    // determine if a weekend or holiday
    alias weekend: IsWeekend(date, businessCenters)
    alias holiday: IsHoliday(date, businessCenters)
    // return whether it's a good business day
    set isGoodBusinessDay:
        if weekend then False else if holiday then False else True

func AddBusinessDays: <"Returns a good business date that has been offset by the given number of business days given the supplied business centers. A negative value implies an earlier date (before the supplied originalDate), and a positive value a later date (after the supplied date).">
    inputs:
        originalDate date (1..1) <"date to be shifted. If not a good business day, a supplied shift of 0 will shift it to the next business day">
        offsetBusinessDays int (1..1) <"number of business days to shift the original date">
        businessCenters BusinessCenterEnum (0..*) <"business centers to use in the shifting">
    output:
        shiftedDate date (1..1)

    alias isGoodBusinessDay: IsBusinessDay(originalDate, businessCenters) // check if a good business day
    alias shift: if offsetBusinessDays < 0 then -1 else 1 // determine the direction of shifting, earlier or later
    // calculate the new offset: if we're at a good business day, reduce by one, else keep it
    alias shiftedByOne: AddDays(originalDate, shift) // add/subtract one calendar day
    alias isShiftedGood: IsBusinessDay(shiftedByOne, businessCenters)
    alias newShift: if isShiftedGood then shift else 0
    alias newOffset:
        if offsetBusinessDays = 0
        then 0
        else offsetBusinessDays - newShift
    alias done: offsetBusinessDays = 0 and isGoodBusinessDay = True // we're done if the offsetBusinessDays is 0 and it's a good business day
    // calculate the shifted date: if we're done, return the supplied date, else recursively try after having shifted by one day (recursion because iteration isn't supported by the Rosetta DSL)
    alias newDate:
        if done
        then originalDate
        else AddBusinessDays(shiftedByOne, newOffset, businessCenters)
    set shiftedDate: newDate

func GenerateDateList: <"Creates a list of good business days starting from the startDate and going to the end date, inclusive, omitting any days that are weekends or holidays according to the supplied business centers.">
    inputs:
        startDate date (1..1) <"Start of the date range to be generated.">
        endDate date (1..1) <"End of the date range to be generated">
        businessCenters BusinessCenterEnum (0..*) <"Business centers to be used to generate the list of good business days">
    output:
        dateList date (0..*) <"Resulting list of good business days.">

    alias active: startDate <= endDate // do we have anything to do? Nothing to do if start date is after end date
    alias isGoodBusinessDay: IsBusinessDay(endDate, businessCenters) // is endDate a good business day?
    alias priorDate: AddBusinessDays(endDate, -1, businessCenters) // find the previous good business day before the endDate
    alias priorList: GenerateDateList(startDate, priorDate, businessCenters) // recursively find the list of dates from the start to the prior business day
    // add the current end date to the previous list if it is a good business day (the test handles the case when the first supplied end date is not a business day)
    alias newList:
        if isGoodBusinessDay
        then AppendDateToList(priorList, endDate)
        else priorList
    add dateList: if active then newList

func AdjustableOrAdjustedOrRelativeDateResolution: <"Prioritization of unadjustedDate over adjustedDate.">
    inputs:
        adjustableDate AdjustableOrAdjustedOrRelativeDate (1..1)
    output:
        date date (0..1)
    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

func AdjustableDateResolution: <"Prioritization of unadjustedDate over adjustedDate.">
    inputs:
        adjustableDate AdjustableDate (1..1)
    output:
        date date (0..1)

    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

func AdjustableDatesResolution: <"Prioritization of unadjustedDate over adjustedDate.">
    inputs:
        adjustableDates AdjustableDates (1..1)
    output:
        date date (0..*)

    add date:
        if adjustableDates -> unadjustedDate exists
        then adjustableDates -> unadjustedDate
        else adjustableDates -> adjustedDate


================================================================================
FILE: rosetta-source/src/main/rosetta/base-datetime-type.rosetta
================================================================================

namespace cdm.base.datetime : <"Basic date and time concepts: relative date, date range, offset, business centre etc.">
version "${project.version}"

type AdjustableDate: <"A class for defining a date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.">
    [metadata key]

    unadjustedDate date (0..1) <"A date subject to adjustment. While in FpML this date is required, this cardinality constraint has been relaxed as part of the CDM in order to support the FRA representation, which effective and termination dates are specified in FpML as adjusted dates.">
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business date in the specified business centers.">
    dateAdjustmentsReference BusinessDayAdjustments (0..1) <"A pointer style reference to date adjustments defined elsewhere in the document.">
        [metadata reference]
    adjustedDate date (0..1) <"The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).">
        [metadata id]

    condition AdjustableDateChoice: <"Choice rule to represent an FpML choice construct.">
        optional choice dateAdjustments, dateAdjustmentsReference

type AdjustableDates: <"A class for defining a series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the dates.">
    [metadata key]

    unadjustedDate date (0..*) <"A date subject to adjustment.">
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business date in the specified business centers.">
    adjustedDate date (0..*) <"The date(s) once the adjustment has been performed. (Note that this date may change if the business center holidays change).">
        [metadata id]

    condition AdjustedDate: <"FpML specifies a choice between adjustedDate and [unadjustedDate (required), dateAdjutsments (required), adjustedDate (optional)].">
        if adjustedDate is absent
        then unadjustedDate exists and dateAdjustments exists

type AdjustableOrAdjustedDate: <"A class for defining a date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.">
    [metadata key]

    unadjustedDate date (0..1) <"A date subject to adjustment.">
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business date in the specified business centers.">
    adjustedDate date (0..1) <"The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).">
        [metadata id]

    condition AdjustedDate: <"FpML specifies a choice between adjustedDate and [unadjustedDate (required), dateAdjutsments (required), adjustedDate (optional)].">
        if adjustedDate is absent
        then unadjustedDate exists and dateAdjustments exists

type AdjustableOrAdjustedOrRelativeDate: <"This Rosetta class specifies the date as either an unadjusted, adjusted or relative date. It supplements the features of the AdjustableOrAdjustedDate to support the credit default swap option premium, which uses the relative date construct.">

    unadjustedDate date (0..1) <"A date subject to adjustment.">
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business date in the specified business centers.">
    adjustedDate date (0..1) <"The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).">
        [metadata id]
    relativeDate RelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">

    condition AdjustedDate: <"This data rule extends the data rule AdjustableOrAdjustedDate_adjustedDate by specifying logic applicable to the relative date.">
        adjustedDate exists
            or relativeDate exists
            or unadjustedDate exists
            or (unadjustedDate exists and dateAdjustments exists and adjustedDate is absent)

type AdjustableOrRelativeDate: <"A class giving the choice between defining a date as an explicit date together with applicable adjustments or as relative to some other (anchor) date.">
    [metadata key]

    adjustableDate AdjustableDate (0..1) <"A date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.">
    relativeDate AdjustedRelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">

    condition AdjustableOrRelativeDateChoice: <"Choice rule to represent an FpML choice construct.">
        required choice adjustableDate, relativeDate

type AdjustableOrRelativeDates: <"A class giving the choice between defining a series of dates as an explicit list of dates together with applicable adjustments or as relative to some other series of (anchor) dates.">
    [metadata key]

    adjustableDates AdjustableDates (0..1) <"A series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.">
    relativeDates RelativeDates (0..1) <"A series of dates specified as some offset to another series of dates (the anchor dates).">

    condition AdjustableOrRelativeDatesChoice: <"Choice rule to represent an FpML choice construct.">
        required choice adjustableDates, relativeDates

type AdjustedRelativeDateOffset extends RelativeDateOffset: <"A type defining a date (referred to as the derived date) as a relative offset from another date (referred to as the anchor date) plus optional date adjustments.">

    relativeDateAdjustments BusinessDayAdjustments (0..1) <"The business day convention and financial business centers used for adjusting the relative date if it would otherwise fall on a day that is not a business date in the specified business centers.">

type BusinessCenters: <"A class for specifying the business day calendar location used in determining whether a day is a business day or not, either by specifying this business center by reference to an enumerated list that is maintained by the FpML standard, or by reference to such specification when it exists elsewhere as part of the instance document. This class corresponds to the FpML BusinessCentersOrReference.model.">
    [metadata key]

    businessCenter BusinessCenterEnum (0..*) <"A code identifying one or several business day calendar location(s). The set of business day calendar locations are specified by the business day calendar location enumeration which is maintained by the FpML standard.">
        [metadata scheme]
    commodityBusinessCalendar CommodityBusinessCalendarEnum (0..*)
        [metadata scheme]
    businessCentersReference BusinessCenters (0..1) <"A reference to a financial business center location specified elsewhere in the instance document.">
        [metadata reference]

    condition BusinessCentersChoice: <"Choice rule to represent an FpML choice construct.">
        required choice businessCenter, businessCentersReference, commodityBusinessCalendar

type BusinessCenterTime: <"A class for defining a time with respect to a business day calendar location. For example, 11:00:00 GBLO.">

    hourMinuteTime time (1..1) <"A time specified in hh:mm:ss format where the second component must be '00', e.g. 11am would be represented as 11:00:00.">
    businessCenter BusinessCenterEnum (1..1) <"A code identifying a business day calendar location. A business day calendar location is drawn from the list identified by the business day calendar location enumeration.">
        [metadata scheme]

type BusinessDateRange extends DateRange: <"A class defining a range of contiguous business days by defining an unadjusted first date, an unadjusted last date and a business day convention and business centers for adjusting the first and last dates if they would otherwise fall on a non business day in the specified business centers. The days between the first and last date must also be good business days in the specified centers to be counted in the range.">

    businessDayConvention BusinessDayConventionEnum (1..1) <"The convention for adjusting a date if it would otherwise fall on a day that is not a business day, as specified by an ISDA convention (e.g. Following, Precedent).">
    businessCenters BusinessCenters (0..1) <"The business center(s), specified either explicitly or by reference to those specified somewhere else in the instance document.">

type BusinessDayAdjustments: <"A class defining the business day convention and financial business centers used for adjusting any relevant date if it would otherwise fall on a day that is not a business day in the specified business center.">
    [metadata key]

    businessDayConvention BusinessDayConventionEnum (1..1) <"The convention for adjusting a date if it would otherwise fall on a day that is not a business day.">
    businessCenters BusinessCenters (0..1) <"The business center(s), specified either explicitly or by reference to those specified somewhere else in the instance document.">

type DateRange: <"A class defining a contiguous series of calendar dates. The date range is defined as all the dates between and including the start and the end date. The start date must fall on or before the end date.">

    startDate date (1..1) <"The first date of a date range.">
    endDate date (1..1) <"The last date of a date range.">

    condition DatesOrdered: <"The start date must fall on or before the end date (a date range of only one date is allowed).">
        startDate <= endDate

type DateList: <"List of dates.">
    date date (1..*)

type DateTimeList: <"List of dateTimes.">
    dateTime zonedDateTime (1..*) <"The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">

type Frequency: <"A class for defining a date frequency, e.g. one day, three months, through the combination of an integer value and a standardized period value that is specified as part of an enumeration.">
    [metadata key]

    periodMultiplier int (1..1) <"A time period multiplier, e.g. 1, 2, or 3. If the period value is T (Term) then period multiplier must contain the value 1.">
    period PeriodExtendedEnum (1..1) <"A time period, e.g. a day, week, month, year or term of the stream.">

    condition TermPeriod: <"FpML specifies that if period value is T (Term) then periodMultiplier must contain the value 1.">
        if period = PeriodExtendedEnum -> T then periodMultiplier = 1

    condition PositivePeriodMultiplier: <"FpML specifies periodMultiplier as a positive integer.">
        periodMultiplier > 0

type Offset extends Period: <"A class defining an offset used in calculating a new date relative to a reference date, e.g. calendar days, business days, commodity Business days, etc.">

    dayType DayTypeEnum (0..1) <"In the case of an offset specified as a number of days, this element defines whether consideration is given as to whether a day is a good business day or not. If a day type of business days is specified then non-business days are ignored when calculating the offset. The financial business centers to use for determination of business days are implied by the context in which this element is used. This element must only be included when the offset is specified as a number of days. If the offset is zero days then the dayType element should not be included.">
    condition DayType: <"FpML specifies that the dayType must only be included when the offset is specified as a number of days, while should not be included if the offset is zero days.">
        if period <> PeriodEnum -> D or periodMultiplier = 0
        then dayType is absent

type CustomisableOffset: <"A class to specify an offset either as a normalized [multiplier, period, dayType] or as a custom provision of type string.">

    offset Offset (0..1)
    customProvision string (0..1)

type Period: <"A class to define recurring periods or time offsets.">
    [metadata key]

    periodMultiplier int (1..1) <"A time period multiplier, e.g. 1, 2 or 3 etc. A negative value can be used when specifying an offset relative to another date, e.g. -2 days.">
    period PeriodEnum (1..1) <"A time period, e.g. a day, week, month or year of the stream. If the periodMultiplier value is 0 (zero) then period must contain the value D (day).">

    condition DayPeriod: <"FpML specifies that if the periodMultiplier value is 0 (zero) then period must contain the value D (day).">
        if periodMultiplier = 0 then period = PeriodEnum -> D

type RelativeDates extends RelativeDateOffset: <"A class describing a set of dates defined as relative to another set of dates.">

    periodSkip int (0..1) <"The number of periods in the referenced date schedule that are between each date in the relative date schedule. Thus a skip of 2 would mean that dates are relative to every second date in the referenced schedule. If present this should have a value greater than 1.">
    scheduleBounds DateRange (0..1) <"The first and last dates of a schedule. This can be used to restrict the range of values in a reference series of dates.">

    condition PeriodSkipGreaterThanOne: <"FpML specifies that, if present, the period skip should have a value greater than 1.">
        if periodSkip exists then periodSkip > 1

type RelativeDateOffset extends Offset: <"A class defining a date (referred to as the derived date) as a relative offset from another date (referred to as the anchor date). If the anchor date is itself an adjustable date then the offset is assumed to be calculated from the adjusted anchor date. A number of different scenarios can be supported, namely; 1) the derived date may simply be a number of calendar periods (days, weeks, months or years) preceding or following the anchor date; 2) the unadjusted derived date may be a number of calendar periods (days, weeks, months or years) preceding or following the anchor date with the resulting unadjusted derived date subject to adjustment in accordance with a specified business day convention, i.e. the derived date must fall on a good business day; 3) the derived date may be a number of business days preceding or following the anchor date. Note that the businessDayConvention specifies any required adjustment to the unadjusted derived date. A negative or positive value in the periodMultiplier indicates whether the unadjusted derived precedes or follows the anchor date. The businessDayConvention should contain a value NONE if the day type element contains a value of Business (since specifying a negative or positive business days offset would already guarantee that the derived date would fall on a good business day in the specified business centers).">

    businessDayConvention BusinessDayConventionEnum (1..1) <"The convention for adjusting a date if it would otherwise fall on a day that is not a business day, as specified by an ISDA convention (e.g. Following, Precedent).">
    businessCenters BusinessCenters (0..1)
    businessCentersReference BusinessCenters (0..1) <"A pointer style reference to a set of financial business centers defined elsewhere in the document. This set of business centers is used to determine whether a particular day is a business day or not.">
        [metadata reference]
    dateRelativeTo date (0..1) <"Specifies the anchor as an href attribute. The href attribute value is a pointer style reference to the element or component elsewhere in the document where the anchor date is defined.">
        [metadata reference]
    adjustedDate date (0..1) <"The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).">

type TimeZone: <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
    time time (1..1) <"The observation time.">
    location string (0..1) <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">
        [metadata scheme]

type PeriodRange: <"Indicates The period range defined as either a lower and upper period bound, or both.">
    lowerBound PeriodBound (0..1) <"Specifies the lower bound of a period range, e.g. greater than or equal to 5Y.">
    upperBound PeriodBound (0..1) <"Specifies the upper bound of a period range, e.g. less than to 10Y.">

    condition AtLeastOneOf:
        lowerBound exists or upperBound exists

type PeriodBound: <"Indicator to specify if the period bound is defined as a period and whether the bound is inclusive.">
    period Period (1..1) <"Specifies the period is to be used as the bound, e.g. 5Y.">
    inclusive boolean (1..1) <"Specifies whether the period bound is inclusive, e.g. for a lower bound, false would indicate greater than, whereas true would indicate greater than or equal to.">

type AveragingSchedule: <"Class to representing a method for generating a series of dates.">

    startDate date (1..1) <"Date on which this period begins.">
    endDate date (1..1) <"Date on which this period ends.">
    averagingPeriodFrequency CalculationPeriodFrequency (1..1) <"The frequency at which averaging period occurs with the regular part of the valuation schedule and their roll date convention.">

type AdjustableRelativeOrPeriodicDates: <"A class giving the choice between defining a series of dates as an explicit list of dates together with applicable adjustments or as relative to some other series of (anchor) dates, or as a calculation period schedule.">
    [metadata key]

    adjustableDates AdjustableDates (0..1) <"A series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.">
    relativeDates RelativeDates (0..1) <"A series of dates specified as some offset to another series of dates (the anchor dates).">
    periodicDates PeriodicDates (0..1) <"A calculation period schedule.">

    condition AdjustableRelativeOrPeriodicDatesChoice: <"Choice rule to represent an FpML choice construct.">
        required choice adjustableDates, relativeDates, periodicDates

type PeriodicDates: <"A class for specifying a calculation period schedule.">

    startDate AdjustableOrRelativeDate (0..1) <"The start date of the calculation period. FpML specifies that for interest rate swaps this date must only be specified if it is not equal to the effective date. It is always specified in the case of equity swaps and credit default swaps with periodic payments. This date may be subject to adjustment in accordance with a business day convention.">
    endDate AdjustableOrRelativeDate (0..1) <"The end date of the calculation period. FpML specifies that for interest rate swaps this date must only be specified if it is not equal to the termination date. It is always specified in the case of equity swaps with periodic payments. This date may be subject to adjustment in accordance with a business day convention.">
    periodFrequency CalculationPeriodFrequency (0..1) <"The frequency at which calculation period end dates occur with the regular part of the calculation period schedule and their roll date convention.">
    periodDatesAdjustments BusinessDayAdjustments (0..1) <"The specification of the business day convention and financial business centers used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
    dayType DayTypeEnum (0..1) <"Denotes the enumerated values to specify the day type classification used in counting the number of days between two dates.">

type CalculationPeriodFrequency extends Frequency: <"A class to specify the frequency at which calculation period end dates occur within the regular part of the calculation period schedule and their roll date convention.">

    rollConvention RollConventionEnum (1..1) <"The roll convention specifies the period term as part of a periodic schedule, i.e. the calculation period end date within the regular part of the calculation period. The value could be a rule, e.g. IMM Settlement Dates, which is the 3rd Wednesday of the month, or it could be a specific day of the month, such as the first day of the applicable month. It is used in conjunction with a frequency and the regular period start date of a calculation period.">
    balanceOfFirstPeriod boolean (0..1) <"Indicates, when true, that that the first Calculation Period should run from the Effective Date to the end of the calendar period in which the Effective Date falls, e.g. Jan 15 - Jan 31 if the calculation periods are one month long and Effective Date is Jan 15. If false, the first Calculation Period should run from the Effective Date for one whole period, e.g. Jan 15 to Feb 14 if the calculation periods are one month long and Effective Date is Jan 15. Mostly used in Commmodity Swaps.">

    condition FpML_ird_57: <"FpML validation rule ird-57 - Context: CalculationPeriodFrequency. [period eq ('M', 'Y')] not(rollConvention = ('NONE', 'SFE', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT','SUN')).">
        if period = PeriodExtendedEnum -> M or period = PeriodExtendedEnum -> Y
        then rollConvention <> RollConventionEnum -> NONE
                and rollConvention <> RollConventionEnum -> SFE
                and rollConvention <> RollConventionEnum -> MON
                and rollConvention <> RollConventionEnum -> TUE
                and rollConvention <> RollConventionEnum -> WED
                and rollConvention <> RollConventionEnum -> THU
                and rollConvention <> RollConventionEnum -> FRI
                and rollConvention <> RollConventionEnum -> SAT
                and rollConvention <> RollConventionEnum -> SUN

    condition FpML_ird_58: <"FpML validation rule ird-58 - Context: CalculationPeriodFrequency. When the period is 'W', the rollConvention must be a week day, 'SFE' or 'NONE'.">
        if period = PeriodExtendedEnum -> W
        then rollConvention = RollConventionEnum -> NONE
                or rollConvention = RollConventionEnum -> SFE
                or rollConvention = RollConventionEnum -> MON
                or rollConvention = RollConventionEnum -> TUE
                or rollConvention = RollConventionEnum -> WED
                or rollConvention = RollConventionEnum -> THU
                or rollConvention = RollConventionEnum -> FRI
                or rollConvention = RollConventionEnum -> SAT
                or rollConvention = RollConventionEnum -> SUN

    condition FpML_ird_60: <"FpML validation rule ird-60 - Context: CalculationPeriodFrequency. When the period is 'T', the rollConvention must be 'NONE'.">
        if period = PeriodExtendedEnum -> T
        then rollConvention = RollConventionEnum -> NONE

type CalculationFrequency: <"Represents the parameters for describing how often something (such as collateral interest) is to be calculated.">
    period Period (1..1) <"Specifies the time period at which calculation is performed, e.g. 1 month.">
    monthOfYear number (0..1) <"Specifies the month of the year if used.">
    dayOfMonth number (0..1) <"Specifies the day of the month if used.">
    dayOfWeek DayOfWeekEnum (0..1) <"Specifies the day of the week if used.">
    weekOfMonth number (0..1) <"Specifies the week of the month if used.">
    offsetDays number (1..1) <"Specifies how many days from the trigger event should the payment occur.">
    dateLocation BusinessCenterTime (1..1) <"Specifies where is the time measured.">
    businessCenter BusinessCenterEnum (0..*) <"Specifies the business center for adjustment of calculation period.">

    condition Moy:
        if monthOfYear exists then monthOfYear <= 12

    condition Dom:
        if dayOfMonth exists then dayOfMonth <= 31

    condition Wom:
        if weekOfMonth exists then weekOfMonth <= 5

    condition MoyTerm:
        if monthOfYear exists
        then (period -> period = PeriodEnum -> Y)

    condition DomTerm:
        if dayOfMonth exists then (period -> period = PeriodEnum -> M)

    condition DowTerm:
        if dayOfWeek exists then (period -> period = PeriodEnum -> W)

    condition WomTerm:
        if weekOfMonth exists
        then (period -> period = PeriodEnum -> M)


================================================================================
FILE: rosetta-source/src/main/rosetta/base-desc.rosetta
================================================================================

namespace cdm.base : <"Basic concepts used across the model: date, time, math, static data.">
version "${project.version}"

metaType id string
metaType key string
metaType reference string
metaType scheme string
metaType address string
metaType location string

body Organisation ISDA
body Organisation ICMA <"ICMA promotes well-functioning cross-border capital markets, which are essential to fund sustainable economic growth. It is a not-for-profit membership association with offices in Zurich, London, Paris, Brussels and Hong Kong, serving over 600 member firms in 65 jurisdictions. Among its members are private and official sector issuers, banks, broker-dealers, asset managers, pension funds, insurance companies, market infrastructure providers, central banks and law firms. It provides industry-driven standards and recommendations, prioritising  four core fixed income market areas: primary, secondary, repo and collateral and sustainable finance. ICMA works with regulatory and governmental authorities, helping to ensure that financial regulation supports stable and efficient capital markets.  www.icmagroup.org">
body Organisation ISO

corpus MasterAgreement "Global Master Repurchase Agreement GMRA 2011" GMRA <"The Global Master Repurchase Agreement (GMRA) is a model legal agreement designed for parties transacting repos and is published by the International Capital Market Association (ICMA).">
corpus Guidance "ERCC Guide to Best Practice in the European Repo Market ERCC Guide to Best Practice in the European Repo Market" ERCCBestPractice <"The ERCC Guide to Best Practice in the European Repo Market is published by ICMAs European Repo and Collateral Council (ERCC). Its purpose is to help foster a fair and efficient European repo market by recommending practices which market experience suggests can help avoid uncertainty or disagreement about transactions, and consequent delay or disruption to repo trading and settlement. With the same purpose in mind, the Guide also codifies market conventions, where this has been thought to be helpful, usually in response to queries from market participants.">
corpus Scheme FpML_Coding_Scheme
corpus Scheme ISO_4217_Currency_Scheme

segment schemeLocation
segment namingConvention


================================================================================
FILE: rosetta-source/src/main/rosetta/base-math-enum.rosetta
================================================================================

namespace cdm.base.math : <"Basic maths concepts: quantity and unit, rounding, curve / schedule, non-negativity constraint etc.">
version "${project.version}"

enum AveragingWeightingMethodEnum: <"The enumerated values to specify the method of calculation to be used when averaging rates. Per ISDA 2000 Definitions, Section 6.2. Certain Definitions Relating to Floating Amounts.">
    Unweighted <"The arithmetic mean of the relevant rates for each reset date.">
    Weighted <"The arithmetic mean of the relevant rates in effect for each day in a calculation period calculated by multiplying each relevant rate by the number of days such relevant rate is in effect, determining the sum of such products and dividing such sum by the number of days in the calculation period.">

enum AveragingCalculationMethodEnum: <"Specifies enumerations for the type of averaging calculation.">
    Arithmetic <"Refers to the calculation of an average by taking the sum of observations divided by the count of observations.">
    Geometric <"Refers to the calculation of an average by taking the nth root of the product of n observations.">
    Harmonic <"Refers to the calculation of an average by taking the reciprocal of the arithmetic mean of the reciprocals of the observations.">

enum RoundingDirectionEnum: <"The enumerated values to specify the rounding direction and precision to be used in the rounding of a number.  Used by function cdm.base.math.RoundToPrecision.">
    Up <"A fractional number will be rounded up to the specified number of decimal places (the precision). For example, 5.21 and 5.25 rounded up to 1 decimal place are 5.3 and 5.3 respectively.">
    Down <"A fractional number will be rounded down to the specified number of decimal places (the precision). For example, 5.29 and 5.25 rounded down to 1 decimal place are 5.2 and 5.2 respectively.">
    Nearest <"A fractional number will be rounded either up or down to the specified number of decimal places (the precision) depending on its value. For example, 5.24 would be rounded down to 5.2 and 5.25 would be rounded up to 5.3 if a precision of 1 decimal place were specified.">

enum RoundingModeEnum: <"The enumerated values to specify the rounding direction when rounding of a number to nearest.  Used by function cdm.base.math.RoundToNearest.">
    Down <"A number will be rounded down to the specified nearest number. For example, 529 rounded down to the nearest 10 is 520.">
    Up <"A number will be rounded up to the specified nearest number. For example, 521 rounded up to the nearest 10 is 530.">

enum QuantifierEnum: <"Represents the enumerated values to specify a logical quantification, i.e. either All or Any.">
    All <"Specifies that the condition in the scope of the quantifier is true of every member of the domain i.e. every one of the elements in scope.">
    Any <"Specifies that the condition in the scope of the quantifier is true of at least one member of the domain i.e. one or more of the elements in scope.">

enum CompareOp:
    GreaterThan
    GreaterThanOrEquals
    Equals
    LessThanOrEquals
    LessThan

enum CapacityUnitEnum: <"Provides enumerated values for capacity units, generally used in the context of defining quantities for commodities.">
    ALW <"Denotes Allowances as standard unit.">
    BBL <"Denotes a Barrel as a standard unit.">
    BCF <"Denotes Billion Cubic Feet as a standard unit.">
    BDFT <"Denotes Board Feet as a standard unit.">
    CBM <"Denotes Cubic Meters as a standard unit.">
    CER <"Denotes Certified Emissions Reduction as a standard unit.">
    CRT <"Denotes Climate Reserve Tonnes as a standard unit.">
    DAG <"Denotes 10 grams as a standard unit used in precious metals contracts (e.g MCX).">
    DAY <"Denotes a single day as a standard unit used in time charter trades.">
    DMTU <"Denotes Dry Metric Ton (Tonne) Units - Consists of a metric ton of mass excluding moisture.">
    ENVCRD <"Denotes Environmental Credit as a standard unit.">
    ENVOFST <"Denotes Environmental Offset as a standard unit.">
    FEU <"Denotes a 40 ft. Equivalent Unit container as a standard unit.">
    G <"Denotes a Gram as a standard unit.">
    GBBSH <"Denotes a GB Bushel as a standard unit.">
    GBBTU <"Denotes a GB British Thermal Unit as a standard unit.">
    GBCWT <"Denotes a GB Hundredweight unit as standard unit.">
    GBGAL <"Denotes a GB Gallon unit as standard unit.">
    GBMBTU <"Denotes a Thousand GB British Thermal Units as a standard unit.">
    GBMMBTU <"Denotes a Million GB British Thermal Units as a standard unit.">
    GBT <"Denotes a GB Ton as a standard unit.">
    GBTHM <"Denotes a GB Thermal Unit as a standard unit.">
    GJ <"Denotes a Gigajoule as a standard unit.">
    GW <"Denotes a Gigawatt as a standard unit.">
    GWH <"Denotes a Gigawatt-hour as a standard unit.">
    HL <"Denotes a Hectolitre as a standard unit.">
    HOGB <"Denotes a 100-troy ounces Gold Bar as a standard unit.">
    ISOBTU <"Denotes an ISO British Thermal Unit as a standard unit.">
    ISOMBTU <"Denotes a Thousand ISO British Thermal Unit as a standard unit.">
    ISOMMBTU <"Denotes a Million ISO British Thermal Unit as a standard unit.">
    ISOTHM <"Denotes an ISO Thermal Unit as a standard unit.">
    J <"Denotes a Joule as a standard unit.">
    KG <"Denotes a Kilogram as a standard unit.">
    KL <"Denotes a Kilolitre as a standard unit.">
    KW <"Denotes a Kilowatt as a standard unit.">
    KWD <"Denotes a Kilowatt-day as a standard unit.">
    KWH <"Denotes a Kilowatt-hour as a standard unit.">
    KWM <"Denotes a Kilowatt-month as a standard unit.">
    KWMIN <"Denotes a Kilowatt-minute as a standard unit.">
    KWY <"Denotes a Kilowatt-year as a standard unit.">
    L <"Denotes a Litre as a standard unit.">
    LB <"Denotes a Pound as a standard unit.">
    MB <"Denotes a Thousand Barrels as a standard unit.">
    MBF <"Denotes a Thousand board feet, which are used in contracts on forestry underlyers as a standard unit.">
    MJ <"Denotes a Megajoule as a standard unit.">
    MMBF <"Denotes a Million board feet, which are used in contracts on forestry underlyers as a standard unit.">
    MMBBL <"Denotes a Million Barrels as a standard unit.">
    MSF <"Denotes a Thousand square feet as a standard unit.">
    MT <"Denotes a Metric Ton as a standard unit.">
    MW <"Denotes a Megawatt as a standard unit.">
    MWD <"Denotes a Megawatt-day as a standard unit.">
    MWH <"Denotes a Megawatt-hour as a standard unit.">
    MWM <"Denotes a Megawatt-month as a standard unit.">
    MWMIN <"Denotes a Megawatt-minute as a standard unit.">
    MWY <"Denotes a Megawatt-year as a standard unit.">
    OZT <"Denotes a Troy Ounce as a standard unit.">
    SGB <"Denotes a Standard Gold Bar as a standard unit.">
    TEU <"Denotes a 20 ft. Equivalent Unit container as a standard unit.">
    USBSH <"Denotes a US Bushel as a standard unit.">
    USBTU <"Denotes a US British Thermal Unit as a standard unit.">
    USCWT <"Denotes US Hundredweight unit as a standard unit.">
    USGAL <"Denotes a US Gallon unit as a standard unit.">
    USMBTU <"Denotes a Thousand US British Thermal Units as a standard unit.">
    USMMBTU <"Denotes a Million US British Thermal Units as a standard unit.">
    UST <"Denotes a US Ton as a standard unit.">
    USTHM <"Denotes a US Thermal Unit as a standard unit.">

enum WeatherUnitEnum: <"Provides enumerated values for weather units, generally used in the context of defining quantities for commodities.">
    CDD <"Denotes Cooling Degree Days as a standard unit.">
    CPD <"Denotes Critical Precipitation Day as a standard unit.">
    HDD <"Heating Degree Day as a standard unit.">

enum FinancialUnitEnum: <"Provides enumerated values for financial units, generally used in the context of defining quantities for securities.">
    Contract <"Denotes financial contracts, such as listed futures and options.">
    ContractualProduct <"Denotes a Contractual Product as defined in the CDM.  This unit type would be used when the price applies to the whole product, for example, in the case of a premium expressed as a cash amount.">
    IndexUnit <"Denotes a price expressed in index points, e.g. for a stock index.">
    LogNormalVolatility <"Denotes a log normal volatility, expressed in %/month, where the percentage is represented as a decimal. For example, 0.15 means a log-normal volatility of 15% per month.">
    Share <"Denotes the number of units of financial stock shares.">
    ValuePerDay <"Denotes a value (expressed in currency units) for a one day change in a valuation date, which is typically used for expressing sensitivity to the passage of time, also known as theta risk, or carry, or other names.">
    ValuePerPercent <"Denotes a value (expressed in currency units) per percent change in the underlying rate which is typically used for expressing sensitivity to volatility changes, also known as vega risk.">
    Weight <"Denotes a quantity (expressed as a decimal value) represented the weight of a component in a basket.">

enum ArithmeticOperationEnum: <"An arithmetic operator that can be passed to a function">
    Add <"Addition of 2 values">
    Subtract <"Subtraction of 2nd value from 1st value">
    Multiply <"Multiplication of 2 values">
    Divide <"Division of 1st value by 2nd value">
    Max <"Maximum of 2 values">
    Min <"Minimum of 2 values">

enum QuantityChangeDirectionEnum: <"Specifies whether a quantity change is an increase, a decrease or a replacement, whereby the quantity is always specified as a positive number.">
    Increase <"When the quantity should go up by the specified amount.">
    Decrease <"When the quantity should go down by the specified amount.">
    Replace <"When the quantity should be replaced by the specified amount.">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-math-func.rosetta
================================================================================

namespace cdm.base.math : <"Basic maths concepts: quantity and unit, rounding, curve / schedule, non-negativity constraint etc.">
version "${project.version}"

func CompareNumbers:
    inputs:
        n1 number (1..1)
        op CompareOp (1..1)
        n2 number (1..1)
    output:
        result boolean (1..1)

    set result:
        if op = CompareOp -> GreaterThan
        then n1 > n2 = True
        else if op = CompareOp -> GreaterThanOrEquals
        then n1 >= n2 = True
        else if op = CompareOp -> Equals
        then n1 = n2 = True
        else if op = CompareOp -> LessThanOrEquals
        then n1 <= n2 = True
        else if op = CompareOp -> LessThan
        then n1 < n2 = True
        else False

func Abs: <"Returns the absolute value of a number. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned.">
    inputs:
        arg number (1..1)
    output:
        result number (1..1)
    set result: if arg < 0 then -1 * arg else arg

func Max: <"Returns the greater number of two supplied numbers.">
    inputs:
        a number (1..1)
        b number (1..1)
    output:
        result number (1..1)
    set result: if a > b then a else b

func Min: <"Returns the lesser number of two supplied numbers.">
    inputs:
        a number (1..1)
        b number (1..1)
    output:
        result number (1..1)
    set result: if a > b then b else a

func RoundToNearest: <"Round a number to the supplied nearest, using the supplied rounding mode.">
    [codeImplementation]
    inputs:
        value number (1..1) <"The original (unrounded) number.">
        nearest number (1..1) <"The nearest number to round to.">
        roundingMode RoundingModeEnum (1..1) <"The method of rounding (up to nearest/down to nearest).">
    output:
        roundedValue number (1..1)
    condition PositiveNearest:
        nearest > 0

func RoundToPrecision: <"Round a number to the supplied precision, using the supplied rounding direction.">
    [codeImplementation]
    inputs:
        value number (1..1) <"The original (unrounded) number.">
        precision int (1..1) <"The number of decimal digits of precision.">
        roundingMode RoundingDirectionEnum (1..1) <"The method of rounding (up/down/nearest).">
        removeTrailingZeros boolean (1..1) <"Flag to specify whether to strip trailing zeros.">
    output:
        roundedValue number (1..1) <"The value to the desired precision">

    condition NonNegativePrecision: <"The number of decimal digits of precision should be greater than or equal to zero.">
        precision >= 0

func RoundToSignificantFigures: <"Round a number to the supplied significant figures, using the supplied rounding direction.">
    [codeImplementation]
    inputs:
        value number (1..1) <"The original (unrounded) number.">
        significantFigures int (1..1) <"The number of significant figures.">
        roundingMode RoundingDirectionEnum (1..1) <"The method of rounding (up/down/nearest).">
    output:
        roundedValue number (1..1) <"The value to the desired number of significant figures.">

    condition NonZeroSignificantFigures: <"The number of significant figures should be greater than zero.">
        significantFigures > 0

func CompareQuantityByUnitOfAmount:
    inputs:
        quantity1 Quantity (0..*)
        op CompareOp (1..1)
        quantity2 Quantity (0..*)
        unitOfAmount UnitType (1..1)
    output:
        result boolean (1..1)

    set result:
        FilterQuantity(quantity1, unitOfAmount)
            extract q1 [
                FilterQuantity(quantity2, unitOfAmount)
                    extract q2 [ CompareNumbers(q1 -> value, op, q2 -> value) ]
            ]
            then flatten all = True

func FilterQuantity: <"Filter list of quantities based on unit type.">
    inputs:
        quantities Quantity (0..*) <"List of quantities to filter.">
        unit UnitType (1..1) <"Currency unit type.">
    output:
        filteredQuantities Quantity (0..*)

    add filteredQuantities: quantities filter item -> unit = unit

func FilterQuantityByCurrency: <"Filter list of quantities based on unit type.">
    inputs:
        quantities QuantitySchedule (0..*) <"List of quantities to filter.">
        currency string (1..1) <"Currency unit type.">
    output:
        filteredQuantities QuantitySchedule (0..*)

    add filteredQuantities: quantities filter item -> unit -> currency = currency

func FilterQuantityByCurrencyExists: <"Filter list of quantities based on unit type.">
    inputs:
        quantities QuantitySchedule (0..*) <"List of quantities to filter.">
    output:
        filteredQuantities QuantitySchedule (0..*)

    add filteredQuantities: quantities filter item -> unit -> currency exists

func FilterQuantityByFinancialUnit: <"Filter list of quantities based on unit type.">
    inputs:
        quantities QuantitySchedule (0..*) <"List of quantities to filter.">
        financialUnit FinancialUnitEnum (1..1) <"FinancialUnitEnum unit type.">
    output:
        filteredQuantities QuantitySchedule (0..*)

    add filteredQuantities: quantities filter item -> unit -> financialUnit = financialUnit

func AppendToVector: <"Append a single value to a vector (list of numbers).">
    inputs:
        vector number (0..*) <"Input vector.">
        value number (1..1) <"Value to add to the vector.">
    output:
        resultVector number (0..*) <"Resulting vector.">

    add resultVector: vector
    add resultVector: value

func VectorOperation: <"Generates a result vector by applying the supplied arithmetic operation to each element of the supplied left and right vectors in turn.  i.e. result[n] = left[n] <op> right[n], where <op> is the arithmetic operation defined by ArithmeticOperationEnum.">
    [codeImplementation]
    inputs:
        arithmeticOp ArithmeticOperationEnum (1..1) <"Vector operator.">
        left number (0..*) <"Left vector.">
        right number (0..*) <"Right vector.">
    output:
        result number (0..*) <"Result vector.">

func VectorScalarOperation: <"Generates a result vector by applying the supplied arithmetic operation and scalar right value to each element of the supplied left vector in turn. i.e. result[n] = left[n] <op> right, where <op> is the arithmetic operation defined by ArithmeticOperationEnum.">
    inputs:
        arithmeticOp ArithmeticOperationEnum (1..1) <"Arithmetic operator to be applied.">
        left number (0..*) <"Left vector.">
        right number (0..1) <"Scalar number - a single value to be applied to all elements of vector.">
    output:
        result number (0..*) <"Result vector.">

    alias rightOrDefault: if right exists then right else 0.0

    add result: left extract ArithmeticOperation(item, arithmeticOp, rightOrDefault)

func VectorGrowthOperation: <"Generates a result vector by starting with the supplied base value (typically 1), and then multiplying it in turn by each growth factor, which is typically a number just above 1. For instance, a growth factor of 1.1 reprsents a 10% increase, and 0.9 a 10% decrease. The results will show the successive results of applying the successive growth factors, with the first value of the list being the supplied baseValue, and final value of the results list being the product of all of the supplied values.  i.e. result[1] = baseValue * factor[1], result[n] = result[n-1] * factor[n]. The resulting list will have the one more element than the supplied list of factors.">
    [codeImplementation]
    inputs:
        baseValue number (1..1) <"Original value, typically 1.0.">
        factor number (0..*) <"Vector of growth factors, which are all typically slightly greater than 1.0.">
    output:
        result number (0..*) <"Result vector, showing all of the interim growth values">

func ArithmeticOperation:
    inputs:
        n1 number (1..1)
        op ArithmeticOperationEnum (1..1)
        n2 number (1..1)
    output:
        result number (1..1)

    set result:
        if op = ArithmeticOperationEnum -> Add
        then n1 + n2
        else if op = ArithmeticOperationEnum -> Subtract
        then n1 - n2
        else if op = ArithmeticOperationEnum -> Multiply
        then n1 * n2
        else if op = ArithmeticOperationEnum -> Divide
        then n1 / n2
        else if op = ArithmeticOperationEnum -> Max
        then Max(n1, n2)
        else if op = ArithmeticOperationEnum -> Min
        then Min(n1, n2)


================================================================================
FILE: rosetta-source/src/main/rosetta/base-math-type.rosetta
================================================================================

namespace cdm.base.math : <"Basic maths concepts: quantity and unit, rounding, curve / schedule, non-negativity constraint etc.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.observable.asset.*

type UnitType: <"Defines the unit to be used for price, quantity, or other purposes">
    capacityUnit CapacityUnitEnum (0..1) <"Provides an enumerated value for a capacity unit, generally used in the context of defining quantities for commodities.">
    weatherUnit WeatherUnitEnum (0..1) <"Provides an enumerated values for a weather unit, generally used in the context of defining quantities for commodities.">
    financialUnit FinancialUnitEnum (0..1) <"Provides an enumerated value for financial units, generally used in the context of defining quantities for securities.">
    currency string (0..1) <"Defines the currency to be used as a unit for a price, quantity, or other purpose.">
        [metadata scheme]

    condition UnitType: <"Requires that a unit type must be set.">
        one-of

type MeasureBase: <"Provides an abstract type to define a measure as a number associated to a unit. This type is abstract because all its attributes are optional. The types that extend it can specify further existence constraints.">

    value number (0..1) <"Specifies the value of the measure as a number. Optional because in a measure vector or schedule, this single value may be omitted.">
    unit UnitType (0..1) <"Qualifies the unit by which the amount is measured. Optional because a measure may be unit-less (e.g. when representing a ratio between amounts in the same unit).">

type Measure extends MeasureBase: <"Defines a concrete measure as a number associated to a unit. It extends MeasureBase by requiring the value attribute to be present. A measure may be unit-less so the unit attribute is still optional.">

    condition ValueExists: <"The value attribute must be present in a concrete measure.">
        value exists

type MeasureSchedule extends MeasureBase: <"A set of measures, all in the same unit, where the values are defined through a schedule of steps. The initial value may be defined either as part of the steps, or using the single amount attribute.">
    datedValue DatedValue (0..*) <"A schedule of step date and value pairs. On each step date the associated step value becomes effective. The step dates are used to order the steps by ascending order. This attribute is optional so the data type may be used to define a schedule with a single value.">

    condition ValueExists: <"A schedule may be specified as a single value or as a set of date-value pairs. Both attributes may be specified, in which case the single amount number is the initial value.">
        value exists or datedValue exists

type QuantitySchedule extends MeasureSchedule: <"Specifies a quantity schedule to be associated to a financial product to represent a trade amount. This data type extends MeasureSchedule with several unit or multiplier attributes that are used to define financial quantities. This data type is generically based on a schedule and can also be used to represent a quantity as a single value.">

    multiplier Measure (0..1) <"Defines an optional number that the quantity should be multiplied by to derive a total quantity. This number is associated to a unit. For example in the case of the Coal (API2) CIF ARA (ARGUS-McCloskey) Futures Contract on the CME, where the unit would be contracts, the multiplier value would 1,000 and the mulitiplier unit would be 1,000 MT (Metric Tons).">
    frequency Frequency (0..1) <"Defines the frequency to be used when defining a quantity. For example a quantity may be specified as a number of barrels of oil per day, which needs multiplying by the number of days in the relevant period to get the total quantity as a number of barrels.">

    condition Quantity_multiplier: <"Requires that the multiplier must be positive.">
        if multiplier exists then multiplier -> value >= 0.0

    condition UnitOfAmountExists: <"Requires that a unit of amount must be specified for any quantity.">
        unit exists

type Quantity extends QuantitySchedule: <"Specifies a quantity as a single value to be associated to a financial product, for example a transfer amount resulting from a trade. This data type extends QuantitySchedule and requires that only the single amount value exists.">

    condition AmountOnlyExists: <"The amount must exist when the quantity represents a single value, and the steps must be absent.">
        value exists and datedValue is absent

type NonNegativeQuantity extends Quantity: <"Specifies a quantity as a non-negative number, which condition is enforced through a data rule that only applies to the extending class.">

    condition NonNegativeQuantity_amount: <"For a non-negative quantity, the amount attribute must be positive.">
        value >= 0.0

type NonNegativeStep: <"A class defining a step date and non-negative step value pair. This step definitions are used to define varying rate or amount schedules, e.g. a notional amortisation or a step-up coupon schedule.">
    [metadata key]

    stepDate date (1..1) <"The date on which the associated stepValue becomes effective. This day may be subject to adjustment in accordance with a business day convention.">
    stepValue number (1..1) <"The non-negative rate or amount which becomes effective on the associated stepDate. A rate of 5% would be represented as 0.05.">

    condition StepValue: <"FpML specified stepValue as a NonNegativeDecimal.">
        stepValue >= 0.0

type NonNegativeQuantitySchedule extends QuantitySchedule:

    condition NonNegativeQuantity_amount: <"For a non-negative quantity, all amount attribute must be positive.">
        if value exists
        then value >= 0.0 and if datedValue exists
                then datedValue -> value all >= 0.0

type Rounding: <"Defines rounding rules and precision to be used in the rounding of a number.">

    roundingDirection RoundingDirectionEnum (1..1) <"Specifies the rounding rounding rule as up, down, or nearest.">
    precision int (0..1) <"Specifies the rounding precision in terms of a number of decimal places when the number is evaluated in decimal form (not percentage), e.g. 0.09876543 rounded to the nearest 5 decimal places is  0.0987654.">

type Schedule: <"A class defining a schedule of rates or amounts in terms of an initial value and then a series of step date and value pairs. On each step date the rate or amount changes to the new step value. The series of step date and value pairs are optional. If not specified, this implies that the initial value remains unchanged over time.">

    value number (1..1) <"The initial rate or amount, as the case may be. An initial rate of 5% would be represented as 0.05.">
    datedValue DatedValue (0..*) <"The schedule of step date and value pairs. On each step date the associated step value becomes effective. A list of steps may be ordered in the document by ascending step date. An FpML document containing an unordered list of steps is still regarded as a conformant document.">

type DatedValue: <"Defines a date and value pair. This definition is used for varying rate or amount schedules, e.g. a notional amortisation or a step-up coupon schedule.">
    [metadata key]

    date date (1..1) <"The date on which the associated step value becomes effective. This day may be subject to adjustment in accordance with a business day convention.">
    value number (1..1) <"The rate of amount which becomes effective on the associated step date. A rate of 5% would be represented as 0.05.">

type NumberRange: <"The number range defined as either a lower and upper number bound, or both.">

    lowerBound NumberBound (0..1) <"The lower bound of a number range, e.g. greater than or equal to 5.">
    upperBound NumberBound (0..1) <"The upper bound of a number range, e.g. less than 10.">

    condition AtLeastOneOf:
        lowerBound exists or upperBound exists

type NumberBound: <"The number bound is defined as a number and whether the bound is inclusive.">

    number number (1..1) <"The number to be used as the bound, e.g. 5.">
    inclusive boolean (1..1) <"Whether the number bound is inclusive, e.g. for a lower bound, false would indicate greater than, whereas true would indicate greater than or equal to.">

type MoneyRange: <"The money range defined as either a lower and upper money bound, or both.">

    lowerBound MoneyBound (0..1) <"The lower bound of a money range, e.g. greater than or equal to 1,000 USD.">
    upperBound MoneyBound (0..1) <"The upper bound of a money range, e.g. less than 10,000 USD.">

    condition AtLeastOneOf:
        lowerBound exists or upperBound exists

type MoneyBound: <"The money bound is defined as a money amount and whether the bound is inclusive.">

    money Money (1..1) <"The money amount to be used as the bound, e.g. 1,000 USD.">
    inclusive boolean (1..1) <"Whether the money amount bound is inclusive, e.g. for a lower bound, false would indicate greater than, whereas true would indicate greater than or equal to.">

type AveragingCalculationMethod: <"Defines the ways in which multiple values can be aggregated into a single value.">
    isWeighted boolean (1..1) <"Identifies whether the average values will be weighted or unweighted.">
    calculationMethod AveragingCalculationMethodEnum (1..1) <"Identifies which of the Pythagorean means is being used to compute an average value.">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-commodity-enum.rosetta
================================================================================

namespace cdm.base.staticdata.asset.commodity
version "${project.version}"

import cdm.base.*

enum ProductGradeEnum: <"Identifies the grade of physical commodity product to be delivered.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/commodity-oil-product-grade"]

    _0_1_Percent displayName "0.1-Percent" <"Applies to Oil Product Type Fuel Oil.">
    _0_5_Percent displayName "0.5-Percent" <"Applies to Oil Product Type Fuel Oil.">
    _1_0_Percent displayName "1.0-Percent" <"Applies to Oil Product Type Fuel Oil.">
    _10_PPM displayName "10-PPM" <"Applies to Oil Product Type Gasoline.">
    _10_PPM_95_R displayName "10-PPM-95-R" <"Applies to Oil Product Type Gasoline.">
    _10_PPM_Premium_Unleaded displayName "10-PPM-Premium-Unleaded" <"Applies to Oil Product Type Gasoline.">
    _10_PPM_Regular_Unleaded displayName "10-PPM-Regular-Unleaded" <"Applies to Oil Product Type Gasoline.">
    _180_CST displayName "180-CST" <"Applies to Oil Product Type Fuel Oil.">
    _3_5_Percent displayName "3.5-Percent" <"Applies to Oil Product Type Fuel Oil.">
    _380_CST displayName "380-CST" <"Applies to Oil Product Type Fuel Oil.">
    _50_PPM displayName "50-PPM" <"Applies to Oil Product Type Fuel Oil.">
    _54 displayName "54" <"Applies to Oil Product Type Jet Fuel.">
    _55 displayName "55" <"Applies to Oil Product Type Jet Fuel.">
    _87_M displayName "87-M" <"Applies to Oil Product Type Gasoline.">
    _87_Unleaded displayName "87-Unleaded" <"Applies to Oil Product Type Gasoline.">
    _87_Unleaded_ULS_30 displayName "87-Unleaded-ULS-30" <"Applies to Oil Product Type Gasoline.">
    _92_Unleaded displayName "92-Unleaded" <"Applies to Oil Product Type Gasoline.">
    _93_Unleaded displayName "93-Unleaded" <"Applies to Oil Product Type Gasoline.">
    _95_Unleaded displayName "95-Unleaded" <"Applies to Oil Product Type Gasoline.">
    _97_Unleaded displayName "97-Unleaded" <"Applies to Oil Product Type Gasoline.">
    _98_Unleaded displayName "98-Unleaded" <"Applies to Oil Product Type Gasoline.">
    Arabian_Light displayName "Arabian-Light" <"Applies to Oil Product Type Oil.">
    Brass_Blend displayName "Brass-Blend" <"Applies to Oil Product Type Oil.">
    Brent <"Applies to Oil Product Type Oil.">
    CARBOB <"Applies to Oil Product Type Gasoline.">
    CBOB <"Applies to Oil Product Type Gasoline.">
    Cold_Lake displayName "Cold-Lake" <"Applies to Oil Product Type Oil.">
    Dubai <"Applies to Oil Product Type Oil.">
    Edmonton_High_Sulphur_Sour displayName "Edmonton-High-Sulphur-Sour" <"Applies to Oil Product Type Oil.">
    EUROBOB <"Applies to Oil Product Type Gasoline.">
    German_10PPM displayName "German-10PPM" <"Applies to Oil Product Type Diesel Fuel.">
    Gulf_Coast_Sweet displayName "Gulf-Coast-Sweet" <"Applies to Oil Product Type Oil.">
    Hardisty_Light displayName "Hardisty-Light" <"Applies to Oil Product Type Oil.">
    Iranian_Light_1 displayName "Iranian-Light" <"Applies to Oil Product Type Oil.">
    Iranian_Light displayName "Iranian-Light" <"Applies to Oil Product Type Oil.">
    Jet <"Applies to Oil Product Type Jet Fuel.">
    Kirkuk_Light displayName "Kirkuk-Light" <"Applies to Oil Product Type Oil.">
    Kuwait <"Applies to Oil Product Type Oil.">
    Light_Louisiana_Sweet displayName "Light-Louisiana-Sweet" <"Applies to Oil Product Type Oil.">
    Low_Sulphur displayName "Low-Sulphur" <"Applies to Oil Product Type Diesel Fuel.">
    Low_Sulphur_Jet displayName "Low-Sulphur-Jet" <"Applies to Oil Product Type Jet Fuel.">
    Mars <"Applies to Oil Product Type Oil.">
    Mixed_Sour_Blend displayName "Mixed-Sour-Blend" <"Applies to Oil Product Type Oil.">
    Mixed_Sweet_Blend displayName "Mixed-Sweet-Blend" <"Applies to Oil Product Type Oil.">
    Murban <"Applies to Oil Product Type Oil.">
    Natural_Gasoline displayName "Natural-Gasoline" <"Applies to Oil Product Type Gasoline.">
    No__2 displayName "No.-2" <"Applies to Oil Product Type Diesel Fuel.">
    No__6_0_3_Percent displayName "No.-6-0.3-Percent" <"Applies to Oil Product Type Fuel Oil.">
    No__6_0_3_Percent_HP displayName "No.-6-0.3-Percent-HP" <"Applies to Oil Product Type Fuel Oil.">
    No__6_0_3_Percent_LP displayName "No.-6-0.3-Percent-LP" <"Applies to Oil Product Type Fuel Oil.">
    No__6_0_7_Percent displayName "No.-6-0.7-Percent" <"Applies to Oil Product Type Fuel Oil.">
    No__6_1_0_Percent displayName "No.-6-1.0-Percent" <"Applies to Oil Product Type Fuel Oil.">
    No__6_2_2_Percent displayName "No.-6-2.2-Percent" <"Applies to Oil Product Type Fuel Oil.">
    No__6_3_Percent displayName "No.-6-3-Percent" <"Applies to Oil Product Type Fuel Oil.">
    Normal_Butane displayName "Normal-Butane" <"Applies to Oil Product Type Butane.">
    North_Dakota_Light displayName "North-Dakota-Light" <"Applies to Oil Product Type Oil.">
    Oman <"Applies to Oil Product Type Oil.">
    Polymer_Grade displayName "Polymer-Grade" <"Applies to Oil Product Type Propylene.">
    RBOB <"Applies to Oil Product Type Gasoline.">
    Saharan <"Applies to Oil Product Type Oil.">
    Sour <"Applies to Oil Product Type Oil.">
    Southern_Green_Canyon displayName "Southern-Green-Canyon" <"Applies to Oil Product Type Oil.">
    Tapis <"Applies to Oil Product Type Oil.">
    Thunder_Horse displayName "Thunder-Horse" <"Applies to Oil Product Type Oil.">
    Ultra_Low_Sulphur displayName "Ultra-Low-Sulphur" <"Applies to Oil Product Type Diesel Fuel.">
    Urals <"Applies to Oil Product Type Oil.">
    Urals_Sour displayName "Urals-Sour" <"Applies to Oil Product Type Oil.">
    US_Regular_Unleaded displayName "US-Regular-Unleaded" <"Applies to Oil Product Type Gasoline.">
    Western_Canadian_Select displayName "Western-Canadian-Select" <"Applies to Oil Product Type Oil.">
    WTI <"Applies to Oil Product Type Oil.">
    WTS <"Applies to Oil Product Type Oil.">
    Zuetina <"Applies to Oil Product Type Oil.">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-common-enum.rosetta
================================================================================

namespace cdm.base.staticdata.asset.common : <"Basic static asset concepts that apply across asset classes: taxonomy etc.">
version "${project.version}"

import cdm.base.*

enum AssetClassEnum: <"The enumerated values to specify the FpML asset class categorization.">
    Commodity <"Commodity.">
    Credit <"Credit.">
    Equity <"Equity.">
    ForeignExchange <"ForeignExchange.">
    InterestRate <"InterestRate.">
    MoneyMarket <"Money Market Assets like CP and CD.">

enum AssetIdTypeEnum extends ProductIdTypeEnum: <"Extends product identifiers with additional identifier sources for Assets.">
    CurrencyCode <"Used to identify the currency of a Cash Asset.">
    ExchangeCode <"The identifier follows the symbology set by the exchange which lists the asset.">
    ClearingCode <"The identifier follows the symbology set by the clearing house which clears the asset.">

enum ProductIdTypeEnum: <"Provides the enumerated values to specify the product identifier source.">
    BBGID <"Published by Bloomberg, the BBGID is a 12-digit alphanumeric randomly generated ID covering active and non-active securities.">
    BBGTICKER <"Published by Bloomberg as a short code to identify publicly trades shares of a particular stock on a specific exchange.">
    CUSIP <"Derived from the Committee on Uniform Security Identification Procedures, CUSIPs are 9-character identifiers that capture an issue’s important differentiating characteristics for issuers and their financial instruments in the U.S. and Canada.">
    FIGI <"Issued under the guidelines of the Object Management Group, the Financial Instrument Global Identifier (FIGI) is a 12 character, alphanumeric, randomly generated ID covering hundreds of millions of active and inactive instruments. The identifier acts as a Uniform Resource Identifier (URI) to link to a set of metadata that uniquely and clearly describes the instrument.">
    ISDACRP <"Issued by the International Swaps Dealers Association as a string representing a Commodity Reference Price used for purposes of determining a relevant price for an underlying commodity in an OTC derivatives contract.">
    ISIN <"Issued by The International Securities Identification Number (ISIN) Organization, the ISIN is a 12-character alpha-numerical code used to uniformly identify a security for trading and settlement purposes. Securities with which ISINs can be used include debt securities, such as notes or bonds as well shares, such as common stock or shares of a fund, options, derivatives, and futures. The ISIN structure is defined in ISO 6166.">
    Name <"The name of the product.">
    REDID <"Assigned by S&P Global Market Intelligence, REDID (Reference Entity Data Identifier) is a unique alphanumeric code to reference entities, primarily utilized within the credit derivatives market for the standardized identification of underlying entities.">
    RIC <"Issued by Refinitiv (formerly Reuters), the Reuters Instrument Codes(RIC) uniquely identifies financial instruments, including where they are traded.">
    Other <"Used when the source is not otherwise in this enumerated list because it is internal or other reasons.  The source can be identified in the scheme which is part of the identifier attribute.">
    Sicovam <"Issued by the French Société Interprofessionnelle pour la Compensation des Valeurs Mobilières (SICOVAM) to identify French securities listed on French stock exchanges.">
    SEDOL <"Assigned by the London Stock Exchange, the Stock Exchange Daily Official List (SEDOL) is a list of security identifiers used in the United Kingdom and Ireland for clearing purposes.  SEDOLs serve as the National Securities Identifying Number for all securities issued in the United Kingdom and are therefore part of the security's ISIN as well.">
    UPI <"Assigned by the Derivatives Service Bureau Ltd (DSB), the Unique Product Identifier (UPI) is a unique code to describe an over-the-counter (OTC) derivatives product.  The UPI is used for identifying the product in transaction reporting data.">
    Valoren <"Assigned by SIX Financial Information, Valoren is a unique numerical identification number typically ranging from six to nine digits primarily traded in Switzerland, Liechtenstein, and Belgium. This code enables the identification of securities such as stocks, bonds, and investment funds within these markets.">
    Wertpapier <"Issued by the Institute for the Issuance and Administration of Securities in Germany (Securities Information), the Wertpapierkennnummer (WKN, WPKN, WPK or simply Wert) consists of six digits or capital letters (excluding I and O), and no check digit. It is used to identify German securities.">

enum TaxonomySourceEnum: <"Represents the enumerated values to specify taxonomy sources.">
    CFI <"Represents the ISO 10962 Classification of Financial Instruments code.">
    ISDA <"Represents the ISDA product taxonomy.">
    ICAD <"Represents the ISDA Collateral Asset Definition Identifier code.">
    EMIR <"Represents the EMIR Article 9 Asset Definition Identifier code.">
    EU_EMIR_EligibleCollateralAssetClass <"Identifies European Union Eligible Collateral Assets classification categories based on EMIR Uncleared Margin Rules.">
    UK_EMIR_EligibleCollateralAssetClass <"Identifies United Kingdom Eligible Collateral Assets classification categories based on UK Onshored EMIR Uncleared Margin Rules Eligible Collateral asset classes for both initial margin (IM) and variation margin (VM) posted and collected between specified entities.Please note: UK EMIR regulation will detail which eligible collateral assets classes apply to each type of entity pairing (counterparty) and which apply to posting of IM and VM.">
    US_CFTC_PR_EligibleCollateralAssetClass <"Identifies US Eligible Collateral Assets classification categories based on Uncleared Margin Rules published by the CFTC and the US Prudential Regulator. Note: While the same basic categories exist in the CFTC and US Prudential Regulators margin rules, the precise definitions or application of those rules could differ between the two rules.">
    MAS <"Represents the Monetary Authority of Singapore (MAS) as a taxonomy source.">
    CSA <"Represents the Canadian Securities Administrators (CSA) as a taxonomy source.">
    Other <"Denotes a user-specific scheme or taxonomy or other external sources not listed here.">

enum ISOCurrencyCodeEnum: <"The enumerated values to specify standard currency codes according to the International Standards Organization (ISO).  The set of codes in this enumerated list is sourced from ISO Standard 4217 (https://www.currency-iso.org/en/home/tables/table-a1.html), as of 29-Aug-18.">
    [docReference ISO ISO_4217_Currency_Scheme schemeLocation "https://www.six-group.com/dam/download/financial-information/data-center/iso-currrency/lists/list-one.xml"]

    AED <"UAE Dirham">
    AFN <"Afghani">
    ALL <"Lek">
    AMD <"Armenian Dram">
    AOA <"Kwanza">
    ARS <"Argentine Peso">
    AUD <"Australian Dollar">
    AWG <"Aruban Florin">
    AZN <"Azerbaijan Manat">
    BAM <"Convertible Mark">
    BBD <"Barbados Dollar">
    BDT <"Taka">
    BGN <"Bulgarian Lev">
    BHD <"Bahraini Dinar">
    BIF <"Burundi Franc">
    BMD <"Bermudian Dollar">
    BND <"Brunei Dollar">
    BOB <"Boliviano">
    BOV <"Mvdol">
    BRL <"Brazilian Real">
    BSD <"Bahamian Dollar">
    BTN <"Ngultrum">
    BWP <"Pula">
    BYN <"Belarusian Ruble">
    BZD <"Belize Dollar">
    CAD <"Canadian Dollar">
    CDF <"Congolese Franc">
    CHE <"WIR Euro">
    CHF <"Swiss Franc">
    CHW <"WIR Franc">
    CLF <"Unidad de Fomento">
    CLP <"Chilean Peso">
    CNY <"Yuan Renminbi">
    COP <"Colombian Peso">
    COU <"Unidad de Valor Real">
    CRC <"Costa Rican Colon">
    CUP <"Cuban Peso">
    CVE <"Cabo Verde Escudo">
    CZK <"Czech Koruna">
    DJF <"Djibouti Franc">
    DKK <"Danish Krone">
    DOP <"Dominican Peso">
    DZD <"Algerian Dinar">
    EGP <"Egyptian Pound">
    ERN <"Nakfa">
    ETB <"Ethiopian Birr">
    EUR <"Euro">
    FJD <"Fiji Dollar">
    FKP <"Falkland Islands Pound">
    GBP <"Pound Sterling">
    GEL <"Lari">
    GHS <"Ghana Cedi">
    GIP <"Gibraltar Pound">
    GMD <"Dalasi">
    GNF <"Guinean Franc">
    GTQ <"Quetzal">
    GYD <"Guyana Dollar">
    HKD <"Hong Kong Dollar">
    HNL <"Lempira">
    HTG <"Gourde">
    HUF <"Forint">
    IDR <"Rupiah">
    ILS <"New Israeli Sheqel">
    INR <"Indian Rupee">
    IQD <"Iraqi Dinar">
    IRR <"Iranian Rial">
    ISK <"Iceland Krona">
    JMD <"Jamaican Dollar">
    JOD <"Jordanian Dinar">
    JPY <"Yen">
    KES <"Kenyan Shilling">
    KGS <"Som">
    KHR <"Riel">
    KMF <"Comorian Franc ">
    KPW <"North Korean Won">
    KRW <"Won">
    KWD <"Kuwaiti Dinar">
    KYD <"Cayman Islands Dollar">
    KZT <"Tenge">
    LAK <"Lao Kip">
    LBP <"Lebanese Pound">
    LKR <"Sri Lanka Rupee">
    LRD <"Liberian Dollar">
    LSL <"Loti">
    LYD <"Libyan Dinar">
    MAD <"Moroccan Dirham">
    MDL <"Moldovan Leu">
    MGA <"Malagasy Ariary">
    MKD <"Denar">
    MMK <"Kyat">
    MNT <"Tugrik">
    MOP <"Pataca">
    MRU <"Ouguiya">
    MUR <"Mauritius Rupee">
    MVR <"Rufiyaa">
    MWK <"Malawi Kwacha">
    MXN <"Mexican Peso">
    MXV <"Mexican Unidad de Inversion (UDI)">
    MYR <"Malaysian Ringgit">
    MZN <"Mozambique Metical">
    NAD <"Namibia Dollar">
    NGN <"Naira">
    NIO <"Cordoba Oro">
    NOK <"Norwegian Krone">
    NPR <"Nepalese Rupee">
    NZD <"New Zealand Dollar">
    OMR <"Rial Omani">
    PAB <"Balboa">
    PEN <"Sol">
    PGK <"Kina">
    PHP <"Philippine Peso">
    PKR <"Pakistan Rupee">
    PLN <"Zloty">
    PYG <"Guarani">
    QAR <"Qatari Rial">
    RON <"Romanian Leu">
    RSD <"Serbian Dinar">
    RUB <"Russian Ruble">
    RWF <"Rwanda Franc">
    SAR <"Saudi Riyal">
    SBD <"Solomon Islands Dollar">
    SCR <"Seychelles Rupee">
    SDG <"Sudanese Pound">
    SEK <"Swedish Krona">
    SGD <"Singapore Dollar">
    SHP <"Saint Helena Pound">
    SLE <"Leone">
    SOS <"Somali Shilling">
    SRD <"Surinam Dollar">
    SSP <"South Sudanese Pound">
    STN <"Dobra">
    SVC <"El Salvador Colon">
    SYP <"Syrian Pound">
    SZL <"Lilangeni">
    THB <"Baht">
    TJS <"Somoni">
    TMT <"Turkmenistan New Manat">
    TND <"Tunisian Dinar">
    TOP <"Pa’anga">
    TRY <"Turkish Lira">
    TTD <"Trinidad and Tobago Dollar">
    TWD <"New Taiwan Dollar">
    TZS <"Tanzanian Shilling">
    UAH <"Hryvnia">
    UGX <"Uganda Shilling">
    USD <"US Dollar">
    USN <"US Dollar (Next day)">
    UYI <"Uruguay Peso en Unidades Indexadas (UI)">
    UYU <"Peso Uruguayo">
    UYW <"Unidad Previsional">
    UZS <"Uzbekistan Sum">
    VED <"Bolívar Soberano">
    VES <"Bolívar Soberano">
    VND <"Dong">
    VUV <"Vatu">
    WST <"Tala">
    XAD <"Arab Accounting Dinar">
    XAF <"CFA Franc BEAC">
    XAG <"Silver">
    XAU <"Gold">
    XBA <"Bond Markets Unit European Composite Unit (EURCO)">
    XBB <"Bond Markets Unit European Monetary Unit (E.M.U.-6)">
    XBC <"Bond Markets Unit European Unit of Account 9 (E.U.A.-9)">
    XBD <"Bond Markets Unit European Unit of Account 17 (E.U.A.-17)">
    XCD <"East Caribbean Dollar">
    XCG <"Caribbean Guilder">
    XDR <"SDR (Special Drawing Right)">
    XOF <"CFA Franc BCEAO">
    XPD <"Palladium">
    XPF <"CFP Franc">
    XPT <"Platinum">
    XSU <"Sucre">
    XTS <"Codes specifically reserved for testing purposes">
    XUA <"ADB Unit of Account">
    XXX <"The codes assigned for transactions where no currency is involved">
    YER <"Yemeni Rial">
    ZAR <"Rand">
    ZMW <"Zambian Kwacha">
    ZWG <"Zimbabwe Gold">

enum CurrencyCodeEnum extends ISOCurrencyCodeEnum: <"Union of the enumerated values defined by the International Standards Organization (ISO) and the FpML nonISOCurrencyScheme which consists of offshore and historical currencies (https://www.fpml.org/coding-scheme/non-iso-currency), as of 28-Oct-2016.">
    CNH <"Offshore Chinese Yuan traded in Hong Kong.">
    CNT <"Offshore Chinese Yuan traded in Taiwan.">
    GGP <"Guernsey Pound.">
    IMP <"Isle of Man Pound.">
    JEP <"Jersey Pound.">
    KID <"Tuvaluan Dollar.">
    MCF <"Monegasque Franc.">
    SML <"Sammarinese Lira.">
    VAL <"Vatican Lira.">

enum IssuerTypeEnum: <"Represents an enumeration list to identify the type of entity issuing the asset.">
    SupraNational <"Specifies debt issued by international organisations and multilateral banks, entities constituted by treaties or with multiple sovereign members includes Multilateral development Banks.">
    SovereignCentralBank <"Specifies Sovereign, Government Debt Securities including Central Banks.">
    QuasiGovernment <"Specifies debt issues by institutions or bodies, typically constituted by statute, with a function mandated by the government and subject to government supervision inclusive of profit- and non-profit making bodies. Includes the US Agencies and GSEs and the EU concept of public sector entities. Excluding any entities which are also Regional Government.">
    RegionalGovernment <"Specifies Regional Government Issued Debt including states within countries, local authorities and municipalities.">
    Corporate <"Specifies debt issued Securities by corporate bodies including Banks.">
    Fund <"Specifies a vehicle (with or without separate legal personality) designed for the purposes of collective investment towards a defined investment goal.">
    SpecialPurposeVehicle <"Specifies a vehicle setup for the purpose of acquisition and financing of specific assets on a limited recourse basis. E.g. asset backed securities, including securitisations.">

enum SupraNationalIssuerTypeEnum: <"Represents an enumeration list to identify the type of supranational entity issuing the asset.">
    InternationalOrganisation <"Specifies International Financial Institution.">
    MultilateralBank <"Specifies Multilateral Bank or Multilateral Development Bank.">

enum CreditRiskEnum: <"Represents an enumeration list to identify tranched or untranched credit risk.">
    TranchedCreditRisk <"Indicates tranched credit risk, including securitizations.">
    UntranchedCreditRisk <"Indicates tranched credit risk, including repackagings.">

enum InstrumentTypeEnum: <"Represents an enumeration list to indentify the type of an instrument.">
    Debt <"Identifies an instrument as a fixed income instrument of debt issued and securitized as a tradable asset.">
    Equity <"Identifies an instrument as an Equity value of holding of shares in listed company.">
    Fund <"Identifies an instrument as representing holding in an investment fund.">
    Warrant <"Identifies an instrument as a Warrant that give the right, but not the obligation, to buy or sell a security — most commonly an equity — at a certain price before expiration, or to receive the cash equivalent.">
    Certificate <"Identifies an instrument as one that that offers a derivative-based economic return which is not structured as a bond, an equity or a warrant. Note that this security type is not a Certificate of Deposit (aka CD).">
    LetterOfCredit <"Identifies an instrument as a letter of credit or documentary credit/ bankers commercial credit.  A payment mechanism used in international trade to provide economic guarantee of payment by a creditworthy issuer for payment of exported goods.">
    ListedDerivative <"Identifies an instrument as a listed derivative on an exchange.">

enum PutCallEnum: <"The enumerated values to specify the types of listed derivative options.">
    Put <"A put option gives the holder the right to sell the underlying asset by a certain date for a certain price.">
    Call <"A call option gives the holder the right to buy the underlying asset by a certain date for a certain price.">

enum EquityTypeEnum: <"Represents an enumeration list to identify the type of Equity.">
    Ordinary <"Identifies an Equity of Common stocks and shares.">
    NonConvertiblePreference <"Identifies an Equity of Non-Convertible Preference, Shares which hold priority to receive capital return in event of issuer liquidation.">

enum FundProductTypeEnum: <"Represents an enumeration list to identify the fund product type.">
    MoneyMarketFund <"Denotes a fund that invests only in highly liquid near-term instruments such as cash, cash equivalent securities, and high credit rating debt instruments with a short-term maturity.">
    ExchangeTradedFund <"Denotes an investment fund consisting of stocks, bonds, and/or other assets that is passively managed and traded on a stock exchange.">
    MutualFund <"Denotes an investment fund consisting of stocks, bonds, and/or other assets that is actively managed and can only be purchased or sold through the investment manager.">
    OtherFund <"Denotes a fund that is not an Exchange Traded Fund, Money Market Fund or Mutual Fund.">

enum MaturityTypeEnum: <"Represents an enumeration list to identify the Maturity.">
    RemainingMaturity <"Denotes a period from now until maturity date.">
    OriginalMaturity <"Denotes a period from issuance until maturity date.">
    FromIssuance <"Denotes a period from issuance date until now.">

enum DebtClassEnum: <"Represents an enumeration list that identifies the type of debt.">

    AssetBacked <"Identifies a debt instrument that has periodic income payments and value derived from or backed by a specified pool of underlying assets which could be mortgages or other obligations.">
    Convertible <"Identifies a debt instrument that can be converted into common shares.">
    RegCap <"Identifies a debt instrument as one issued by financial institutions to count towards regulatory capital, including term and perpetual subordinated debt, contingently convertible and others.  Excludes preferred share capital.">
    Structured <"Identifies a debt instrument athat has non-standard interest or principal features, with full recourse to the issuer.">
    Vanilla <"Identifies a debt instrument that has a periodic coupon, a defined maturity, and is not backed by any specific asset. The seniority and the structure of the income and principal payments can optionally be defined in DebtType.DebtEconomics.">
    HolderConvertible <"Identifies a debt instrument that can be converted primarily at the election of the holder into common shares of the Issuer.">
    HolderExchangeable <"Identifies a debt instrument that can be converted primarily at the election of the holder into common shares of a party other than the Issuer.">
    IssuerConvertible <"Identifies a debt instrument that can be converted at the election of the Issuer into common shares of the Issuer.  Also known as reverse convertible.">
    IssuerExchangeable <"Identifies a debt instrument that can be converted at the election of the Issuer into common shares of a party other than the Issuer.  Also known as reverse exchangeable.">

enum DebtSeniorityEnum: <"Specifies the order of repayment in the event of a sale or bankruptcy of the issuer or a related party (eg guarantor).">
    Secured <"Denotes debt which is secured over assets of the issuer or a related party (eg guarantor).">
    Senior <"Denotes debt  which ranks pari passu with all other unsecured creditors of the issuer.">
    Subordinated <"Denotes debt  owed to an unsecured creditor that in the event of a liquidation can only be paid after the claims of secured and senior creditors have been met.">

enum DebtInterestEnum: <"Represents an enumeration list that specifies the general rule for periodic interest rate payment.">
    Fixed <"Denotes payment calculated with reference to a fixed interest rate.">
    Floating <"Denotes payment calculated with reference to a floating interest rate.">
    InflationLinked <"Denotes payment calculated with reference to one or more specified inflation rates.">
    IndexLinked <"Denotes payment calculated with reference to one or more price or other indices (other than inflation rates).">
    InterestOnly <"Denotes a stripped bond representing only the interest component.">
    OtherStructured <"Denotes payment calculated with reference to other underlyings (not being floating interest rates, inflation rates or indices) or with a non-linear relationship to floating interest rates, inflation rates or indices.">
    InverseFloating <"Denotes payment calculated with reference to the inverse of a floating interest rate.">
    ZeroCoupon <"Denotes a zero coupon bond that does not pay intetrest.">

enum DebtPrincipalEnum: <"Represents an enumeration list that specifies the general rule for repayment of principal.">
    Bullet <"Denotes that the principal is paid all at once on maturity of the debt insrument. Bullet debt instruments cannot be redeemed early by an issuer, which means they are non-callable.">
    Callable <"Denotes that the principal on the debt can be repaid early, in whole or in part, at the option of the issuer.">
    Puttable <"Denotes that the principal on the debt can be repaid early, in whole or in part, at the option of the holder.">
    Amortising <"Denotes that the principal on the debt is paid down regularly, along with its interest expense over the life of the debt instrument.  Includes amortising instruments with a bullet balance repayment at maturity.">
    InflationLinked <"Denotes that the principal on the debt is calculated with reference to one or more specified inflation rates.">
    IndexLinked <"Denotes that the  principal on the debt is calculated with reference to one or more price or other indices (other than inflation rates).">
    OtherStructured <"Denotes that the  principal on the debt is calculated with reference to other underlyings (not being floating interest rates, inflation rates or indices) or with a non-linear relationship to floating interest rates, inflation rates or indices.">
    PrincipalOnly <"Denotes a stripped bond representing only the principal component.">

enum AssetTypeEnum: <"Represents an enumeration list to identify the asset type.">
    Security <"Indentifies negotiable financial instrument of monetary value with an issue ownership position.">
    Cash <"Indentifies cash in a currency form.">
    Commodity <"Indentifies basic good used in commerce that is interchangeable with other goods of the same type.">
    Other <"Indentifies other asset types.">

enum MoneyMarketTypeEnum:
    CommercialPaper
    CertificateOfDeposit

enum DeliveryNearbyTypeEnum:
    CalculationPeriod <"Describes the reference contract as the one that pertains to the month-year of the calculation period. If used, the nearby count is expected to be 0.">
    NearbyMonth <"Specifies that the reference delivery date of the underlying Commodity shall be the expiration date of the futures contract in the nth nearby month.">
    NearbyWeek <"Specifies that the reference delivery date of the underlying Commodity shall be the expiration date of the futures contract in the nth nearby week.">

enum CommodityInformationPublisherEnum: <"Defines a publication in which the price can be found. (e.g Gas Daily, Platts Bloomberg.">
    Argus
    ArgusMcCloskeys
    ArgusAmericasCrudeReport
    ArgusBiofuelReport
    ArgusCrudeReport
    ArgusEuropeanProductsReport
    ArgusFMB
    ArgusInternationalLPGReport
    ArgusLPG
    ArgusNatGas
    AssocBanksSingapore
    BandD
    BalticExchange
    BankOfCanada
    BankOfEngland
    BankOfJapan
    Bloomberg
    BLUENEXT
    CAISO
    CanadianGasPriceReporter
    CanadianGasReporter
    ChemicalMarketsAssociation
    CMAIAromaticsMarketReport
    CMAIWeeklyMethanolMarketReport
    CRUSteelLongProductMonitor
    CRUSteelSheetProductsMonitor
    DowJonesEnergyService
    DowJonesEnergyServiceScreen
    DowJonesNatGas
    EEX
    ERCOT
    EuroCentralBank
    EURONEXMATIF
    FederalReserve
    FERTECON
    FertilizerWeek
    FHLBSF
    GasDaily
    GasDailyPriceGuide
    GlobalCoale
    GME
    HerenReport
    ICE
    ICE10XDailyNaturalGas
    ICE10XDailyPower
    ICE10XMonthly
    ICEDayAheadIndex
    ICEECX
    ICIS
    InsideFERC
    IPE
    ISDA
    ISONewEngland
    JAPANMOFTSRR
    LEBA
    LondonBullionMarketAssociation
    LONDONPLATINUMPALLADIUMMARKET
    MegawattDaily
    MetalBulletin
    MISO
    NaturalGasWeek
    NGIBidweekSurvey
    NYISO
    OBM
    OMEL
    OPIS
    PaperTrader
    PIX
    PJM
    PlattsAsiaPacific
    PlattsAsiaPacificArabMarketscan
    PlattsCleanTankerwire
    PlattsCoalTrader
    PlattsCrudeOilMarketwire
    PlattsDirtyTakerwire
    PlattsENGR
    PlattsEuropean
    PlattsEuropeanMarketscan
    PlattsGasDaily
    PlattsGasDailyPriceGuide
    PlattsInsideFERC
    PlattsLPG
    PlattsMarketwire
    PlattsMegawattDaily
    PlattsMetalsAlert
    PlattsOilgram
    PlattsOilgramBunkerwire
    PlattsPolymerscan
    PlattsTSIIronOre
    TSIScrap
    TSISteel
    PlattsUS
    PlattsUSMarketscan
    PPM
    PPMEurope
    PPW
    ReserveBankAustralia
    ReserveBankNewZealand
    Reuters
    ReutersScreen
    RIMIntelligenceProducts
    SeaPac
    Telerate
    TelerateScreen
    UXWEEKLY
    WorldCrudeReport
    WorldPulpMonthly

enum EU_EMIR_EligibleCollateralEnum: <"Identifies European Union Eligible Collateral Assets classification categories based on EMIR Uncleared Margin Rules. Eligible Collateral asset classes for both initial margin (IM) and variation margin (VM) posted and collected between specified entities. Please note: EMIR regulation will detail which eligible collateral assets classes apply to each type of entity pairing (counterparty) and which apply to posting of IM and VM.">
    EU_EMIRTypeA <"Denotes Cash in the form of money credited to an account in any currency, or similar claims for the repayment of money, such as money market deposits.">
    EU_EMIRTypeB <" Denotes gold in the form of allocated pure gold bullion of recognised good delivery.">
    EU_EMIRTypeC <" Denotes debt securities issued by Member States' central governments or central banks.">
    EU_EMIRTypeD <" Denotes debt securities issued by Member States' regional governments or local authorities whose exposures are treated as exposures to the central government of that Member State in accordance with Article 115(2) of Regulation (EU) No 575/2013.">
    EU_EMIRTypeE <" Denotes debt securities issued by Member States' public sector entities whose exposures are treated as exposures to the central government, regional government or local authority of that Member State in accordance with Article 116(4) of Regulation (EU) No 575/2013.">
    EU_EMIRTypeF <" Denotes debt securities issued by Member States' regional governments or local authorities other than those referred to in (TypeD.)">
    EU_EMIRTypeG <" Denotes debt securities issued by Member States' public sector entities other than those referred to in (TypeE).">
    EU_EMIRTypeH <" Denotes debt securities issued by multilateral development banks listed in Article 117(2) of Regulation (EU) No 575/2013.">
    EU_EMIRTypeI <" Denotes debt securities issued by the international organisations listed in Article 118 of Regulation (EU) No 575/2013.">
    EU_EMIRTypeJ <" Denotes debt securities issued by third countries' governments or central banks.">
    EU_EMIRTypeK <" Denotes debt securities issued by third countries' regional governments or local authorities that meet the requirements of (TypeD) and (TypeE).">
    EU_EMIRTypeL <" Denotes debt securities issued by third countries' regional governments or local authorities other than those referred to in (TypeD) and (TypeE).">
    EU_EMIRTypeM <" Denotes debt securities issued by credit institutions or investment firms including bonds referred to in Article 52(4) of Directive 2009/65/EC of the European Parliament and of the Council.">
    EU_EMIRTypeN <" Denotes corporate bonds.">
    EU_EMIRTypeO <" Denotes the most senior tranche of a securitisation, as defined in Article 4(61) of Regulation (EU) No 575/2013, that is not a re-securitisation as defined in Article 4(63) of that Regulation.">
    EU_EMIRTypeP <" Denotes convertible bonds provided that they can be converted only into equities which are included in an index specified pursuant to point (a) of Article 197 (8) of Regulation (EU) No 575/2013.">
    EU_EMIRTypeQ <" Denotes equities included in an index specified pursuant to point (a) of Article 197(8) of Regulation (EU) No 575/2013.">
    EU_EMIRTypeR <" Denotes shares or units in undertakings for collective investments in transferable securities (UCITS), provided that the conditions set out in Article 5 of EU Regulation 2016/2251 are met.">

enum UK_EMIR_EligibleCollateralEnum: <"Identifies United Kingdom Eligible Collateral Assets classification categories based on UK Onshored EMIR Uncleared Margin Rules. Eligible Collateral asset classes for both initial margin (IM) and variation margin (VM) posted and collected between specified entities. Please note: UK EMIR regulation will detail which eligible collateral assets classes apply to each type of entity pairing (counterparty) and which apply to posting of IM and VM.">

    UK_EMIRTypeA <"Denotes cash in the form of money credited to an account in any currency, or similar claims for the repayment of money, such as money market deposits.">
    UK_EMIRTypeB <"Denotes gold in the form of allocated pure gold bullion of recognised good delivery.">
    UK_EMIRTypeC <"Denotes debt securities issued by the central government of the United Kingdom or the Bank of England.">
    UK_EMIRTypeD <"Denotes debt securities issued by United Kingdom regional governments or local authorities whose exposures are treated as exposures to the central government of the United Kingdom in accordance with Article 115(2) of Regulation (EU) No 575/2013.">
    UK_EMIRTypeE <"Denotes debt securities issued by United Kingdom public sector entities whose exposures are treated as exposures to the central government, regional government or local authority of the United Kingdom in accordance with Article 116(4) of Regulation (EU) No 575/2013.">
    UK_EMIRTypeF <"Denotes debt securities issued by United Kingdom regional governments or local authorities other than those referred to in (TypeD).">
    UK_EMIRTypeG <"Denotes debt securities issued by United Kingdom public sector entities other than those referred to in (TypeE).">
    UK_EMIRTypeH <"Denotes debt securities issued by multilateral development banks listed in Article 117(2) of Regulation (EU) No 575/2013.">
    UK_EMIRTypeI <"Denotes debt securities issued by the international organisations listed in Article 118 of Regulation (EU) No 575/2013.">
    UK_EMIRTypeJ <"Denotes debt securities issued by third countries' governments or central banks.">
    UK_EMIRTypeK <"Denotes debt securities issued by third countries' regional governments or local authorities that meet the requirements of (TypeD) and (TypeE).">
    UK_EMIRTypeL <"Denotes debt securities issued by third countries' regional governments or local authorities other than those referred to in (TypeD) and (TypeE).">
    UK_EMIRTypeM <"Denotes debt securities issued by credit institutions or investment firms including bonds admitted to the register of regulated covered bonds maintained under Regulation 7(1)(b) of the Regulated Covered Bonds Regulations 2008 (SI 2008/346).">
    UK_EMIRTypeN <"Denotes corporate bonds.">
    UK_EMIRTypeO <"Denotes the most senior tranche of a securitisation, as defined in Article 4(61) of Regulation (EU) No 575/2013, that is not a re-securitisation as defined in Article 4(63) of that Regulation.">
    UK_EMIRTypeP <"Denotes convertible bonds provided that they can be converted only into equities which are included in an index specified pursuant to point (a) of Article 197 (8) of Regulation (EU) No 575/2013.">
    UK_EMIRTypeQ <"Denotes equities included in an index specified pursuant to point (a) of Article 197(8) of Regulation (EU) No 575/2013.">
    UK_EMIRTypeR <"Denotes shares or units in undertakings for UK UCITS, provided that the conditions set out in Article 5 of EU Regulation 2016/2251 (as modified by the Technical Standards (European Market Infrastructure) (EU Exit) (No. 3) Instrument 2019) are met.">

enum US_CFTC_PR_EligibleCollateralEnum: <"Identifies US Eligible Collateral Assets classification categories based on Uncleared Margin Rules published by the CFTC and the US Prudential Regulator. Note: While the same basic categories exist in the CFTC and US Prudential Regulators margin rules, the precise definitions or application of those rules could differ between the two rules.">

    US_CFTC_PRType1 <"Denotes immediately available cash funds denominated in USD, a major currency, a currency of settlement for the uncleared swap.">
    US_CFTC_PRType2 <"Denotes a security that is issued by, or unconditionally guaranteed as to the timely payment of principal and interest by, the U.S. Department of the Treasury.">
    US_CFTC_PRType3 <"Denotes a security that is issued by, or unconditionally guaranteed as to the timely payment of principal and interest by, a U.S. government agency (other than the U.S. Department of Treasury) whose obligations are fully guaranteed by the full faith and credit of the United States government.">
    US_CFTC_PRType4 <"Denotes a security that is issued by, or fully guaranteed as to the payment of principal and interest by, the European Central Bank or a sovereign entity that is assigned no higher than a 20 percent risk weight under the capital rules applicable to swap dealers subject to regulation by a prudential regulator.">
    US_CFTC_PRType5A <"Denotes a publicly traded debt security issued by, or an asset-backed security fully guaranteed as to the timely payment of principal and interest by, a U.S. Government-sponsored enterprise that is operating with capital support or another form of direct financial assistance received from the U.S. government that enables the repayments of the U.S. Government-sponsored enterprise's eligible securities.">
    US_CFTC_PRType5B <"Denotes a publicly traded debt security, but not an asset backed security, that is investment grade and issued by a U.S. Government-sponsored enterprise that is not operating with capital support or another form of direct financial assistance received from the U.S. government.">
    US_CFTC_PRType6 <"Denotes a security that is issued by, or fully guaranteed as to the payment of principal and interest by, the Bank for International Settlements, the International Monetary Fund, or a multilateral development bank.">
    US_CFTC_PRType7 <"Denotes publicly-traded debt, but not an asset backed security, that is investment grade and is not a debt security issued by a  U.S. Government-sponsored enterprise. This category excludes a security issued by a non-bank financial institution supervised by the board of governors of the Federal Reserve System under Title I of the Dodd-Frank Wall Street Reform and Consumer Protection Act. This category also excludes a security issued by any of the following entities, by a company that would be any of the following entities if it were the organized under the laws of the United States or any State, or in either case by an affiliate of such an entity: the party posting the collateral, a bank holding company, a savings and loan holding company, a U.S. intermediate holding company, a foreign bank, a depositary institution, a securities holding company, a broker, a dealer, a futures commission merchant, a swap dealer, or a security-based swap dealer.">
    US_CFTC_PRType8A <"Denotes a publicly traded common equity security that is included in the Standard & Poor's Composite 500 Index or related indexes. This category excludes a security issued by a non-bank financial institution supervised by the board of governors of the Federal Reserve System under Title I of the Dodd-Frank Wall Street Reform and Consumer Protection Act. This category also excludes a security issued by any of the following entities, by a company that would be any of the following entities if it were the organized under the laws of the United States or any State, or in either case by an affiliate of such an entity: the party posting the collateral, a bank holding company, a savings and loan holding company, a U.S. intermediate holding company, a foreign bank, a depositary institution, a securities holding company, a broker, a dealer, a futures commission merchant, a swap dealer, or a security-based swap dealer.">
    US_CFTC_PRType8B <" Denotes a publicly traded common equity security that is included in the Standard & Poor's Composite 1500 Index or related indexes. This category excludes a security issued by a non-bank financial institution supervised by the board of governors of the Federal Reserve System under Title I of the Dodd-Frank Wall Street Reform and Consumer Protection Act. This category also excludes a security issued by any of the following entities, by a company that would be any of the following entities if it were the organized under the laws of the United States or any State, or in either case by an affiliate of such an entity: the party posting the collateral, a bank holding company, a savings and loan holding company, a U.S. intermediate holding company, a foreign bank, a depositary institution, a securities holding company, a broker, a dealer, a futures commission merchant, a swap dealer, or a security-based swap dealer.">
    US_CFTC_PRType8C <"Denotes a publicly traded common equity security that is included in an index that a regulated swap entity's supervisor in a foreign jurisdiction recognizes for purposes of including publicly traded common equity as initial margin under applicable regulatory policy, if held in that foreign jurisdiction. This category excludes a security issued by a non-bank financial institution supervised by the board of governors of the Federal Reserve System under Title I of the Dodd-Frank Wall Street Reform and Consumer Protection Act. This category also excludes a security issued by any of the following entities, by a company that would be any of the following entities if it were the organized under the laws of the United States or any State, or in either case by an affiliate of such an entity: the party posting the collateral, a bank holding company, a savings and loan holding company, a U.S. intermediate holding company, a foreign bank, a depositary institution, a securities holding company, a broker, a dealer, a futures commission merchant, a swap dealer, or a security-based swap dealer.">
    US_CFTC_PRType9 <"Denotes securities in the form of redeemable securities in a pooled investment fund representing the security-holder's proportional interest in the fund's net assets and that are issued and redeemed only on the basis of the market value of the fund's net assets prepared each business day after the security-holder makes its investment commitment or redemption request to the fund, if the fund's investments are limited to the following: (A) securities that are issued by, or unconditionally guaranteed as to the timely payment of principal and interest by, the U.S. Department of the Treasury, and immediately-available cash funds denominated in U.S. dollars; or (B) securities denominated in a common currency and issued by, or fully guaranteed as to the payment of principal and interest by, the European Central Bank or a sovereign entity that is assigned no higher than a 20 percent risk weight under the capital rules applicable to swap dealers subject to regulation by a prudential regulator, and immediately-available cash funds denominated in the same currency; and (C) assets of the fund may not be transferred through securities lending, securities borrowing, repurchase agreements, reverse repurchase agreements, or other means that involve the fund having rights to acquire the same or similar assets from the transferee.">
    US_CTFC_PRType10 <"Denotes Gold.">

enum ISOCountryCodeEnum: <"The enumerated values to specify standard currency codes according to the International Standards Organization (ISO). The set of codes in this enumerated list is sourced from ISO Standard 3166 (ISO-3166-1alpha-2)(https://www.iso.org/iso-3166-country-codes.html) as at 14-Aug-23.">

    AF <"Afghanistan">
    AL <"Albania">
    DZ <"Algeria">
    AS <"American Samoa">
    AD <"Andorra">
    AO <"Angola">
    AI <"Anguilla">
    AQ <"Antarctica">
    AG <"Antigua and Barbuda">
    AR <"Argentina">
    AM <"Armenia">
    AW <"Aruba">
    AU <"Australia">
    AT <"Austria">
    AZ <"Azerbaijan">
    BS <"Bahamas (the)">
    BH <"Bahrain">
    BD <"Bangladesh">
    BB <"Barbados">
    BY <"Belarus">
    BE <"Belgium">
    BZ <"Belize">
    BJ <"Benin">
    BM <"Bermuda">
    AX <"Aland Islands">
    BT <"Bhutan">
    BO <"Bolivia (Plurinational State of)">
    BQ <"Bonaire, Sint Eustatius and Saba">
    BA <"Bosnia and Herzegovina">
    BW <"Botswana">
    BV <"Bouvet Island">
    BR <"Brazil">
    IO <"British Indian Ocean Territory (the)">
    BN <"Brunei Darussalam">
    BG <"Bulgaria">
    BF <"Burkina Faso">
    BI <"Burundi">
    CV <"Cabo Verde">
    KH <"Cambodia">
    CM <"Cameroon">
    CA <"Canada">
    KY <"Cayman Islands (the)">
    CF <"Central African Republic (the)">
    TD <"Chad">
    CL <"Chile">
    CN <"China">
    CX <"Christmas Island">
    CC <"Cocos (Keeling) Islands (the)">
    CO <"Colombia">
    KM <"Comoros (the)">
    CD <"Congo (the Democratic Republic of the)">
    CG <"Congo (the)">
    CK <"Cook Islands (the)">
    CR <"Costa Rica">
    HR <"Croatia">
    CU <"Cuba">
    CW <"Curaao">
    CY <"Cyprus">
    CZ <"Czechia">
    CI <"Cte d'Ivoire">
    DK <"Denmark">
    DJ <"Djibouti">
    DM <"Dominica">
    DO <"Dominican Republic (the)">
    EC <"Ecuador">
    EG <"Egypt">
    SV <"El Salvador">
    GQ <"Equatorial Guinea">
    ER <"Eritrea">
    EE <"Estonia">
    SZ <"Eswatini">
    ET <"Ethiopia">
    FK <"Falkland Islands (the) [Malvinas]">
    FO <"Faroe Islands (the)">
    FJ <"Fiji">
    FI <"Finland">
    FR <"France">
    GF <"French Guiana">
    PF <"French Polynesia">
    TF <"French Southern Territories (the)">
    GA <"Gabon">
    GM <"Gambia (the)">
    GE <"Georgia">
    DE <"Germany">
    GH <"Ghana">
    GI <"Gibraltar">
    GR <"Greece">
    GL <"Greenland">
    GD <"Grenada">
    GP <"Guadeloupe">
    GU <"Guam">
    GT <"Guatemala">
    GG <"Guernsey">
    GN <"Guinea">
    GW <"Guinea-Bissau">
    GY <"Guyana">
    HT <"Haiti">
    HM <"Heard Island and McDonald Islands">
    VA <"Holy See (the)">
    HN <"Honduras">
    HK <"Hong Kong">
    HU <"Hungary">
    IS <"Iceland">
    IN <"India">
    ID <"Indonesia">
    IR <"Iran (Islamic Republic of)">
    IQ <"Iraq">
    IE <"Ireland">
    IM <"Isle of Man">
    IL <"Israel">
    IT <"Italy">
    JM <"Jamaica">
    JP <"Japan">
    JE <"Jersey">
    JO <"Jordan">
    KZ <"Kazakhstan">
    KE <"Kenya">
    KI <"Kiribati">
    KP <"Korea (the Democratic People's Republic of)">
    KR <"Korea (the Republic of)">
    KW <"Kuwait">
    KG <"Kyrgyzstan">
    LA <"Lao People's Democratic Republic (the)">
    LV <"Latvia">
    LB <"Lebanon">
    LS <"Lesotho">
    LR <"Liberia">
    LY <"Libya">
    LI <"Liechtenstein">
    LT <"Lithuania">
    LU <"Luxembourg">
    MO <"Macao">
    MG <"Madagascar">
    MW <"Malawi">
    MY <"Malaysia">
    MV <"Maldives">
    ML <"Mali">
    MT <"Malta">
    MH <"Marshall Islands (the)">
    MQ <"Martinique">
    MR <"Mauritania">
    MU <"Mauritius">
    YT <"Mayotte">
    MX <"Mexico">
    FM <"Micronesia (Federated States of)">
    MD <"Moldova (the Republic of)">
    MC <"Monaco">
    MN <"Mongolia">
    ME <"Montenegro">
    MS <"Montserrat">
    MA <"Morocco">
    MZ <"Mozambique">
    MM <"Myanmar">
    NA <"Namibia">
    NR <"Nauru">
    NP <"Nepal">
    NL <"Netherlands (Kingdom of the)">
    NC <"New Caledonia">
    NZ <"New Zealand">
    NI <"Nicaragua">
    NE <"Niger (the)">
    NG <"Nigeria">
    NU <"Niue">
    NF <"Norfolk Island">
    MK <"North Macedonia">
    MP <"Northern Mariana Islands (the)">
    NO <"Norway">
    OM <"Oman">
    PK <"Pakistan">
    PW <"Palau">
    PS <"Palestine, State of">
    PA <"Panama">
    PG <"Papua New Guinea">
    PY <"Paraguay">
    PE <"Peru">
    PH <"Philippines (the)">
    PN <"Pitcairn">
    PL <"Poland">
    PT <"Portugal">
    PR <"Puerto Rico">
    QA <"Qatar">
    RO <"Romania">
    RU <"Russian Federation (the)">
    RW <"Rwanda">
    RE <"Runion">
    BL <"Saint Barthlemy">
    SH <"Saint Helena, Ascension and Tristan da Cunha">
    KN <"Saint Kitts and Nevis">
    LC <"Saint Lucia">
    MF <"Saint Martin (French part)">
    PM <"Saint Pierre and Miquelon">
    VC <"Saint Vincent and the Grenadines">
    WS <"Samoa">
    SM <"San Marino">
    ST <"Sao Tome and Principe">
    SA <"Saudi Arabia">
    SN <"Senegal">
    RS <"Serbia">
    SC <"Seychelles">
    SL <"Sierra Leone">
    SG <"Singapore">
    SX <"Sint Maarten (Dutch part)">
    SK <"Slovakia">
    SI <"Slovenia">
    SB <"Solomon Islands">
    SO <"Somalia">
    ZA <"South Africa">
    GS <"South Georgia and the South Sandwich Islands">
    SS <"South Sudan">
    ES <"Spain">
    LK <"Sri Lanka">
    SD <"Sudan (the)">
    SR <"Suriname">
    SJ <"Svalbard and Jan Mayen">
    SE <"Sweden">
    CH <"Switzerland">
    SY <"Syrian Arab Republic (the)">
    TW <"Taiwan (Province of China)">
    TJ <"Tajikistan">
    TZ <"Tanzania, the United Republic of">
    TH <"Thailand">
    TL <"Timor-Leste">
    TG <"Togo">
    TK <"Tokelau">
    TO <"Tonga">
    TT <"Trinidad and Tobago">
    TN <"Tunisia">
    TM <"Turkmenistan">
    TC <"Turks and Caicos Islands (the)">
    TV <"Tuvalu">
    TR <"Trkiye">
    UG <"Uganda">
    UA <"Ukraine">
    AE <"United Arab Emirates (the)">
    GB <"United Kingdom of Great Britain and Northern Ireland (the)">
    UM <"United States Minor Outlying Islands (the)">
    US <"United States of America (the)">
    UY <"Uruguay">
    UZ <"Uzbekistan">
    VU <"Vanuatu">
    VE <"Venezuela (Bolivarian Republic of)">
    VN <"Viet Nam">
    VG <"Virgin Islands (British)">
    VI <"Virgin Islands (U.S.)">
    WF <"Wallis and Futuna">
    EH <"Western Sahara*">
    YE <"Yemen">
    ZM <"Zambia">
    ZW <"Zimbabwe">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-common-func.rosetta
================================================================================

namespace cdm.base.staticdata.asset.common
version "${project.version}"

func AssetIdentifierByType: <"Returns all the Asset Identifiers of a certain Identifier Type.">
    inputs:
        identifiers AssetIdentifier (0..*)
        idType AssetIdTypeEnum (1..1)
    output:
        filteredIdentifier AssetIdentifier (0..*)

    add filteredIdentifier: identifiers filter item -> identifierType = idType

func GetCashCurrency: <"Returns the enumerated Currency Code of a Cash asset.">
    inputs:
        cash Cash (1..1)
    output:
        currencyEnum CurrencyCodeEnum (1..1)

    alias cashId: AssetIdentifierByType(cash -> identifier, AssetIdTypeEnum -> CurrencyCode)
    set currencyEnum: cashId -> identifier first to-enum CurrencyCodeEnum

func SetCashCurrency: <"Sets (or updates) the string identifier of a Cash asset using an enumerated Currency Code.">
    inputs:
        cash Cash (0..1)
        currency CurrencyCodeEnum (1..1)
    output:
        cashOutput Cash (1..1)

    set cashOutput -> identifier:
        AssetIdentifier {
            identifier: currency to-string,
            identifierType: AssetIdTypeEnum -> CurrencyCode
        }


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-common-type.rosetta
================================================================================

namespace cdm.base.staticdata.asset.common : <"Basic static asset concepts that apply across asset classes: taxonomy etc.">
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.party.*
import cdm.observable.asset.*

choice Asset: <"An Asset is defined as something that can be owned and transferred in the financial markets. As a choice data type, one and only one of the attributes must be used.">
    Cash <"An Asset that consists solely of a monetary holding in a currency.">
    Commodity <"An Asset comprised of raw or refined materials or agricultural products, eg gold, oil or wheat.">
    DigitalAsset <"An Asset that exists only in digital form, eg Bitcoin or Ethereum; excludes the digital representation of other Assets.">
    Instrument <"An asset that is issued by one party to one or more others; Instrument is also a choice data type.">

type AssetBase: <"The base data type to specify common attributes for all Assets.">
    identifier AssetIdentifier (1..*) <"Asset Identifiers are used to uniquely identify an Asset, using a specified Asset Identifier Type.">
    taxonomy Taxonomy (0..*) <"Defines the taxonomy of an object by combining a taxonomy source (i.e. the rules to classify the object) and a value (i.e. the output of those rules on the object.">
    isExchangeListed boolean (0..1) <"Defines whether the Asset is listed on a public exchange.">
    exchange LegalEntity (0..1) <"If the Asset is listed, defines the public exchange of the listing.">
    relatedExchange LegalEntity (0..*) <"Provides the related Exchanges, if applicable.">

    condition ExchangeListed: <"If Exchange is specified, it must be an exchange-listed Instrument.">
        if exchange exists then isExchangeListed

    condition RelatedExchange: <"Related Exchange should only be specified if an Exchange is also specified.">
        if exchange is absent then relatedExchange is absent

type AssetIdentifier: <"The unique identifier for an Asset, specified using an Asset Identifier Type enumerator.">
    identifier string (1..1) <"The identifier value.">
        [metadata scheme]
    identifierType AssetIdTypeEnum (1..1) <"Defines the symbology source of the Asset Identifier, eg CUSIP, ISIN, etc.">

type InstrumentBase extends AssetBase: <"Defines the common attributes for all Instrument data types.">
    instrumentType InstrumentTypeEnum (1..1) <"Identifies the type of an instrument using an enumerated list.">

choice Instrument: <"A type of Asset that is issued by one party to one or more others.">
    ListedDerivative <"A securitized derivative on another asset that is created by an exchange.">
    Loan <"An Asset that represents a loan or borrow obligation.">
    Security <"An Asset that is issued by a party to be held by or transferred to others.">

type ProductIdentifier: <"Comprises an identifier and a source. The associated metadata key denotes the ability to associate a hash value to the ProductIdentifier instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    [metadata key]
    identifier string (1..1) <"Provides an identifier associated with a specific product.  The identifier is unique within the public source specified in the source attribute.">
        [metadata scheme]
    source ProductIdTypeEnum (1..1) <"Defines the source of the identifier.">

type TaxonomyValue: <"Defines a taxonomy value as either a simple string or a more granular expression with class names and values for each class.">

    name string (0..1) <"Specifies the taxonomy value as a simple string, which may be associated to an external scheme.">
        [metadata scheme]
    classification TaxonomyClassification (0..*) <"Specifies the taxonomy value as a set of class names and values for each class.">

    condition ValueExists:
        name exists or classification exists

type Taxonomy: <"Defines the taxonomy of an object by combining a taxonomy source (i.e. the rules to classify the object) and a value (i.e. the output of those rules on the object).">
    source TaxonomySourceEnum (0..1) <"The source of the taxonomy that defines the rules for classifying the object. The taxonomy source is taken from a enumerated list of taxonomy names. Optional as the taxonomy source may not be provided.">
    value TaxonomyValue (0..1) <"The value according to that taxonomy. Optional as it may not be possible to classify the object in that taxonomy.">

    condition DifferentOrdinals: <"Prevents several identical ordinals from being specified in the same commodity classification, since classification values for each classification layer are mutually exclusive (i.e.: only a value can exist for each layer).">
        if value -> classification -> ordinal exists
        then DifferentOrdinalsCondition

// This is a work around for the following bug in the code generators https://github.com/REGnosys/rosetta-code-generators/issues/246
func DifferentOrdinalsCondition:
    inputs:
        taxonomy Taxonomy (1..1)
    output:
        result boolean (1..1)
    set result:
        (taxonomy -> value
            extract [ classification -> ordinal = classification -> ordinal distinct ]
        = True)

type ProductTaxonomy extends Taxonomy: <"Specifies the product taxonomy, which is composed of a taxonomy value and a taxonomy source.">
    primaryAssetClass AssetClassEnum (0..1) <"Classifies the most important risk class of the trade.">
        [metadata scheme]
    secondaryAssetClass AssetClassEnum (0..*) <" Classifies additional risk classes of the trade, if any.">
        [metadata scheme]
    productQualifier string (0..1) <"Derived from the product payout features using a CDM product qualification function that determines the product type based on the product payout features.">

    condition TaxonomyType: <"Requires a taxonomy type to be chosen, either from a taxonomy source or using asset classes.">
        required choice source, primaryAssetClass, secondaryAssetClass

    condition TaxonomySource: <"A taxonomy source can only be associated with a taxonomy value or productQualifier">
        if source exists
        then (value exists or productQualifier exists)

    condition TaxonomyValue: <"A taxonomy value and product qualifier are mutually exclusive. Choice is optional as it only applies when source exists.">
        optional choice value, productQualifier

type Cash extends AssetBase: <"An Asset that consists solely of a monetary holding in a currency. The currency of the Cash asset is held in the string Identifier (from AssetBase) and the AssetIdTypeEnum must be set to define that a CurrencyCode is set.  The function SetCashCurrency can be used to create (or update) a Cash object and the function GetCashCurrency can be used to retrieve the currency of a Cash object.">

    condition CurrencyExists: <"There must be one and only one currency code and it must be valid (ie in the enumerated list).">
        AssetIdentifierByType(identifier, AssetIdTypeEnum -> CurrencyCode) count = 1
            and AssetIdentifierByType(identifier, AssetIdTypeEnum -> CurrencyCode) -> identifier
                first
                to-enum CurrencyCodeEnum
                exists

    condition NoTaxonomy: <"Taxonomy is not applicable for a Cash asset.">
        taxonomy is absent

    condition NoExchange: <"Cash cannot be a listed Asset.">
        exchange is absent and isExchangeListed is absent

type Commodity extends AssetBase: <"Identifies a specific commodity by referencing a product identifier or by a product definition.">
    commodityProductDefinition CommodityProductDefinition (0..1) <"Specifies the commodity underlier in the event that no ISDA Commodity Reference Benchmark exists.">
    priceQuoteType QuotationSideEnum (1..1) <"Describes the required quote type of the underlying price that will be observed. Example values include 'Bid, 'Ask', 'Settlement' (for a futures contract) and 'WeightedAverage' (for some published prices and indices).">
    deliveryDateReference DeliveryDateParameters (0..1) <"Specifies the parameters for identifying the relevant contract date when the commodity reference price is a futures contract.">
    description string (0..1) <"Provides additional information about the commodity underlier.">

    condition OrdinalExists: <"Requires that, if multiple classification elements are present, they contain an  ordinal so that they can be sorted.">
        if taxonomy -> value -> classification count > 1
        then taxonomy -> value -> classification -> ordinal exists

    condition ValueSource: <"Requires that value and source are present when product taxonomy is present">
        if taxonomy exists
        then (taxonomy -> source exists and taxonomy -> value exists)

type CommodityProductDefinition: <"Specifies the commodity underlier in the event that no ISDA Commodity Reference Price exists.">
    referenceFramework CommodityReferenceFramework (1..1) <"Specifies the type of commodity.">
    priceSource PriceSource (0..1) <"Specifies a publication that provides the commodity price, including, where applicable the details of where in the publication the price is published.  Applicable when the commodity reference price is not a futures contract">
    commodityInfoPublisher CommodityInformationPublisherEnum (0..1) <"Specifies the publication where the commodity prices can be found.">
    exchangeId string (1..1) <" Identifies the exchange from which the reference price should be sourced, using the scheme at the following url: http://www.fpml.org/coding-scheme/external/exchange-id-MIC-1-0">
        [metadata scheme]

    condition CommodityProductDefinitionChoice: <"Requires the definition of either delivery date parameters or non-exchange price source.">
        optional choice exchangeId, priceSource

type DeliveryDateParameters: <"Specifies a specific date or the parameters for identifying the relevant contract date when the commodity reference price is a futures contract.">

    deliveryNearby cdm.base.datetime.Offset (0..1) <"Provides a container for the parametric representation that specifies which nearby contract date would be used as a refrence for a price.">
    deliveryDate cdm.base.datetime.AdjustableDate (0..1) <"Specifies the specific contract date for the contract that should be referenced for a price.">
    deliveryDateRollConvention cdm.base.datetime.Offset (0..1) <"Specifies, for a Commodity Transaction that references a listed future, the day on which the specified future will roll to the next nearby month prior to the expiration of the referenced future. If the future will not roll at all - i.e. the price will be taken from the expiring contract, 0 days should be specified here. If the future will roll to the next nearby on the last trading day - i.e. the price will be taken from the next nearby on the last trading day, then 1 business day should be specified and so on.">
    deliveryDateExpirationConvention cdm.base.datetime.Offset (0..1) <"Specifies, for a Commodity Transaction that references a listed future, the day on which the specified future will expire ahead of the actual expiration of the referenced future. For example: Z21 Contract expires on 19Nov21, with an adjust of 2D the 'expire' will be 16Nov21. DeliveryDateRollConvention takes precedence. Example: Pricing on the Z21 Contract with NearbyContractDay and a deliveryDateRoll of 10D, Sampling of the F22 Contract will occur on 8Nov21 through the last Date of the Z21 Contract. With an ExpConvention of 5D, the last sampling date on the F22 contract will be 12Nov21.">

    condition DeliveryDateParametersChoice: <"Requires definition of a delivery date or delieryNearby parameters.">
        optional choice deliveryNearby, deliveryDate

type CommodityReferenceFramework: <"Specifies the type of commodity.">
    commodityName string (1..1) <"Identifies the commodity more specifically. Where possible, this should follow the naming convention used in the 2005 ISDA Commodity Definitions SubAnnex A, including the subCommodity and additional qualifiers, but should be limited to 256 characters or less.">
    capacityUnit CapacityUnitEnum (0..1) <"Provides an enumerated value for a capacity unit, generally used in the context of defining quantities for commodities.">
    weatherUnit WeatherUnitEnum (0..1) <"Provides an enumerated values for a weather unit, generally used in the context of defining quantities for commodities.">
    currency string (1..1) <"Defines the currency in which the commodity is priced.">
        [metadata scheme]

    condition CommodityReferenceFrameworkChoice: <"Requires that either the capacity unit or weather unit is populated.">
        optional choice capacityUnit, weatherUnit

type DigitalAsset extends AssetBase: <"An Asset that exists only in digital form, eg Bitcoin or Ethereum, that is not backed by other Assets; excludes the digital representation of other Assets, eg coins or Tokenised assets.">

type ListedDerivative extends InstrumentBase: <"A securitized derivative on another asset.">
    deliveryTerm string (0..1) <"Also called contract month or delivery month. However, it's not always a month. It is usually expressed using a code, e.g. Z23 would be the Dec 2023 contract, (Z = December). For crude oil, the corresponding contract might be called CLZ23. Optional as this can be uniquely identified in the identifier.">
    optionType PutCallEnum (0..1) <"The type of option, ie Put or Call. Left empty if it is a Future.">
    strike number (0..1) <"Specifies the strike of the option.">

    condition Options: <"Options must have a strike price.">
        if optionType exists then strike exists else strike is absent

type Loan extends InstrumentBase: <"Identifies a loan by referencing an asset identifier and through an optional set of attributes.">
    borrower LegalEntity (0..*) <"Specifies the borrower. There can be more than one borrower. It is meant to be used in the event that there is no Bloomberg Id or the Secured List isn't applicable.">
    lien string (0..1) <"Specifies the seniority level of the lien.">
        [metadata scheme]
    facilityType string (0..1) <"Specifies the type of loan facility (letter of credit, revolving, ...).">
        [metadata scheme]
    creditAgreementDate date (0..1) <"Specifies the credit agreement date is the closing date (the date where the agreement has been signed) for the loans in the credit agreement. Funding of the facilities occurs on (or sometimes a little after) the Credit Agreement date. This underlier attribute is used to help identify which of the company's outstanding loans are being referenced by knowing to which credit agreement it belongs. ISDA Standards Terms Supplement term: Date of Original Credit Agreement.">
    tranche string (0..1) <"Denotes the loan tranche that is subject to the derivative transaction. It will typically be referenced as the Bloomberg tranche number. ISDA Standards Terms Supplement term: Bloomberg Tranche Number.">
        [metadata scheme]

type CollateralTaxonomy: <"Specifies the collateral taxonomy, which is composed of a taxonomy value and a taxonomy source.">
    taxonomyValue CollateralTaxonomyValue (1..1) <"Specifies the taxonomy value.">
    taxonomySource TaxonomySourceEnum (1..1) <"Specifies the taxonomy source.">

    condition Eu_EligibleCollateralTaxonomy: <"If the Taxonomy Source is specified as EU EMIR Eligible Collateral then the enumeration must be EU EMIR Eligible Collateral.">
        if taxonomySource = TaxonomySourceEnum -> EU_EMIR_EligibleCollateralAssetClass
        then taxonomyValue -> eu_EMIR_EligibleCollateral exists

    condition UkEligibleCollateralTaxonomy: <"If the Taxonomy Source is specified as UK EMIR Eligible Collateral then the enumeration must be UK EMIR Eligible Collateral.">
        if taxonomySource = TaxonomySourceEnum -> UK_EMIR_EligibleCollateralAssetClass
        then taxonomyValue -> uk_EMIR_EligibleCollateral exists

    condition UsEligibleCollateralTaxonomy: <"If the Taxonomy Source is specified as US CFTCPR Eligbile Collateral then the enumeration must be US CFTCPR Eligible Collateral.">
        if taxonomySource = TaxonomySourceEnum -> US_CFTC_PR_EligibleCollateralAssetClass
        then taxonomyValue -> us_CFTC_PR_EligibleCollateral exists

    condition TaxonomyValue: <"If the Taxonomy Value is specified as a string then the taxonomy Source cannot be either EU Eligible Collateral or Uk Eligible Collateral or US Eligible Collateral.">
        if taxonomyValue -> nonEnumeratedTaxonomyValue exists
        then taxonomySource <> TaxonomySourceEnum -> EU_EMIR_EligibleCollateralAssetClass
                and taxonomySource <> TaxonomySourceEnum -> UK_EMIR_EligibleCollateralAssetClass
                and taxonomySource <> TaxonomySourceEnum -> US_CFTC_PR_EligibleCollateralAssetClass

type CollateralTaxonomyValue: <"Specifies the collateral taxonomy value, either as a specified enumeration or as a string.">
    eu_EMIR_EligibleCollateral EU_EMIR_EligibleCollateralEnum (0..*) <"Identifies European Union Eligible Collateral Assets classification categories based on EMIR Uncleared Margin Rules. Eligible Collateral asset classes for both initial margin (IM) and variation margin (VM) posted and collected between specified entities. Please note: EMIR regulation will detail which eligible collateral assets classes apply to each type of entity pairing (counterparty) and which apply to posting of IM and VM">
    uk_EMIR_EligibleCollateral UK_EMIR_EligibleCollateralEnum (0..*) <"Identifies United Kingdom Eligible Collateral Assets classification categories based on UK Onshored EMIR Uncleared Margin Rules Eligible Collateral asset classes for both initial margin (IM) and variation margin (VM) posted and collected between specified entities. Please note: UK EMIR regulation will detail which eligible collateral assets classes apply to each type of entity pairing (counterparty) and which apply to posting of IM and VM.">
    us_CFTC_PR_EligibleCollateral US_CFTC_PR_EligibleCollateralEnum (0..*) <"Identifies US Eligible Collateral Assets classification categories based on Uncleared Margin Rules published by the CFTC and the US Prudential Regulator. Note: While the same basic categories exist in the CFTC and US Prudential Regulators’ margin rules, the precise definitions or application of those rules could differ between the two rules.">
    nonEnumeratedTaxonomyValue string (0..*) <"Identifies the taxonomy value when not specified as an enumeration.">
        [metadata scheme]

    condition:
        one-of

type Security extends InstrumentBase: <"Identifies a security by referencing an identifier and by specifying the sector.">
    [docReference ICMA GMRA namingConvention "Purchased Security"
		provision "As defined in GMRA paragraph 2(oo) The Purchased Securities are the Securities sold or to be sold and any New Purchased Securities transferred by Seller to Buyer under paragraph 8 (Substitution)."]
    debtType DebtType (0..1) <"Identifies the type of debt and selected debt economics.">
    equityType EquityTypeEnum (0..1) <"Identifies the type of equity.">
    fundType FundProductTypeEnum (0..1) <"Identifies the type of fund.">

    condition DebtSubType:
        if instrumentType <> InstrumentTypeEnum -> Debt
        then debtType is absent

    condition EquitySubType:
        if instrumentType <> InstrumentTypeEnum -> Equity
        then equityType is absent

    condition FundSubType:
        if instrumentType <> InstrumentTypeEnum -> Fund
        then fundType is absent

type DebtType: <"Specifies the type of debt instrument.">
    debtClass DebtClassEnum (0..1) <"Specifies the characteristics of a debt instrument.">
    debtEconomics DebtEconomics (0..*) <"Specifies selected financial terms of a debt instrument.">

type DebtEconomics: <"Specifies selected economics of a debt instrument.">
    debtSeniority DebtSeniorityEnum (0..1) <"Specifies the order of repayment in the event of a sale or bankruptcy of the issuer or a related party (eg guarantor).">
    debtInterest DebtInterestEnum (0..1) <"Specifies the general rule for periodic interest rate payment.">
    debtPrincipal DebtPrincipalEnum (0..1) <"Specifies the general rule for repayment of principal.">

type CollateralIssuerType: <"Represents a class to allow specification of the type of entity issuing the collateral.">

    issuerType IssuerTypeEnum (1..1) <"Specifies the origin of entity issuing the collateral.">
    supraNationalType SupraNationalIssuerTypeEnum (0..1) <"Specifies debt issued by international organisations and multilateral banks.">
    quasiGovernmentType QuasiGovernmentIssuerType (0..1) <"Specifies debt issues by institutions or bodies, typically constituted by statute, with a function mandated by the government and subject to government supervision inclusive of profit- and non-profit making bodies. Includes the US Agencies and GSEs and the EU concept of public sector entities. Excluding any entities which are also Regional Government.">
    regionalGovernmentType RegionalGovernmentIssuerType (0..1) <"Specifies Regional government, local authority or municipal.">
    specialPurposeVehicleType SpecialPurposeVehicleIssuerType (0..1) <"Specifies a subsidiary company that is formed to undertake a specific business purpose of acquisition and financing of specific assets on a potentially limited recourse basis dependent of how it is designed. E.g. asset backed securities, including securitisations.">

    condition SupraNationalSubType:
        if issuerType <> IssuerTypeEnum -> SupraNational
        then supraNationalType is absent

    condition QuasiGovernmentSubType:
        if issuerType <> IssuerTypeEnum -> QuasiGovernment
        then quasiGovernmentType is absent

    condition RegionalGovernmentSubType:
        if issuerType <> IssuerTypeEnum -> RegionalGovernment
        then regionalGovernmentType is absent

    condition SpecialPurposeVehicleSubType:
        if issuerType <> IssuerTypeEnum -> SpecialPurposeVehicle
        then specialPurposeVehicleType is absent

type QuasiGovernmentIssuerType: <"Represents a class to allow specification of different types of Quasi Government collateral.">

    sovereignEntity boolean (1..1) <"True if sovereign entity (e.g. not separate legal personality from sovereign) or false if non-sovereign entity (e.g. separate legal personality from sovereign).">
    sovereignRecourse boolean (0..1) <"Applies to non-sovereign entity (e.g. separate legal personality from sovereign).  True if entity has recourse to sovereign (e.g. debt guaranteed by government).  False if entity does not have recourse to sovereign.">

    condition NonSovereignEntityRecourse:
        if sovereignRecourse exists then sovereignEntity = False

type RegionalGovernmentIssuerType: <"Represents a class to allow specification of different type of Regional government collateral.">

    sovereignRecourse boolean (1..1) <"Applies to regional governments, local authorities or municipals.  True if entity has recourse to sovereign (e.g. debt guaranteed by government).  False if entity does not have recourse to sovereign.">

type SpecialPurposeVehicleIssuerType: <"Represents a class to allow specification of different types of special purpose vehicle (SPV) collateral.">
    creditRisk CreditRiskEnum (0..1) <"Indicates tranched or untranched credit risk.">

type TaxonomyClassification:
    className string (0..1) <"The name defined by the classification system for a specific attribute in the taxonomy">
    value string (1..1) <"The value set by the taxonomy that is specific to the className attribute.">
    description string (0..1) <"A description of the class.">
    ordinal int (0..1) <"In the case of multi-layered hierarchical classification systems such as commodity classification, the layer the value and className occupy in the classification hierarchy, where 1 represents the top-layer.">

type AssetType: <"Represents a class to allow specification of the asset product type.">
    assetType AssetTypeEnum (1..1) <"Represents a filter based on the type of collateral asset.">
    securityType InstrumentTypeEnum (0..1) <"Represents a filter based on the type of security.">
    debtType DebtType (0..1) <"Represents a filter based on the type of bond.">
    equityType EquityTypeEnum (0..1) <"Represents a filter based on the type of equity.">
    fundType FundProductTypeEnum (0..1) <"Represents a filter based on the type of fund.">
    otherAssetType string (0..*) <"Specifies the eligible asset type when not enumerated.">

    condition SecuritySubType:
        if assetType <> AssetTypeEnum -> Security
        then securityType is absent
                and debtType is absent
                and equityType is absent
                and fundType is absent

    condition BondSubType:
        if securityType <> InstrumentTypeEnum -> Debt
        then debtType is absent

    condition EquitySubType:
        if securityType <> InstrumentTypeEnum -> Equity
        then equityType is absent

    condition FundSubType:
        if securityType <> InstrumentTypeEnum -> Fund
        then fundType is absent

    condition OtherAssetSubType:
        if assetType = AssetTypeEnum -> Other
        then otherAssetType exists

type PriceSource: <"Specifies a publication that provides the commodity price, including, where applicable, the details of where in the publication the price is published.">
    pricePublisher string (1..1) <"Defines a publication in which the price can be found. (e.g Gas Daily, Platts Bloomberg. Commodity publishers can be found at this URL:  http://www.fpml.org/coding-scheme/commodity-information-provider>">
        [metadata scheme]
    priceSourceLocation string (0..1) <"Specifies the location of the price which may be a specific page, electornic screen name, or a code (e.g. a RIC code) where the price can be found.">
    priceSourceHeading string (0..1) <"Specifies the heading or field name for the price  on a given page or screen, where applicable.">
    priceSourceTime time (0..1) <"Specifies the time at which the price should be observed.">

    condition PriceSourceHeading: <"Requires that if a priceSourceHeading is specified, then a priceSourceLocation must be speficified">
        if priceSourceHeading exists then priceSourceLocation exists


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-credit-enum.rosetta
================================================================================

namespace cdm.base.staticdata.asset.credit
version "${project.version}"

enum ObligationCategoryEnum: <"The enumerated values used in both the obligations and deliverable obligations of the credit default swap to represent a class or type of securities which apply.">
    Payment <"ISDA term 'Payment'.">
    BorrowedMoney <"ISDA term 'Borrowed Money'.">
    ReferenceObligationsOnly <"ISDA term 'Reference Obligations Only'.">
    Bond <"ISDA term 'Bond'.">
    Loan <"ISDA term 'Loan'.">
    BondOrLoan <"ISDA term 'Bond or Loan'.">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-credit-type.rosetta
================================================================================

namespace cdm.base.staticdata.asset.credit
version "${project.version}"

type NotDomesticCurrency: <"A class to specify the ISDA 2003 Term: Not Domestic Currency.">

    applicable boolean (1..1) <"Indicates whether the Not Domestic Currency provision is applicable.">
    currency string (0..1) <"An explicit specification of the domestic currency. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]

type Obligations: <"A class to specify the underlying obligations of the reference entity on which protection is purchased or sold through the Credit Default Swap.">

    category ObligationCategoryEnum (1..1) <"Used in both obligations and deliverable obligations to represent a class or type of securities which apply. ISDA 2003 Term: Obligation Category/Deliverable Obligation Category.">
    notSubordinated boolean (0..1) <"An obligation and deliverable obligation characteristic. An obligation that ranks at least equal with the most senior Reference Obligation in priority of payment or, if no Reference Obligation is specified in the related Confirmation, the obligations of the Reference Entity that are senior. ISDA 2003 Term: Not Subordinated.">
    specifiedCurrency SpecifiedCurrency (0..1) <"An obligation and deliverable obligation characteristic. The currency or currencies in which an obligation or deliverable obligation must be payable. ISDA 2003 Term: Specified Currency.">
    notSovereignLender boolean (0..1) <"An obligation and deliverable obligation characteristic. Any obligation that is not primarily (majority) owed to a Sovereign or Supranational Organisation. ISDA 2003 Term: Not Sovereign Lender.">
    notDomesticCurrency NotDomesticCurrency (0..1) <"An obligation and deliverable obligation characteristic. Any obligation that is payable in any currency other than the domestic currency. Domestic currency is either the currency so specified or, if no currency is specified, the currency of (a) the reference entity, if the reference entity is a sovereign, or (b) the jurisdiction in which the relevant reference entity is organised, if the reference entity is not a sovereign. ISDA 2003 Term: Not Domestic Currency.">
    notDomesticLaw boolean (0..1) <"An obligation and deliverable obligation characteristic. If the reference entity is a Sovereign, this means any obligation that is not subject to the laws of the reference entity. If the reference entity is not a sovereign, this means any obligation that is not subject to the laws of the jurisdiction of the reference entity. ISDA 2003 Term: Not Domestic Law.">
    listed boolean (0..1) <"An obligation and deliverable obligation characteristic. Indicates whether or not the obligation is quoted, listed or ordinarily purchased and sold on an exchange. ISDA 2003 Term: Listed.">
    notDomesticIssuance boolean (0..1) <"An obligation and deliverable obligation characteristic. Any obligation other than an obligation that was intended to be offered for sale primarily in the domestic market of the relevant Reference Entity. This specifies that the obligation must be an internationally recognised bond. ISDA 2003 Term: Not Domestic Issuance.">
    fullFaithAndCreditObLiability boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S. Municipal as Reference Entity. ISDA 2003 Term: Full Faith and Credit Obligation Liability.">
    generalFundObligationLiability boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S. Municipal as Reference Entity. ISDA 2003 Term: General Fund Obligation Liability.">
    revenueObligationLiability boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S. Municipal as Reference Entity. ISDA 2003 Term: Revenue Obligation Liability.">
    notContingent boolean (0..1) <"OTE: Only allowed as an obligation characteristic under ISDA Credit 1999. In essence Not Contingent means the repayment of principal cannot be dependent on a formula/index, i.e. to prevent the risk of being delivered an instrument that may never pay any element of principal, and to ensure that the obligation is interest bearing (on a regular schedule). ISDA 2003 Term: Not Contingent.">
    excluded string (0..1) <"A free format string to specify any excluded obligations or deliverable obligations, as the case may be, of the reference entity or excluded types of obligations or deliverable obligations. ISDA 2003 Term: Excluded Obligations/Excluded Deliverable Obligations.">
    othReferenceEntityObligations string (0..1) <"This element is used to specify any other obligations of a reference entity in both obligations and deliverable obligations. The obligations can be specified free-form. ISDA 2003 Term: Other Obligations of a Reference Entity.">
    designatedPriority string (0..1) <"Applies to Loan CDS, to indicate what lien level is appropriate for a deliverable obligation. Applies to European Loan CDS, to indicate the Ranking of the obligation. Example: a 2nd lien Loan CDS would imply that the deliverable obligations are 1st or 2nd lien loans.">
        [metadata scheme]
    cashSettlementOnly boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published Standard Terms Supplement for use with CDS Transactions on Leveraged Loans. ISDA 2003 Term: Cash Settlement Only.">
    deliveryOfCommitments boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published Standard Terms Supplement for use with CDS Transactions on Leveraged Loans. ISDA 2003 Term: Delivery of Commitments.">
    continuity boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published Standard Terms Supplement for use with CDS Transactions on Leveraged Loans. ISDA 2003 Term: Continuity.">

    condition ObligationsChoice: <"Choice rule to represent an FpML choice construct.">
        optional choice fullFaithAndCreditObLiability, generalFundObligationLiability, revenueObligationLiability

type SpecifiedCurrency:

    applicable boolean (1..1) <"Indicates whether the specified currency provision is applicable.">
    currency string (0..1) <"The currency in which the specified currency is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-desc.rosetta
================================================================================

namespace cdm.base.staticdata.asset : <"Basic static asset identifier and taxonomy concepts.">
version "${project.version}"


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-asset-rates-enum.rosetta
================================================================================

namespace cdm.base.staticdata.asset.rates
version "${project.version}"

import cdm.base.*

enum FloatingRateIndexEnum: <"The enumerated values to specify the list of floating rate index.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/floating-rate-index"]

    AED_EBOR_Reuters displayName "AED-EBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AED_EIBOR displayName "AED-EIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    AUD_AONIA displayName "AUD-AONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_AONIA_OIS_Compound_1 displayName "AUD-AONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    AUD_AONIA_OIS_COMPOUND displayName "AUD-AONIA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_AONIA_OIS_COMPOUND_SwapMarker displayName "AUD-AONIA-OIS-COMPOUND-SwapMarker" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_BBR_AUBBSW displayName "AUD-BBR-AUBBSW" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_BBR_BBSW displayName "AUD-BBR-BBSW" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_BBR_BBSW_Bloomberg displayName "AUD-BBR-BBSW-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_BBR_BBSY__BID_ displayName "AUD-BBR-BBSY (BID)" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_BBR_ISDC displayName "AUD-BBR-ISDC" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_BBSW displayName "AUD-BBSW" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    AUD_BBSW_Quarterly_Swap_Rate_ICAP displayName "AUD-BBSW Quarterly Swap Rate ICAP" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    AUD_BBSW_Semi_Annual_Swap_Rate_ICAP displayName "AUD-BBSW Semi Annual Swap Rate ICAP" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    AUD_BBSY_Bid displayName "AUD-BBSY Bid" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    AUD_LIBOR_BBA displayName "AUD-LIBOR-BBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_LIBOR_BBA_Bloomberg displayName "AUD-LIBOR-BBA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_LIBOR_Reference_Banks displayName "AUD-LIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_Quarterly_Swap_Rate_ICAP displayName "AUD-Quarterly Swap Rate-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_Quarterly_Swap_Rate_ICAP_Reference_Banks displayName "AUD-Quarterly Swap Rate-ICAP-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "AUD-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks displayName "AUD-Semi-Annual Swap Rate-BGCANTOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_Semi_annual_Swap_Rate_ICAP displayName "AUD-Semi-annual Swap Rate-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks displayName "AUD-Semi-Annual Swap Rate-ICAP-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    AUD_Swap_Rate_Reuters displayName "AUD-Swap Rate-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    BRL_CDI displayName "BRL-CDI" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CAD_BA_CDOR displayName "CAD-BA-CDOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_BA_CDOR_Bloomberg displayName "CAD-BA-CDOR-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_BA_ISDD displayName "CAD-BA-ISDD" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_BA_Reference_Banks displayName "CAD-BA-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_BA_Reuters displayName "CAD-BA-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_BA_Telerate displayName "CAD-BA-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_CDOR displayName "CAD-CDOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CAD_CORRA displayName "CAD-CORRA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_CORRA_CanDeal_TMX_Term displayName "CAD-CORRA CanDeal TMX Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_CORRA_Compounded_Index displayName "CAD-CORRA Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_CORRA_OIS_Compound_1 displayName "CAD-CORRA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_CORRA_OIS_COMPOUND displayName "CAD-CORRA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_ISDA_Swap_Rate displayName "CAD-ISDA-Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_LIBOR_BBA displayName "CAD-LIBOR-BBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_LIBOR_BBA_Bloomberg displayName "CAD-LIBOR-BBA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_LIBOR_BBA_SwapMarker displayName "CAD-LIBOR-BBA-SwapMarker" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_LIBOR_Reference_Banks displayName "CAD-LIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_REPO_CORRA displayName "CAD-REPO-CORRA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_TBILL_ISDD displayName "CAD-TBILL-ISDD" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_TBILL_Reference_Banks displayName "CAD-TBILL-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_TBILL_Reuters displayName "CAD-TBILL-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CAD_TBILL_Telerate displayName "CAD-TBILL-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP displayName "CHF-3M LIBOR SWAP-CME vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg displayName "CHF-3M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP displayName "CHF-3M LIBOR SWAP-EUREX vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg displayName "CHF-3M LIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_6M_LIBOR_SWAP_CME_vs_LCH_ICAP displayName "CHF-6M LIBOR SWAP-CME vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_6M_LIBORSWAP_CME_vs_LCH_ICAP_Bloomberg displayName "CHF-6M LIBORSWAP-CME vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP displayName "CHF-6M LIBOR SWAP-EUREX vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg displayName "CHF-6M LIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_Annual_Swap_Rate displayName "CHF-Annual Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_Annual_Swap_Rate_11_00_ICAP displayName "CHF-Annual Swap Rate-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_Annual_Swap_Rate_Reference_Banks displayName "CHF-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_Basis_Swap_3m_vs_6m_LIBOR_11_00_ICAP displayName "CHF-Basis Swap-3m vs 6m-LIBOR-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_ISDAFIX_Swap_Rate displayName "CHF-ISDAFIX-Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_LIBOR displayName "CHF-LIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_LIBOR_BBA displayName "CHF-LIBOR-BBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_LIBOR_BBA_Bloomberg displayName "CHF-LIBOR-BBA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_LIBOR_ISDA displayName "CHF-LIBOR-ISDA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_LIBOR_Reference_Banks displayName "CHF-LIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_OIS_11_00_ICAP displayName "CHF-OIS-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_SARON displayName "CHF-SARON" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Average_12M displayName "CHF-SARON Average 12M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Average_1M displayName "CHF-SARON Average 1M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Average_1W displayName "CHF-SARON Average 1W" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Average_2M displayName "CHF-SARON Average 2M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Average_3M displayName "CHF-SARON Average 3M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Average_6M displayName "CHF-SARON Average 6M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Average_9M displayName "CHF-SARON Average 9M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_Compounded_Index displayName "CHF-SARON Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_OIS_Compound_1 displayName "CHF-SARON-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CHF_SARON_OIS_COMPOUND displayName "CHF-SARON-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_TOIS_OIS_COMPOUND displayName "CHF-TOIS-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CHF_USD_Basis_Swaps_11_00_ICAP displayName "CHF USD-Basis Swaps-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CL_CLICP_Bloomberg displayName "CL-CLICP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CLP_ICP displayName "CLP-ICP" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CLP_TNA displayName "CLP-TNA" <"Refers to the Indice Camara Promedio ('ICP') rate for Chilean Pesos which, for a Reset Date, is determined and published by the Asociacion de Bancos e Instituciones Financieras de Chile A.G. ('ABIF') in accordance with the 'Reglamento Indice de Camara Promedio' of the ABIF as published in the Diario Oficial de la Republica de Chile (the 'ICP Rules') and which is reported on the ABIF website by not later than 10:00 a.m., Santiago time, on that Reset Date.">
    CNH_HIBOR displayName "CNH-HIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CNH_HIBOR_Reference_Banks displayName "CNH-HIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNH_HIBOR_TMA displayName "CNH-HIBOR-TMA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_7_Repo_Compounding_Date displayName "CNY 7-Repo Compounding Date" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_CNREPOFIX_CFXS_Reuters displayName "CNY-CNREPOFIX=CFXS-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_Deposit_Rate displayName "CNY-Deposit Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CNY_Fixing_Repo_Rate displayName "CNY-Fixing Repo Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CNY_LPR displayName "CNY-LPR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CNY_PBOCB_Reuters displayName "CNY-PBOCB-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION displayName "CNY-Quarterly 7 day Repo Non Deliverable Swap Rate-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION_Reference_Banks displayName "CNY-Quarterly 7 day Repo Non Deliverable Swap Rate-TRADITION-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_Quarterly_7D_Repo_NDS_Rate_Tradition displayName "CNY-Quarterly 7D Repo NDS Rate Tradition" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CNY_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "CNY-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_Semi_Annual_Swap_Rate_Reference_Banks displayName "CNY-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_SHIBOR displayName "CNY-SHIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CNY_SHIBOR_OIS_Compound displayName "CNY-SHIBOR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CNY_Shibor_OIS_Compounding displayName "CNY-Shibor-OIS-Compounding" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CNY_SHIBOR_Reuters displayName "CNY-SHIBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction..">
    COP_IBR_OIS_Compound_1 displayName "COP-IBR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    COP_IBR_OIS_COMPOUND displayName "COP-IBR-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CZK_Annual_Swap_Rate_11_00_BGCANTOR displayName "CZK-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CZK_Annual_Swap_Rate_Reference_Banks displayName "CZK-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CZK_CZEONIA displayName "CZK-CZEONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CZK_CZEONIA_OIS_Compound displayName "CZK-CZEONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CZK_PRIBOR displayName "CZK-PRIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    CZK_PRIBOR_PRBO displayName "CZK-PRIBOR-PRBO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    CZK_PRIBOR_Reference_Banks displayName "CZK-PRIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_CIBOR displayName "DKK-CIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    DKK_CIBOR2 displayName "DKK-CIBOR2" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    DKK_CIBOR2_Bloomberg displayName "DKK-CIBOR2-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_CIBOR2_DKNA13 displayName "DKK-CIBOR2-DKNA13" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_CIBOR_DKNA13 displayName "DKK-CIBOR-DKNA13" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_CIBOR_DKNA13_Bloomberg displayName "DKK-CIBOR-DKNA13-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_CIBOR_Reference_Banks displayName "DKK-CIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_CITA displayName "DKK-CITA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    DKK_CITA_DKNA14_COMPOUND displayName "DKK-CITA-DKNA14-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_DESTR displayName "DKK-DESTR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    DKK_DESTR_Compounded_Index displayName "DKK-DESTR Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    DKK_DESTR_OIS_Compound displayName "DKK-DESTR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    DKK_DKKOIS_OIS_COMPOUND displayName "DKK-DKKOIS-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    DKK_Tom_Next_OIS_Compound displayName "DKK-Tom Next-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP displayName "EUR-3M EURIBOR SWAP-CME vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg displayName "EUR-3M EURIBOR SWAP-CME vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP displayName "EUR-3M EURIBOR SWAP-EUREX vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg displayName "EUR-3M EURIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP displayName "EUR-6M EURIBOR SWAP-CME vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg displayName "EUR-6M EURIBOR SWAP-CME vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP displayName "EUR-6M EURIBOR SWAP-EUREX vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg displayName "EUR-6M EURIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_10_00 displayName "EUR-Annual Swap Rate-10:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_10_00_BGCANTOR displayName "EUR-Annual Swap Rate-10:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_10_00_Bloomberg displayName "EUR-Annual Swap Rate-10:00-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_10_00_ICAP displayName "EUR-Annual Swap Rate-10:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_10_00_SwapMarker displayName "EUR-Annual Swap Rate-10:00-SwapMarker" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_10_00_TRADITION displayName "EUR-Annual Swap Rate-10:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_11_00 displayName "EUR-Annual Swap Rate-11:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_11_00_Bloomberg displayName "EUR-Annual Swap Rate-11:00-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_11_00_ICAP displayName "EUR-Annual Swap Rate-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_11_00_SwapMarker displayName "EUR-Annual Swap Rate-11:00-SwapMarker" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_3_Month displayName "EUR-Annual Swap Rate-3 Month" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_3_Month_SwapMarker displayName "EUR-Annual Swap Rate-3 Month-SwapMarker" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_4_15_TRADITION displayName "EUR-Annual Swap Rate-4:15-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Annual_Swap_Rate_Reference_Banks displayName "EUR-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_Basis_Swap_EONIA_vs_3m_EUR_IBOR_Swap_Rates_A_360_10_00_ICAP displayName "EUR Basis Swap-EONIA vs 3m EUR+IBOR Swap Rates-A/360-10:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_CNO_TEC10 displayName "EUR-CNO TEC10" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EONIA displayName "EUR-EONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_AVERAGE_1 displayName "EUR-EONIA-AVERAGE" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_Average displayName "EUR-EONIA-Average" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_10_00_BGCANTOR displayName "EUR-EONIA-OIS-10:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_10_00_ICAP displayName "EUR-EONIA-OIS-10:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_10_00_TRADITION displayName "EUR-EONIA-OIS-10:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_11_00_ICAP displayName "EUR-EONIA-OIS-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_4_15_TRADITION displayName "EUR-EONIA-OIS-4:15-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_Compound_1 displayName "EUR-EONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_COMPOUND displayName "EUR-EONIA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_OIS_COMPOUND_Bloomberg displayName "EUR-EONIA-OIS-COMPOUND-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EONIA_Swap_Index displayName "EUR-EONIA-Swap-Index" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR displayName "EUR-EURIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Act_365 displayName "EUR-EURIBOR-Act/365" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Act_365_Bloomberg displayName "EUR-EURIBOR-Act/365-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Annual_Bond_Swap_vs_1m_11_00_ICAP displayName "EUR EURIBOR-Annual Bond Swap vs 1m-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Basis_Swap_1m_vs_3m_Euribor_11_00_ICAP displayName "EUR EURIBOR-Basis Swap-1m vs 3m-Euribor-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Basis_Swap_3m_vs_6m_11_00_ICAP displayName "EUR EURIBOR-Basis Swap-3m vs 6m-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_ICE_Swap_Rate_11_00 displayName "EUR-EURIBOR ICE Swap Rate-11:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_ICE_Swap_Rate_12_00 displayName "EUR-EURIBOR ICE Swap Rate-12:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Reference_Banks displayName "EUR-EURIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Reuters displayName "EUR-EURIBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURIBOR_Telerate displayName "EUR-EURIBOR-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EURONIA_OIS_Compound_1 displayName "EUR-EURONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EURONIA_OIS_COMPOUND displayName "EUR-EURONIA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR displayName "EUR-EuroSTR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_Average_12M displayName "EUR-EuroSTR Average 12M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_Average_1M displayName "EUR-EuroSTR Average 1M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_Average_1W displayName "EUR-EuroSTR Average 1W" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_Average_3M displayName "EUR-EuroSTR Average 3M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_Average_6M displayName "EUR-EuroSTR Average 6M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_COMPOUND displayName "EUR-EuroSTR-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_Compounded_Index displayName "EUR-EuroSTR Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_FTSE_Term displayName "EUR-EuroSTR FTSE Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_ICE_Compounded_Index displayName "EUR-EuroSTR ICE Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_ICE_Compounded_Index_0_Floor displayName "EUR-EuroSTR ICE Compounded Index 0 Floor" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_ICE_Compounded_Index_0_Floor_2D_Lag displayName "EUR-EuroSTR ICE Compounded Index 0 Floor 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_ICE_Compounded_Index_0_Floor_5D_Lag displayName "EUR-EuroSTR ICE Compounded Index 0 Floor 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_ICE_Compounded_Index_2D_Lag displayName "EUR-EuroSTR ICE Compounded Index 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_ICE_Compounded_Index_5D_Lag displayName "EUR-EuroSTR ICE Compounded Index 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_ICE_Swap_Rate displayName "EUR-EuroSTR ICE Swap Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_OIS_Compound displayName "EUR-EuroSTR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_EuroSTR_Term displayName "EUR-EuroSTR Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_ISDA_EURIBOR_Swap_Rate_11_00 displayName "EUR-ISDA-EURIBOR Swap Rate-11:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_ISDA_EURIBOR_Swap_Rate_12_00 displayName "EUR-ISDA-EURIBOR Swap Rate-12:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_ISDA_LIBOR_Swap_Rate_10_00 displayName "EUR-ISDA-LIBOR Swap Rate-10:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_ISDA_LIBOR_Swap_Rate_11_00 displayName "EUR-ISDA-LIBOR Swap Rate-11:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_LIBOR displayName "EUR-LIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    EUR_LIBOR_BBA displayName "EUR-LIBOR-BBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_LIBOR_BBA_Bloomberg displayName "EUR-LIBOR-BBA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_LIBOR_Reference_Banks displayName "EUR-LIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TAM_CDC displayName "EUR-TAM-CDC" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TEC10_CNO displayName "EUR-TEC10-CNO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TEC10_CNO_SwapMarker displayName "EUR-TEC10-CNO-SwapMarker" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TEC10_Reference_Banks displayName "EUR-TEC10-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TEC5_CNO displayName "EUR-TEC5-CNO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TEC5_CNO_SwapMarker displayName "EUR-TEC5-CNO-SwapMarker" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TEC5_Reference_Banks displayName "EUR-TEC5-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_TMM_CDC_COMPOUND displayName "EUR-TMM-CDC-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    EUR_USD_Basis_Swaps_11_00_ICAP displayName "EUR USD-Basis Swaps-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP displayName "GBP-6M LIBOR SWAP-CME vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg displayName "GBP-6M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP displayName "GBP-6M LIBOR SWAP-EUREX vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg displayName "GBP-6M LIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_ISDA_Swap_Rate displayName "GBP-ISDA-Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_LIBOR displayName "GBP-LIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    GBP_LIBOR_BBA displayName "GBP-LIBOR-BBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_LIBOR_BBA_Bloomberg displayName "GBP-LIBOR-BBA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_LIBOR_ICE_Swap_Rate displayName "GBP-LIBOR ICE Swap Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    GBP_LIBOR_ISDA displayName "GBP-LIBOR-ISDA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_LIBOR_Reference_Banks displayName "GBP-LIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_RONIA displayName "GBP-RONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    GBP_RONIA_OIS_Compound displayName "GBP-RONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    GBP_Semi_Annual_Swap_Rate displayName "GBP-Semi-Annual Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_Semi_Annual_Swap_Rate_11_00_ICAP displayName "GBP-Semi-Annual Swap Rate-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_Semi_Annual_Swap_Rate_11_00_TRADITION displayName "GBP-Semi Annual Swap Rate-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_Semi_Annual_Swap_Rate_4_15_TRADITION displayName "GBP-Semi Annual Swap Rate-4:15-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_Semi_Annual_Swap_Rate_Reference_Banks displayName "GBP-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_Semi_Annual_Swap_Rate_SwapMarker26 displayName "GBP-Semi-Annual Swap Rate-SwapMarker26" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA displayName "GBP-SONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_COMPOUND displayName "GBP-SONIA-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_Compounded_Index displayName "GBP-SONIA Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_FTSE_Term displayName "GBP-SONIA FTSE Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Compounded_Index displayName "GBP-SONIA ICE Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Compounded_Index_0_Floor displayName "GBP-SONIA ICE Compounded Index 0 Floor" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Compounded_Index_0_Floor_2D_Lag displayName "GBP-SONIA ICE Compounded Index 0 Floor 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Compounded_Index_0_Floor_5D_Lag displayName "GBP-SONIA ICE Compounded Index 0 Floor 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Compounded_Index_2D_Lag displayName "GBP-SONIA ICE Compounded Index 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Compounded_Index_5D_Lag displayName "GBP-SONIA ICE Compounded Index 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Swap_Rate displayName "GBP-SONIA ICE Swap Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_ICE_Term displayName "GBP-SONIA ICE Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_OIS_11_00_ICAP displayName "GBP-SONIA-OIS-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_OIS_11_00_TRADITION displayName "GBP-SONIA-OIS-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_OIS_4_15_TRADITION displayName "GBP-SONIA-OIS-4:15-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_OIS_Compound displayName "GBP-SONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    GBP_SONIA_Swap_Rate displayName "GBP-SONIA Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_UK_Base_Rate displayName "GBP-UK Base Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    GBP_USD_Basis_Swaps_11_00_ICAP displayName "GBP USD-Basis Swaps-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_WMBA_RONIA_COMPOUND displayName "GBP-WMBA-RONIA-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GBP_WMBA_SONIA_COMPOUND displayName "GBP-WMBA-SONIA-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GRD_ATHIBOR_ATHIBOR displayName "GRD-ATHIBOR-ATHIBOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GRD_ATHIBOR_Reference_Banks displayName "GRD-ATHIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GRD_ATHIBOR_Telerate displayName "GRD-ATHIBOR-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GRD_ATHIMID_Reference_Banks displayName "GRD-ATHIMID-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    GRD_ATHIMID_Reuters displayName "GRD-ATHIMID-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HIBOR displayName "HKD-HIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    HKD_HIBOR_HIBOR_ displayName "HKD-HIBOR-HIBOR=" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HIBOR_HIBOR_Bloomberg displayName "HKD-HIBOR-HIBOR-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HIBOR_HKAB displayName "HKD-HIBOR-HKAB" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HIBOR_HKAB_Bloomberg displayName "HKD-HIBOR-HKAB-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HIBOR_ISDC displayName "HKD-HIBOR-ISDC" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HIBOR_Reference_Banks displayName "HKD-HIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HONIA displayName "HKD-HONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_HONIA_OIS_Compound displayName "HKD-HONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    HKD_HONIX_OIS_COMPOUND displayName "HKD-HONIX-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_ISDA_Swap_Rate_11_00 displayName "HKD-ISDA-Swap Rate-11:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_ISDA_Swap_Rate_4_00 displayName "HKD-ISDA-Swap Rate-4:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR displayName "HKD-Quarterly-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_Quarterly_Annual_Swap_Rate_11_00_TRADITION displayName "HKD-Quarterly-Annual Swap Rate-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_Quarterly_Annual_Swap_Rate_4_00_BGCANTOR displayName "HKD-Quarterly-Annual Swap Rate-4:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_Quarterly_Annual_Swap_Rate_Reference_Banks displayName "HKD-Quarterly-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_Quarterly_Quarterly_Swap_Rate_11_00_ICAP displayName "HKD-Quarterly-Quarterly Swap Rate-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_Quarterly_Quarterly_Swap_Rate_4_00_ICAP displayName "HKD-Quarterly-Quarterly Swap Rate-4:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HKD_Quarterly_Quarterly_Swap_Rate_Reference_Banks displayName "HKD-Quarterly-Quarterly Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HUF_BUBOR displayName "HUF-BUBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    HUF_BUBOR_Reference_Banks displayName "HUF-BUBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HUF_BUBOR_Reuters displayName "HUF-BUBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    HUF_HUFONIA displayName "HUF-HUFONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    HUF_HUFONIA_OIS_Compound displayName "HUF-HUFONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    IDR_IDMA_Bloomberg displayName "IDR-IDMA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_IDRFIX displayName "IDR-IDRFIX" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_INDONIA displayName "IDR-INDONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    IDR_INDONIA_OIS_Compound displayName "IDR-INDONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    IDR_JIBOR displayName "IDR-JIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    IDR_JIBOR_Reuters displayName "IDR-JIBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_SBI_Reuters displayName "IDR-SBI-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "IDR-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon displayName "IDR-Semi Annual Swap Rate-Non-deliverable-16:00-Tullett Prebon" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_Semi_Annual_Swap_Rate_Reference_Banks displayName "IDR-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_SOR_Reference_Banks displayName "IDR-SOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_SOR_Reuters displayName "IDR-SOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    IDR_SOR_Telerate displayName "IDR-SOR-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ILS_SHIR displayName "ILS-SHIR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    ILS_SHIR_OIS_Compound displayName "ILS-SHIR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    ILS_TELBOR displayName "ILS-TELBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    ILS_TELBOR01_Reuters displayName "ILS-TELBOR01-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ILS_TELBOR_Reference_Banks displayName "ILS-TELBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_BMK displayName "INR-BMK" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_CMT displayName "INR-CMT" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_FBIL_MIBOR_OIS_COMPOUND displayName "INR-FBIL-MIBOR-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_INBMK_REUTERS displayName "INR-INBMK-REUTERS" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_MIBOR_OIS displayName "INR-MIBOR OIS" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    INR_MIBOR_OIS_Compound_1 displayName "INR-MIBOR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    INR_MIBOR_OIS_COMPOUND displayName "INR-MIBOR-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_MIFOR displayName "INR-MIFOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_MIOIS displayName "INR-MIOIS" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_MITOR_OIS_COMPOUND displayName "INR-MITOR-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_Modified_MIFOR displayName "INR-Modified MIFOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_Reference_Banks displayName "INR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_Semi_Annual_Swap_Rate_11_30_BGCANTOR displayName "INR-Semi-Annual Swap Rate-11:30-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon displayName "INR-Semi Annual Swap Rate-Non-deliverable-16:00-Tullett Prebon" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    INR_Semi_Annual_Swap_Rate_Reference_Banks displayName "INR-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ISK_REIBOR displayName "ISK-REIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    ISK_REIBOR_Reference_Banks displayName "ISK-REIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ISK_REIBOR_Reuters displayName "ISK-REIBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_Annual_Swap_Rate_11_00_TRADITION displayName "JPY-Annual Swap Rate-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_Annual_Swap_Rate_3_00_TRADITION displayName "JPY-Annual Swap Rate-3:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_BBSF_Bloomberg_10_00 displayName "JPY-BBSF-Bloomberg-10:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_BBSF_Bloomberg_15_00 displayName "JPY-BBSF-Bloomberg-15:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_Euroyen_TIBOR displayName "JPY-Euroyen TIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    JPY_ISDA_Swap_Rate_10_00 displayName "JPY-ISDA-Swap Rate-10:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_ISDA_Swap_Rate_15_00 displayName "JPY-ISDA-Swap Rate-15:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR displayName "JPY-LIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR_BBA displayName "JPY-LIBOR-BBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR_BBA_Bloomberg displayName "JPY-LIBOR-BBA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR_FRASETT displayName "JPY-LIBOR-FRASETT" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR_ISDA displayName "JPY-LIBOR-ISDA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR_Reference_Banks displayName "JPY-LIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR_TSR_10_00 displayName "JPY-LIBOR TSR-10:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    JPY_LIBOR_TSR_15_00 displayName "JPY-LIBOR TSR-15:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    JPY_LTPR_MHBK displayName "JPY-LTPR MHBK" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    JPY_LTPR_MHCB displayName "JPY-LTPR-MHCB" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_LTPR_TBC displayName "JPY-LTPR-TBC" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_MUTANCALL_TONAR displayName "JPY-MUTANCALL-TONAR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_OIS_11_00_ICAP displayName "JPY-OIS-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_OIS_11_00_TRADITION displayName "JPY-OIS-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_OIS_3_00_TRADITION displayName "JPY-OIS-3:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_Quoting_Banks_LIBOR displayName "JPY-Quoting Banks-LIBOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_STPR_Quoting_Banks displayName "JPY-STPR-Quoting Banks" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR displayName "JPY-TIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_17096 displayName "JPY-TIBOR-17096" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_17097 displayName "JPY-TIBOR-17097" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_DTIBOR01 displayName "JPY-TIBOR-DTIBOR01" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_TIBM displayName "JPY-TIBOR-TIBM" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_TIBM__10_Banks_ displayName "JPY-TIBOR-TIBM (10 Banks)" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_TIBM__5_Banks_ displayName "JPY-TIBOR-TIBM (5 Banks)" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_TIBM__All_Banks_ displayName "JPY-TIBOR-TIBM (All Banks)" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_TIBM__All_Banks__Bloomberg displayName "JPY-TIBOR-TIBM (All Banks)-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_TIBM_Reference_Banks displayName "JPY-TIBOR-TIBM-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TIBOR_ZTIBOR displayName "JPY-TIBOR-ZTIBOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA displayName "JPY-TONA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_Average_180D displayName "JPY-TONA Average 180D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_Average_30D displayName "JPY-TONA Average 30D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_Average_90D displayName "JPY-TONA Average 90D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_Compounded_Index displayName "JPY-TONA Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_ICE_Compounded_Index displayName "JPY-TONA ICE Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_ICE_Compounded_Index_0_Floor displayName "JPY-TONA ICE Compounded Index 0 Floor" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_ICE_Compounded_Index_0_Floor_2D_Lag displayName "JPY-TONA ICE Compounded Index 0 Floor 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_ICE_Compounded_Index_0_Floor_5D_Lag displayName "JPY-TONA ICE Compounded Index 0 Floor 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_ICE_Compounded_Index_2D_Lag displayName "JPY-TONA ICE Compounded Index 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_ICE_Compounded_Index_5D_Lag displayName "JPY-TONA ICE Compounded Index 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_OIS_Compound_1 displayName "JPY-TONA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    JPY_TONA_OIS_COMPOUND displayName "JPY-TONA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_TSR_10_00 displayName "JPY-TONA TSR-10:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TONA_TSR_15_00 displayName "JPY-TONA TSR-15:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TORF_QUICK displayName "JPY-TORF QUICK" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TSR_Reference_Banks displayName "JPY-TSR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TSR_Reuters_10_00 displayName "JPY-TSR-Reuters-10:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TSR_Reuters_15_00 displayName "JPY-TSR-Reuters-15:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TSR_Telerate_10_00 displayName "JPY-TSR-Telerate-10:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_TSR_Telerate_15_00 displayName "JPY-TSR-Telerate-15:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    JPY_USD_Basis_Swaps_11_00_ICAP displayName "JPY USD-Basis Swaps-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    KRW_Bond_3222 displayName "KRW-Bond-3222" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    KRW_CD_3220 displayName "KRW-CD-3220" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    KRW_CD_91D displayName "KRW-CD 91D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    KRW_CD_KSDA_Bloomberg displayName "KRW-CD-KSDA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    KRW_KOFR displayName "KRW-KOFR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    KRW_KOFR_OIS_Compound displayName "KRW-KOFR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    KRW_Quarterly_Annual_Swap_Rate_3_30_ICAP displayName "KRW-Quarterly Annual Swap Rate-3:30-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MXN_TIIE displayName "MXN-TIIE" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    MXN_TIIE_Banxico displayName "MXN-TIIE-Banxico" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MXN_TIIE_Banxico_Bloomberg displayName "MXN-TIIE-Banxico-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MXN_TIIE_Banxico_Reference_Banks displayName "MXN-TIIE-Banxico-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MXN_TIIE_ON displayName "MXN-TIIE ON" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    MXN_TIIE_ON_OIS_Compound displayName "MXN-TIIE ON-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    MXN_TIIE_Reference_Banks displayName "MXN-TIIE-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MYR_KLIBOR displayName "MYR-KLIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    MYR_KLIBOR_BNM displayName "MYR-KLIBOR-BNM" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MYR_KLIBOR_Reference_Banks displayName "MYR-KLIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MYR_MYOR displayName "MYR-MYOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    MYR_MYOR_OIS_Compound displayName "MYR-MYOR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    MYR_Quarterly_Swap_Rate_11_00_TRADITION displayName "MYR-Quarterly Swap Rate-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    MYR_Quarterly_Swap_Rate_TRADITION_Reference_Banks displayName "MYR-Quarterly Swap Rate-TRADITION-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NOK_NIBOR displayName "NOK-NIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    NOK_NIBOR_NIBR displayName "NOK-NIBOR-NIBR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NOK_NIBOR_NIBR_Bloomberg displayName "NOK-NIBOR-NIBR-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NOK_NIBOR_NIBR_Reference_Banks displayName "NOK-NIBOR-NIBR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NOK_NIBOR_OIBOR displayName "NOK-NIBOR-OIBOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NOK_NIBOR_Reference_Banks displayName "NOK-NIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NOK_NOWA displayName "NOK-NOWA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NOK_NOWA_OIS_Compound displayName "NOK-NOWA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    NZD_BBR_BID displayName "NZD-BBR-BID" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_BBR_FRA displayName "NZD-BBR-FRA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_BBR_ISDC displayName "NZD-BBR-ISDC" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_BBR_Reference_Banks displayName "NZD-BBR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_BBR_Telerate displayName "NZD-BBR-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_BKBM_Bid displayName "NZD-BKBM Bid" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    NZD_BKBM_FRA displayName "NZD-BKBM FRA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    NZD_BKBM_FRA_Swap_Rate_ICAP displayName "NZD-BKBM FRA Swap Rate ICAP" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    NZD_NZIONA displayName "NZD-NZIONA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction. NOTE: In accordance with Section 2.1.11(ii) (New Zealand Business Days), from the date on which the New Zealand Financial Markets Association's 'New Zealand Business Day Guidance' (proposed effective date of October 6, 2025) becomes effective, the reference to a 'Wellington and Auckland Business Day' will be deemed to be replaced with a reference to a 'New Zealand Business Day' for all Transactions entered into from (and including) that effective date.">
    NZD_NZIONA_OIS_Compound_1 displayName "NZD-NZIONA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction. NOTE: In accordance with Section 2.1.11(ii) (New Zealand Business Days), from the date on which the New Zealand Financial Markets Association's 'New Zealand Business Day Guidance' (proposed effective date of October 6, 2025) becomes effective, the reference to a 'Wellington and Auckland Business Day' will be deemed to be replaced with a reference to a 'New Zealand Business Day' for all Transactions entered into from (and including) that effective date.">
    NZD_NZIONA_OIS_COMPOUND displayName "NZD-NZIONA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "NZD-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks displayName "NZD-Semi-Annual Swap Rate-BGCANTOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_Swap_Rate_ICAP displayName "NZD-Swap Rate-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    NZD_Swap_Rate_ICAP_Reference_Banks displayName "NZD-Swap Rate-ICAP-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PHP_ORR displayName "PHP-ORR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PHP_PHIREF displayName "PHP-PHIREF" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PHP_PHIREF_BAP displayName "PHP-PHIREF-BAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PHP_PHIREF_Bloomberg displayName "PHP-PHIREF-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PHP_PHIREF_Reference_Banks displayName "PHP-PHIREF-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PHP_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "PHP-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PHP_Semi_Annual_Swap_Rate_Reference_Banks displayName "PHP-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PLN_POLONIA displayName "PLN-POLONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PLN_POLONIA_OIS_Compound_1 displayName "PLN-POLONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PLN_POLONIA_OIS_COMPOUND displayName "PLN-POLONIA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PLN_WIBID displayName "PLN-WIBID" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PLN_WIBOR displayName "PLN-WIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PLN_WIBOR_Reference_Banks displayName "PLN-WIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PLN_WIBOR_WIBO displayName "PLN-WIBOR-WIBO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PLN_WIRON displayName "PLN-WIRON" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PLN_WIRON_OIS_Compound displayName "PLN-WIRON-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    PLZ_WIBOR_Reference_Banks displayName "PLZ-WIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    PLZ_WIBOR_WIBO displayName "PLZ-WIBOR-WIBO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    REPOFUNDS_RATE_FRANCE_OIS_COMPOUND displayName "REPOFUNDS RATE-FRANCE-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    REPOFUNDS_RATE_GERMANY_OIS_COMPOUND displayName "REPOFUNDS RATE-GERMANY-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    REPOFUNDS_RATE_ITALY_OIS_COMPOUND displayName "REPOFUNDS RATE-ITALY-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RON_Annual_Swap_Rate_11_00_BGCANTOR displayName "RON-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RON_Annual_Swap_Rate_Reference_Banks displayName "RON-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RON_RBOR_Reuters displayName "RON-RBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RON_ROBID displayName "RON-ROBID" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    RON_ROBOR displayName "RON-ROBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    RUB_Annual_Swap_Rate_11_00_BGCANTOR displayName "RUB-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RUB_Annual_Swap_Rate_12_45_TRADITION displayName "RUB-Annual Swap Rate-12:45-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RUB_Annual_Swap_Rate_4_15_TRADITION displayName "RUB-Annual Swap Rate-4:15-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RUB_Annual_Swap_Rate_Reference_Banks displayName "RUB-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RUB_Annual_Swap_Rate_TRADITION_Reference_Banks displayName "RUB-Annual Swap Rate-TRADITION-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RUB_Key_Rate_CBRF displayName "RUB-Key Rate CBRF" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    RUB_MosPrime displayName "RUB-MosPrime" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    RUB_MOSPRIME_NFEA displayName "RUB-MOSPRIME-NFEA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RUB_MOSPRIME_Reference_Banks displayName "RUB-MOSPRIME-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    RUB_RUONIA displayName "RUB-RUONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    RUB_RUONIA_OIS_Compound_1 displayName "RUB-RUONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    RUB_RUONIA_OIS_COMPOUND displayName "RUB-RUONIA-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SAR_SAIBOR displayName "SAR-SAIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    SAR_SRIOR_Reference_Banks displayName "SAR-SRIOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SAR_SRIOR_SUAA displayName "SAR-SRIOR-SUAA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_Annual_Swap_Rate displayName "SEK-Annual Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_Annual_Swap_Rate_SESWFI displayName "SEK-Annual Swap Rate-SESWFI" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SIOR_OIS_COMPOUND displayName "SEK-SIOR-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_STIBOR displayName "SEK-STIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    SEK_STIBOR_Bloomberg displayName "SEK-STIBOR-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_STIBOR_OIS_Compound displayName "SEK-STIBOR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    SEK_STIBOR_Reference_Banks displayName "SEK-STIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_STIBOR_SIDE displayName "SEK-STIBOR-SIDE" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR displayName "SEK-SWESTR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR_Average_1M displayName "SEK-SWESTR Average 1M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR_Average_1W displayName "SEK-SWESTR Average 1W" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR_Average_2M displayName "SEK-SWESTR Average 2M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR_Average_3M displayName "SEK-SWESTR Average 3M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR_Average_6M displayName "SEK-SWESTR Average 6M" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR_Compounded_Index displayName "SEK-SWESTR Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SEK_SWESTR_OIS_Compound displayName "SEK-SWESTR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Currency_Basis_Swap_Rate_11_00_Tullett_Prebon displayName "SGD-Semi-Annual Currency Basis Swap Rate-11:00-Tullett Prebon" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Currency_Basis_Swap_Rate_16_00_Tullett_Prebon displayName "SGD-Semi-Annual Currency Basis Swap Rate-16:00-Tullett Prebon" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "SGD-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_11_00_Tullett_Prebon displayName "SGD-Semi-Annual Swap Rate-11:00-Tullett Prebon" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_11_00_TRADITION displayName "SGD-Semi-Annual Swap Rate-11.00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_16_00_Tullett_Prebon displayName "SGD-Semi-Annual Swap Rate-16:00-Tullett Prebon" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_ICAP displayName "SGD-Semi-Annual Swap Rate-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks displayName "SGD-Semi-Annual Swap Rate-ICAP-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_Reference_Banks displayName "SGD-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks displayName "SGD-Semi-Annual Swap Rate-TRADITION-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SIBOR displayName "SGD-SIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    SGD_SIBOR_Reference_Banks displayName "SGD-SIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SIBOR_Reuters displayName "SGD-SIBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SIBOR_Telerate displayName "SGD-SIBOR-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SONAR_OIS_COMPOUND displayName "SGD-SONAR-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SONAR_OIS_VWAP_COMPOUND displayName "SGD-SONAR-OIS-VWAP-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SOR displayName "SGD-SOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    SGD_SORA displayName "SGD-SORA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SORA_COMPOUND displayName "SGD-SORA-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SORA_OIS_Compound displayName "SGD-SORA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    SGD_SOR_Reference_Banks displayName "SGD-SOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SOR_Reuters displayName "SGD-SOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SOR_Telerate displayName "SGD-SOR-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SOR_VWAP displayName "SGD-SOR-VWAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SGD_SOR_VWAP_Reference_Banks displayName "SGD-SOR-VWAP-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SKK_BRIBOR_Bloomberg displayName "SKK-BRIBOR-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SKK_BRIBOR_BRBO displayName "SKK-BRIBOR-BRBO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SKK_BRIBOR_NBSK07 displayName "SKK-BRIBOR-NBSK07" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    SKK_BRIBOR_Reference_Banks displayName "SKK-BRIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "THB-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_Semi_Annual_Swap_Rate_Reference_Banks displayName "THB-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_SOR_Reference_Banks displayName "THB-SOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_SOR_Reuters displayName "THB-SOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_SOR_Telerate displayName "THB-SOR-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_THBFIX displayName "THB-THBFIX" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    THB_THBFIX_Reference_Banks displayName "THB-THBFIX-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_THBFIX_Reuters displayName "THB-THBFIX-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_THOR displayName "THB-THOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_THOR_COMPOUND displayName "THB-THOR-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    THB_THOR_OIS_Compound displayName "THB-THOR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    TRY_Annual_Swap_Rate_11_00_TRADITION displayName "TRY Annual Swap Rate-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TRY_Annual_Swap_Rate_11_15_BGCANTOR displayName "TRY-Annual Swap Rate-11:15-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TRY_Annual_Swap_Rate_Reference_Banks displayName "TRY-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TRY_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks displayName "TRY-Semi-Annual Swap Rate-TRADITION-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TRY_TLREF displayName "TRY-TLREF" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    TRY_TLREF_OIS_Compound_1 displayName "TRY-TLREF-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    TRY_TLREF_OIS_COMPOUND displayName "TRY-TLREF-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TRY_TRLIBOR displayName "TRY-TRLIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    TRY_TRYIBOR_Reference_Banks displayName "TRY-TRYIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TRY_TRYIBOR_Reuters displayName "TRY-TRYIBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR displayName "TWD-Quarterly-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_Quarterly_Annual_Swap_Rate_Reference_Banks displayName "TWD-Quarterly-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_Reference_Dealers displayName "TWD-Reference Dealers" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_Reuters_6165 displayName "TWD-Reuters-6165" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_TAIBIR01 displayName "TWD-TAIBIR01" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_TAIBIR02 displayName "TWD-TAIBIR02" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_TAIBOR displayName "TWD-TAIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    TWD_TAIBOR_Bloomberg displayName "TWD-TAIBOR-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_TAIBOR_Reuters displayName "TWD-TAIBOR-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_Telerate_6165 displayName "TWD-Telerate-6165" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    TWD_TWCPBA displayName "TWD-TWCPBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    UK_Base_Rate displayName "UK Base Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP displayName "USD-3M LIBOR SWAP-CME vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg displayName "USD-3M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP displayName "USD-6M LIBOR SWAP-CME vs LCH-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg displayName "USD-6M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_AMERIBOR displayName "USD-AMERIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_AMERIBOR_Average_30D displayName "USD-AMERIBOR Average 30D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_AMERIBOR_Average_90D displayName "USD-AMERIBOR Average 90D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_AMERIBOR_Term displayName "USD-AMERIBOR Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_AMERIBOR_Term_Structure displayName "USD-AMERIBOR Term Structure" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Annual_Swap_Rate_11_00_BGCANTOR displayName "USD-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Annual_Swap_Rate_11_00_TRADITION displayName "USD-Annual Swap Rate-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Annual_Swap_Rate_4_00_TRADITION displayName "USD-Annual Swap Rate-4:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_AXI_Term displayName "USD-AXI Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_BA_H_15 displayName "USD-BA-H.15" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_BA_Reference_Dealers displayName "USD-BA-Reference Dealers" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_BMA_Municipal_Swap_Index displayName "USD-BMA Municipal Swap Index" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_BSBY displayName "USD-BSBY" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CD_H_15 displayName "USD-CD-H.15" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CD_Reference_Dealers displayName "USD-CD-Reference Dealers" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CMS_Reference_Banks displayName "USD-CMS-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CMS_Reference_Banks_ICAP_SwapPX displayName "USD-CMS-Reference Banks-ICAP SwapPX" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CMS_Reuters displayName "USD-CMS-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CMS_Telerate displayName "USD-CMS-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CMT displayName "USD-CMT" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_CMT_Average_1W displayName "USD-CMT Average 1W" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_CMT_T7051 displayName "USD-CMT-T7051" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CMT_T7052 displayName "USD-CMT-T7052" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_COF11_FHLBSF displayName "USD-COF11-FHLBSF" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_COF11_Reuters displayName "USD-COF11-Reuters" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_COF11_Telerate displayName "USD-COF11-Telerate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_COFI displayName "USD-COFI" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_CP_H_15 displayName "USD-CP-H.15" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CP_Money_Market_Yield displayName "USD-CP-Money Market Yield" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_CP_Reference_Dealers displayName "USD-CP-Reference Dealers" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_CRITR displayName "USD-CRITR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Federal_Funds displayName "USD-Federal Funds" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_Federal_Funds_H_15 displayName "USD-Federal Funds-H.15" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Federal_Funds_H_15_Bloomberg displayName "USD-Federal Funds-H.15-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Federal_Funds_H_15_OIS_COMPOUND displayName "USD-Federal Funds-H.15-OIS-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Federal_Funds_OIS_Compound displayName "USD-Federal Funds-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_Federal_Funds_Reference_Dealers displayName "USD-Federal Funds-Reference Dealers" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_FFCB_DISCO displayName "USD-FFCB-DISCO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_FXI_Term displayName "USD-FXI Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_ISDAFIX3_Swap_Rate displayName "USD-ISDAFIX3-Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_ISDAFIX3_Swap_Rate_3_00 displayName "USD-ISDAFIX3-Swap Rate-3:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_ISDA_Swap_Rate displayName "USD-ISDA-Swap Rate" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_ISDA_Swap_Rate_3_00 displayName "USD-ISDA-Swap Rate-3:00" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_LIBOR displayName "USD-LIBOR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_LIBOR_BBA displayName "USD-LIBOR-BBA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_LIBOR_BBA_Bloomberg displayName "USD-LIBOR-BBA-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_LIBOR_ICE_Swap_Rate_11_00 displayName "USD-LIBOR ICE Swap Rate-11:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_LIBOR_ICE_Swap_Rate_15_00 displayName "USD-LIBOR ICE Swap Rate-15:00" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_LIBOR_ISDA displayName "USD-LIBOR-ISDA" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_LIBOR_LIBO displayName "USD-LIBOR-LIBO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_LIBOR_Reference_Banks displayName "USD-LIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Municipal_Swap_Index displayName "USD-Municipal Swap Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_Municipal_Swap_Libor_Ratio_11_00_ICAP displayName "USD-Municipal Swap Libor Ratio-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Municipal_Swap_Rate_11_00_ICAP displayName "USD-Municipal Swap Rate-11:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_OIS_11_00_BGCANTOR displayName "USD-OIS-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_OIS_11_00_LON_ICAP displayName "USD-OIS-11:00-LON-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_OIS_11_00_NY_ICAP displayName "USD-OIS-11:00-NY-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_OIS_11_00_TRADITION displayName "USD-OIS-11:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_OIS_3_00_BGCANTOR displayName "USD-OIS-3:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_OIS_3_00_NY_ICAP displayName "USD-OIS-3:00-NY-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_OIS_4_00_TRADITION displayName "USD-OIS-4:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Overnight_Bank_Funding_Rate displayName "USD-Overnight Bank Funding Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Prime displayName "USD-Prime" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_Prime_H_15 displayName "USD-Prime-H.15" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Prime_Reference_Banks displayName "USD-Prime-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_S_P_Index_High_Grade displayName "USD-S&P Index-High Grade" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SandP_Index_High_Grade displayName "USD-SandP Index High Grade" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_SIBOR_Reference_Banks displayName "USD-SIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SIBOR_SIBO displayName "USD-SIBOR-SIBO" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SIFMA_Municipal_Swap_Index displayName "USD-SIFMA Municipal Swap Index" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR displayName "USD-SOFR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_Average_180D displayName "USD-SOFR Average 180D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_Average_30D displayName "USD-SOFR Average 30D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_Average_90D displayName "USD-SOFR Average 90D" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_CME_Term displayName "USD-SOFR CME Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_COMPOUND displayName "USD-SOFR-COMPOUND" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_Compounded_Index displayName "USD-SOFR Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Compounded_Index displayName "USD-SOFR ICE Compounded Index" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Compounded_Index_0_Floor displayName "USD-SOFR ICE Compounded Index 0 Floor" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Compounded_Index_0_Floor_2D_Lag displayName "USD-SOFR ICE Compounded Index 0 Floor 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Compounded_Index_0_Floor_5D_Lag displayName "USD-SOFR ICE Compounded Index 0 Floor 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Compounded_Index_2D_Lag displayName "USD-SOFR ICE Compounded Index 2D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Compounded_Index_5D_Lag displayName "USD-SOFR ICE Compounded Index 5D Lag" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Swap_Rate displayName "USD-SOFR ICE Swap Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix and 2006 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Swap_Rate_Spreads displayName "USD-SOFR ICE Swap Rate Spreads" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_SOFR_ICE_Term displayName "USD-SOFR ICE Term" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_SOFR_OIS_Compound displayName "USD-SOFR-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_Swap_Rate_BCMP1 displayName "USD Swap Rate-BCMP1" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_TBILL_Auction_High_Rate displayName "USD-TBILL Auction High Rate" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_TBILL_H_15 displayName "USD-TBILL-H.15" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_TBILL_H_15_Bloomberg displayName "USD-TBILL-H.15-Bloomberg" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_TBILL_Secondary_Market displayName "USD-TBILL-Secondary Market" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_TBILL_Secondary_Market_Bond_Equivalent_Yield displayName "USD-TBILL Secondary Market-Bond Equivalent Yield" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    USD_TIBOR_ISDC displayName "USD-TIBOR-ISDC" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_TIBOR_Reference_Banks displayName "USD-TIBOR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Treasury_19901_3_00_ICAP displayName "USD-Treasury-19901-3:00-ICAP" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Treasury_Rate_BCMP1 displayName "USD Treasury Rate-BCMP1" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Treasury_Rate_ICAP_BrokerTec displayName "USD-Treasury Rate-ICAP BrokerTec" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Treasury_Rate_SwapMarker100 displayName "USD-Treasury Rate-SwapMarker100" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Treasury_Rate_SwapMarker99 displayName "USD-Treasury Rate-SwapMarker99" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Treasury_Rate_T19901 displayName "USD-Treasury Rate-T19901" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    USD_Treasury_Rate_T500 displayName "USD-Treasury Rate-T500" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    VND_Semi_Annual_Swap_Rate_11_00_BGCANTOR displayName "VND-Semi-Annual Swap Rate-11:00-BGCANTOR" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    VND_Semi_Annual_Swap_Rate_Reference_Banks displayName "VND-Semi-Annual Swap Rate-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_DEPOSIT_Reference_Banks displayName "ZAR-DEPOSIT-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_DEPOSIT_SAFEX displayName "ZAR-DEPOSIT-SAFEX" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_JIBAR displayName "ZAR-JIBAR" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    ZAR_JIBAR_Reference_Banks displayName "ZAR-JIBAR-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_JIBAR_SAFEX displayName "ZAR-JIBAR-SAFEX" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_Prime_Average_1 displayName "ZAR-Prime Average" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    ZAR_PRIME_AVERAGE displayName "ZAR-PRIME-AVERAGE" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_PRIME_AVERAGE_Reference_Banks displayName "ZAR-PRIME-AVERAGE-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_Quarterly_Swap_Rate_1_00_TRADITION displayName "ZAR-Quarterly Swap Rate-1:00-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_Quarterly_Swap_Rate_5_30_TRADITION displayName "ZAR-Quarterly Swap Rate-5:30-TRADITION" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_Quarterly_Swap_Rate_TRADITION_Reference_Banks displayName "ZAR-Quarterly Swap Rate-TRADITION-Reference Banks" <"Per 2006 ISDA Definitions or Annex to the 2000 ISDA Definitions, Section 7.1 Rate Options, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    ZAR_ZARONIA displayName "ZAR-ZARONIA" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">
    ZAR_ZARONIA_OIS_Compound displayName "ZAR-ZARONIA-OIS Compound" <"Per 2021 ISDA Interest Rate Derivatives Definitions Floating Rate Matrix, as amended through the date on which parties enter into the relevant transaction.">

enum InflationRateIndexEnum: <"The enumerated values to specify the list of inflation rate indices.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/inflation-index-description"]

    AUD_CPI displayName "AUD-CPI" <"Australia: AUD - Non-revised Consumer Price Index (CPI)">
    AUS_CPI displayName "AUS-CPI" <"Austria: AUS - Non-revised Consumer Price Index (CPI)">
    AUS_HICP displayName "AUS-HICP" <"Austria: AUS - Non-revised Harmonised Indices of Consumer Prices (HICP)">
    BLG_CPI_GI displayName "BLG-CPI-GI" <"Belgium: BLG - Non-revised Consumer Price Index - General Index (CPI)">
    BLG_CPI_HI displayName "BLG-CPI-HI" <"Belgium: BLG - Non-revised Consumer Price Index - Health Index (CPI)">
    BLG_HICP displayName "BLG-HICP" <"Belgium: BLG - Non-revised Harmonised Consumer Price Index (HICP)">
    BRL_IGPM displayName "BRL-IGPM" <"Brazil: BRL - Non-revised Price Index (IGP-M)">
    BRL_IPCA displayName "BRL-IPCA" <"Brazil: BRL - Non-revised Consumer Price Index (IPCA)">
    CAD_CPI displayName "CAD-CPI" <"Canada: CAD - Non-revised Consumer Price Index (CPI)">
    CLP_CPI displayName "CLP-CPI" <"Chile: CLP - Non-revised Consumer Price Index (CPI)">
    CNY_CPI displayName "CNY-CPI" <"China: CNY - Non-revised Consumer Price Index (CPI)">
    CZK_CPI displayName "CZK-CPI" <"Czech Republic: CZK - Non-revised Consumer Price Index (CPI)">
    DEK_CPI displayName "DEK-CPI" <"Denmark: DEK - Non-revised Consumer Price Index (CPI)">
    DEK_HICP displayName "DEK-HICP" <"Denmark: DEK - Non-revised Harmonised Consumer Price Index (HICP)">
    DEM_CPI displayName "DEM-CPI" <"Germany: DEM - Non-revised Consumer Price Index (CPI)">
    DEM_CPI_NRW displayName "DEM-CPI-NRW" <"Germany: DEM - Non-revised Consumer Price Index for North Rhine-Westphalia">
    DEM_HICP displayName "DEM-HICP" <"Germany: DEM - Non-revised Harmonised Consumer Price Index (HICP)">
    ESP_CPI displayName "ESP-CPI" <"Spain: ESP - National-Non-revised Consumer Price Index (CPI)">
    ESP_HICP displayName "ESP-HICP" <"Spain: ESP - Harmonised-Non-revised Consumer Price Index (HICP)">
    ESP_R_CPI displayName "ESP-R-CPI" <"Spain: ESP - National-Revised Consumer Price Index (CPI).">
    ESP_R_HICP displayName "ESP-R-HICP" <"Spain: ESP - Harmonised-Revised Consumer Price Index (HICP)">
    EUR_AI_CPI displayName "EUR-AI-CPI" <"European Union: EUR - All Items-Non-revised Consumer Price Index">
    EUR_AI_R_CPI displayName "EUR-AI-R-CPI" <"European Union: EUR - All Items-Revised Consumer Price Index">
    EUR_EXT_CPI displayName "EUR-EXT-CPI" <"European Union: EUR - Excluding Tobacco-Non-revised Consumer Price Index">
    EUR_EXT_R_CPI displayName "EUR-EXT-R-CPI" <"European Union: EUR - Excluding Tobacco-Revised Consumer Price Index">
    FIN_CPI displayName "FIN-CPI" <"Finland: FIN - Non-revised Consumer Price Index (CPI)">
    FIN_HICP displayName "FIN-HICP" <"Finland: FIN - Harmonised-Non-revised Consumer Price Index (HICP)">
    FRC_EXT_CPI displayName "FRC-EXT-CPI" <"France: FRC - Excluding Tobacco-Non-Revised Consumer Price Index">
    FRC_HICP displayName "FRC-HICP" <"France: FRC - Harmonised-Non-revised Consumer Price Index (HICP)">
    GRD_CPI displayName "GRD-CPI" <"Greece: GRD - Non-revised Consumer Price Index (CPI)">
    GRD_HICP displayName "GRD-HICP" <"Greece: GRD - Harmonised-Non-revised Consumer Price Index (HICP)">
    HKD_CPI displayName "HKD-CPI" <"Hong Kong: HKD - Non-revised Consumer Price Index (CPI)">
    HUF_CPI displayName "HUF-CPI" <"Hungary: HUF - Non-revised Consumer Price Index (CPI)">
    IDR_CPI displayName "IDR-CPI" <"Indonesia: IDR - Non-revised Consumer Price Index (CPI)">
    ILS_CPI displayName "ILS-CPI" <"Israel: ILS - Non-revised Consumer Price Index (CPI)">
    IRL_CPI displayName "IRL-CPI" <"Ireland: IRL - Non-revised Consumer Price Index (CPI)">
    IRL_HICP displayName "IRL-HICP" <"Ireland: IRL - Harmonised-Non-revised Consumer Price Index (HICP)">
    ISK_CPI displayName "ISK-CPI" <"Iceland: ISK - Non-revised Consumer Price Index (CPI)">
    ISK_HICP displayName "ISK-HICP" <"Iceland: ISK - Harmonised Consumer Price Index (HICP)">
    ITL_BC_EXT_CPI displayName "ITL-BC-EXT-CPI" <"Italy: ITL - Inflation for Blue Collar Workers and Employees-Excluding Tobacco Consumer Price Index">
    ITL_BC_INT_CPI displayName "ITL-BC-INT-CPI" <"Italy: ITL - Inflation for Blue Collar Workers and Employees-Including Tobacco Consumer Price Index">
    ITL_HICP displayName "ITL-HICP" <"Italy: ITL - Non-revised Harmonised Consumer Price Index (HICP)">
    ITL_WC_EXT_CPI displayName "ITL-WC-EXT-CPI" <"Italy: ITL - Whole Community - Excluding Tobacco Consumer Price Index">
    ITL_WC_INT_CPI displayName "ITL-WC-INT-CPI" <"Italy: ITL - Whole Community - Including Tobacco Consumer Price Index">
    JPY_CPI_EXF displayName "JPY-CPI-EXF" <"Japan: JPY - Non-revised Consumer Price Index Nationwide General Excluding Fresh Food (CPI)">
    KRW_CPI displayName "KRW-CPI" <"South Korea: KRW - Non-revised Consumer Price Index (CPI)">
    LUX_CPI displayName "LUX-CPI" <"Luxembourg: LUX - Non-revised Consumer Price Index (CPI)">
    LUX_HICP displayName "LUX-HICP" <"Luxembourg: LUX - Harmonised-Non-revised Consumer Price Index (HICP)">
    MXN_CPI displayName "MXN-CPI" <"Mexico: MXN - Non-revised Consumer Price Index (CPI)">
    MXN_UDI displayName "MXN-UDI" <"Mexico: MXN - Unidad de Inversion Index (UDI)">
    MYR_CPI displayName "MYR-CPI" <"Malaysia: MYR - Non-revised Consumer Price Index (CPI)">
    NLG_CPI displayName "NLG-CPI" <"Netherlands: NLG - Non-revised Consumer Price Index (CPI)">
    NLG_HICP displayName "NLG-HICP" <"Netherlands: NLG - Harmonised-Non-revised Consumer Price Index (HICP)">
    NOK_CPI displayName "NOK-CPI" <"Norway: NOK - Non-revised Consumer Price Index (CPI)">
    NZD_CPI displayName "NZD-CPI" <"New Zealand: NZD - Non-revised Consumer Price Index (CPI)">
    PER_CPI displayName "PER-CPI" <"Peru: PER - Non-revised Consumer Price Index (CPI)">
    PLN_CPI displayName "PLN-CPI" <"Poland: PLN - Non-Revised Consumer Price Index (CPI)">
    POR_CPI displayName "POR-CPI" <"Portugal: POR - Non-revised Consumer Price Index (CPI)">
    POR_HICP displayName "POR-HICP" <"Portugal: POR - Harmonised-Non-revised Consumer Price Index (HICP)">
    RUB_CPI displayName "RUB-CPI" <"Russia: RUB - Non-revised Consumer Price Index (CPI)">
    SEK_CPI displayName "SEK-CPI" <"Sweden: SEK - Non-revised Consumer Price Index (CPI)">
    SGD_CPI displayName "SGD-CPI" <"Singapore: SGD - Non-revised Consumer Price Index (CPI)">
    SWF_CPI displayName "SWF-CPI" <"Switzerland: SWF - Non-revised Consumer Price Index (CPI)">
    TRY_CPI displayName "TRY-CPI" <"Turkey: TRY - Non-revised Consumer Price Index (CPI)">
    TWD_CPI displayName "TWD-CPI" <"Taiwan: TWD - Non-revised Consumer Price Index (CPI)">
    UK_CPIH displayName "UK-CPIH" <"United Kingdom: GBP - Non-revised Consumer Prices Index including Housing (UKCPIH)">
    UK_HICP displayName "UK-HICP" <"United Kingdom: GBP - Harmonised-Non-revised Consumer Price Index (HICP)">
    UK_RPI displayName "UK-RPI" <"United Kingdom: GBP - Non-revised Retail Price Index (UKRPI)">
    UK_RPIX displayName "UK-RPIX" <"United Kingdom: GBP - Non-revised Retail Price Index Excluding Mortgage Interest Payments (UKRPIX)">
    USA_CPI_U displayName "USA-CPI-U" <"United States: USA - Non-revised Consumer Price Index - Urban (CPI-U)">
    ZAR_CPI displayName "ZAR-CPI" <"South Africa: ZAR - Non-revised Consumer Price Index (CPI)">
    ZAR_CPIX displayName "ZAR-CPIX" <"South Africa: ZAR - Non-revised Consumer Price Index Excluding Mortgages (CPIX)">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-desc.rosetta
================================================================================

namespace cdm.base.staticdata : <"Basic static data concepts: e.g. party, asset identifiers etc.">
version "${project.version}"


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-identifier-enum.rosetta
================================================================================

namespace cdm.base.staticdata.identifier : <"Basic identifier and assigned identifier concepts that are applicable across the model.">
version "${project.version}"

enum CommodityLocationIdentifierTypeEnum: <"Defines the enumerated values to specify the nature of a location identifier.">

    DeliveryPoint <"The physical or virtual point at which the commodity will be delivered.">
    EntryPoint <"The physical or virtual point at which the commodity enters a transportation system.">
    InterconnectionPoint <"Identification of the border(s) or border point(s) of a transportation contract.">
    WithdrawalPoint <"The physical or virtual point at which the commodity is withdrawn from a transportation system.">
    DeliveryZone <"The zone covering potential delivery points for the commodity">
    BuyerHub <"The hub code of the buyer.">
    SellerHub <"The hub code of the seller.">

enum TradeIdentifierTypeEnum: <"Defines the enumerated values to specify the nature of a trade identifier.">
    UniqueTransactionIdentifier
    UniqueSwapIdentifier


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-identifier-type.rosetta
================================================================================

namespace cdm.base.staticdata.identifier : <"Basic identifier and assigned identifier concepts that are applicable across the model.">
version "${project.version}"

import cdm.base.*
import cdm.base.staticdata.party.*
import cdm.observable.asset.*

type AssignedIdentifier: <"A class to specify the identifier value and its associated version.">

    identifier string (1..1) <"The identifier value.">
        [metadata scheme]
    version int (0..1) <"The identifier version, which is specified as an integer and is meant to be incremented each time the transaction terms (whether contract or event) change. This version is made option to support the use case where the identifier is referenced without the version. The constraint that a contract and a lifecycle event need to have an associated version is enforced through data rules.">

type Identifier: <"A class to specify a generic identifier, applicable to CDM artefacts such as executions, contracts, lifecycle events and legal documents. An issuer can be associated with the actual identifier value as a way to properly qualify it.">
    [metadata key]
	[docReference ICMA GMRA namingConvention "Identifier"
		provision "As referenced in GMRA paragraph 3(b) Securities may be identified using identifying numbers such as CUSIP or ISIN"]

    issuerReference Party (0..1) <"The identifier issuer, when specified by reference to a party specified as part of the transaction.">
        [metadata reference]
    issuer string (0..1) <"The identifier issuer, when specified explicitly alongside the identifier value (instead of being specified by reference to a party).">
        [metadata scheme]
    assignedIdentifier AssignedIdentifier (1..*) <"The identifier value. This level of indirection between the issuer and the identifier and its version provides the ability to associate multiple identifiers to one issuer, consistently with the FpML PartyTradeIdentifier.">

    condition IssuerChoice: <"The identifier issuer is specified either explicitly or by reference to one of the parties.">
        required choice issuerReference, issuer

type IdentifiedList: <"Attaches an identifier to a collection of objects, when those objects themselves can each be represented by an identifier. One use case is the representation of package transactions, where each component is a separate trade with its own identifier, and those trades are linked together as a package with its own identifier. The data type has been named generically rather than referring to 'packages' as it may have a number of other uses.">
    [metadata key]

    listId Identifier (1..1) <"The identifier for the list. In the case of a package transaction, this would be the package identifier. This attribute is mandatory to allow the list itself to be identified.">
    componentId Identifier (2..*) <"Identifiers for each component of the list. Since the data type is used to link multiple identified objects together, at least 2 components are required in the list. Creating an identified list with only 1 identified component has been deemed unnecessary, because it would just create a redundant identifier.">
    price Price (0..1) <"The price of the package.">

type LocationIdentifier extends Identifier: <"Specifies a location identifier. An issuer and an identifier type can be associated with the actual identifier value as a way to properly qualify it.">

    locationIdentifierType CommodityLocationIdentifierTypeEnum (0..1) <"Specifies the nature of a location identifier.">

    condition IdentifierType: <"The element specifying the nature of a location identifier can only be applied to a single identifier.">
        if locationIdentifierType exists
        then assignedIdentifier count = 1


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-party-enum.rosetta
================================================================================

namespace cdm.base.staticdata.party : <"Basic party concepts: legal entity, natural person, contact details, buyer / payer and all related enums.">
version "${project.version}"

import cdm.mapping.config.*

enum CounterpartyRoleEnum: <"Defines the enumerated values to specify the two counterparties to the transaction.">
    Party1
    Party2

enum EntityTypeEnum: <"The enumerated values to specify the reference entity types corresponding to a list of types defined in the ISDA First to Default documentation.">
    Asian <"Entity Type of Asian.">
    AustralianAndNewZealand <"Entity Type of Australian and New Zealand.">
    EuropeanEmergingMarkets <"Entity Type of European Emerging Markets.">
    Japanese <"Entity Type of Japanese.">
    NorthAmericanHighYield <"Entity Type of North American High Yield.">
    NorthAmericanInsurance <"Entity Type of North American Insurance.">
    NorthAmericanInvestmentGrade <"Entity Type of North American Investment Grade.">
    Singaporean <"Entity Type of Singaporean.">
    WesternEuropean <"Entity Type of Western European.">
    WesternEuropeanInsurance <"Entity Type of Western European Insurance.">

enum PayerReceiverEnum: <"The enumerated values to specify an interest rate stream payer or receiver party.">
    Payer <"The party identified as the stream payer.">
    Receiver <"The party identified as the stream receiver.">

enum AccountTypeEnum: <"The enumeration values to qualify the type of account.">
    AggregateClient <"Aggregate client account, as defined under ESMA MiFIR.">
    Client <"The account contains trading activity or positions that belong to a client of the firm that opened the account.">
    House <"The account contains proprietary trading activity or positions, belonging to the firm that is the owner of the account.">

enum NaturalPersonRoleEnum: <"The enumerated values for the natural person's role.">
    Broker <"The person who arranged with a client to execute the trade.">
    Buyer <"Acquirer of the legal title to the financial instrument.">
    DecisionMaker <"The party or person with legal responsibility for authorization of the execution of the transaction.">
    ExecutionWithinFirm <"Person within the firm who is responsible for execution of the transaction.">
    InvestmentDecisionMaker <"Person who is responsible for making the investment decision.">
    Seller <"Seller of the legal title to the financial instrument.">
    Trader <"The person who executed the trade.">

enum PersonIdentifierTypeEnum: <"The enumeration values associated with person identifier sources.">
    ARNU <"Alien Registration Number, number assigned by a social security agency to identify a non-resident person.">
        [synonym ISO20022 value "ARNU"]
    CCPT <"Passport Number, number assigned by an authority to identify the passport number of a person.">
        [synonym ISO20022 value "CCPT"]
    CUST <"Customer Identification Number, number assigned by an issuer to identify a customer.">
        [synonym ISO20022 value "CUST"]
    DRLC <"Drivers License Number, number assigned by an authority to identify a driver's license.">
        [synonym ISO20022 value "DRLC"]
    EMPL <"Employee Identification Number, number assigned by a registration authority to an employee.">
        [synonym ISO20022 value "EMPL"]
    NIDN <"National Identity Number, number assigned by an authority to identify the national identity number of a person..">
        [synonym ISO20022 value "NIDN"]
    SOSE <"Social Security Number, number assigned by an authority to identify the social security number of a person.">
        [synonym ISO20022 value "SOSE"]
    TXID <"Tax Identification Number, number assigned by a tax authority to identify a person.">
        [synonym ISO20022 value "TXID"]
    NPID <"Natural Person Identifier. To identify the person who is acting as private individual, not as business entity. Used for regulatory reporting.">
    PLID <"Privacy Law Identifier. It refers to the DMO Letter No. 17-16, http://www.cftc.gov/idc/groups/public/@lrlettergeneral/documents/letter/17-16.pdf">

enum PartyIdentifierTypeEnum: <"The enumeration values associated with party identifier sources.">
    BIC <"The Bank Identifier Code.">
    LEI <"The ISO 17442:2012 Legal Entity Identifier.">
    MIC <"The ISO 10383 Market Identifier Code (MIC).">

enum PartyRoleEnum: <"The enumerated values for the party role. The enumerated values go beyond the FpML partyRoleScheme as they also include elements that are part of the FpML Trade, such as the Barrier Determination Agent and the Hedging Party.">
    Accountant <"Organization responsible for preparing the accounting for the trade.">
    AgentLender <"An agent who lends securities of its principals under stock lending arrangements.">
    AllocationAgent <"The organization responsible for supplying the allocations for a trade to be allocated to multiple accounts/organizations.">
    ArrangingBroker <"The organization that arranged the trade, i.e. brought together the counterparties.  Synonyms/Alternatives: Inter-dealer broker, agent.">
    BarrierDeterminationAgent <"The party specified in the related confirmation as Barrier Determination Agent.">
    BeneficialOwner <"The party that lends out securities under stock lending arrangements via an Agent Lender.">
    Beneficiary <"Organization that suffers the economic benefit of the trade.  The beneficiary may be distinct from the principal/counterparty - an example occurs when a hedge fund trades via a prime broker; in this case the principal is the prime broker, but the beneficiary is the hedge fund.  This can be represented as a payer/receiver account in the name of the hedge fund, but it is also possible to add the party role of 'Beneficiary' at the partyTradeInformation level.">
    BookingParty <"The entity for which the organization supporting the trade's processing has booked/recorded the trade. This is used in non-reporting workflows situations in which the trade doesn\'t need to be reported but a firm still wants to specify their own side.">
    Borrower <"The party that borrows securities under stock lending arrangements.">
    Buyer <"Acquirer of the legal title to the financial instrument. In the case of an option, the buyer is the holder of the option. In the case of a swap or forward, the buyer will be determined by industry best practice.  This does not refer to an investor or investment manager or other organization on what is typically called  the 'Buy side'; for that, see the 'Client' role. Corresponds to 'Buyer' as defined in certain regulations such as ESMA MiFID II/MIFIR RTS 22 field 9.">
    BuyerDecisionMaker <"The party or person who, having legal authority to act on behalf of the trade counterparty acting as Buyer as defined in this coding scheme, made the decision to acquire the financial instrument. Corresponds to 'buyer decision maker' as defined in ESMA\'s MIFIR RTS 23 report. This does not refer to the decision maker for what is traditionally called the 'Buy side'; for that, see the 'Client Decision Maker' role.">
    Chargor <"The party that provides credit support under English Law.">
    ClearingClient <"An organization that clears trades through a clearing house, via a clearing broker (member of the clearing house) who acts as an agent on its behalf. The term 'client' refers to the organization\'s role in the clearing process in relation to its clearing broker, and not whether it is a price maker or taker in the execution process.">
    ClearingExceptionParty <"A party to the trade that claims a clearing exception, such as an end-user exception under Dodd-Frank Act provisions.">
    ClearingFirm <"Organization that submits the trade to a clearing house on behalf of the principal. Synonyms/alternates: Futures Commission Merchant (FCM), Clearing Broker, Clearing Member Firm. Some implementations use 'Clearing Broker' as synonym.">
    ClearingOrganization <"The organization that acts as a central counterparty to clear a derivatives contract.  This is used to represent the role of Central Counterparties (CCPs) or Derivative Clearing Organizations (DCOs).  Sometimes called 'ClearingService'. Some implementations also use the term 'Clearer'.">
    Client <"Client as defined under ESMA MIFIR. This is generally the investor or other client of an investment firm, and is synonymous with the Beneficiary in many circumstances.">
    ClientDecisionMaker <"The party or person who, having legal authority to act on behalf of a trade counterparty, made the decision to acquire or sell the financial instrument.">
    ConfirmationPlatform <"Organization serving as a financial intermediary for the purposes of electronic confirmation or providing services for post-processing of transactional data.">
    ContractualParty <"A party to a contractual document.  If the intended usage relates to the context of the trade lifecycle, more specific annotations have been defined which might be more appropriate.">
    CounterPartyAffiliate <"Organization officially attached to the counterparty. e.g. partner, branch, subsidiary.">
    CounterPartyUltimateParent <"The topmost entity or organization, within the corporate hierarchy, responsible for the reporting party.">
    Counterparty <"An economic counterparty to the trade. Synonym: principal.">
    CreditSupportProvider <"Organization that enhances the credit of another organization (similar to guarantor, but may not fully guarantee the obligation).">
    Custodian <"Organization that maintains custody of the asset represented by the trade on behalf of the owner/principal.">
    DataSubmitter <"Entity submitting the transaction report to the competent authority.">
    DeterminingParty <"The party referenced is specified in the contract confirmation as Determination Party.">
    DisputingParty <"Organization that is disputing the trade or transaction.">
    DocumentRepository <"A marketplace organization which purpose is to maintain document records.  If the intended usage relates to the context of the trade lifecycle, more specific annotations have been defined which might be more appropriate.">
    ExecutingBroker <"The (generally sell-side) organization that executed the trade; the price-making party.">
    ExecutingEntity <"Entity executing the transaction.  If the transaction is executed directly by the reporting party, it will be the reporting party.  If it is executed by an execution agent or an affiliated party on behalf of the reporting party, it will be that affiliate or agent.">
    ExecutionAgent <"The (generally buy-side) organization that acts to execute trades on behalf of an investor. Typically this is an investment manager or asset manager, and also makes the investment decisions for the investor. If required, a separate InvestmentDecision role can be specified to distinguish that the party making the investment decision is different.">
    ExecutionFacility <"The facility, exchange, or market where the trade was executed. Synonym: Swap Execution Facility, Designated Contract Market, Execution Venue.">
    Guarantor <"Organization that backs (guarantees) the credit risk of the trade.">
    HedgingParty <"The ISDA Hedging Party that is specified in the related confirmation as Hedging, or if no Hedging Party is specified, either party to the contract.">
    Lender <"The party that lends out securities under stock lending arrangements as principal.">
    OrderTransmitter <"The entity transmitting the order to the reporting firm. Synonym: Transmitting Firm.">
    Pledgor <"The party that provides credit support under New York Law.">
    PrimeBroker <"The organization that takes on or took on the credit risk for this trade by stepping in between the two economic parties (without a central counterparty clearing mechanism).">
    PriorTradeRepository <"The trade repository at which the trade was reported previous to the current trade repository.">
    PTRRServiceProvider <"The party that acts as either a portfolio compression or portfolio rebalancing service provider, as defined under ESMA MIFIR">
    PublicationVenue <"The reporting service (whether trade repository, market data service, or exchange/facility/venue data distribution service) that published the report of this trade.">
    ReportingParty <"The party with the regulatory responsibility to report this trade.">
    ReportingPartyAffiliate <"Organization officially attached to the reporting party  e.g. partner, branch, subsidiary.">
    ReportingPartyUltimateParent <"The topmost entity or organization, within the corporate hierarchy, responsible for the reporting party.">
    Seller <"A counterparty in a trade, which performs in one of the following capacities: 1) it transfers or agrees to transfer in the future an instrument or title to that instrument in exchange for payment, 2) it writes a derivatives instrument such as an option or a swap in which it provides risk protection to the buyer. This does not refer to the broker/dealer or other organization on what is typically called  the 'Sell side'; for that, see the 'Executing Broker' role. Corresponds to 'Seller' as defined in certain regulations such as ESMA MiFID II/MIFIR RTS 22 field 16.">
    SellerDecisionMaker <"The party or person who, having legal authority to act on behalf of the trade counterparty acting as Seller as defined in this coding scheme, made the decision to sell the financial instrument. Corresponds to 'seller decision maker' as defined in ESMA\'s MIFIR RTS 23 report. This does not refer to the decision maker for what is traditionally called the 'Sell side'; for that, see the 'Trader' person role.">
    SecuredParty <"The party that receives credit support under New York or English Law.">
    SettlementAgent <"The organization that makes or receives payments on behalf of the given principal party.">
    TradeRepository <"An organization that maintains records of the trade for regulatory reporting purposes.">
    TradeSource <"The organization that originally supplied the record of the trade. In the context of regulatory reporting, it is the submitter of the trade record to a regulator or TR.">
    TradingManager <"The entity responsible for managing the assets/investments of this party.  Synonym:  Asset Manager, Investment Manager, Trading Advisory.">
    TradingPartner <"An entity with which this party trades from time to time, ie. with which it acts as a counterparty on some transactions.   This role is used for static reference data, not individual transactions.">
    TripartyAgent <"A third party entity that acts as an intermediary and provides automated clearing, settlement, allocation, valuation and reporting services.">
    ThirdPartyCustodian <"A third-party providing custody, settlement, segregation and reporting services.">

enum AncillaryRoleEnum: <"Defines the enumerated values to specify the ancillary roles to the transaction. The product is agnostic to the actual parties involved in the transaction, with the party references abstracted away from the product definition and replaced by the AncillaryRoleEnum. The AncillaryRoleEnum can then be positioned in the product and the AncillaryParty type, which is positioned outside of the product definition, allows the AncillaryRoleEnum to be associated with an actual party reference.">
    DisruptionEventsDeterminingParty <"Specifies the party which determines additional disruption events.">
    ExtraordinaryDividendsParty <"Specifies the party which determines if dividends are extraordinary in relation to normal levels.">
    PredeterminedClearingOrganizationParty <"Specifies the clearing organization (CCP, DCO) which the trade should be cleared.">
    ExerciseNoticeReceiverPartyManual <"Specifies the party to which notice of a manual exercise should be given.">
    ExerciseNoticeReceiverPartyOptionalEarlyTermination <"Specifies the party to which notice of a optional early termination exercise should be given.">
    ExerciseNoticeReceiverPartyCancelableProvision <"Specifies the party to which notice of a cancelable provision exercise should be given.">
    ExerciseNoticeReceiverPartyExtendibleProvision <"Specifies the party to which notice of a extendible provision exercise should be given.">
    CalculationAgentIndependent <"Specifies the party responsible for performing calculation agent duties as defined in the applicable product definition.">
    CalculationAgentOptionalEarlyTermination <"Specifies the party responsible for performing calculation agent duties associated with an optional early termination.">
    CalculationAgentMandatoryEarlyTermination <"Specifies the party responsible for performing calculation agent duties associated with an mandatory early termination.">
    CalculationAgentFallback <"Specifies the party responsible for deciding the fallback rate.">

enum TelephoneTypeEnum: <"The enumerated values to specify the type of telephone number, e.g. work vs. mobile.">
    Work <"A number used primarily for work-related calls. Includes home office numbers used primarily for work purposes.">
    Mobile <"A number on a mobile telephone that is often or usually used for work-related calls. This type of number can be used for urgent work related business when a work number is not sufficient to contact the person or firm.">
    Fax <"A number used primarily for work-related facsimile transmissions.">
    Personal <"A number used primarily for non work-related calls. (Normally this type of number would be used only as an emergency backup number, not as a regular course of business).">


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-party-func.rosetta
================================================================================

namespace cdm.base.staticdata.party : <"Basic party concepts: legal entity, natural person, contact details, buyer / payer and all related enums.">
version "${project.version}"

func ExtractCounterpartyByRole: <"Extracts from a list of Counterparty data types, the Counterparty that corresponds to the role i.e. Party1 or Party2.">
    inputs:
        counterparties Counterparty (1..*) <"The list of counterparties to filter.">
        roleEnumToExtract CounterpartyRoleEnum (1..1) <"The counterparty role enum to filter by.">
    output:
        counterparty Counterparty (0..1) <"The counterparty with specified counterparty role.">

    set counterparty:
        counterparties
            filter role = roleEnumToExtract
            then only-element

func ExtractAncillaryPartyByRole: <"Extracts from a list of AncillaryParty data types, the AncillaryParty that corresponds to the AncillaryRoleEnum.">
    inputs:
        ancillaryParties AncillaryParty (1..*) <"The list of ancillary parties to filter.">
        roleEnumToExtract AncillaryRoleEnum (1..1) <"The ancillary role enum to filter by.">
    output:
        ancillaryParty AncillaryParty (0..1) <"The ancillary party with specified ancillary role.">

    set ancillaryParty:
        ancillaryParties
            filter role = roleEnumToExtract
            then only-element

func ReplaceParty: <"Removes the old party, and adds the new party.">
    inputs:
        parties Party (0..*) <"Specifies the list of parties to update.">
        oldParty Party (1..1) <"Specifies the party to be removed.">
        newParty Party (1..1) <"Specifies the party to be added.">
    output:
        updatedParties Party (0..*) <"The updated list of parties.">

    add updatedParties:
        parties
            extract (if item = oldParty then newParty else item)
            then distinct

func FilterPartyRole: <"Filters the list of partyRoles based on the provided partyRoleEnum.">
    inputs:
        partyRoles PartyRole (0..*)
        partyRoleEnum PartyRoleEnum (1..1)
    output:
        filteredPartyRoles PartyRole (0..*)

    add filteredPartyRoles: partyRoles filter role = partyRoleEnum

func FilterRelatedPartyByRole: <"Filters the list of RelatedParty based on the provided partyRoleEnum.">
    inputs:
        relatedParties RelatedParty (0..*)
        partyRoleEnum PartyRoleEnum (1..1)
    output:
        filteredRelatedParties RelatedParty (0..*)

    add filteredRelatedParties: relatedParties filter role = partyRoleEnum


================================================================================
FILE: rosetta-source/src/main/rosetta/base-staticdata-party-type.rosetta
================================================================================

namespace cdm.base.staticdata.party : <"Basic party concepts: legal entity, natural person, contact details, buyer / payer and all related enums.">
version "${project.version}"

import cdm.base.*
import cdm.base.staticdata.identifier.*

type Counterparty: <"Defines a counterparty enumerated value, e.g. Party1 or Party2, with an associated party reference. The product is agnostic to the actual parties to the transaction, with the party references abstracted away from the product definition and replaced by the CounterpartyEnum (e.g. values Party1 or Party2). The CounterpartyEnum can then be positioned in the product (e.g. to specify which counterparty is the payer, receiver etc) and this Counterparty type, which is positioned outside of the product definition, allows the CounterpartyEnum to be associated with an actual party reference.">

    role CounterpartyRoleEnum (1..1) <"Specifies the CounterpartyEnum, e.g. either Party1 or Party2, that is associated to the partyReference.">
    partyReference Party (1..1) <"Specifies the party that is associated to the counterparty.">
        [metadata reference]

type AncillaryParty: <"Defines an ancillary role enumerated value with an associated party reference. The product is agnostic to the actual parties involved in the transaction, with the party references abstracted away from the product definition and replaced by the AncillaryRoleEnum. The AncillaryRoleEnum can then be positioned in the product and this AncillaryParty type, which is positioned outside of the product definition, allows the AncillaryRoleEnum to be associated with an actual party reference.">

    role AncillaryRoleEnum (1..1) <"Specifies the AncillaryRoleEnum that is associated to the party reference. An ancillary party is any involved party that is not one of the two principal parties to the transaction.">
    partyReference Party (1..*) <"Specifies the party, or parties, associated to the ancillary role.">
        [metadata reference]
    onBehalfOf CounterpartyRoleEnum (0..1) <"Optionally specifies the counterparty that the ancillary party is acting on behalf of.">

type BuyerSeller: <"This class corresponds to the FpML BuyerSeller.model construct.">

    buyer CounterpartyRoleEnum (1..1) <"Buyer party that can be resolved as one of the two principal parties to the transaction. The party that buys this instrument, i.e. pays for this instrument and receives the rights defined by it. ISDA 2002 Equity Definitions section 1.18: `Buyer` means the party specified as such in the related Confirmation. | ISDA 2006 Definitions article 12.1 (b)(i) relating to a Swaption: 'Buyer' means the party that will, on each Premium Payment Date, pay to Seller the Premium | ISDA 2006 Definitions article 12.1 (b)(ii) relating to Swap Transactions with applicable Early Termination: the party specified as such in the related Confirmation, or the Exercising Party if neither party is specified | ISDA 2006 Definitions article 12.1 (b)(iii) relating to any other Option Transaction: the party specified as such in the related Confirmation. | ISDA 2014 Credit Definition article 1.4: `Buyer` means the Fixed Rate Payer.">
    seller CounterpartyRoleEnum (1..1) <"Seller party that can be resolved as one of the two principal parties to the transaction. The party that sells ('writes') this instrument, i.e. that grants the rights defined by this instrument and in return receives a payment for it. ISDA 2002 Equity Definitions section 1.19: `Seller` means the party specified as such in the related Confirmation. | ISDA 2006 Definitions article 12.1 (a)(i) relating to a Swaption: 'Seller' means the party the party specified as such or as writer in the related Confirmation | ISDA 2006 Definitions article 12.1 (a)(ii) relating to Swap Transactions with applicable Early Termination: the party specified as such or as writer in the related Confirmation or, if neither party is specified as such, the Non-exercising Party | ISDA 2006 Definitions article 12.1 (a)(iii) relating to any other Option Transaction: the party specified as such in the related Confirmation. | ISDA 2014 Credit Definition article 1.4: `Seller` means the Floating Rate Payer.">

type PayerReceiver: <"Specifies the parties responsible for making and receiving payments defined by this structure.">

    payer CounterpartyRoleEnum (1..1) <"Specifies the counterparty responsible for making the payments defined by this structure.  The party is one of the two principal parties to the transaction.">
        [docReference ICMA GMRA namingConvention "Seller"
            provision "As defined in the GMRA, paragraph 1(a). The Seller transfers Securities in exchange for the Purchase Price on the Purchase Date and agrees to buy Equivalent Securities from the Buyer in exchange for the Repurchase Price on the Repurchase Date."]
        [docReference ICMA ERCCBestPractice namingConvention "Seller"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The party to a repo who sells collateral for cash in the form of the Purchase Price on the Purchase Date and commits to buy back the same quantity of equivalent collateral on the Repurchase Date --- which will be a fixed maturity date or, in the case of open repo, on demand --- at an agreed or calculable Repurchase Price. The Seller is effectively borrowing cash. Cf Buyer."]
    receiver CounterpartyRoleEnum (1..1) <"Specifies the party that receives the payments corresponding to this structure.  The party is one of the two counterparties to the transaction.">
        [docReference ICMA GMRA namingConvention "Buyer"
            provision "As defined in the GMRA, paragraph 1(a). The Buyer purchases Securities at the Purchase Price on the Purchase Date and agrees to sell Equivalent Securities to the Seller in exchange for the Repurchase Price on the Repurchase Date."]
        [docReference ICMA ERCCBestPractice namingConvention "Buyer"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The party to a repo who buys collateral at the Purchase Price on the Purchase Date and commits to sell back the same quantity of equivalent collateral on the Repurchase Date --- which will be a fixed maturity date or, in the case of open repo, on demand --- at an agreed or calculable Repurchase Price. The Buyer is effectively a lender of cash and is said to be doing a reverse repo."]

type PartyReferencePayerReceiver: <"Specifies the parties responsible for making and receiving payments defined by this structure.">

    payerPartyReference Party (1..1) <"The party responsible for making the payments defined by this structure.">
        [metadata reference]
    payerAccountReference Account (0..1) <"A reference to the account responsible for making the payments defined by this structure.">
        [metadata reference]
    receiverPartyReference Party (1..1) <"The party that receives the payments corresponding to this structure.">
        [metadata reference]
    receiverAccountReference Account (0..1) <"A reference to the account that receives the payments corresponding to this structure.">
        [metadata reference]

type ReferenceBank: <"A class to describe an institution (party) identified by means of a coding scheme and an optional name.">

    referenceBankId string (1..1) <"An institution (party) identifier, e.g. a bank identifier code (BIC). FpML specifies a referenceBankIdScheme.">
        [metadata scheme]
    referenceBankName string (0..1) <"The name of the institution (party). A free format string. FpML does not define usage rules for the element.">

type ReferenceBanks: <"A class defining the list of reference institutions polled for relevant rates or prices when determining the cash settlement amount for a product where cash settlement is applicable.">
    referenceBank ReferenceBank (1..*) <"An institution (party) identified by means of a coding scheme and an optional name.">

type RelatedParty:

    partyReference Party (1..1) <"Reference to a party.">
        [metadata reference]
    accountReference Account (0..1) <"Reference to an account.">
        [metadata reference]
    role PartyRoleEnum (1..1) <"The category of the relationship. The related party performs the role specified in this field for the base party. For example, if the role is ,Guarantor, the related party acts as a guarantor for the base party.">

type Account: <"A class to specify an account as an account number alongside, optionally. an account name, an account type, an account beneficiary and a servicing party.">
    [metadata key]

    partyReference Party (0..1) <"A reference to the party to which the account refers to.">
        [metadata reference]
    accountNumber string (1..1) <"The account number.">
        [metadata scheme]
    accountName string (0..1) <"The name by which the account is known.">
        [metadata scheme]
    accountType AccountTypeEnum (0..1) <"The type of account, e.g. client, house.">
        [metadata scheme]
    accountBeneficiary Party (0..1) <"A reference to the party beneficiary of the account.">
        [metadata reference]
    servicingParty Party (0..1) <"The reference to the legal entity that services the account, i.e. in the books of which the account is held.">
        [metadata reference]

type Address: <"A class to specify a post or street address.">

    street string (1..*) <"The set of street and building number information that identifies a postal address within a city.">
    city string (0..1) <"The city component of the postal address.">
    state string (0..1) <"A country subdivision used in postal addresses in some countries. For example, US states, Canadian provinces, Swiss cantons, ...">
    country string (0..1) <"The ISO 3166 standard code for the country within which the postal address is located.">
        [metadata scheme]
    postalCode string (0..1) <"The code, required for computerized mail sorting systems, that is allocated to a physical address by a national postal authority.">

type BusinessUnit: <"A class to specify an organizational unit.">
    [metadata key]

    name string (1..1) <"A name used to describe the organizational unit">
    identifier Identifier (0..1) <"An identifier used to uniquely identify the organizational unit">
    contactInformation ContactInformation (0..1) <"The contact information for such business unit, when different from the contact information associated with the party.">

type ContactInformation: <"A class to specify contact information associated with a party: telephone, postal/street address, email and web page.">

    telephone TelephoneNumber (0..*) <"The telephone number.">
    address Address (0..*) <"The street/postal address.">
    email string (0..*) <"The email address.">
    webPage string (0..*) <"The web page. This attribute is not specified as part of the FpML ContactInformation complex type.">

type LegalEntity: <"A class to specify a legal entity, with a required name and an optional entity identifier (such as the LEI).">
    [metadata key]

    entityId string (0..*) <"A legal entity identifier (e.g. RED entity code).">
        [metadata scheme]
    name string (1..1) <"The legal entity name.">
        [metadata scheme]

type NaturalPerson: <"A class to represent the attributes that are specific to a natural person.">
    [metadata key]

    personId PersonIdentifier (0..*) <"The identifier associated with a person, e.g. the internal identification code.">
        [metadata scheme]
    honorific string (0..1) <"An honorific title, such as Mr., Ms., Dr. etc.">
    firstName string (0..1) <"The natural person's first name. It is optional in FpML.">
    middleName string (0..*) <"The natural person's middle name(s). If a middle name is provided then an initial should be absent.">
    initial string (0..*) <"The natural person's middle initial(s). If a middle initial is provided then a name should be absent.">
    surname string (0..1) <"The natural person's surname.">
    suffix string (0..1) <"Name suffix, such as Jr., III, etc.">
    dateOfBirth date (0..1) <"The natural person's date of birth.">
    contactInformation ContactInformation (0..1) <"The contact information for such person, when different from the contact information associated with the party.">

    condition NameOrIdChoice:
        (firstName exists and surname exists) or personId exists

    condition NaturalPersonChoice: <"Choice rule to represent an FpML choice construct.">
        optional choice middleName, initial

type NaturalPersonRole: <"A class to specify the role(s) that natural person(s) may have in relation to the contract.">

    personReference NaturalPerson (1..1) <"A reference to the natural person to whom the role refers to.">
        [metadata reference]
    role NaturalPersonRoleEnum (0..*) <"FpML specifies a person role that is distinct from the party role.">
        [metadata scheme]

type Party: <"A class to specify a party, without a qualification as to whether this party is a legal entity or a natural person, although the model provides the ability to associate a person (or set of persons) to a party, which use case would imply that such party would be a legal entity (even if not formally specified as such). ">
    [metadata key]

    partyId PartyIdentifier (1..*) <"The identifier associated with a party, e.g. the 20 digits LEI code.">
    name string (0..1) <"The party name.">
        [metadata scheme]
    businessUnit BusinessUnit (0..*) <"Optional organization unit information used to describe the organization units (e.g. trading desks) involved in a transaction or business process, incl. the contact information (when relevant).">
    person NaturalPerson (0..*) <"The person(s) who might be associated with the party as part of the execution, contract or legal document.">
    personRole NaturalPersonRole (0..*) <"The role of the person(s) ">
    account Account (0..1) <"The account that might be associated with the party. At most one account can be specified, as it is expected that this information is used in the context of a contract or legal document where only one account per party can be associated with such object.">
    contactInformation ContactInformation (0..1) <"The postal/street address, telephone number, email address and/or web page. If the contact information is specific to the associated business unit(s) or person (s), it should be associated with those.">

type PartyIdentifier: <"Comprises an identifier and a source. The associated metadata key denotes the ability to associate a hash value to the PartyIdentifier instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    [metadata key]
    identifier string (1..1) <"Provides an identifier associated with a party. The identifier is unique within the public source specified in the source attribute.">
        [metadata scheme]
    identifierType PartyIdentifierTypeEnum (0..1) <"Defines the source of the identifier.">

type PersonIdentifier: <"Comprises an identifier and a source. The associated metadata key denotes the ability to associate a hash value to the PersonIdentifier instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    [metadata key]
    identifier string (1..1) <"Provides an identifier associated with a person. The identifier is unique within the public source specified in the source attribute.">
        [metadata scheme]
    identifierType PersonIdentifierTypeEnum (0..1) <"Defines the source of the identifier.">
    country string (0..1) <"The ISO 3166 standard code for the country issuing the identifier.">
        [metadata scheme]

type PartyContactInformation: <"A class to specify contact information within a party: address and, optionally, associated business unit and person. This class also supports the ISDA CSA representation as a single string, through the address attribute.">

    partyReference Party (0..1) <"The reference to the party to which the contact information refers to.">
        [metadata reference]
    contactInformation ContactInformation (0..1) <"The postal/street address, telephone number, email address and/or web page. If the contact information is specific to the associated business unit(s), it should be associated with those.">
    businessUnit BusinessUnit (0..*) <"Optional organization unit information used to describe the organization units (e.g. trading desks) involved in a transaction or business process, incl. the contact information (when relevant).">
    person NaturalPerson (0..*) <"Optional information about people involved in a transaction or business process. (These are employees of the party.)">
    additionalInformation string (0..1) <"Specification of special instructions of the relevant party.">

type PartyRole: <"A class to specify the role(s) that party(ies) may have in relation to the execution, contract or other legal agreement.">

    partyReference Party (1..1) <"A reference to the party to which the role refers to.">
        [metadata reference]
    role PartyRoleEnum (1..1) <"The party role.">
    ownershipPartyReference Party (0..1) <"A reference to the party that has ownership of this party role information. FpML specifies that For shared trade information, this attribute will reference the originator of the data (for example, an execution facility or clearing house).">
        [metadata reference]

type TelephoneNumber: <"A class to specify a telephone number as a type of phone number (e.g. work, personal, ...) alongside with the actual number.">

    telephoneNumberType TelephoneTypeEnum (0..1) <"The type of telephone number, e.g. work, mobile.">
    number string (1..1) <"The actual telephone number.">

type AncillaryEntity: <"Holds an identifier for an ancillary entity, either identified directly via its ancillary role or directly as a legal entity.">

    ancillaryParty AncillaryRoleEnum (0..1) <"Identifies a party via its ancillary role on a transaction (e.g. CCP or DCO through which the trade should be cleared.)">
    legalEntity LegalEntity (0..1)

    condition:
        one-of


================================================================================
FILE: rosetta-source/src/main/rosetta/event-common-enum.rosetta
================================================================================

namespace cdm.event.common : <"Business event concepts: primitives, contract state and associated state transition function specifications.">
version "${project.version}"

import cdm.base.*

enum ConfirmationStatusEnum: <"Enumeration for the different types of confirmation status.">
    Confirmed
    Unconfirmed

enum AffirmationStatusEnum: <"Enumeration for the different types of affirmation status.">
    Affirmed
    Unaffirmed

enum ExecutionTypeEnum: <"The enumerated values to specify how a contract has been executed, e.g. electronically, verbally, ...">
    Electronic <"Execution via electronic execution facility, derivatives contract market, or other electronic message such as an instant message.">
    OffFacility <"Bilateral execution between counterparties not pursuant to the rules of a SEF or DCM.">
    OnVenue <"Execution via a platform that may or may not be covered by a regulatory defintion. OnVenue is intended to distinguish trades executed on a trading platform from those executed via phone, email or messaging apps. The role and details of the venue are included in the party attribute of the trade. The general rule is that if the parties utilitzed the services of the platform to execute the trade then it would be considered OnVenue.">

enum ActionEnum: <"The enumeration values to specify the actions associated with transactions.">
    New <"A new instance of a transaction event, which is also characterized by the fact that the eventIdentifier has an associated version 1.">
    Correct <"A correction of a prior instance of the transaction event. The eventIdentifier has an associated version greater than 1.">
    Cancel <"A cancellation of a prior instance of the transaction event. The eventIdentifier has an associated version greater than 1.">

enum AssetTransferTypeEnum: <"The qualification of the type of asset transfer.">
    FreeOfPayment <"The transfer of assets takes place without a corresponding exchange of payment.">

enum EventIntentEnum: <"The enumeration values to qualify the intent associated with a transaction event.">
    Allocation <"The intent is to allocate one or more trades as part of an allocated block trade.">
    CashFlow <"The intent is to designate a stand-alone cash transfer as a result of Trade contracual terms e.g. incurred by payout for instance a Performance Amount or a Floating Rate Amount. The particular CashFlow at stake shall be further specified in priceTransferEnum or transferTypeEnum. For clarity, such intentEnum value shall not be used whenever a cash transfer is not stand-alone but is instead embedded in another Event as part of the composable modelling e.g. Decrease with Fees, Cross-Currency Notional Reset, etc. or any other Event whenever including a cash transfer with other features. For clarity, a principal payment related to a Principal Exhange is excluded as well, because a dedicated intentEnum value exists for this event i.e. PrincipalExchange value.">
    Clearing <"The intent is to clear the contract.">
    Compression <"The intent is to compress multiple trades as part of a netting or compression event.">
    ContractFormation <"The intent is to form a contract from an execution.">
    ContractTermsAmendment <"The intent is to amend the terms of the contract through renegotiation.">
    CorporateActionAdjustment <"The intent is to take into effect the occurrence of a Corporate Action and the particular Corporate Action at stake shall be further specified in CorporateActionTypeEnum.">
    CreditEvent <"The intent is to take into effect the occurrence of a Credit Event.">
    Decrease <"The intent is to Decrease the quantity or notional of the contract.">
    EarlyTerminationProvision <"The intent is to fully unwind the Trade, as a result of the application of Trade contractual terms (e.g. an obligation to do so before Termination Date as part of any kind of Early Termination terms) as defined within the CDM EarlyTerminationProvision data type. Accordingly, increase and decrease of positions which result from negotiation by the parties shall not be designated by such intentEnum. For clarity, partial exercise of an option before its expiration date is excluded as well, though related to Trade contract terms, because a dedicated intentEnum value exists for this event i.e. OptionExercise value.">
    Increase <"The intent is to Increase the quantity or notional of the contract.">
    IndexTransition <"The intent is to replace an interest rate index by another one during the life of a trade and add a transition spread on top of this index (and on top of the spreads already defined in the trade, if any). ">
    NotionalReset <"The intent is to increase or to decrease the notional of the Trade, in accordance with Notional Reset features e.g. could apply for Cross Currency Swaps, Equity Performance Swaps, etc.">
    NotionalStep <"The intent is to increase or to decrease the notional of the Trade, in accordance with Step features attached to a Payout Quantity.">
    Novation <"The intent is to novate the contract.">
    ObservationRecord <"The intent is to record any kind of stand-alone obervervations e.g. internal data recording, usage of CDM for recording and/or exchanging data as part of pricing 'consensus' processing, etc. For clarity, such intentEnum value shall not be used whenever an observation is not stand-alone but is instead embedded in another Event as part of the composable modelling e.g. CashFlow to which an observation of prices is associated, etc.">
    OptionExercise <"The intent is to Exercise a contract that is made of one or several option payout legs. For clarity, such intentEnum value shall not be used whenever an optional right is exercised in relation with a Trade which composition includes other types of payout legs e.g. right to call or to cancel before Termination Date as part of any kind of Early Termination terms other than genuine bermuda or american style features described in option payout. ">
    OptionalExtension <"The intent is to extend the trade through exercise of an optional right as defined within the CDM OptionProvision data type.">
    OptionalCancellation <"The intent is to cancel the trade through exercise of an optional right as defined within the CDM OptionProvision data type.">
    PortfolioRebalancing <"The intent is to rebalance a portfolio, by inserting new derivatives transactions into portfolios of participants to reduce risks linked to those trades. These are offsetting trades that rebalance relationships between different counterparties when it comes to exposure of portfolios to certain types of risk, such as interest rate risk.">
    PrincipalExchange <"The intent is to pay or to receive a cash transfer, in accordance with Principal Exchange features.">
    Reallocation <"The intent is to reallocate one or more trades as part of an allocated block trade.">
    Repurchase <"The intent is to close a repo transaction through repurchase.">

enum PositionEventIntentEnum:
    PositionCreation <"The intent is to form a position from a fully formed contract.">
    CorporateActionAdjustment <"The intent is to take into effect the occurrence of a Corporate Action and the particular Corporate Action at stake shall be further specified in CorporateActionTypeEnum.">
    Decrease <"The intent is to Decrease the quantity of the position.">
    Increase <"The intent is to Increase the quantity of the position.">
    Transfer <"The intent is to transfer the position to another clearing member.">
    OptionExercise <"The intent is to Exercise a position or part of a position.">
    Valuation <"The intent is to update the valuation of the position.">

enum RecordAmountTypeEnum: <"The enumeration of the account level for the billing summary.">
    AccountTotal
    GrandTotal
    ParentTotal

enum TransferStatusEnum: <"The enumeration values to specify the transfer status.">
    Disputed <"The transfer is disputed.">
    Instructed <"The transfer has been instructed.">
    Pending <"The transfer is pending instruction.">
    Settled <"The transfer has been settled.">
    Netted <"The transfer has been netted into a separate Transfer.">

enum InstructionFunctionEnum: <"The enumeration values indicating the BusinessEvent function associated input instructions.">
    Execution
    ContractFormation
    QuantityChange
    Renegotiation
    Compression

enum CallTypeEnum: <"Represents the enumeration values that indicate the intended status of message type, such as expected call, notification of a call or a margin call.">
    MarginCall <"Identifies an actionable Margin Call.">
    Notification <"Identifies a notification of a Margin Call for legal obligation to notify other party to initiate a margin call when notifying party is calculation or valuation agent.">
    ExpectedCall <"Identifies an expected Margin Call instruction for either party to notify the other or their service provider of an expected margin call movement.">

enum MarginCallActionEnum: <"Represents the enumeration values to identify the collateral action instruction.">
    Delivery <"Indicates an instruction of a new collateral asset delivery.">
    Return <"Indicates an instruction for a return of a principals collateral asset delivery.">

enum CollateralStatusEnum: <"Represents the enumeration list to identify the settlement status of the collateral.">
    FullAmount <"Indicates the collateral balance amount in full, inclusive of any pre-agreed collateral positions in transit for settlement.">
    SettledAmount <"Indicates the collateral is settled and not an in transit pre-agreed collateral amount/s.">
    InTransitAmount <"Indicates collateral amount in transit settlement cycle only, excluding settled collateral amount/s.">

enum MarginCallResponseTypeEnum: <"Represents the enumeration values to define the response type to a margin call.">
    AgreeinFull <"Specifies a 'Full Agreement' to Margin Call.">
    PartiallyAgree <"Specifies a 'Partial agreement' to Margin Call.">
    Dispute <"Specifies a 'Full Dispute' to a Margin call.">

enum RegMarginTypeEnum: <"Represents the enumeration values to specify the margin type in relation to bilateral or regulatory obligation.">
    VM <"Indicates Variation Margin">
    RegIM <"Indicates Regulatory Initial Margin">
    NonRegIM <"Indicates Non Regulatory Initial margin or independent amount">

enum RegIMRoleEnum: <"Represents the enumeration values to specify the role of the party in relation to a regulatory initial margin call.">
    Pledgor <"Indicates 'Pledgor' party of initial margin call.">
    Secured <"Indicates 'Secured' party of initial margin call.">

enum HaircutIndicatorEnum: <"Represents the enumeration indicators to specify if an asset or group of assets valuation is based on any valuation treatment haircut.">
    PreHaircut <"Indicates Pre haircut value">
    PostHaircut <"Indicates Post haircut value">

enum PerformanceTransferTypeEnum: <"The enumerated values to specify the origin of a performance transfer">
    Commodity
    Correlation
    Dividend
    Equity
    Interest
    Volatility
    Variance

enum CorporateActionTypeEnum: <"The enumerated values to specify the origin of a corporate action transfer.">
    CashDividend <"Corporate action triggered by the distribution of a cash dividend.">
    StockDividend <"Corporate action triggered by the distribution of a stock dividend.">
    StockSplit <"Corporate action triggered by a stock split. A stock split or stock divide increases the number of shares in a public company. The price is adjusted such that the before and after market capitalization of the company remains the same and dilutiondoes not occur. The value maps closely to the ISO code (SPLF) defined as a distribution of subsidiary stock to the shareholders of the parent company without a surrender of shares.">
    ReverseStockSplit <"Corporate action triggered by a reverse split. A reverse stock split or reverse split is a process by a company of issuing to each shareholder in that company a smaller number of new shares in proportion to that shareholder's original shares that are subsequently canceled. A reverse stock split is also called a stock merge. The reduction in the number of issued shares is accompanied by a proportional increase in the share price. The value maps closely to the ISO code (SPLR) defined as a decrease in a company's number of outstanding equities without any change in the shareholder's equity or the aggregate market value at the time of the split. Equity price and nominal value are increased accordingly.">
    SpinOff <"Corporate action triggered by a spin Off. A spin-out, also known as a spin-off or a starburst, refers to a type of corporate action where a company splits off sections of itself as a separate business. The value maps closely to the ISO code (SOFF) defined as a a distribution of subsidiary stock to the shareholders of the parent company without a surrender of shares. Spin-off represents a form of divestiture usually resulting in an independent company or in an existing company. For example, demerger, distribution, unbundling.">
    Merger <"Corporate action triggered by a merger. Mergers and acquisitions (abbreviated M&A) is an aspect of corporate strategy, corporate finance and management dealing with the buying, selling, dividing and combining of different companies and similar entities that can help an enterprise grow rapidly in its sector or location of origin, or a new field or new location, without creating a subsidiary, other child entity or using a joint venture. The distinction between a merger and an acquisition has become increasingly blurred in various respects (particularly in terms of the ultimate economic outcome), although it has not completely disappeared in all situations. The value maps closely to the ISO code (MRGR) defined as an offer made to shareholders, normally by a third party, requesting them to sell (tender) or exchange their equities.">
    Delisting <"Corporate action triggered by the removal of a security from a stock exchange.">
    StockNameChange <"Corporate action triggered by a change in the name used to trade the security.">
    StockIdentifierChange <"Corporate action triggered by a change in the code used to trade the security.">
    RightsIssue <"Corporate action triggered by an issuance to shareholders of rights to purchase additional shares at a discount.">
    Takeover <"Corporate action triggered by a takeover. A takeover is the purchase of onecompany (the target) by another (the acquirer, or bidder). The value maps to the ISO code (TEND) but is finer grained than TEND which emcompasses Tender/Acquisition/Takeover/Purchase Offer/Buyback. ISO defines the TEND code as an offer made to shareholders, normally by a third party, requesting them to sell (tender) or exchange their equities.">
    StockReclassification <"Corporate action triggered by a Stock Reclassification.">
    BonusIssue <"Corporate action triggered by a bonus issue. A bonus issue or bonus share is a free share of stock given to current shareholders in a company, based upon the number of shares that the shareholder already owns. While the issue of bonus shares increases the total number of shares issued and owned, it does not change the value of the company. The value maps closely to the ISO code (BONU) defined as a bonus, scrip or capitalisation issue. Security holders receive additional assets free of payment from the issuer, in proportion to their holding.">
    ClassAction <"Corporate action triggered by a Class Action. An action where an individual represents a group in a court claim. The judgment from the suit is for all the members of the group (class). The value maps closely to the ISO code (CLSA) defined as the situation where interested parties seek restitution for financial loss. The security holder may be offered the opportunity to join a class action proceeding and would need to respond with an instruction.">
    EarlyRedemption <"Corporate action triggered by an early redemption. The value maps closely to the ISO code (MCAL) defined as the redemption of an entire issue outstanding of securities, for example, bonds, preferred equity, funds, by the issuer or its agent, for example, asset manager, before final maturity.">
    Liquidation <"Corporate action triggered by a liquidation. When a business or firm is terminated or bankrupt, its assets are sold (liquidated) and the proceeds pay creditors. Any leftovers are distributed to shareholders. The value maps closely to the ISO code (LIQU) defined as a distribution of cash, assets or both. Debt may be paid in order of priority based on preferred claims to assets specified by the security.">
    BankruptcyOrInsolvency <"Corporate action triggered by bankruptcy, insolvency filing or insolvency of the issuer of the Security.">
    IssuerNationalization <"Corporate action triggered by the nationalization of the issuer of the Security.">
    Relisting <"Corporate action triggered by the relisting of a security from the original stock exchange to another exchange.">
    BespokeEvent <"Corporate Action which is separately agreed between the parties and/or described elsewhere in the document (for instance in bespoke term described in string type objects present in some root attributes of Agreement type).">

enum CreditEventTypeEnum: <"Represents the enumerated values to specify a credit event type.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/credit-event-type"]

    Bankruptcy <"The reference entity has been dissolved or has become insolvent. It also covers events that may be a precursor to insolvency such as instigation of bankruptcy or insolvency proceedings. Sovereign trades are not subject to Bankruptcy as 'technically' a Sovereign cannot become bankrupt. ISDA 2003 Term: Bankruptcy.">
    DistressedRatingsDowngrade <"Results from the fact that the rating of the reference obligation is downgraded to a distressed rating level. From a usage standpoint, this credit event is typically not applicable in case of RMBS trades.">
    FailureToPay <"This credit event triggers, after the expiration of any applicable grace period, if the reference entity fails to make due payments in an aggregrate amount of not less than the payment requirement on one or more obligations (e.g. a missed coupon payment). ISDA 2003 Term: Failure to Pay.">
    FailureToPayInterest <"Corresponds to the failure by the Reference Entity to pay an expected interest amount or the payment of an actual interest amount that is less than the expected interest amount. ISDA 2003 Term: Failure to Pay Interest.">
    FailureToPayPrincipal <"Corresponds to the failure by the Reference Entity to pay an expected principal amount or the payment of an actual principal amount that is less than the expected principal amount. ISDA 2003 Term: Failure to Pay Principal.">
    GovernmentalIntervention <"A governmental intervention is an event resulting from an action by a governmental authority that materially impacts the reference entity's obligations, such as an interest rate reduction, principal reduction, deferral of interest or principal, change in priority ranking, or change in currency or composition of payment. ISDA 2014 Term: Governmental Intervention.">
    ImpliedWritedown <"Results from the fact that losses occur to the underlying instruments that do not result in reductions of the outstanding principal of the reference obligation.">
    MaturityExtension <"Results from the fact that the underlier fails to make principal payments as expected.">
    ObligationAcceleration <"One or more of the obligations have been declared due and payable before they would otherwise have been due and payable as a result of, or on the basis of, the occurrence of a default, event of default or other similar condition or event other than failure to pay (preferred by the market over Obligation Default, because more definitive and encompasses the definition of Obligation Default - this is more favorable to the Seller). Subject to the default requirement amount. ISDA 2003 Term: Obligation Acceleration.">
    ObligationDefault <"One or more of the obligations have become capable of being declared due and payable before they would otherwise have been due and payable as a result of, or on the basis of, the occurrence of a default, event of default or other similar condition or event other than failure to pay. ISDA 2003 Term: Obligation Default.">
    RepudiationMoratorium <"The reference entity, or a governmental authority, either refuses to recognise or challenges the validity of one or more obligations of the reference entity, or imposes a moratorium thereby postponing payments on one or more of the obligations of the reference entity. Subject to the default requirement amount. ISDA 2003 Term: Repudiation/Moratorium.">
    Restructuring <"A restructuring is an event that materially impacts the reference entity's obligations, such as an interest rate reduction, principal reduction, deferral of interest or principal, change in priority ranking, or change in currency or composition of payment. ISDA 2003 Term: Restructuring.">
    Writedown <"Results from the fact that the underlier writes down its outstanding principal amount.">

enum ValuationTypeEnum: <"Method used for the valuation of the transaction by the valuation party.">
    MarkToMarket <"Mark-to-Market">
    MarkToModel <"Mark-to-Model">

enum ValuationSourceEnum: <"Source for the valuation of the transaction by the valuation party.">
    CentralCounterparty <"Central Counterparty's Valuation">

enum ValuationScopeEnum: <"Scope of the valuation i.e. what it applies to.">
    Collateral <"Valuation of the collateral used against a trade.">
    Trade <"Valuation of the actual trade itself.">

enum PriceTimingEnum:
    ClosingPrice <"The last price anyone paid for a share of a product during the business hours of the exchange where the product is traded on a business day.">
    OpeningPrice <"The first price anyone paid for a share of a product during the business hours of the exchange where the product is traded on a business day.">

enum ClosedStateEnum: <"The enumerated values to specify what led to the contract or execution closure.">
    Allocated <"The execution or contract has been allocated.">
    Cancelled <"The execution or contract has been cancelled.">
    Exercised <"The (option) contract has been exercised.">
    Expired <"The (option) contract has expired without being exercised.">
    Matured <"The contract has reached its contractual termination date.">
    Novated <"The contract has been novated. This state applies to the stepped-out contract component of the novation event.">
    Terminated <"The contract has been subject of an early termination event.">


================================================================================
FILE: rosetta-source/src/main/rosetta/event-common-func.rosetta
================================================================================

namespace cdm.event.common: <"Business event concepts: primitives, contract state and associated state transition function specifications.">
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.position.*
import cdm.event.workflow.*
import cdm.legaldocumentation.common.*
import cdm.legaldocumentation.transaction.*
import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.observable.event.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.template.*

func QuantityIncreased:
    inputs:
        before TradeState (1..1)
        after TradeState (0..*)
    output:
        result boolean (1..1)

    set result: <"Check each after (list item) is greater than before (func input).">
        after
            extract [
                CompareTradeLot(
                        item -> trade -> tradeLot only-element,
                        CompareOp -> GreaterThan,
                        before -> trade -> tradeLot only-element
                    ) = True
            ] all = True

func QuantityDecreased:
    inputs:
        before TradeState (1..1)
        after TradeState (0..*)
    output:
        result boolean (1..1)

    set result:
        after
            extract [
                // check each after (item) is less than before (input)
                CompareTradeLot(
                            item -> trade -> tradeLot only-element,
                            CompareOp -> LessThan,
                            before -> trade -> tradeLot only-element
                        ) = True
                    and // check each after (item) is greater than zero
                    CompareTradeLotToAmount(
                            item -> trade -> tradeLot only-element,
                            CompareOp -> GreaterThan,
                            0.0
                        ) = True
            ] all = True

func QuantityDecreasedToZero:
    inputs:
        before TradeState (0..*)
        after TradeState (0..*)
    output:
        result boolean (1..1)

    set result:
        CompareTradeLotToAmount(
                    before -> trade -> tradeLot only-element,
                    CompareOp -> GreaterThan,
                    0.0
                ) = True
            and CompareTradeStatesToAmount(after, CompareOp -> Equals, 0.0) = True

func CompareTradeStatesToAmount: <"For each TradeState, compare the Quantity amounts in each TradeState to the given amount (regardless of unit of amount), based on the CompareOp enum.">
    inputs:
        tradeStates TradeState (0..*) <"List of TradeState to be compared.">
        op CompareOp (1..1) <"Comparison operation to use.">
        amount number (1..1) <"Quantity amount to use.">
    output:
        result boolean (1..1)

    set result:
        tradeStates
            extract [
                CompareTradeLotToAmount(item -> trade -> tradeLot only-element, op, amount)
            ] all = True

func TransfersForDate:
    inputs:
        transfers Transfer (0..*)
        date date (1..1)
    output:
        transfersForDate Transfer (0..*)

    add transfersForDate: transfers filter settlementDate -> adjustedDate = date

func FilterCashTransfers:
    inputs:
        transfers Transfer (0..*)
    output:
        cashTransfers Transfer (0..*)

    add cashTransfers: transfers filter quantity -> unit -> currency exists

func FilterSecurityTransfers:
    inputs:
        transfers Transfer (0..*)
    output:
        securityTransfers Transfer (0..*)

    add securityTransfers: transfers filter asset -> Instrument -> Security exists

func ResolveInterestRateObservationIdentifiers: <"Defines which attributes on the InterestRatePayout should be used to locate and resolve the underlier's price, for example for the reset process.">
    inputs:
        payout InterestRatePayout (1..1)
        date date (1..1)
    output:
        identifiers ObservationIdentifier (1..1)

    set identifiers -> observable -> Index -> InterestRateIndex:
        payout -> rateSpecification -> FloatingRateSpecification -> rateOption
    set identifiers -> observationDate: date

// ResolveInterestRateReset is similar to ResolveEquityReset as they both only support the basic use cases for reset. Once support is added for stub periods and thus rate interpolation, the formula to derive the reset value will start to look different between the functions.
func ResolveInterestRateReset: <"Defines how to resolve the reset value for an InterestRatePayout.">
    inputs:
        payouts InterestRatePayout (1..*)
        observation Observation (1..1)
        resetDate date (1..1)
        rateRecordDate date (0..1)
    output:
        reset Reset (1..1)

    set reset -> resetValue: <"Assigns the observed value to the reset value.">
        observation -> observedValue
    set reset -> resetDate: resetDate
    set reset -> rateRecordDate: rateRecordDate
    add reset -> observations: <"Assigns the observation required to compute the rest value as audit.">
        observation

func InterestCashSettlementAmount: <"Defines the performance calculations relevant for a fixed or floating rate payout.">
    inputs:
        tradeState TradeState (1..1)
        payout Payout (1..1)
        resets Reset (1..*)
        date date (1..1)
    output:
        interestCashSettlementAmount Transfer (1..1)

    alias interestRatePayout: payout -> InterestRatePayout

    alias performance:
        if interestRatePayout -> rateSpecification -> FixedRateSpecification exists
        then FixedAmount(
                    interestRatePayout,
                    interestRatePayout -> priceQuantity -> quantitySchedule -> value,
                    date,
                    empty
                )
        else if interestRatePayout -> rateSpecification -> FloatingRateSpecification exists
        then FloatingAmount(
                    interestRatePayout,
                    resets only-element -> resetValue -> value,
                    interestRatePayout -> priceQuantity -> quantitySchedule -> value,
                    date,
                    empty
                )
    alias payer:
        ExtractCounterpartyByRole(
                tradeState -> trade -> counterparty,
                interestRatePayout -> payerReceiver -> payer
            ) -> partyReference
    alias receiver:
        ExtractCounterpartyByRole(
                tradeState -> trade -> counterparty,
                interestRatePayout -> payerReceiver -> receiver
            ) -> partyReference

    condition IsInterestRatePayout: <"Payout must be an InterestRatePayout.">
        payout -> InterestRatePayout exists

    set interestCashSettlementAmount -> quantity -> value: performance
    set interestCashSettlementAmount -> quantity -> unit -> currency:
        interestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency
    set interestCashSettlementAmount -> payerReceiver -> payerPartyReference:
        if performance >= 0 then payer else receiver
    set interestCashSettlementAmount -> payerReceiver -> receiverPartyReference:
        if performance >= 0 then receiver else payer

    set interestCashSettlementAmount -> settlementDate -> adjustedDate: date

    set interestCashSettlementAmount -> settlementOrigin: payout as-key

func ResolveReset: <"Defines the interface for adopters to resolve a reset, given a trade state and a date.">
    [codeImplementation]
    inputs:
        tradeState TradeState (1..1)
        date date (1..1)
    output:
        reset Reset (1..1)

func ResolvePerformanceObservationIdentifiers: <"Defines which attributes on the PerformancePayout should be used to locate and resolve the underlier's price, for example for the reset process.">
    inputs:
        payout PerformancePayout (1..1)
        adjustedDate date (1..1)
    output:
        identifiers ObservationIdentifier (1..1)

    alias adjustedFinalValuationDate:
        ResolveAdjustableDate(
                payout -> valuationDates -> finalValuationDate -> valuationDate
            )
    alias valuationDates: <"Determine which valuation date to get valuation time and type from.">
        if adjustedDate < adjustedFinalValuationDate
        then payout -> valuationDates -> interimValuationDate
        else payout -> valuationDates -> finalValuationDate

    set identifiers -> observable: <"Represents the identifer for the equity underlier.">
        payout -> underlier -> Observable
    set identifiers -> observationDate: <"Specifies the date for which to retrieve the market data value(s). Selects the most recent valuation date.">
        AdjustedValuationDates(payout -> valuationDates)
            filter item <= adjustedDate
            then last
    set identifiers -> observationTime: <"Specifies the time for which to retrieve the market data value(s).">
        ResolvePerformanceValuationTime(
                valuationDates -> valuationTime,
                valuationDates -> valuationTimeType,
                identifiers -> observable -> Asset ->> identifier only-element,
                valuationDates -> determinationMethod
            )
    set identifiers -> informationSource:
        payout -> observationTerms -> informationSource -> primarySource
    set identifiers -> determinationMethodology -> determinationMethod: <"Identifies a more specific price should multiple prices for the underlier be available at the given date time, for example bid or ask prices.">
        valuationDates -> determinationMethod

func AdjustedValuationDates:
    inputs:
        valuationDates ValuationDates (1..1)
    output:
        adjustedValuationDates date (0..*)
    set adjustedValuationDates: <"Build sorted list of adjusted valuation dates.">
        [
            ResolveAdjustableDates(valuationDates -> interimValuationDate -> valuationDates),
            ResolveAdjustableDate(valuationDates -> finalValuationDate -> valuationDate)
        ]
            sort

func ResolvePerformanceValuationTime: <"Defines how to resolve the observation time from those specified in the Performance Valuation type.">
    inputs:
        valuationTime BusinessCenterTime (0..1) <"Represents the Equity Valuation terms from the Equity product definition.">
        valuationTimeType TimeTypeEnum (0..1) <"The time of day at which the calculation agent values the underlying, for example the official closing time of the exchange.">
        assetIdentifier AssetIdentifier (1..1) <"Specifies the asset identifier, along with the source, which should be used to determine the correct valuation time i.e. close times are different across exchanges.">
        determinationMethod DeterminationMethodEnum (1..1) <"Specifies the method according to which an amount or a date is determined.">
    output:
        time TimeZone (1..1)
    set time:
        if valuationTime exists
        then TimeZoneFromBusinessCenterTime(valuationTime)
    set time:
        if valuationTimeType exists
        then ResolveTimeZoneFromTimeType(
                    assetIdentifier,
                    valuationTimeType,
                    determinationMethod
                )

func ResolvePerformanceReset: <"Defines how to resolve the reset value for a performance payout.">
    inputs:
        performancePayout PerformancePayout (1..1) <"Represents the PerformancePayout to which the reset will apply.">
        observation Observation (1..1) <"Represents the observation that will be used to compute the reset value.">
        date date (1..1) <"Specifies the date of the reset.">
    output:
        reset Reset (1..1)
    set reset -> resetValue: <"Assigns the observed value to the reset value.">
        observation -> observedValue
    set reset -> resetDate: date
    add reset -> observations: <"Assigns the observation required to compute the rest value as audit.">
        observation

func EquityCashSettlementAmount: <"Represents Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 72. 'Equity Cash Settlement Amount' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Cash Settlement Amount = ABS(Rate Of Return) * Equity Notional Amount.">
    inputs:
        tradeState TradeState (1..1)
        date date (1..1)
    output:
        equityCashSettlementAmount Transfer (1..1)

    alias payout:
        tradeState -> trade -> product -> economicTerms -> payout
            filter PerformancePayout exists
            then only-element
    alias equityPerformancePayout: payout -> PerformancePayout
    alias equityPerformance:
        EquityPerformance(
                tradeState -> trade,
                tradeState -> resetHistory only-element -> resetValue,
                date
            )
    alias payer:
        ExtractCounterpartyByRole(
                tradeState -> trade -> counterparty,
                equityPerformancePayout -> payerReceiver -> payer
            ) -> partyReference
    alias receiver:
        ExtractCounterpartyByRole(
                tradeState -> trade -> counterparty,
                equityPerformancePayout -> payerReceiver -> receiver
            ) -> partyReference

    set equityCashSettlementAmount -> quantity -> value: <"Equity Cash Settlement Amount is defined here as Abs( Equity Performance ). Per the ISDA Definitions: Equity Performance = (Rate Of Return)  Equity Notional Amount and Equity Cash Settlement Amount = ABS(Rate Of Return)  Equity Notional Amount; so the calculation for Equity Cash Settlement Amount in the CDM is mathematically equivalent, with the added benefit that Rate of Return does not need to be recomputed, since it was already computed in the Reset Event.">
        Abs(equityPerformance)
    set equityCashSettlementAmount -> quantity -> unit -> currency: <"Does not handle the cross currency case. Only works in the case of a single trade lot.">
        ResolveEquityInitialPrice(
                tradeState -> trade -> tradeLot only-element -> priceQuantity -> price
            ) -> unit -> currency
    set equityCashSettlementAmount -> payerReceiver -> payerPartyReference:
        if equityPerformance >= 0 then payer else receiver
    set equityCashSettlementAmount -> payerReceiver -> receiverPartyReference:
        if equityPerformance >= 0 then receiver else payer
    set equityCashSettlementAmount -> settlementDate -> adjustedDate:
        ResolveCashSettlementDate(tradeState)
    set equityCashSettlementAmount -> settlementOrigin: payout as-key

func EquityPerformance: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance' means, in respect of an Equity Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent as of the Equity Valuation Date to which the Equity Cash Settlement Amount relates, pursuant to the following formula: Equity Performance = (Rate Of Return)  Equity Notional Amount.">
    inputs:
        trade Trade (1..1)
        observation Price (1..1)
        date date (1..1)
    output:
        equityPerformance number (1..1)

    alias performancePayout:
        trade -> product -> economicTerms -> payout -> PerformancePayout only-element
    alias periodStartPrice: <"Only works in the case of a single trade lot.">
        ResolvePerformancePeriodStartPrice(
                performancePayout,
                trade -> tradeLot only-element -> priceQuantity -> price,
                trade -> tradeLot -> priceQuantity -> observable only-element,
                date
            )
    alias periodEndPrice: observation
    alias numberOfSecurities:
        performancePayout -> priceQuantity -> quantitySchedule -> value / periodStartPrice -> value
    alias rateOfReturn: RateOfReturn(periodStartPrice, periodEndPrice)
    alias notionalAmount: EquityNotionalAmount(numberOfSecurities, periodEndPrice)

    condition PriceReturnTermsExists:
        trade -> product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists

    set equityPerformance: rateOfReturn * notionalAmount

func RateOfReturn: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 139. 'Rate Of Return' means, in respect of any Equity Valuation Date, the amount determined pursuant to the following formula: Rate Of Return = (Final Price - Initial Price) / Initial Price.">
    inputs:
        initialPrice PriceSchedule (1..1)
        finalPrice PriceSchedule (1..1)
    output:
        rateOfReturn number (1..1)

    alias initialPriceValue: initialPrice -> value
    alias finalPriceValue: finalPrice -> value
    set rateOfReturn:
        if finalPriceValue exists and initialPriceValue exists and initialPriceValue > 0
        then (finalPriceValue - initialPriceValue) / initialPriceValue

func EquityNotionalAmount: <"Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 74. 'Equity Notional Amount' means the Number Of Securities times the Initial Price, adjusted, if applicable, as provided in Part 1 Section 2.2, 'Equity Notional Reset'. If 'With Reset' is the Equity Notional Reset Election, then in respect of each Equity Cash Settlement Date: (i) the Equity Notional Amount applicable in respect of the first Equity Cash Settlement Date will be the amount specified as such in the definition of Equity Notional Amount; (ii) the Equity Notional Amount applicable in respect of each subsequent Equity Cash Settlement Date will be the sum of (a) the Equity Notional Amount in respect of the prior Equity Cash Settlement Date and (b) the Equity Performance, whether positive or negative, in respect of the prior Equity Cash Settlement Date; and (iii)	the Floating Notional Amount will be adjusted as provided in sub-clauses (i) and (ii) above as though it were an Equity Notional Amount.">
    inputs:
        numberOfSecurities number (1..1)
        price Price (1..1)
    output:
        equityNotionalAmount number (1..1)
    alias priceValue: price -> value
    set equityNotionalAmount: numberOfSecurities * priceValue

func Create_StockSplit: <"Function specification to create the fully-formed business event which represents the impact of a stock split (or a reverse stock split) on an Equity Derivatives contract on a certain date.">
    inputs:
        stockSplitInstruction StockSplitInstruction (1..1)
        before TradeState (1..1)
    output:
        after TradeState (1..1)

    alias preSplitNumberOfShares: <"Only works in the case of a single trade lot.">
        FilterQuantityByFinancialUnit(
                before -> trade -> tradeLot only-element -> priceQuantity -> quantity,
                FinancialUnitEnum -> Share
            )
            only-element -> value
    alias postSplitNumberOfShares: <"The adjustment ratio is be multiplied by existing shares in an equity derivative contract or other positions to determine the post-split number of shares.">
        NonNegativeQuantitySchedule {
            value: preSplitNumberOfShares * stockSplitInstruction -> adjustmentRatio,
            unit: UnitType {
                financialUnit: FinancialUnitEnum -> Share,
                ...
            },
            ...
        }
    alias preSplitPrice:
        before -> trade -> tradeLot -> priceQuantity -> price
            filter perUnitOf -> financialUnit = FinancialUnitEnum -> Share
            then only-element
    alias postSplitPrice: <"The pre-split price is divided by the adjustment ratio to determine the post-split price.">
        Price {
            value: preSplitPrice -> value / stockSplitInstruction -> adjustmentRatio,
            unit: preSplitPrice -> unit,
            perUnitOf: preSplitPrice -> perUnitOf,
            priceType: preSplitPrice -> priceType,
            priceExpression: preSplitPrice -> priceExpression,
            composite: preSplitPrice -> composite,
            arithmeticOperator: preSplitPrice -> arithmeticOperator,
            cashPrice: preSplitPrice -> cashPrice,
            datedValue: empty
        }
    alias postSplitPriceQuantity:
        PriceQuantity {
            price: postSplitPrice,
            quantity: postSplitNumberOfShares,
            ...
        }
    alias quantityChangeInstruction:
        QuantityChangeInstruction {
            change: postSplitPriceQuantity,
            direction: QuantityChangeDirectionEnum -> Replace,
            lotIdentifier: empty
        }
    alias primitiveInstruction:
        PrimitiveInstruction {
            quantityChange: quantityChangeInstruction,
            ...
        }
    set after: Create_TradeState(primitiveInstruction, before)

func Create_Execution: <"Specifies the function to compose an execution based on a minimum required set of inputs: product, quantity, parties, etc.">
    inputs:
        instruction ExecutionInstruction (1..1) <"Instructions to be used as an input to the function">
    output:
        execution TradeState (1..1) <"Execution primitive event with absent before state and an after state containing the tradable product, parties, associated party roles and the known settlement terms.">
    set execution -> trade -> product: <"Assign the product input to the tradable product of the execution object.">
        instruction -> product
    add execution -> trade -> tradeLot: <"Assign the prices and quantities and lot identifier input to the tradable product of the execution object.">
        TradeLot {
            priceQuantity: instruction -> priceQuantity,
            lotIdentifier: instruction -> lotIdentifier
        }

    add execution -> trade -> counterparty: <"Assign the counterparty input to the tradable product of the execution object.">
        instruction -> counterparty
    add execution -> trade -> ancillaryParty: <"Assign the ancillaryRole input to the tradable product of the execution object.">
        instruction -> ancillaryParty
    add execution -> trade -> party: <"Assign the parties input to the execution object.">
        instruction -> parties
    add execution -> trade -> partyRole: <"Assign the party roles input to the execution object.">
        instruction -> partyRoles
    set execution -> trade -> executionDetails: <"Assign the settlement terms input to the execution object.">
        instruction -> executionDetails
    set execution -> trade -> tradeDate: <"Assign the tradeDate input to the execution object.">
        instruction -> tradeDate
    add execution -> trade -> tradeIdentifier: <"Assign the identifier input to the execution object.">
        instruction -> tradeIdentifier
    set execution -> state -> positionState: <"Assign the position status to executed.">
        PositionStatusEnum -> Executed
    set execution -> trade -> collateral: <"Assign the anticpated collateral details to the tradable product of the excution object.">
        instruction -> collateral

func Create_ContractFormationInstruction:
    inputs:
        legalAgreement LegalAgreement (0..*)
    output:
        instruction ContractFormationInstruction (1..1)
    condition ExecutedAgreement: <"The full formation of a contract can only be completed with executed legal agreements if any.">
        if legalAgreement exists
        then legalAgreement -> agreementDate exists

    add instruction -> legalAgreement: legalAgreement

func Create_ContractFormation: <"Function specification that represents an executed trade for a contractual product that has been affirmed (or confirmed) by the two parties. The formed contract can reference a legal agreement for instance a master agreement, by using the optional legalAgreement input.">
    inputs:
        instruction ContractFormationInstruction (1..1) <"Instructions to be used as an input to the function">
        execution TradeState (1..1)
    output:
        contractFormation TradeState (1..1) <"Primitive event containing the execution as its before state and the contract as the after state.">

    set contractFormation: execution
    add contractFormation -> trade -> contractDetails -> documentation: <"Append any legal agreements from the instructions.">
        instruction -> legalAgreement
    set contractFormation -> state -> positionState: <"Assign the position status to formed.">
        PositionStatusEnum -> Formed

func Create_Exercise: <"Defines the process of putting into effect the rights specified in an options contract, such as to buy or sell a security.  Once exercised the option contract is terminated.">
    inputs:
        exerciseInstruction ExerciseInstruction (1..1) <"Instruction containing the terms of the option exercise.">
        originalTrade TradeState (1..1) <"The original trade to be split, which must be of single cardinality.">
    output:
        exercise TradeState (1..*)

    alias optionPayout: <"Extracts the optionPayout from exerciseInstruction if provided or from the original trade if absent">
        if exerciseInstruction -> exerciseOption exists
        then exerciseInstruction -> exerciseOption
        else originalTrade -> trade -> product -> economicTerms -> payout -> OptionPayout only-element

    alias underlier: <"Extracts the underlying financial product, upon which the option decision is contingent. Requires that the original contract contains an option payout that contains an Observable or a Product as the underlier.">
        optionPayout -> underlier

    alias resultProduct: <"Find or create the the non transferable product that will result from the exercise.">
        if underlier -> Product -> NonTransferableProduct exists // It already exists, no need to create
        then underlier -> Product -> NonTransferableProduct
        else Create_NonTransferableProduct(underlier, optionPayout -> payerReceiver)

    alias productWithDirection: <"If the option is a Put, then the direction on the result product needs to be flipped from that on the underlier.">
        if optionPayout -> optionType = OptionTypeEnum -> Put
        then Update_ProductDirection(
                    resultProduct,
                    optionPayout -> payerReceiver -> payer,
                    optionPayout -> payerReceiver -> receiver
                )
        else resultProduct

    alias execution: <"Creates the execution primitive describing the exchange of the underlying product, either as a cash transfer or as the formation of a new contractual product between parties.">
        Create_Execution(
                ExecutionInstruction {
                    product: productWithDirection,
                    priceQuantity: originalTrade -> trade -> tradeLot only-element -> priceQuantity,
                    counterparty: originalTrade -> trade -> counterparty,
                    ancillaryParty: originalTrade -> trade -> ancillaryParty,
                    parties: originalTrade -> trade -> party,
                    partyRoles: originalTrade -> trade -> partyRole,
                    executionDetails: empty,
                    tradeDate: originalTrade -> trade -> tradeDate,
                    tradeIdentifier: exerciseInstruction -> replacementTradeIdentifier,
                    ...
                }
            )

    condition OptionPayoutExists: <"Requires that the original contract contains an option payout.">
        optionPayout exists

    add exercise: <"Reduces notional / quantity of option by the amount exercised.">
        Create_TradeState(exerciseInstruction -> exerciseQuantity, originalTrade)

    add exercise: <"Adds the replacement trade">
        execution

func Update_ProductDirection: <"Flips the payer and receiver on a product (used when a Put Option is exercised).">
    inputs:
        before NonTransferableProduct (1..1)
        originalPayer CounterpartyRoleEnum (1..1)
        originalReceiver CounterpartyRoleEnum (1..1)
    output:
        after NonTransferableProduct (1..1)

    set after: before
    set after -> economicTerms -> payout -> OptionPayout -> payerReceiver -> payer:
        originalReceiver
    set after -> economicTerms -> payout -> OptionPayout -> payerReceiver -> receiver:
        originalPayer

func Create_NonTransferableProduct: <"Creates a NonTransferableProduct (ie EconomicTerms) from an underlier.">
    inputs:
        underlier Underlier (1..1)
        payerReceiver PayerReceiver (1..1)
    output:
        newProduct NonTransferableProduct (1..1)

    set newProduct -> economicTerms -> payout -> SettlementPayout -> underlier: underlier
    set newProduct -> economicTerms -> payout -> SettlementPayout -> payerReceiver:
        payerReceiver

func Create_Reset: <"Defines how a Reset should be constructed.">
    inputs:
        instruction ResetInstruction (1..1) <"Specifies the reset instructions.">
        tradeState TradeState (1..1) <"Specifies the trade that is resetting.">
    output:
        reset TradeState (1..1)

    alias payout: <"Specifies the payout that is resetting.">
        instruction -> payout

    alias observationDate: <"If the rateRecordDate is provided in the instructions, it should used as the observation date when determining the fixing rate for an interest rate payout.">
        if instruction -> rateRecordDate exists
        then instruction -> rateRecordDate
        else instruction -> resetDate

    alias observationIdentifiers: <"Resolves the ObservationIdentifier to be used to derive the single observation to be used in the reset calculation. Resolving the ObservationIdentifier is dependent on the type of payout in use.">
        if payout -> PerformancePayout count = 1
        then ResolvePerformanceObservationIdentifiers(
                    payout -> PerformancePayout only-element,
                    instruction -> resetDate
                )
        else if payout -> InterestRatePayout exists
        then ResolveInterestRateObservationIdentifiers(
                    payout -> InterestRatePayout only-element,
                    observationDate
                )

    alias observation: <"Represents the single observation that will be used to compute the reset value.">
        ResolveObservation([observationIdentifiers], empty)

    set reset: tradeState

    add reset -> resetHistory: <"To handle the various ways Contracts can change over time, ">
        if payout -> PerformancePayout count = 1
        then ResolvePerformanceReset(
                    payout -> PerformancePayout only-element,
                    observation,
                    instruction -> resetDate
                )
        else if payout -> InterestRatePayout exists
        then ResolveInterestRateReset(
                    payout -> InterestRatePayout,
                    observation,
                    instruction -> resetDate,
                    instruction -> rateRecordDate
                )

func CalculateTransfer: <"Function specification to calculate a transfer, e.g. following a reset on a contract">
    inputs:
        instruction CalculateTransferInstruction (1..1)
    output:
        transfer Transfer (0..*)

    add transfer: <"Assigns the result of the Create_Transfer function to the transferHistory attribute.">
        if instruction -> payout -> InterestRatePayout exists
                or instruction -> payout -> PerformancePayout exists
                or instruction -> payout -> AssetPayout exists
        then Create_CashTransfer(instruction)

    add transfer: <"Assigns the result of the Create_AssetTransfer function to the transferHistory attribute.">
        if instruction -> payout -> AssetPayout exists
        then Create_AssetTransfer(instruction)

func Create_Transfer: <"Defines how a transfer should be constructed, when representing the exchange of cash between parties.">
    [docReference ICMA GMRA namingConvention "Purchase Price"
        provision "As defined in the GMRA, paragraph 2(nn) The Purchase Price is the price at which the Purchased Securities are sold or are to be sold by Seller to Buyer."]
    [docReference ICMA ERCCBestPractice namingConvention "Purchase Price"
        provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the sum of money paid by the Buyer to the Seller on the Purchase Date of a repo. It is equal to the initial Market Value of the collateral less any haircut or initial margin (called Margin Ratio in the GMRA)."]
    inputs:
        instruction TransferInstruction (1..1)
        tradeState TradeState (1..1) <"Represents the trade and associated state on which to construct the Transfer data type.">
    output:
        transfer TradeState (1..1)

    set transfer: tradeState

    add transfer -> transferHistory: <"Assigns the transfer contained in the transfer instruction to the transferHistory attribute.">
        instruction -> transferState

func Create_CashTransfer: <"Defines how Transfer that represents an exchange of cash, should be constructed.">
    inputs:
        instruction CalculateTransferInstruction (1..1)
    output:
        transfer Transfer (1..1)

    set transfer: <"Resolves the cashflow due to be transferred from the trade and associated state.">
        ResolveTransfer(instruction)

func Create_AssetTransfer: <"Defines how Transfer that represents an exchange of asset based on an asset payout, should be constructed.">
    inputs:
        instruction CalculateTransferInstruction (1..1)
    output:
        transfer Transfer (1..1)

    alias payout: <"Single payout containing an asset payout.">
        instruction -> tradeState -> trade -> product -> economicTerms -> payout
            filter AssetPayout exists
            then only-element

    alias assetPayout: payout -> AssetPayout

    alias tradeQuantity: <"Security quantity obtained by filtering on the trade quantity">
        FilterQuantityByFinancialUnit(
                instruction -> tradeState -> trade -> tradeLot -> priceQuantity -> quantity,
                FinancialUnitEnum -> Share
            )
            only-element

    alias securityQuantity:
        if instruction -> quantity exists
        then instruction -> quantity
        else NonNegativeQuantity {
            value: tradeQuantity -> value,
            unit: tradeQuantity -> unit,
            ...
        }

    alias securityPrice:
        FilterPrice(
                instruction -> tradeState -> trade -> tradeLot -> priceQuantity -> price,
                PriceTypeEnum -> AssetPrice,
                empty,
                empty
            )

    condition ShareUnits:
        if instruction -> quantity exists
        then instruction -> quantity -> unit -> financialUnit = FinancialUnitEnum -> Share

    set transfer -> quantity:
        NonNegativeQuantity {
            value: securityQuantity -> value,
            unit: securityQuantity -> unit,
            ...
        }

    add transfer -> asset -> Instrument -> Security -> identifier:
        assetPayout -> underlier ->> identifier

    set transfer -> payerReceiver -> payerPartyReference:
        if instruction -> payerReceiver -> payer exists
        then ExtractCounterpartyByRole(
                    instruction -> tradeState -> trade -> counterparty,
                    instruction -> payerReceiver -> payer
                ) -> partyReference
        else if assetPayout -> payerReceiver -> payer exists
        then ExtractCounterpartyByRole(
                    instruction -> tradeState -> trade -> counterparty,
                    assetPayout -> payerReceiver -> payer
                ) -> partyReference

    set transfer -> payerReceiver -> receiverPartyReference:
        if instruction -> payerReceiver -> payer exists
        then ExtractCounterpartyByRole(
                    instruction -> tradeState -> trade -> counterparty,
                    instruction -> payerReceiver -> receiver
                ) -> partyReference
        else if assetPayout -> payerReceiver -> receiver exists
        then ExtractCounterpartyByRole(
                    instruction -> tradeState -> trade -> counterparty,
                    assetPayout -> payerReceiver -> receiver
                ) -> partyReference

    set transfer -> settlementDate -> adjustedDate: instruction -> date

    set transfer -> settlementOrigin: payout as-key

func ResolveTransfer: <"Defines how to calculate the amount due to be transferred after a Reset Event.">
    inputs:
        instruction CalculateTransferInstruction (1..1)
    output:
        transfer Transfer (1..1)
    alias payout: instruction -> payout
    set transfer:
        if payout -> AssetPayout exists
        then SecurityFinanceCashSettlementAmount(
                    instruction -> tradeState,
                    instruction -> date,
                    instruction -> quantity,
                    instruction -> payerReceiver
                )
        else if payout -> PerformancePayout exists
        then EquityCashSettlementAmount(instruction -> tradeState, instruction -> date)
        else if payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification exists
                or payout -> InterestRatePayout -> rateSpecification -> FixedRateSpecification exists
        then InterestCashSettlementAmount(
                    instruction -> tradeState,
                    payout,
                    instruction -> resets,
                    instruction -> date
                )
    set transfer -> settlementDate -> adjustedDate: instruction -> date

func ResolveCashSettlementDate: <"A product agnostic function that resolves the settlement date of the payout for the period in question">
    [codeImplementation]
    inputs:
        tradeState TradeState (1..1)
    output:
        date date (1..1)

func SecurityFinanceCashSettlementAmount:
    [docReference ICMA GMRA namingConvention "Repurchase Price"
        provision "As defined in GMRA paragraph 2(rr) The Repurchase Price is the sum of Purchase Price and Price Differential."]
    [docReference ICMA ERCCBestPractice namingConvention "Repurchase Price"
        provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the sum of money to be paid by the Seller of a repo to the Buyer on the Repurchase Date to buy back equivalent collateral. It is equal to the Purchase Price plus repo interest. This term also applies to the value of the cash owed to the Buyer on any day during the term of a repo, that is, the Purchase Price plus repo interest accrued up to that particular date. In the case of Buy/Sell-Backs, the Repurchase Price is net of the amount of any coupon, dividend or other income on the collateral paid to the Buyer during the life of the transaction plus reinvestment income to compensate for the delayed payment."]
    inputs:
        tradeState TradeState (1..1)
        date date (1..1)
        quantity Quantity (0..1) <"Specifies quantity amount returned if not the full amount from the TradeState, e.g. partial return">
        payerReceiver PayerReceiver (0..1)
    output:
        cashSettlementAmount Transfer (1..1)

    alias payout: <"Single payout that contains the AssetPayout.">
        tradeState -> trade -> product -> economicTerms -> payout
            filter AssetPayout exists
            then only-element

    alias assetPayout: payout -> AssetPayout

    alias collateral: tradeState -> trade -> product -> economicTerms -> collateral

    alias securityQuantity: <"Specifies the number of securities.">
        if quantity exists
        then quantity
        else FilterQuantityByFinancialUnit(
                tradeState -> trade -> tradeLot -> priceQuantity -> quantity,
                FinancialUnitEnum -> Share
            )
            only-element

    alias securityPrice: <"Specifies the price per security.">
        FilterPrice(
                tradeState -> trade -> tradeLot -> priceQuantity -> price,
                PriceTypeEnum -> AssetPrice,
                empty,
                empty
            )

    alias marginRatio:
        if collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> haircutPercentage exists
        then 1 / (1.0 - collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> haircutPercentage)
        else if collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> marginPercentage exists
        then collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> marginPercentage
        else 1.0

    condition ShareUnitExists:
        if quantity exists
        then quantity -> unit -> financialUnit = FinancialUnitEnum -> Share

    condition IdentifiersMatch:
        tradeState -> trade -> tradeLot -> priceQuantity -> observable -> Asset ->> identifier
            = assetPayout -> underlier ->> identifier

    set cashSettlementAmount -> quantity -> value:
        securityPrice -> value * securityQuantity -> value * marginRatio

    set cashSettlementAmount -> quantity -> unit -> currency:
        securityPrice -> unit -> currency

    set cashSettlementAmount -> payerReceiver -> payerPartyReference:
        if payerReceiver exists
        then ExtractCounterpartyByRole(
                    tradeState -> trade -> counterparty,
                    payerReceiver -> receiver
                ) -> partyReference
        else if assetPayout -> payerReceiver -> receiver exists
        then ExtractCounterpartyByRole(
                    tradeState -> trade -> counterparty,
                    assetPayout -> payerReceiver -> receiver
                ) -> partyReference

    set cashSettlementAmount -> payerReceiver -> receiverPartyReference:
        if payerReceiver exists
        then ExtractCounterpartyByRole(
                    tradeState -> trade -> counterparty,
                    payerReceiver -> payer
                ) -> partyReference
        else if assetPayout -> payerReceiver -> payer exists
        then ExtractCounterpartyByRole(
                    tradeState -> trade -> counterparty,
                    assetPayout -> payerReceiver -> payer
                ) -> partyReference

    set cashSettlementAmount -> settlementDate -> adjustedDate: date

    set cashSettlementAmount -> settlementOrigin: payout as-key

func Create_Split: <"Defines the logic for splitting a trade into separate copies. The split instruction contains a breakdown into N set of primitive instructions. Each set contains the primitive instructions to be applied to each post-split trade, eventually producing N trades. The split function underpins a number of business events such as clearing or allocation.">
    inputs:
        breakdown PrimitiveInstruction (1..*) <"Each primitive instruction contains the set of instructions to be applied to each post-split trade.">
        originalTrade TradeState (1..1) <"The original trade to be split, which must be of single cardinality.">
    output:
        splitTrade TradeState (1..*)

    add splitTrade: <"Iterate over each breakdown and apply the set of primitive instructions to each copy of the original trade.">
        breakdown extract Create_TradeState(item, originalTrade)

func Create_PartyChange: <"Defines the logic for changing one of the counterparties on a trade. A new trade identifier must be specified as a change of party results in a new trade. An ancillary party can also be specified, for instance to refer to the original executing party on the new trade.">
    inputs:
        counterparty Counterparty (1..1) <"The counterparty to change and the role it plays in the transaction.">
        ancillaryParty AncillaryParty (0..1) <"Optional ancillary party, which can be used to keep a reference to the original executing party, for instance.">
        partyRole PartyRole (0..1)
        tradeId TradeIdentifier (1..*) <"A mandatory trade identifier must be specified, as the chnage of party results in a new trade.">
        originalTrade TradeState (1..1) <"The original trade on which to update the counterparty. The original trade will be terminated.">
    output:
        newTrade TradeState (1..1)

    alias counterparty1:
        if counterparty -> role = CounterpartyRoleEnum -> Party1
        then Counterparty {
                partyReference: counterparty -> partyReference as-key,
                role: counterparty -> role
            }
        else ExtractCounterpartyByRole(
                originalTrade -> trade -> counterparty,
                CounterpartyRoleEnum -> Party1
            )
    alias counterparty2:
        if counterparty -> role = CounterpartyRoleEnum -> Party2
        then Counterparty {
                partyReference: counterparty -> partyReference as-key,
                role: counterparty -> role
            }
        else ExtractCounterpartyByRole(
                originalTrade -> trade -> counterparty,
                CounterpartyRoleEnum -> Party2
            )
    alias partyToRemove:
        ExtractCounterpartyByRole(
                originalTrade -> trade -> counterparty,
                counterparty -> role
            ) -> partyReference

    set newTrade: <"Copy the original trade.">
        originalTrade
    set newTrade -> trade -> counterparty: <"Assigns the new counterparties.">
        [counterparty1, counterparty2]
    set newTrade -> trade -> party: <"Removes the existing party, and adds the new party.">
        ReplaceParty(
                originalTrade -> trade -> party,
                partyToRemove,
                counterparty -> partyReference
            )
    set newTrade -> trade -> tradeIdentifier: <"Replaces the existing trade identifier with the new trade identifier">
        tradeId
    add newTrade -> trade -> party: <"Add ancillary party as an additional party">
        ancillaryParty -> partyReference
    add newTrade -> trade -> ancillaryParty: <"Add ancillary party role">
        ancillaryParty
    add newTrade -> trade -> party: <"Add party role party reference as an additional party">
        partyRole -> partyReference
    add newTrade -> trade -> partyRole: <"Add party role">
        partyRole
    set newTrade -> transferHistory: <"Clear transfer history.">
        EmptyTransferHistory()

func EmptyTransferHistory:
    [codeImplementation]
    output:
        emptyTransferHistory TransferState (0..*)

func Create_QuantityChange: <"A specification of the inputs, outputs and constraints when calculating the after state of a Quantity Change Primitive Event">
    inputs:
        instruction QuantityChangeInstruction (1..1)
        tradeState TradeState (1..1)
    output:
        quantityChange TradeState (1..1)

    alias trade: <"The Trade from the input TradeState">
        tradeState -> trade

    alias tradeLotExists: <"The quantity change instruction applies to an existing tradeLot">
        FilterTradeLot(trade -> tradeLot, instruction -> lotIdentifier) exists

    alias tradeLot: <"Get the existing trade lot if specified, or return only trade lot">
        if tradeLotExists
        then FilterTradeLot(trade -> tradeLot, instruction -> lotIdentifier)
        else trade -> tradeLot only-element

    alias newPriceQuantity: <"Update the PriceQuantity based on the change and direction inputs. For an increase, if the trade lot exists, apply the changes to the existing PriceQuantity; otherwise, add the changed PriceQuantity to the list of TradeLots. For a decrease or replace, apply the changes to the existing PriceQuantity.">
        if instruction -> direction = QuantityChangeDirectionEnum -> Increase
                and tradeLotExists = False
        then instruction -> change
        else UpdateAmountForEachMatchingQuantity(
                tradeLot -> priceQuantity,
                instruction -> change,
                instruction -> direction
            )

    alias newTradeLots: <"Add or merge updated TradeLot.">
        if instruction -> direction = QuantityChangeDirectionEnum -> Increase
                and tradeLotExists = False
        then AddTradeLot(
                    trade,
                    TradeLot {
                        lotIdentifier: instruction -> lotIdentifier,
                        priceQuantity: newPriceQuantity
                    }
                ) -> tradeLot
        else ReplaceTradeLot(
                trade -> tradeLot,
                TradeLot {
                    lotIdentifier: instruction -> lotIdentifier,
                    priceQuantity: newPriceQuantity
                }
            )

    condition CashPriceOnly: <"Only termination where the termination price is specified as a cash price is supported for now.">
        if instruction -> direction = QuantityChangeDirectionEnum -> Decrease
                and instruction -> change -> price exists
        then instruction -> change -> price -> priceType all = PriceTypeEnum -> CashPrice

    set quantityChange: tradeState

    // Update trade with new TradableProduct.
    set quantityChange -> trade -> product: trade -> product
    set quantityChange -> trade -> tradeLot: newTradeLots
    set quantityChange -> trade -> counterparty: trade -> counterparty
    set quantityChange -> trade -> ancillaryParty: trade -> ancillaryParty
    set quantityChange -> trade -> adjustment: trade -> adjustment

    set quantityChange -> state -> positionState:
        if newTradeLots -> priceQuantity -> quantity -> value all = 0
        then PositionStatusEnum -> Closed

func Create_TermsChange: <"A specification of the inputs, outputs and constraints when calculating the after tradeState based Terms Change Primitive Instruction.">
    inputs:
        termsChange TermsChangeInstruction (1..1) <"Instructions to be used as an input to the function">
        before TradeState (1..1) <"current trade to be ammended">
    output:
        tradeState TradeState (1..1)

    alias newProduct:
        if termsChange -> product exists
        then termsChange -> product
        else before -> trade -> product

    alias newAncillaryParty:
        if termsChange -> ancillaryParty exists
        then termsChange -> ancillaryParty
        else before -> trade -> ancillaryParty

    alias newAdjustment:
        if termsChange -> adjustment exists
        then termsChange -> adjustment
        else before -> trade -> adjustment

    set tradeState: before

    // Contract to be updated based on the new terms change inputs.
    set tradeState -> trade -> product: newProduct
    set tradeState -> trade -> tradeLot: tradeState -> trade -> tradeLot
    set tradeState -> trade -> counterparty: tradeState -> trade -> counterparty
    set tradeState -> trade -> ancillaryParty: newAncillaryParty
    set tradeState -> trade -> adjustment: newAdjustment

func FilterOpenTradeStates: <"Filter to only 'open' TradeState - where both the closedState and positionState are not set.">
    inputs:
        tradeStates TradeState (0..*)
    output:
        openTradeStates TradeState (0..*)

    add openTradeStates: tradeStates filter state -> closedState is absent

func FilterClosedTradeStates: <"Filter to only 'closed' TradeState - where either the closedState or positionState are set.">
    inputs:
        tradeStates TradeState (0..*)
    output:
        closedTradeStates TradeState (0..*)

    add closedTradeStates: tradeStates filter state -> closedState exists

func NewEquitySwapProduct: <"Function specification to create an Equity Swap according to the 2018 ISDA CDM Equity Confirmation Template, based on a minimum set of inputs which can (optionally) include a Master Confirmation Agreement. The inputs represent the minimum set of inputs required to create an Equity Swap, either based on an existing Master Confirmation Agreement or as a stand-alone Equity Swap">
    inputs:
        security Security (1..1) <"The underlying Equity asset for the swap.">
        masterConfirmation EquitySwapMasterConfirmation2018 (0..1) <"An (optional) pointer to the Master Confirmation Agreement, if any, that holds further inputs to the Equity Swap">
    output:
        product NonTransferableProduct (1..1)

    condition EquitySecurityType: <"Security must be equity (single name).">
        security -> instrumentType = InstrumentTypeEnum -> Equity

    add product -> economicTerms -> payout:
        Payout {
            PerformancePayout: NewSingleNameEquityPerformancePayout(
                    security,
                    masterConfirmation
                ),
            ...
        }

    add product -> economicTerms -> payout: <"Equity and interest rate payouts must be set-up according to their corresponding payout specifications">
        if masterConfirmation exists
        then Payout {
                InterestRatePayout: NewFloatingPayout(masterConfirmation),
                ...
            }

    post-condition PayoutType: <"Other payout types must be absent.">
        if masterConfirmation is absent
        then (product -> economicTerms -> payout
            extract PerformancePayout exists
            then all = True)

func NewSingleNameEquityPerformancePayout: <"Function specification to create the equity payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
    inputs:
        security Security (1..1)
        masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
    output:
        performancePayout PerformancePayout (1..1)

    condition EquitySecurityType: <"Security must be equity (single name).">
        security -> instrumentType = InstrumentTypeEnum -> Equity

    set performancePayout -> returnTerms -> priceReturnTerms -> returnType: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
        // if masterConfirmation -> typeOfSwapElection -> Price exists
        // or masterConfirmation -> typeOfSwapElection -> Total exists then
        masterConfirmation -> typeOfSwapElection

    set performancePayout -> valuationDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
        masterConfirmation -> valuationDates
    set performancePayout -> paymentDates: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
        masterConfirmation -> equityCashSettlementDates
    set performancePayout -> settlementTerms: <"Equity payout must inherit terms from the Master Confirmation Agreement.">
        masterConfirmation -> settlementTerms

func NewFloatingPayout: <"Function specification to create the interest rate (floating) payout part of an Equity Swap according to the 2018 ISDA CDM Equity Confirmation template.">
    [codeImplementation]
    inputs:
        masterConfirmation EquitySwapMasterConfirmation2018 (0..1)
    output:
        interestRatePayout InterestRatePayout (1..1)

    post-condition InterestRatePayoutTerms: <"Interest rate payout must inherit terms from the Master Confirmation Agreement when it exists.">
        if masterConfirmation exists
        then // interestRatePayout -> calculationPeriodDates = masterConfirmation -> equityCalculationPeriod and
            interestRatePayout -> paymentDates = masterConfirmation -> equityCashSettlementDates

func Create_IndexTransitionTermsChange: <"Function specification to create a terms change that contains changes to the floating rate indexes and adds an adjustment spread to any existing spread.">
    inputs:
        instruction IndexTransitionInstruction (1..1) <"Specifies the instructions containing the floating rate index, spread adjustment for each leg to be updated, and the effective date.">
        tradeState TradeState (1..1) <"Specifies the trade to be updated.">
    output:
        termsChange TradeState (1..1) <"Specifies the resulting term change.">

    set termsChange: <"Updates the trade based on each instruction priceQuantity (e.g. one for each floating rate leg).">
        UpdateSpreadAdjustmentAndRateOptions(tradeState, instruction -> priceQuantity)

func Create_Observation: <"Function specification to create an observation that incorporates an observation event into the observation history of a given trade state.">
    inputs:
        instruction ObservationInstruction (1..1)
        before TradeState (1..1) <"Specifies the trade to be updated.">
    output:
        after TradeState (1..1) <"Specifies the resulting trade state incorporating the observation event in the observation history.">

    set after: before
    add after -> observationHistory: instruction -> observationEvent

func Create_Valuation: <"Function specification to incorporate a new assessment of the valuation in the valuation history of a given trade state.">
    inputs:
        instruction ValuationInstruction (1..1)
        before TradeState (1..1) <"Specifies the trade to be updated.">
    output:
        after TradeState (1..1) <"Specifies the resulting trade state incorporating the valuation update in the valuation history.">

    alias beforeValuationHistory:
        if instruction -> replace = True
        then []
        else before -> valuationHistory

    set after: before

    set after -> valuationHistory: beforeValuationHistory

    add after -> valuationHistory: instruction -> valuation

func UpdateSpreadAdjustmentAndRateOptions: <"For each of the trade state's price quantity, find a matching price quantity instruction, and call the update function.">
    inputs:
        tradeState TradeState (1..1) <"Specifies the trade to be updated.">
        instructions PriceQuantity (1..*) <"List of PriceQuantity from the IndexTransitionInstruction (e.g. one for each floating rate leg).">
    output:
        updatedTradeState TradeState (1..1) <"Specifies the updated trade.">

    set updatedTradeState: tradeState

    set updatedTradeState -> trade -> tradeLot -> priceQuantity:
        tradeState -> trade -> tradeLot only-element -> priceQuantity
            extract
                UpdateIndexTransitionPriceAndRateOption(
                        item,
                        FindMatchingIndexTransitionInstruction(instructions, item)
                    )

func UpdateIndexTransitionPriceAndRateOption:
    inputs:
        priceQuantity PriceQuantity (1..1)
        instruction PriceQuantity (0..1)
    output:
        updatedPriceQuantity PriceQuantity (1..1)

    set updatedPriceQuantity: priceQuantity

    set updatedPriceQuantity -> price -> value: <"If instruction exists, sum the existing and instruction spread adjustments.">
        if instruction exists
        then priceQuantity -> price only-element -> value + instruction -> price only-element -> value
        else priceQuantity -> price only-element -> value

    set updatedPriceQuantity -> observable -> Index -> InterestRateIndex: <"If instruction exists, update the rate option.">
        if instruction exists
        then instruction -> observable -> Index -> InterestRateIndex
        else priceQuantity -> observable -> Index -> InterestRateIndex

func FindMatchingIndexTransitionInstruction:
    inputs:
        instructions PriceQuantity (1..*)
        priceQuantity PriceQuantity (1..1)
    output:
        matchingInstruction PriceQuantity (0..1)

    set matchingInstruction:
        instructions
            filter
                // indexTenor period matches
                observable -> Index -> InterestRateIndex ->> indexTenor -> period = priceQuantity -> observable -> Index -> InterestRateIndex ->> indexTenor -> period
                        // indexTenor periodMultiplier matches
                    and observable -> Index -> InterestRateIndex ->> indexTenor -> periodMultiplier = priceQuantity -> observable -> Index -> InterestRateIndex ->> indexTenor -> periodMultiplier
                        // quantity currency or price currency matches
                    and (quantity -> unit -> currency = priceQuantity -> quantity -> unit -> currency
                        or price -> unit -> currency = priceQuantity -> price -> unit -> currency)
            then first

func Create_SecurityLendingInvoice: <"Defines the process of calculating and creating a Security Lending Invoice.">
    inputs:
        instruction BillingInstruction (1..1) <"Specifies the instructions for creation of a Security Lending billing invoice.">
    output:
        invoice SecurityLendingInvoice (1..1) <"Produces the Security Lending Invoice">

    set invoice -> sendingParty: instruction -> sendingParty

    set invoice -> receivingParty: instruction -> receivingParty

    set invoice -> billingStartDate: instruction -> billingStartDate

    set invoice -> billingEndDate: instruction -> billingEndDate

    add invoice -> billingRecord:
        Create_BillingRecords(instruction -> billingRecordInstruction)

    add invoice -> billingSummary: Create_BillingSummary(invoice -> billingRecord)

func Create_BillingRecords: <"Creates for each billing instruction an individual billing record to be included in a Security Lending Billing Invoice">
    inputs:
        billingInstruction BillingRecordInstruction (1..*) <"Instruction for creating the billing records contained within the invoice">
    output:
        billingRecord BillingRecord (1..*)

    add billingRecord: billingInstruction extract Create_BillingRecord(item)

func Create_BillingRecord: <"Creates an individual billing record to be included in a Security Lending Billing Invoice">
    inputs:
        billingInstruction BillingRecordInstruction (1..1) <"Instruction for creating the billing records contained within the invoice">
    output:
        billingRecord BillingRecord (1..1) <"The billing record">

    alias tradeState: <"Creates a trade state with observations attached.">
        Create_AssetPayoutTradeStateWithObservations(billingInstruction)

    alias billingAmount: <"Resolves the billing amount for the individual trade record.">
        ResolveSecurityFinanceBillingAmount(
                tradeState,
                tradeState -> resetHistory only-element,
                billingInstruction -> recordStartDate,
                billingInstruction -> recordEndDate,
                billingInstruction -> settlementDate
            )

    set billingRecord -> recordStartDate: billingInstruction -> recordStartDate

    set billingRecord -> recordEndDate: billingInstruction -> recordEndDate

    set billingRecord -> tradeState: tradeState

    set billingRecord -> recordTransfer: billingAmount

func ResolveSecurityFinanceBillingAmount: <"Calculates the billing amount for a Security Finance transaction.">
    inputs:
        tradeState TradeState (1..1)
        reset Reset (1..1)
        recordStartDate date (1..1)
        recordEndDate date (1..1)
        transferDate date (1..1)
    output:
        transfer Transfer (1..1)

    alias securityQuantity: <"Specifies the number of securities.">
        FilterQuantityByFinancialUnit(
                tradeState -> trade -> tradeLot -> priceQuantity -> quantity,
                FinancialUnitEnum -> Share
            )
            only-element

    alias interestRatePayout: <"The interest payout that represents the lending fee.">
        tradeState -> trade -> product -> economicTerms -> payout -> InterestRatePayout only-element

    alias assetPayout: <"The security finance payout that represents the securities lent.">
        tradeState -> trade -> product -> economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout only-element

    alias collateral: tradeState -> trade -> product -> economicTerms -> collateral

    alias haircutPercentage:
        (1.0 - collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> haircutPercentage)

    alias valuationPercentage: (1 / haircutPercentage)

    alias marginRatio:
        if collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> haircutPercentage exists
        then valuationPercentage
        else if collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> marginPercentage exists
        then collateral -> collateralProvisions -> eligibleCollateral only-element -> treatment -> valuationTreatment -> marginPercentage
        else 1.0

    alias billingQuantity:
        reset -> resetValue -> value * securityQuantity -> value * marginRatio

    alias calculationPeriodRange:
        CalculationPeriodRange(recordStartDate, recordEndDate, empty)

    alias performance:
        if interestRatePayout -> rateSpecification -> FixedRateSpecification exists
        then FixedAmount(
                    interestRatePayout,
                    billingQuantity,
                    recordEndDate,
                    calculationPeriodRange
                )
        else if interestRatePayout -> rateSpecification -> FloatingRateSpecification exists
        then FloatingAmount(
                    interestRatePayout,
                    reset -> resetValue -> value,
                    billingQuantity,
                    recordEndDate,
                    calculationPeriodRange
                )

    alias payerPartyReference:
        ExtractCounterpartyByRole(
                tradeState -> trade -> counterparty,
                interestRatePayout -> payerReceiver -> payer
            ) -> partyReference

    alias receiverPartyReference:
        ExtractCounterpartyByRole(
                tradeState -> trade -> counterparty,
                interestRatePayout -> payerReceiver -> receiver
            ) -> partyReference

    set transfer -> quantity -> value: performance

    set transfer -> quantity -> unit -> currency:
        interestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency

    set transfer -> payerReceiver -> payerPartyReference:
        if performance >= 0
        then payerPartyReference
        else receiverPartyReference

    set transfer -> payerReceiver -> receiverPartyReference:
        if performance >= 0
        then receiverPartyReference
        else payerPartyReference

    set transfer -> settlementDate -> adjustedDate: transferDate

func ToMoney:
    inputs:
        quantity Quantity (1..1)
    output:
        money Money (1..1)

    set money -> value: quantity -> value
    set money -> unit -> currency: quantity -> unit -> currency

func Create_BillingSummary: <"Creates a billing summary to be included in a Security Lending Billing Invoice.">
    [codeImplementation]
    inputs:
        billingRecord BillingRecord (1..*)
    output:
        billingSummary BillingSummary (1..1)

//sums all billing records and assigns value to billing summary
//sets enum to ParentTotal
func Create_Return: <"Defines the process of partially or fully returning a Security Lending Transaction.">
    [creation BusinessEvent]
    inputs:
        tradeState TradeState (1..1) <"Specifies a previously formed contractual product with a Security Finance payout. It is required that the description of the contractual product be contained within the previous business event, i.e. its lineage must contain the formation of a contractual product.">
        returnInstruction ReturnInstruction (1..1) <"Specifies the information required to fully return the Stock Loan in accordance with the economic terms of the contractual product.">
        returnDate date (1..1) <"Specifies the date of the full return.">
    output:
        returnEvent BusinessEvent (1..1) <"Produces the business event composed of primitive events describing the transfer and termination, as a result of the input return instruction.">

    alias quantitySchedule:
        returnInstruction -> quantity
            extract
                NonNegativeQuantitySchedule {
                    value: value,
                    unit: unit,
                    ...
                }

    alias changePriceQuantity:
        PriceQuantity {
            quantity: quantitySchedule,
            ...
        }

    add returnEvent -> after: <"Creates a new contract within the quantity change primitive's after state equivalent to the new notional on the partially returned original contract, assuming there's a single security finance transaction in the original financial contract that is part returned.">
        Create_QuantityChange(
                QuantityChangeInstruction {
                    change: changePriceQuantity,
                    direction: QuantityChangeDirectionEnum -> Decrease,
                    lotIdentifier: empty
                },
                tradeState
            )

    set returnEvent -> eventDate: returnDate

func ResolveRepurchaseTransferInstruction: <"Resolves an instruction for settlement of a Repurchase Event">
    inputs:
        tradeState TradeState (1..1)
        repurchaseDate date (1..1)
    output:
        repurchaseInstruction EventInstruction (1..1)

    alias changeQuantity: <"Create distinct list of Quantity with value set to zero.">
        tradeState -> trade -> tradeLot -> priceQuantity -> quantity
            extract
                NonNegativeQuantitySchedule {
                    value: 0.0,
                    unit: unit,
                    ...
                }
            then distinct

    alias changePriceQuantity: <"Create change PriceQuantity for QuantityChangeInstruction.">
        PriceQuantity {
            quantity: changeQuantity,
            ...
        }

    set repurchaseInstruction -> intent: EventIntentEnum -> Repurchase

    set repurchaseInstruction -> instruction -> before: tradeState

    set repurchaseInstruction -> instruction -> primitiveInstruction -> quantityChange:
        QuantityChangeInstruction {
            change: changePriceQuantity,
            direction: QuantityChangeDirectionEnum -> Replace,
            lotIdentifier: empty
        }

func Create_RollPrimitiveInstruction: <"Creates the primitive instructions for a trade roll. A trade roll consists in closing an existing trade and entering into a new one which has the same characteristics as the old one, except with an extended termination date and (possibly) a different price.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be rolled.">
        effectiveRollDate AdjustableOrRelativeDate (1..1) <"The date to close and open a new position.">
        terminationDate AdjustableOrRelativeDate (1..1) <"The new termination date.">
        priceQuantity PriceQuantity (1..*) <"The price and quantity of the trade to roll into.">
    output:
        instruction PrimitiveInstruction (1..1)

    set instruction -> split -> breakdown: <"Sets the first part of the split to be a termination instruction for the existing trade.">
        [Create_TerminationInstruction(tradeState)]

    add instruction -> split -> breakdown: <"Sets the second part of the split to be a new contract with the same details as the old one but with effective and termination dates changed (i.e. terms change instruction) and price / quantity changed.">
        [
            PrimitiveInstruction {
                quantityChange: QuantityChangeInstruction {
                    change: priceQuantity,
                    direction: QuantityChangeDirectionEnum -> Replace,
                    lotIdentifier: empty
                },
                termsChange: Create_RollTermChangeInstruction(
                        tradeState -> trade -> product,
                        effectiveRollDate,
                        terminationDate
                    ),
                ...
            }
        ]

func Create_EffectiveOrTerminationDateTermChangeInstruction: <"Creates the relevant terms change primitive instruction object for rolling a contractual product, which consists in the same terms as the original contractual product but with different effective and termination dates.">
    inputs:
        product NonTransferableProduct (1..1) <"The original contractual product to be rolled.">
        effectiveRollDate AdjustableOrRelativeDate (0..1) <"The date to close and open a new position.">
        terminationDate AdjustableOrRelativeDate (0..1) <"The new termination date.">
    output:
        termsChangeInstruction TermsChangeInstruction (1..1) <"The relevant primitive instruction for the roll, which is a terms change.">

    condition DateExists:
        effectiveRollDate exists or terminationDate exists

    set termsChangeInstruction -> product: product

    set termsChangeInstruction -> product -> economicTerms -> effectiveDate:
        if effectiveRollDate exists
        then effectiveRollDate
        else product -> economicTerms -> effectiveDate

    set termsChangeInstruction -> product -> economicTerms -> terminationDate:
        if terminationDate exists
        then terminationDate
        else product -> economicTerms -> terminationDate

func Create_RollTermChangeInstruction: <"Creates the relevant terms change primitive instruction object for rolling a contractual product, which consists in the same terms as the original contractual product but with different effective and termination dates.">
    inputs:
        product NonTransferableProduct (1..1) <"The original contractual product to be rolled.">
        effectiveRollDate AdjustableOrRelativeDate (1..1) <"The date to close and open a new position.">
        terminationDate AdjustableOrRelativeDate (1..1) <"The new termination date.">
    output:
        termsChangeInstruction TermsChangeInstruction (1..1) <"The relevant primitive instruction for the roll, which is a terms change.">

    set termsChangeInstruction -> product: product
    set termsChangeInstruction -> product -> economicTerms -> effectiveDate:
        effectiveRollDate
    set termsChangeInstruction -> product -> economicTerms -> terminationDate:
        terminationDate

func Create_OnDemandRateChangePrimitiveInstruction: <"Creates a full primitive instruction for an on-demand rate change event. A rate change consists in closing the original trade and opening a new one with the same details as the original one, but with a new rate (price) and effective date. The business event logic checks that there is only 1 rate price in the original trade to be updated.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be modified with new rate.">
        effectiveDate AdjustableOrRelativeDate (1..1) <"The date to close and open a new position.">
        agreedRate number (1..1) <"The new rate agreed between the parties.">
    output:
        instruction PrimitiveInstruction (1..1)

    condition SingleTradeLot: <"Rate change only works for a trade with a single trade lot.">
        tradeState -> trade -> tradeLot count = 1

    set instruction -> split -> breakdown: <"Sets the first part of the split to be a termination instruction for the existing trade.">
        [Create_TerminationInstruction(tradeState)]

    add instruction -> split -> breakdown: <"Sets the second part of the split to be a new contract with the same details as the old one but with effective date and price (rate) changed.">
        [
            PrimitiveInstruction {
                quantityChange: Create_OnDemandRateChangePriceChangeInstruction(
                        tradeState -> trade -> tradeLot only-element -> priceQuantity,
                        agreedRate
                    ),
                termsChange: Create_OnDemandRateChangeTermsChangeInstruction(
                        tradeState -> trade -> product,
                        effectiveDate
                    ),
                ...
            }
        ]

func Create_OnDemandRateChangePriceChangeInstruction: <"Creates a price change instruction for an on-demand rate change, based on a new rate provided as a single number by matching it to a single rate price.">
    inputs:
        priceQuantity PriceQuantity (1..*) <"The original price / quantity to be modified with the new rate.">
        newRate number (1..1) <"The new rate value, provided as a single number.">
    output:
        quantityChangeInstruction QuantityChangeInstruction (1..1)

    alias currentRatePrice: <"Filter interest rate price and make it into a single element">
        priceQuantity
            extract price
            then flatten
            then filter priceType = PriceTypeEnum -> InterestRate
            then only-element
    alias newPrice: <"Create the new price object.">
        Price {
            value: newRate,
            unit: currentRatePrice -> unit,
            perUnitOf: currentRatePrice -> perUnitOf,
            priceType: currentRatePrice -> priceType,
            priceExpression: currentRatePrice -> priceExpression,
            composite: currentRatePrice -> composite,
            arithmeticOperator: currentRatePrice -> arithmeticOperator,
            cashPrice: currentRatePrice -> cashPrice,
            datedValue: empty
        }
    alias newPriceQuantity: <"Create the new price quantity object.">
        PriceQuantity {
            price: newPrice,
            ...
        }

    condition OneRatePrice: <"There should be 1 and only 1 rate type price in the current price.">
        currentRatePrice exists

    set quantityChangeInstruction:
        QuantityChangeInstruction {
            change: newPriceQuantity,
            direction: QuantityChangeDirectionEnum -> Replace,
            lotIdentifier: empty
        }

func Create_OnDemandRateChangeTermsChangeInstruction: <"Creates a terms change instruction for an on-demand rate change, based on a new rate provided as a single number. This instruction only updates the effective date but keeps other details of the trade unchanged.">
    inputs:
        product NonTransferableProduct (1..1) <"The original contractual product whose rate is changed.">
        effectiveDate AdjustableOrRelativeDate (1..1) <"The date to open the new position.">
    output:
        termsChangeInstruction TermsChangeInstruction (1..1)

    set termsChangeInstruction -> product: <"Keep the same contractual product as the original trade">
        product
    set termsChangeInstruction -> product -> economicTerms -> effectiveDate: <"Updates the contractual product's effective date to be the new effective date.">
        effectiveDate

func Create_CancellationPrimitiveInstruction: <"Creates a primitive instruction for early cancellation.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be rolled.">
        newRepurchasePrice number (0..1) <"The new repurchase price after the new termination date is set.">
        cancellationDate AdjustableOrRelativeDate (1..1) <"The new termination date.">
    output:
        instruction PrimitiveInstruction (1..1)

    set instruction -> split -> breakdown: <"Sets the first part of the split to be a termination instruction for the existing trade.">
        [Create_TerminationInstruction(tradeState)]

    add instruction -> split -> breakdown: <"Sets the second part of the split to be a new contract with the same details as the old one but with termination date changed and price / quantity changed (taking new repurchase price into account).">
        [
            PrimitiveInstruction {
                quantityChange: QuantityChangeInstruction {
                    change: tradeState -> trade -> tradeLot -> priceQuantity,
                    direction: QuantityChangeDirectionEnum -> Replace,
                    lotIdentifier: empty
                },
                termsChange: Create_CancellationTermChangeInstruction(
                        tradeState -> trade -> product,
                        cancellationDate
                    ),
                ...
            }
        ]

func Create_CancellationTermChangeInstruction: <"Create a terms change instruction for a cancellation that consists in bringing the termination date forward.">
    inputs:
        product NonTransferableProduct (1..1) <"Contractual product of original trade">
        cancellationDate AdjustableOrRelativeDate (1..1) <"The new termination date.">
    output:
        termsChangeInstruction TermsChangeInstruction (1..1)

    set termsChangeInstruction -> product: product
    set termsChangeInstruction -> product -> economicTerms -> terminationDate:
        cancellationDate

func Create_PairOffInstruction: <"Creates a set of instructions to pair-off a set of trades based on a pair reference. A package component is created based on that pair reference and the list of identifiers for the underlying trades. That package component is then added onto the execution details of every underlying trade. The existing trades are not terminated.">
    inputs:
        tradeState TradeState (2..*) <"The trades to pair-off. There must be at least 2.">
        pairReference Identifier (1..1) <"The reference ID of the paired trades.">
    output:
        instruction Instruction (1..*)

    alias componentId: <"Extract the trade identifier from each trade. This list will be used as the componentId attribute of the package.">
        tradeState extract trade -> tradeIdentifier only-element

    set instruction: <"Create a list of new execution instructions for each trade. The new execution instructions include new execution details, with the package component created using the pair reference and the componentId list.">
        tradeState
            extract
                Instruction {
                    before: item,
                    primitiveInstruction: PrimitiveInstruction {
                        contractFormation: if item -> state -> positionState = PositionStatusEnum -> Formed
                            then Create_ContractFormationInstruction(
                                    item -> trade -> contractDetails -> documentation
                                ),
                        execution: ExecutionInstruction {
                            product: item -> trade -> product,
                            priceQuantity: item -> trade -> tradeLot only-element -> priceQuantity,
                            counterparty: item -> trade -> counterparty,
                            ancillaryParty: item -> trade -> ancillaryParty,
                            parties: item -> trade -> party,
                            partyRoles: item -> trade -> partyRole,
                            executionDetails: Create_PackageExecutionDetails(
                                    item -> trade -> executionDetails,
                                    pairReference,
                                    componentId
                                ),
                            tradeDate: item -> trade -> tradeDate,
                            tradeIdentifier: item -> trade -> tradeIdentifier,
                            ...
                        },
                        ...
        }}

func Create_ShapingInstruction: <"Creates a set of instructions to shape a trade based on shaped quantities and a package ID. The original trade is closed and split into (smaller) shaped trades based on a set of trade lots containing the shaped quantities and an identifier for each shaped trade. A package component is created based on the package ID and the list of identifiers for the shaped trades. That package component is then added onto the execution details of every shaped trade.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be shaped.">
        tradeLots TradeLot (2..*) <"The shaped quantities provided as full set of trade lots with price and quantity. Each trade lot also contains an identifier to associate to the corresponding shaped trade. Shaping must result in at least 2 shaped trades.">
        shapeIdentifier Identifier (1..1) <"The package ID of the shaped trades.">
    output:
        instruction PrimitiveInstruction (1..1)

    alias componentId: <"Extract the trade identifier from each trade lot. This list will be used as the componentId attribute of the package.">
        tradeLots extract item -> lotIdentifier only-element

    set instruction -> split -> breakdown: <"Sets the first part of the split to be a termination instruction for the existing trade.">
        [Create_TerminationInstruction(tradeState)]

    add instruction -> split -> breakdown: <"The second part of the split consists in a quantity change and a new execution for each provided trade lot. The quantity change takes care of the shaping according to the provided quantities. The execution adds the required package component to the execution details.">
        tradeLots
            extract priceQuantity
            then extract
                PrimitiveInstruction {
                    contractFormation: if tradeState -> state -> positionState = PositionStatusEnum -> Formed
                        then Create_ContractFormationInstruction(
                                tradeState -> trade -> contractDetails -> documentation
                            ),
                    execution: ExecutionInstruction {
                        product: tradeState -> trade -> product,
                        priceQuantity: tradeState -> trade -> tradeLot only-element -> priceQuantity,
                        counterparty: tradeState -> trade -> counterparty,
                        ancillaryParty: tradeState -> trade -> ancillaryParty,
                        parties: tradeState -> trade -> party,
                        partyRoles: tradeState -> trade -> partyRole,
                        executionDetails: Create_PackageExecutionDetails(
                                tradeState -> trade -> executionDetails,
                                shapeIdentifier,
                                componentId
                            ),
                        tradeDate: tradeState -> trade -> tradeDate,
                        tradeIdentifier: tradeState -> trade -> tradeIdentifier,
                        ...
                    },
                    quantityChange: QuantityChangeInstruction {
                        change: item,
                        direction: QuantityChangeDirectionEnum -> Replace,
                        lotIdentifier: empty
                    },
                    ...
                }

func Create_PartialDeliveryPrimitiveInstruction: <"Creates the primitive instruction for partial delivery of a repo transaction at settlement.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be closed.">
        deliveredPriceQuantity PriceQuantity (1..*) <"The price and quantity of the delivered amount.">
    output:
        instruction PrimitiveInstruction (1..1)

    set instruction -> split -> breakdown: <"Sets the first part of the split to be a termination instruction for the existing trade.">
        [Create_TerminationInstruction(tradeState)]

    set instruction -> split -> breakdown: <"Sets the first part of the split to be a termination instruction for the existing trade.">
        [
            PrimitiveInstruction {
                quantityChange: QuantityChangeInstruction {
                    change: deliveredPriceQuantity,
                    direction: QuantityChangeDirectionEnum -> Replace,
                    lotIdentifier: tradeState -> trade -> tradeLot -> lotIdentifier
                },
                ...
            }
        ]

func Create_RepricePrimitiveInstruction: <"Creates the primitive instructions for a repricing that alters the cash amount of the trade. Transaction value and variation margin are processed separately as are transfers of cash and securities.">
    inputs:
        tradeState TradeState (1..1) <"The original trade state and trade to be repriced.">
        newAllinPrice number (1..1) <"The collateral new all-in price.">
        newCashValue number (1..1) <"The new cash amount.">
        effectiveRepriceDate AdjustableOrRelativeDate (1..1) <"The date to reprice the collateral">
    output:
        instruction PrimitiveInstruction (1..1)

    alias oldPriceQuantity: tradeState -> trade -> tradeLot -> priceQuantity

    alias currentAssetPrice: <"Filter interest rate price and make it into a single element">
        oldPriceQuantity
            extract price
            then flatten
            then filter priceType = PriceTypeEnum -> AssetPrice
            then only-element

    alias newPrice: <"Create the new price object.">
        Price {
            value: newAllinPrice,
            unit: currentAssetPrice -> unit,
            perUnitOf: currentAssetPrice -> perUnitOf,
            priceType: currentAssetPrice -> priceType,
            priceExpression: currentAssetPrice -> priceExpression,
            composite: currentAssetPrice -> composite,
            arithmeticOperator: currentAssetPrice -> arithmeticOperator,
            cashPrice: currentAssetPrice -> cashPrice,
            datedValue: empty
        }

    alias changeCashQuantity: <"Create distinct list of Quantity with value set to newAssetQuantity">
        tradeState -> trade -> tradeLot only-element -> priceQuantity -> quantity
            extract
                NonNegativeQuantitySchedule {
                    value: newCashValue,
                    unit: unit,
                    ...
                }
            then distinct

    alias newPriceQuantity: <"Create the new price quantity object.">
        PriceQuantity {
            price: [newPrice],
            quantity: changeCashQuantity,
            ...
        }

    set instruction -> split -> breakdown: [Create_TerminationInstruction(tradeState)]

    add instruction -> split -> breakdown: <"Sets the second part of the split to be a new contract with a new asset payout.">
        [
            PrimitiveInstruction {
                quantityChange: QuantityChangeInstruction {
                    change: [newPriceQuantity],
                    direction: QuantityChangeDirectionEnum -> Replace,
                    lotIdentifier: empty
                },
                termsChange: Create_EffectiveOrTerminationDateTermChangeInstruction(
                        tradeState -> trade -> product,
                        effectiveRepriceDate,
                        empty
                    ),
                ...
            }
        ]

func Create_AdjustmentPrimitiveInstruction: <"Creates the primitive instructions for a repricing that alters the collateral quantity and value of the trade. Transaction value and variation margin are processed separately as are transfers of cash and securities.">
    inputs:
        tradeState TradeState (1..1) <"The original trade state and trade to be repriced.">
        newAllinPrice number (1..1) <"The collateral new all-in price.">
        newAssetQuantity number (1..1) <"The collateral new quantity.">
        effectiveRepriceDate AdjustableOrRelativeDate (1..1) <"The date to reprice the collateral">
    output:
        instruction PrimitiveInstruction (1..1)

    alias oldPriceQuantity: tradeState -> trade -> tradeLot -> priceQuantity

    alias currentAssetPrice: <"Filter interest rate price and make it into a single element">
        oldPriceQuantity
            extract price
            then flatten
            then filter priceType = PriceTypeEnum -> AssetPrice
            then only-element

    alias newPrice: <"Create the new price object.">
        Price {
            value: newAllinPrice,
            unit: currentAssetPrice -> unit,
            perUnitOf: currentAssetPrice -> perUnitOf,
            priceType: currentAssetPrice -> priceType,
            priceExpression: currentAssetPrice -> priceExpression,
            composite: currentAssetPrice -> composite,
            arithmeticOperator: currentAssetPrice -> arithmeticOperator,
            cashPrice: currentAssetPrice -> cashPrice,
            datedValue: empty
        }

    alias changeQuantity: <"Create distinct list of Quantity with value set to newAssetQuantity">
        tradeState -> trade -> tradeLot only-element -> priceQuantity -> quantity
            extract
                NonNegativeQuantitySchedule {
                    value: newAssetQuantity,
                    unit: unit,
                    ...
                }
            then distinct

    alias newPriceQuantity: <"Create the new price quantity object.">
        PriceQuantity {
            price: [newPrice],
            quantity: changeQuantity,
            ...
        }

    condition SingleTradeLot: <"This repricing function applies only to trades with a single lot.">
        tradeState -> trade -> tradeLot count = 1

    set instruction -> split -> breakdown: [Create_TerminationInstruction(tradeState)]

    add instruction -> split -> breakdown: <"Sets the second part of the split to be a new contract with a new asset payout.">
        [
            PrimitiveInstruction {
                quantityChange: QuantityChangeInstruction {
                    change: [newPriceQuantity],
                    direction: QuantityChangeDirectionEnum -> Replace,
                    lotIdentifier: empty
                },
                termsChange: Create_EffectiveOrTerminationDateTermChangeInstruction(
                        tradeState -> trade -> product,
                        effectiveRepriceDate,
                        empty
                    ),
                ...
            }
        ]

func Create_SubstitutionPrimitiveInstruction: <"Creates the primitive instructions for a substitution of collateral by replacing the assetpayout of the trade.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be for substitution of collateral.">
        effectiveDate AdjustableOrRelativeDate (1..1) <"The date to close and open a new trade with new collateral.">
        newCollateralPortfolio CollateralPortfolio (1..1) <"New collateral portfolio to subtitute for the original collateral.">
        priceQuantity PriceQuantity (1..*) <"The price and quantity of the substituted product.">
    output:
        instruction PrimitiveInstruction (1..1)

    condition SecurityFinance: <"Only security finance products can substitute collateral.">
        tradeState -> trade -> product -> economicTerms -> collateral exists

    set instruction: <"Sets the second part of the split to be a new contract with a new asset payout.">
        PrimitiveInstruction {
            quantityChange: QuantityChangeInstruction {
                change: priceQuantity,
                direction: QuantityChangeDirectionEnum -> Replace,
                lotIdentifier: empty
            },
            termsChange: Create_SubstitutionInstruction(
                    tradeState -> trade -> product,
                    effectiveDate,
                    newCollateralPortfolio
                ),
            ...
        }

func Create_SubstitutionInstruction: <"Creates the terms change instruction that updates the payout with the new substitution payout.">
    inputs:
        product NonTransferableProduct (1..1) <"The original contractual product to be used as the basis of the new trade.">
        effectiveDate AdjustableOrRelativeDate (1..1) <"The effective date of the substitution.">
        newCollateralPortfolio CollateralPortfolio (1..1) <"New collateral portfolio to substitute for the original collateral.">
    output:
        termsChangeInstruction TermsChangeInstruction (1..1)

    set termsChangeInstruction:
        Create_EffectiveOrTerminationDateTermChangeInstruction(
                product,
                effectiveDate,
                empty
            )

    set termsChangeInstruction -> product -> economicTerms -> collateral -> collateralPortfolio:
        newCollateralPortfolio

func Qualify_Substitution: <"Qualification of a collateral substitution event.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeEconomicterms: ExtractBeforeEconomicTerms(businessEvent)

    alias openEconomicTerms: ExtractOpenEconomicTerms(businessEvent)

    set is_event:
        beforeEconomicterms exists
            and openEconomicTerms exists
            and openEconomicTerms -> payout <> beforeEconomicterms -> payout
            and openEconomicTerms -> collateral <> beforeEconomicterms -> collateral
            and openEconomicTerms -> effectiveDate = beforeEconomicterms -> terminationDate
            and openEconomicTerms -> terminationDate = beforeEconomicterms -> terminationDate

func Create_PackageExecutionDetails: <"Add a package component to an execution details object. This package component is constructed using an identifier for the package and the list of identifiers for its components.">
    inputs:
        executionDetails ExecutionDetails (0..1) <"The original execution details. These may be empty.">
        listId Identifier (1..1) <"The identifier for the package.">
        componentId Identifier (2..*) <"The list of identifiers for the package components. There must be at least 2.">
    output:
        newExecutionDetails ExecutionDetails (1..1)

    set newExecutionDetails -> executionType: executionDetails -> executionType
    set newExecutionDetails -> executionVenue: executionDetails -> executionVenue
    set newExecutionDetails -> packageReference -> listId: listId
    set newExecutionDetails -> packageReference -> componentId: componentId

func NewTradeInstructionOnlyExists:
    inputs:
        primitiveInstruction PrimitiveInstruction (1..1)
    output:
        result boolean (1..1)
    set result:
        primitiveInstruction -> execution only exists
            or (primitiveInstruction -> execution, primitiveInstruction -> contractFormation) only exists

func TradeNoExecutionDetails:
    inputs:
        trade Trade (1..1)
    output:
        newTrade Trade (1..1)

    set newTrade: trade
    set newTrade -> executionDetails: EmptyExecutionDetails()

func EmptyExecutionDetails:
    [codeImplementation]
    output:
        executionDetails ExecutionDetails (0..1)

func Create_OnDemandInterestPaymentPrimitiveInstruction: <"An instruction to make a interium interest payment by adding a payout leg to the deal.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be modified.">
        interestAmount Money (1..1)
        settlementDate SettlementDate (1..1)
    output:
        instruction PrimitiveInstruction (1..1) <"Result is a Transfer Instruction.">

    alias interestRatePayout:
        tradeState -> trade -> product -> economicTerms -> payout -> InterestRatePayout only-element

    alias payerReceiver:
        PartyReferencePayerReceiver {
            payerPartyReference: ExtractCounterpartyByRole(
                    tradeState -> trade -> counterparty,
                    interestRatePayout -> payerReceiver -> payer
                ) -> partyReference,
            receiverPartyReference: ExtractCounterpartyByRole(
                    tradeState -> trade -> counterparty,
                    interestRatePayout -> payerReceiver -> receiver
                ) -> partyReference,
            ...
        }

    alias transfer: <"A fully structured Transfer or the following need to be provided to create a cashflow.">
        Transfer {
            quantity: NonNegativeQuantity {
                value: interestAmount -> value,
                unit: interestAmount -> unit,
                ...
            },
            asset: Asset {
                Cash: Cash {
                    identifier: AssetIdentifier {
                        identifier: interestAmount -> unit -> currency,
                        identifierType: CurrencyCode
                    },
                    ...
                },
                ...
            },
            settlementDate: settlementDate -> adjustableOrRelativeDate,
            payerReceiver: payerReceiver,
            transferExpression: TransferExpression {
                scheduledTransfer: ScheduledTransfer {
                    transferType: NetInterest,
                    ...
                },
                ...
            },
            ...
        }

    condition InterestRatePayoutExists: <"Only a contractual product with a single interest rate payout can have an on-demand interest payment.">
        interestRatePayout exists

    condition Currency: <"The currency of the interest amount must match the currency of the original interest rate payout.">
        interestAmount -> unit -> currency = interestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency

    condition SettlementDate: <"The settlement date must be specified as an adjustable or relative date.">
        settlementDate -> adjustableOrRelativeDate exists

    set instruction:
        PrimitiveInstruction {
            transfer: TransferInstruction {
                transferState: TransferState {
                    transfer: transfer,
                    ...
            }},
            ...
        }

func Create_TerminationInstruction: <"Creates the relevant primitive instruction for a termination, which consists in a quantity change to bring the quantity to zero.">
    inputs:
        tradeState TradeState (1..1) <"The original trade to be termintaed.">
    output:
        instruction PrimitiveInstruction (1..1)

    alias changeQuantity: <"Create distinct list of Quantity with value set to zero.">
        tradeState -> trade -> tradeLot only-element -> priceQuantity -> quantity
            extract
                NonNegativeQuantitySchedule {
                    value: 0.0,
                    unit: item -> unit,
                    ...
                }
            then distinct

    alias changePriceQuantity: <"Create change PriceQuantity for QuantityChangeInstruction.">
        PriceQuantity {
            quantity: changeQuantity,
            ...
        }

    set instruction -> quantityChange: <"Set primitive instruction to be only a quantity change instruction (with values set to zero).">
        QuantityChangeInstruction {
            change: changePriceQuantity,
            direction: QuantityChangeDirectionEnum -> Replace,
            lotIdentifier: empty
        }

func Create_BusinessEvent: <"Creates a business event from instructions containing primitive instructions and optionally a trade state.">
    [creation BusinessEvent]
    inputs:
        instruction Instruction (1..*)
        intent EventIntentEnum (0..1)
        eventDate date (1..1)
        effectiveDate date (1..1)
    output:
        businessEvent BusinessEvent (1..1)

    add businessEvent -> instruction: instruction

    set businessEvent -> intent: intent

    set businessEvent -> eventDate: eventDate

    set businessEvent -> effectiveDate: effectiveDate

    add businessEvent -> after:
        instruction
            extract
                if item -> primitiveInstruction -> split exists
                then Create_Split(
                            item -> primitiveInstruction -> split -> breakdown,
                            item -> before
                        )
                else if item -> primitiveInstruction -> exercise exists
                then Create_Exercise(
                            item -> primitiveInstruction -> exercise,
                            item -> before
                        )
                else [Create_TradeState(item -> primitiveInstruction, item -> before)]
            then flatten

// TODO: we should have a condition to ensure that no trade is 'lost' between the before(s) and the after(s).
// This can be implemented by looking at the trade identifier attribute on the before state, and making sure it exists in the after state.
// So for instance where there is a party change (which results in a different trade with a different trade id), the original trade should be split first, and one of the copies should 'close' the trade.
func Create_TradeState: <"Creates a single trade state by applying primitive instructions to an existing trade state (optional in case an execution instruction is included).
    The primitive instructions are applied in the following order:
        Always first:
            - execution, if it exists, otherwise a before state must be provided
        The following 3 can be executed in any order, because they touch separate components of the trade:
            - quantity change
            - terms change
            - party change
        Always last:
            - contract formation, otherwise the contract could be invalid.">
    inputs:
        primitiveInstruction PrimitiveInstruction (0..1) <"The set of primitive instructions to apply to the trade.">
        before TradeState (0..1) <"The original trade on which the primitive instructions are applied">
    output:
        after TradeState (1..1) <"The returned trade state must be of single cardinality. Where a different trade is created and the original trade must be persisted (for instance showing as 'closed'), it should be preceded by a split instruction.">

    alias execution: <"Create execution if instruction exists. If not, then before must exist.">
        if primitiveInstruction -> execution is absent
        then before
        else Create_Execution(primitiveInstruction -> execution)

    alias quantityChange: <"Apply quantity change if instructions exist.">
        if primitiveInstruction -> quantityChange is absent
        then execution
        else Create_QuantityChange(primitiveInstruction -> quantityChange, execution)

    alias termsChange: <"Apply terms change if instructions exist.">
        if primitiveInstruction -> termsChange is absent
        then quantityChange
        else Create_TermsChange(primitiveInstruction -> termsChange, quantityChange)

    alias partyChange: <"Apply party change if instructions exist.">
        if primitiveInstruction -> partyChange is absent
        then termsChange
        else Create_PartyChange(
                primitiveInstruction -> partyChange -> counterparty,
                primitiveInstruction -> partyChange -> ancillaryParty,
                primitiveInstruction -> partyChange -> partyRole,
                primitiveInstruction -> partyChange -> tradeId,
                termsChange /*after*/
            )

    alias contractFormation: <"Create contract formation if instructions exist.">
        if primitiveInstruction exists
                and primitiveInstruction -> contractFormation is absent
        then partyChange
        else Create_ContractFormation(
                primitiveInstruction -> contractFormation,
                partyChange
            )

    alias transfer:
        if primitiveInstruction -> transfer is absent
        then contractFormation
        else Create_Transfer(primitiveInstruction -> transfer, contractFormation)

    alias reset:
        if primitiveInstruction -> reset is absent
        then transfer
        else Create_Reset(primitiveInstruction -> reset, transfer)

    alias indexTransition:
        if primitiveInstruction -> indexTransition is absent
        then reset
        else Create_IndexTransitionTermsChange(
                primitiveInstruction -> indexTransition,
                reset
            )

    alias observation:
        if primitiveInstruction -> observation is absent
        then indexTransition
        else Create_Observation(primitiveInstruction -> observation, indexTransition)

    alias valuation:
        if primitiveInstruction -> valuation is absent
        then observation
        else Create_Valuation(primitiveInstruction -> valuation, observation)

    alias stockSplit:
        if primitiveInstruction -> stockSplit is absent
        then valuation
        else Create_StockSplit(primitiveInstruction -> stockSplit, valuation)

    condition NoSplit: <"The primitive instruction cannot contain a split, as this function is designed to return a single trade state.">
        primitiveInstruction -> split is absent

    set after: <"Initiate applying primitive instructions.">
        stockSplit

    set after -> state -> closedState:
        if contractFormation -> state -> positionState = PositionStatusEnum -> Closed
        then ClosedState {
                state: ClosedStateEnum -> Terminated,
                activityDate: empty, // TODO: set this property
                ...
            }

func ExtractBeforeEconomicTerms:
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        economicTerms EconomicTerms (0..1)

    set economicTerms:
        businessEvent -> instruction only-element -> before -> trade -> product -> economicTerms

func ExtractOpenEconomicTerms:
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        economicTerms EconomicTerms (0..1)

    set economicTerms:
        FilterOpenTradeStates(businessEvent -> after) only-element -> trade -> product -> economicTerms

func ExtractBeforeTrade:
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        trade Trade (0..1)

    set trade: businessEvent -> instruction only-element -> before -> trade

func ExtractAfterTrade:
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        trade Trade (0..1)

    set trade: FilterOpenTradeStates(businessEvent -> after) only-element -> trade

func ExtractTradePurchasePrice:
    inputs:
        tradableProduct TradableProduct (1..1)
    output:
        value number (0..*)

    set value:
        tradableProduct -> tradeLot only-element -> priceQuantity
            extract item -> quantity
            then flatten
            then extract item -> value

func ExtractTradeCollateralQuantity:
    inputs:
        tradableProduct TradableProduct (1..1)
    output:
        value number (0..*)

    set value:
        tradableProduct -> tradeLot only-element -> priceQuantity
            extract item -> quantity
            then flatten
            then extract item -> value

func ExtractTradeCollateralPrice:
    inputs:
        tradableProduct TradableProduct (1..1)
    output:
        value number (0..*)

    set value:
        tradableProduct -> tradeLot only-element -> priceQuantity
            extract item -> price
            then flatten
            then filter item -> priceType = PriceTypeEnum -> AssetPrice
            then extract item -> value

func Create_ExposureFromTrades: <"Builds an Exposure structure from a list of trades.">
    inputs:
        trades TradeState (0..*)
    output:
        exposure Exposure (0..1)

    add exposure -> tradePortfolio -> positions:
        trades
            extract
                Position {
                    cashBalance: empty,
                    priceQuantity: item -> trade -> tradeLot -> priceQuantity,
                    tradeReference: item,
                    product: Product {
                        NonTransferableProduct: item -> trade -> product,
                        ...
        }}

    set exposure -> tradePortfolio -> lineage -> tradeReference: trades -> trade first


================================================================================
FILE: rosetta-source/src/main/rosetta/event-common-type.rosetta
================================================================================

namespace cdm.event.common : <"Business event concepts: primitives, contract state and associated state transition function specifications.">
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.position.*
import cdm.event.workflow.*
import cdm.legaldocumentation.common.*
import cdm.observable.asset.*
import cdm.observable.event.*
import cdm.product.asset.*
import cdm.product.collateral.*
import cdm.product.common.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*
import cdm.product.template.*

type ContractFormationInstruction: <"Specifies instructions to create a fully formed contract, with optional legal agreements.">
    legalAgreement LegalAgreement (0..*) <"Optional legal agreements associated to the contract being formed, for instance a master agreement.">
    condition ExecutedAgreements: <"The full formation of a contract can only be completed with executed legal agreements.">
        if legalAgreement exists
        then legalAgreement -> agreementDate exists

type Instruction: <"Instruction to a function that will be used to perform a business event">
    [rootType]
    primitiveInstruction PrimitiveInstruction (0..1) <"Specifies the primitive instructions that will be used to call primitive event functions.">
    before TradeState (0..1) <"Specifies the trade state that will be acted on by the primitive event functions.">
        [metadata reference]

    condition ExclusiveSplitPrimitive: <"A split primitive is exclusive and cannot be combined with other primitives. Instead, the primitive instructions to be applied to each branch of the split must be specified as breakdowns in the split instruction itself.">
        if primitiveInstruction -> split exists
        then primitiveInstruction -> split only exists

    condition NewTrade: <"There must be no before trade state if the primitive instructions contain an execution, and vice versa. An instruction only handles 1 trade at a time.">
        (if primitiveInstruction -> execution exists then before is absent)
            and (if before is absent then primitiveInstruction -> execution exists)

type PrimitiveInstruction: <"A Primitive Instruction describes the inputs required to pass into the corresponding PrimitiveEvent function.">
    contractFormation ContractFormationInstruction (0..1) <"Specifies instructions describing an contract formation primitive event.">
    execution ExecutionInstruction (0..1) <"Specifies instructions describing an execution primitive event.">
    exercise ExerciseInstruction (0..1) <"Specifies instructions describing an exercise primitive event.">
    partyChange PartyChangeInstruction (0..1) <"Specifies instructions describing a party change primitive event.">
    quantityChange QuantityChangeInstruction (0..1) <"Specifies instructions describing an quantity change primitive event.">
    reset ResetInstruction (0..1) <"Specifies instructions describing a reset event.">
    split SplitInstruction (0..1) <"Specifies instructions to split a trade into multiple branches.">
    termsChange TermsChangeInstruction (0..1) <"Specifies instructions describing a terms change primitive event.">
    transfer TransferInstruction (0..1) <"Specifies instructions describing a transfer primitive event.">
    indexTransition IndexTransitionInstruction (0..1) <"Specifies inputs needed to process a Index Transition business event.">
    stockSplit StockSplitInstruction (0..1) <"Specifies inputs needed to process a Stock Split business event.">
    observation ObservationInstruction (0..1) <"Specifies inputs needed to process an observation.">
    valuation ValuationInstruction (0..1) <"Specifies inputs needed to process an update of a valuation.">

type BusinessEvent extends EventInstruction: <"A business event represents a life cycle event of a trade. The combination of the state changes results in a qualifiable life cycle event. An example of a Business Event is a PartialTermination which is a defined by a quantity change primitive event.">
    [metadata key]
    [rootType]

    eventQualifier string (0..1) <"The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic which qualifies the lifecycle event as a function of its features (e.g. PartialTermination, ClearingSubmission, Novation, ...).">
    after TradeState (0..*) <"Specifies the after trade state(s) created.">

    condition EventDate:
        eventDate exists

type CounterpartyPositionBusinessEvent: <"A business event represents a life cycle event of a position. The combination of the state changes results in a qualifiable life cycle event.">
    intent PositionEventIntentEnum (1..1) <"The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from the event features. As a result it is only associated with those primitives that can give way to such ambiguity, the quantityChange being one of those.">
    corporateActionIntent CorporateActionTypeEnum (0..1) <"The intent of a corporate action on the position.">
    eventDate date (0..1) <"Specifies the date on which the event is taking place. This date is equal to the trade date in the case of a simple execution.  However it can be different from the trade date, for example in the case of a partial termination.">
    effectiveDate date (0..1) <"The date on which the event contractually takes effect, when different from the event date.">
    packageInformation IdentifiedList (0..1) <"Specifies the package information in case the business event represents several trades executed as a package (hence this attribute is optional). The package information is only instantiated once at the business event level to preserve referential integrity, whereas individual trades make reference to it to identify that they are part of a package.">
    after CounterpartyPositionState (0..*) <"Specifies the after position state(s) created.">

type ObservationInstruction: <"Specifies inputs needed to process an observation.">
    observationEvent ObservationEvent (1..1) <"Contains all information related to an observation.">

type ValuationInstruction: <"Specifies inputs needed to process a valuation.">
    valuation Valuation (1..*) <"Contains all information related to a valuation.">
    replace boolean (1..1) <"Specifies whether the previous valuation tracks in the valuation history are removed (True) or kept (False).">

type ExecutionInstruction: <"Specifies instructions for execution of a transaction, consisting of a product, price, quantity, parties, trade identifier, execution details, and settlement terms.">
    product NonTransferableProduct (1..1) <"Defines the financial product to be executed and contract formed.">
    priceQuantity PriceQuantity (1..*) <"Defines the prices (e.g. spread, equity price, FX rate), quantities (e.g. currency amount, no. shares) and settlement terms (e.g. initial fee, broker fee, up-front cds payment or option premium settlement) associated with the constituents of the transacted product.">
    counterparty Counterparty (2..2) <"Maps two defined parties to counterparty enums for the transacted product.">
    ancillaryParty AncillaryParty (0..*) <"Maps any ancillary parties, e.g. parties involved in the transaction that are not one of the two principal parties.">
    parties Party (2..*) <"Defines all parties to that execution, including agents and brokers.">
    partyRoles PartyRole (0..*) <"Defines the role(s) that party(ies) may have in relation to the execution.">
    executionDetails ExecutionDetails (1..1) <"Specifies the type and venue of execution, e.g. via voice, or electronically.">
    tradeDate date (1..1) <"Denotes the trade/execution date.">
        [metadata id]
    tradeTime TimeZone (0..1) <"Denotes the trade time and timezone as agreed by the parties to the trade.">
        [metadata id]
    tradeIdentifier TradeIdentifier (1..*) <"Denotes one or more identifiers associated with the transaction.">
    collateral Collateral (0..1) <"Detail the collateral requirement anticipated with the transaction.">
    lotIdentifier Identifier (0..1) <"Lot Identifier associated with the transaction.">

type ExerciseInstruction: <"Specifies the information required to communicate the choices made by the exercising party, in a financial product endowing the party with at least one option.">

    exerciseQuantity PrimitiveInstruction (1..1) <"Contains instructions for exercising the option including a quantity change, and optionally a transfer.">
    exerciseOption OptionPayout (0..1) <"Specifies the Option Payout being exercised on the trade.">
        [metadata reference]
    exerciseDate AdjustableOrAdjustedDate (0..1) <"Specifies the date on which an option contained within the financial product would be exercised. The date may be omitted if the contractual product allows for only a single date of exercise (European exercise).">
    exerciseTime BusinessCenterTime (0..1) <"Specifies the time at which an option contained within the financial product woulld be exercised. The time may be omitted if the contractual product allows for only a single time of exercise (European exercise). ">
    replacementTradeIdentifier TradeIdentifier (0..*) <"Specifies the trade identifier to apply to the replacement trade for physical exercise.">

type ResetInstruction: <"Defines the information needed to create a Reset Business Event. ">
    payout Payout (1..*)
        [metadata reference]
    rateRecordDate date (0..1) <"Specifies the 'Rate Record Day' for a Fallback rate.  Fallback rate fixing processes typically set the fixing rate in arrears, i.e., the Fallback Rate corresponding to a Rate Record Date is set at the end of the interest accural period.  When this applies, Reset->resetDate occurs at the end of the interest period, and the Reset->rateRecordDate occurs near the start of the interest period.  The Reset->rateRecordDate and Reset->observations->observationIdentifier->observationDate will differ if a Fallback rate is unavailable on the Rate Record Date, and the latest previous available rate is used as the observation.">
    resetDate date (1..1) <"Specifies the date on which the reset is occuring.">

type CalculateTransferInstruction: <"Defines the tradeState or payout on which to create a Transfer along with all necessary resets.">
    tradeState TradeState (1..1)
    payout Payout (1..1)
        [metadata reference]
    resets Reset (0..*)
    payerReceiver PayerReceiver (0..1)
    quantity Quantity (0..1) <"Specifies quantity amount returned if not the full amount from the TradeState, e.g. partial return">
    date date (0..1)

type TransferInstruction: <"Defines the payout on which to create a Transfer along with all necessary resets.">
    transferState TransferState (0..*) <"Specifies the terms and state of a transfers.">

type QuantityChangeInstruction: <"Instructions required to create a Quantity Change Primitive Event, which can be either an increase, a decrease or a replacement. An increase adds a new trade lot to the original trade, whereas a decrease subtracts from an existing trade lot's quantity. A replacement updates the quantity of an existing trade lot to the new value.">
    change PriceQuantity (1..*) <"Quantity by which the trade is being increased, decreased or replaced, and the price at which such quantity change is agreed. The quantity change should always be specified as a positive number, with the direction (increase/decrease/replacement) being specified by the direction enumeration. A fee can also be associated to the quantity change by specifying a Price component of type CashPrice, including the corresponding settlement date and direction.">
    direction QuantityChangeDirectionEnum (1..1) <"Direction of the quantity change specified as either an increase, decrease or replacement.">
    lotIdentifier Identifier (0..*) <"Identifier for the new lot (in case of increase) or for the existing lot to be changed(in case of decrease or replacement). This optional attribute is mandatory in case of a decrease or replacement if the initial trade state contains multiple trade lots.">

type IndexTransitionInstruction: <"Defines the information needed to create a Index Transition Business Event.">
    priceQuantity PriceQuantity (1..*) <"Specifies both new floating rate index and spread adjustment for each leg to be updated.  The spread adjustment accounts for the difference between the old floating rate index relative to the new one. This spread amount is added to the existing spread to determine the new spread, which is applied from the specified effective date forward. In the case of the IBOR Fallback Rate Adjustments, the adjustment spread (also known as the Fallback Adjustment) accounts for two distinctions: i) the fact that the replacement Risk-Free Rate is an overnight rate while IBORs have term structures (e.g., 1, 3, 6-month LIBOR); and (ii) the historical spread differential between IBORs and their term equivalent Overnight Risk-Free Rate compounded rates.">
    effectiveDate date (1..1) <"Specifies the effective date of the index transition event. This is first date on which the floating rate calculation will use the new floating rate index and adjusted spread in the floating rate calculation.">
    cashTransfer Transfer (0..1) <"Specifies the cash transfer that can optionally be tied to an index transition event.">

    condition PriceQuantity:
        priceQuantity -> price -> priceType contains PriceTypeEnum -> InterestRate
            and priceQuantity -> observable -> Index -> InterestRateIndex exists
            and priceQuantity -> quantity is absent

type TermsChangeInstruction: <"Specifies instructions for terms change consisting of the new transaction terms, and the renegotiation fee.">
    product NonTransferableProduct (0..1) <"product to be changed">
    ancillaryParty AncillaryParty (0..*) <"ancillary party to be changed">
    adjustment NotionalAdjustmentEnum (0..1)

    condition AtLeastOneOf:
        (product exists or ancillaryParty exists or adjustment exists)

type SplitInstruction: <"Specifies instructions for a split, consisting of a breakdown of instructions to be applied to each branch of the split. This instruction can be used to duplicate a trade, as in a clearing scenario, or to split a trade into smaller quantities (in which case each breakdown instruction needs to include a quantity change), as in an allocation.">
    // Should cardinality be (2..*)?
    breakdown PrimitiveInstruction (1..*) <"Each split breakdown specifies the set of primitive instructions to be applied to a single branch of that split. N split breakdowns result in N output trades, which include the original trade. Instructions for how to handle the original trade (e.g. if it must be closed) must be specified in one of the breakdowns.">

type PartyChangeInstruction: <"Specifies instruction to change the party on a trade. This primitive instruction is used in a number of scenarios including: clearing, allocation and novation. The instrution must include a trade identifier, because a change of party effectively results in a different trade.">
    counterparty Counterparty (1..1) <"The new counterparty who is stepping into the trade. The stepping out counterparty is inferred based on the counterparty role that is being updated.">
    ancillaryParty AncillaryParty (0..1) <"Specifies an ancillary party to be added onto the new transaction, e.g. the original executing party in an allocation.">
    partyRole PartyRole (0..1) <"Specifies an additional party roles to be added on to the new transaction.">
    tradeId TradeIdentifier (1..*) <"The identifier to be assigned to the new trade post change of party.">

type TradeState: <"Defines the fundamental financial information that can be changed by a Primitive Event and by extension any business or life-cycle event. Each TradeState specifies where a Trade is in its life-cycle. TradeState is a root type and as such, can be created independently to any other CDM data type, but can also be used as part of the CDM Event Model.">
    [metadata key]
    [rootType]
    trade Trade (1..1) <"Represents the Trade that has been effected by a business or life-cycle event.">
    state State (0..1) <"Represents the State of the Trade through its life-cycle.">
    resetHistory Reset (0..*) <"Represents the updated Trade attributes which can change as the result of a reset event. Only the changed values are captured, leaving the remaining data attributes empty. See Create_Reset function for further details on how TradeState is used in the Reset event. The TradeState data type is used to maintain backwards compatibility with the current Reset mechanism.">
    transferHistory TransferState (0..*) <"Represents the updated Trade attributes which can change as the result of a transfer event.">
    observationHistory ObservationEvent (0..*) <"Represents the observed events related to a particular product or process, such as credit events or corporate actions.">
    valuationHistory Valuation (0..*)

type CounterpartyPositionState: <"Defines the fundamental financial information that can be changed by a Primitive Event and by extension any business or life-cycle event. Each PositionState specifies where a Position is in its life-cycle. PositionState is a root type and as such, can be created independently to any other CDM data type, but can also be used as part of the CDM Event Model.">
    [metadata key]
    [rootType]
    counterpartyPosition CounterpartyPosition (1..1) <"Represents the Position that has been effected by a business or life-cycle event.">
    state State (0..1) <"Represents the State of the Position through its life-cycle.">
    observationHistory ObservationEvent (0..*) <"Represents the observed events related to a particular product or process, such as credit events or corporate actions.">
    valuationHistory Valuation (0..*)

type ObservationEvent: <"Specifies the necessary information to create any observation event.">
    creditEvent CreditEvent (0..1) <"Specifies the necessary information to create a credit event.">
    corporateAction CorporateAction (0..1) <"Specifies the necessary information to create a corporate action.">

    condition:
        one-of

type Reset: <"Defines the reset value or fixing value produced in cashflow calculations, during the life-cycle of a financial instrument. The reset process defined in Create_Reset function joins product definition details with observations to compute the reset value.">
    [metadata key]
    resetValue Price (1..1) <"Specifies the reset or fixing value. The fixing value could be a cash price, interest rate, or other value.">
    resetDate date (1..1) <"Specifies the date on which the reset occurred.">
    rateRecordDate date (0..1) <"Specifies the 'Rate Record Day' for a Fallback rate.  Fallback rate fixing processes typically set the fixing rate in arrears, i.e., the Fallback Rate corresponding to a Rate Record Date is set at the end of the interest accural period.  When this applies, Reset->resetDate occurs at the end of the interest period, and the Reset->rateRecordDate occurs near the start of the interest period.  The Reset->rateRecordDate and Reset->observations->observationIdentifier->observationDate will differ if a Fallback rate is unavailable on the Rate Record Date, and the latest previous available rate is used as the observation.">
    observations Observation (1..*) <"Represents an audit of the observations used to produce the reset value. If multiple observations were necessary to produce the reset value, the aggregation method should be defined on the payout.">
        [metadata reference]
    averagingMethodology AveragingCalculation (0..1) <"Identifies the aggregation method to use in the case where multiple observations are used to compute the reset value and the method is not defined in a payout.">

    condition AveragingMethodologyExists: <"Ensures an averaging method is defined when more than one observation is used to compute the reset.">
        if observations count > 1 then averagingMethodology exists

type State: <"Defines the state of a trade at a point in the Trade's life cycle. Trades have many state dimensions, all of which are represented here. For example, states useful for position keeping are represented alongside those needed for regulatory reporting.">
    closedState ClosedState (0..1) <"Represents the qualification of what led to the trade's closure alongside the dates on which this closure took effect.">
    positionState PositionStatusEnum (0..1) <"Identifies the state of the position, to distinguish if just executed, formed, already settled, closed, etc.">

    condition ClosedStateExists: <"When the position state is identified as closed, the closed state must also be specified.">
        if positionState = PositionStatusEnum -> Closed
        then closedState exists

type TransferState: <"Defines the fundamental financial information associated with a Transfer event. Each TransferState specifies where a Transfer is in its life-cycle. TransferState is a root type and as such, can be created independently to any other CDM data type, but can also be used as part of the CDM Event Model.">
    [metadata key]
    [rootType]
    transfer Transfer (1..1) <"Represents the Transfer that has been effected by a business or life-cycle event.">
    transferStatus TransferStatusEnum (0..1) <"Represents the State of the Transfer through its life-cycle.">

type Transfer extends AssetFlowBase: <"Defines the movement of an Asset (eg cash, securities or commodities) between two parties on a date.">
    identifier Identifier (0..*) <"Represents a unique reference to the transfer.">
        [metadata scheme]
    payerReceiver PartyReferencePayerReceiver (1..1) <"Represents the parties to the transfer and their role.">
    settlementOrigin Payout (0..1) <"Represents the origin to the transfer as a reference for lineage purposes, whether it originated from trade level settlement terms or from payment terms on an economic payout.">
        [metadata reference]
    resetOrigin Reset (0..1) <"Represents the reset and observation values that were used to determine the transfer amount.">
    transferExpression TransferExpression (1..1) <"Specifies a transfer expression (cash price, performance amount, scheduled payment amount, etc.) to define the nature of the transfer amount and its source.">

type TransferExpression: <"Specifies a transfer expression (cash price, performance amount, scheduled payment amount, etc.) to define the nature of the transfer amount and its source.">
    priceTransfer FeeTypeEnum (0..1) <"Specifies a transfer amount exchanged as a price or fee for entering into a Business Event, e.g. Premium, Termination fee, Novation fee.">
    scheduledTransfer ScheduledTransfer (0..1) <"Specifies a transfer created from a scheduled or contingent event on a contract, e.g. Exercise, Performance, Credit Event">

    condition:
        one-of

type ScheduledTransfer:
    transferType ScheduledTransferEnum (1..1) <"Specifies a transfer created from a scheduled or contingent event on a contract, e.g. Exercise, Performance, Credit Event">
    corporateActionTransferType CorporateActionTypeEnum (0..1)

    condition CorporateActionTransferTypeExists: <"When transfer type is Performance or Transfer then the type of event must be specified.">
        if transferType = ScheduledTransferEnum -> CorporateAction
        then corporateActionTransferType exists

type TradeIdentifier extends Identifier: <"Defines a trade identifier as a special case of the generic identifier type, that also includes the trade identifier class.">
    identifierType TradeIdentifierTypeEnum (0..1) <"The enumerated classification of the identifier. Optional as a trade identifier may be party-specific, in which case it may not correspond to any established classification.">

type PositionIdentifier extends Identifier: <"Defines a position identifier as a special case of the generic identifier type, that also includes the position identifier class.">
    identifierType TradeIdentifierTypeEnum (0..1) <"The enumerated classification of the identifier. Optional as a position identifier may be party-specific, in which case it may not correspond to any established classification.">

type Valuation: <"Defines the value of an investment, asset, or security">
    amount Money (1..1) <"Current value of the outstanding contract">
    timestamp zonedDateTime (1..1) <"Date and time of the last valuation marked to market, provided by the central counterparty (CCP) or calculated using the current or last available market price of the inputs.">
    method ValuationTypeEnum (0..1) <"Method used for the valuation of the transaction by the valuation party.">
    source ValuationSourceEnum (0..1) <"Source of the valuation of the transaction by the valuation party.">
    scope ValuationScopeEnum (1..1) <" Defines the scope of the valuation, what it applies to e.g. the collateral or the trade">
    delta number (0..1) <"The ratio of the change in the price of a derivative transaction to the change in the price of the underlying. This field is applicable only to options and swaptions.">
    valuationTiming PriceTimingEnum (0..1) <"Denotes when the valuation was sourced during a business day.">
    priceComponent Price (0..1) <"Denotes the price used to compute the valuation.">

    condition ValuationType: <"The below condition ensures one and only one of the two attributes: 'Valuation Method' or 'Valuation Source' is allowed. Valuation of a trade or a portfolio is either internally calculated (via M2Market or M2Model methods) or supplied from an external source (e.g Central Counterparty's Valuation). Valuation cannot be based upon internal calculations and external source at the same time.">
        required choice method, source

type Trade extends TradableProduct: <"Defines the output of a financial transaction between parties - a Business Event. A Trade impacts the financial position (i.e. the balance sheet) of involved parties.">
    [metadata key]
		[docReference ICMA GMRA namingConvention "Transaction"
			provision "As defined in the GMRA, paragraph 1(a) and 1(b) Referring to the agreement between Buyer and Seller in which a Seller agrees to sell Securities against the payment of the purchase price by Buyer to Seller, with a simultaneous agreement by Buyer to sell to Seller Equivalent Securities at a future date. May be a Repurchase Transaction or Buy/Sell Back Transaction."]
    tradeIdentifier TradeIdentifier (1..*) <"Represents the identifier(s) that uniquely identify a trade for an identity issuer. A trade can include multiple identifiers, for example a trade that is reportable to both the CFTC and ESMA, and then has an associated USI (Unique Swap Identifier) UTI (Unique Trade Identifier).">
    tradeDate date (1..1) <"Specifies the date which the trade was agreed.">
        [metadata id]
    tradeTime TimeZone (0..1) <"Denotes the trade time and timezone as agreed by the parties to the trade.">
        [metadata id]
    party Party (0..*) <"Represents the parties to the trade. The cardinality is optional to address the case where the trade is defined within a BusinessEvent data type, in which case the party is specified in BusinessEvent.">
    partyRole PartyRole (0..*) <"Represents the role each specified party takes in the trade. further to the principal roles, payer and receiver.">
    executionDetails ExecutionDetails (0..1) <"Represents information specific to trades that arose from executions.">
    contractDetails ContractDetails (0..1) <"Represents information specific to trades involving contractual products.">
    clearedDate date (0..1) <"Specifies the date on which a trade is cleared (novated) through a central counterparty clearing service.">
        [deprecated]
    collateral Collateral (0..1) <"Represents the collateral obligations of a party.">
    account Account (0..*) <"Represents a party's granular account information, which may be used in subsequent internal processing.">
        [deprecated]

    condition SettlementPayout: <"When the product uses a settlement payout, both buyer and seller party roles, and a price, must exist.">
        if SettlementPayoutOnlyExists(product -> economicTerms -> payout)
        then partyRole -> role contains PartyRoleEnum -> Buyer
                and partyRole -> role contains PartyRoleEnum -> Seller
                and tradeLot -> priceQuantity -> price exists

    condition PackageTrade: <"When the trade is part of a package as specified in the execution details, the trade identifier must be found as one of the package components.">
        if executionDetails -> packageReference exists
        then executionDetails -> packageReference -> componentId -> assignedIdentifier contains tradeIdentifier -> assignedIdentifier

    condition DeliverableObligationsPhysicalSettlementMatrix: <"The below set of credit deliverable obligation provisions are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions cannot be omitted if the Credit Derivatives Physical Settlement Matrix doesn't governs the terms of the contract.">
        if (contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
                    or contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType is absent)
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations exists
        then (product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notSubordinated exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> specifiedCurrency exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notSovereignLender exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notDomesticCurrency exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notDomesticLaw exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notContingent exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notDomesticIssuance exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> assignableLoan exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> consentRequiredLoan exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> transferable exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> maximumMaturity exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> notBearer exists)
                and (product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> fullFaithAndCreditObLiability exists
                    or product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> generalFundObligationLiability exists
                    or product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> revenueObligationLiability exists)

    condition ObligationsPhysicalSettlementMatrix: <"The below set of obligation of the reference entity are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions cannot be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in case the case where an auction could not take place because of, say, liquidity considerations.">
        if (contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
                    or contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType is absent)
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations exists
        then (product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> notSubordinated exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> notSovereignLender exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> notDomesticLaw exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> notDomesticIssuance exists)
                and (product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> fullFaithAndCreditObLiability exists
                    or product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> generalFundObligationLiability exists
                    or product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> revenueObligationLiability exists)

    condition CreditEventsPhysicalSettlementMatrix: <"The below set of credit events are specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that those provisions can only be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in the case where an auction could not take place because of, say, liquidity considerations.">
        if (contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
                    or contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType is absent)
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents exists
        then (product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> bankruptcy exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> obligationDefault exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> obligationAcceleration exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> repudiationMoratorium exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> governmentalIntervention exists)

    condition RestructuringPhysicalSettlementMatrix: <"The below multiple holder obligation restructuring provisions is specified as optional boolean in FpML and the CDM because they would be specified as part of the Physical Settlement Matrix when such document governs the contract terms. As a result, this data rule specifies that this provision can only be omitted if the Physical Settlement Matrix governs the terms of the contract. This data rule also applies to cash settled contracts because those could still end-up being physically settled, in the case where an auction could not take place because of, say, liquidity considerations.">
        if (contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType all <> MatrixTypeEnum -> CreditDerivativesPhysicalSettlementMatrix
                    or contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix -> matrixType is absent)
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> restructuring exists
        then product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleHolderObligation exists

    condition AdditionalFixedPaymentsMortgages: <"The below set of additional fixed payment provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
        if ((product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> instrumentType any = InstrumentTypeEnum -> Debt
                        and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> debtType -> debtClass any = DebtClassEnum -> AssetBacked)
                    or contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualTermsSupplement -> contractualTermsSupplementType contains ContractualSupplementTypeEnum -> CDSonMBS)
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents exists
        then (product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> interestShortfallReimbursement exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> principalShortfallReimbursement exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents -> additionalFixedPayments -> writedownReimbursement exists)

    condition FloatingAmountEventsMortgages: <"The below set of floating amount events provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
        if ((product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> instrumentType any = InstrumentTypeEnum -> Debt
                        and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> debtType -> debtClass any = DebtClassEnum -> AssetBacked)
                    or contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualTermsSupplement -> contractualTermsSupplementType contains ContractualSupplementTypeEnum -> CDSonMBS)
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents exists
        then (product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents -> failureToPayPrincipal exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents -> writedown exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> floatingAmountEvents -> impliedWritedown exists)

    condition CreditEventsMortgages: <"The below set of credit events provisions are specified as optional boolean in FpML and the CDM because they only apply to mortgage credit default swaps. As a result, this data rule specifies that those provisions are required if the contract corresponds to a mortgage credit default swap. The provision related to the existence of the Contractual Term Supplement is meant to address the case where the underlier is a mortgage index.">
        if ((product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> instrumentType any = InstrumentTypeEnum -> Debt
                        and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> debtType -> debtClass any = DebtClassEnum -> AssetBacked)
                    or contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualTermsSupplement -> contractualTermsSupplementType contains ContractualSupplementTypeEnum -> CDSonMBS)
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents exists
        then (product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> failureToPayPrincipal exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> failureToPayInterest exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> distressedRatingsDowngrade exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> maturityExtension exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> writedown exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> impliedWritedown exists)

    condition HedgingParty: <"FpML specifies that there cannot be more than 2 hedging parties.">
        if partyRole -> role contains PartyRoleEnum -> HedgingParty
        then FilterPartyRole(partyRole, PartyRoleEnum -> HedgingParty) count <= 2

    condition DeterminingParty: <"FpML specifies that there cannot be more than 2 determining parties.">
        if partyRole -> role contains PartyRoleEnum -> DeterminingParty
        then FilterPartyRole(partyRole, PartyRoleEnum -> DeterminingParty) count <= 2

    condition BarrierDerterminationAgent: <"FpML specifies that there cannot be more than 1 barrier determination agent.">
        if partyRole -> role contains PartyRoleEnum -> BarrierDeterminationAgent
        then FilterPartyRole(partyRole, PartyRoleEnum -> BarrierDeterminationAgent) count <= 1

    condition ClearedDate: <"If the cleared date exists, it needs to be on or after the trade date.">
        if clearedDate exists then clearedDate >= tradeDate

    condition FpML_cd_1: <"FpML validation rule cd-1 - If referenceInformation exists, tradeDate must be before effectiveDate/unadjustedDate.">
        if product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
        then tradeDate < product -> economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate or tradeDate < product -> economicTerms -> effectiveDate -> adjustableDate -> adjustedDate

    condition FpML_cd_7: <"FpML validation rule cd-7 - If condition LongForm is true, then effectiveDate/dateAdjustments exists.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> masterConfirmationType is absent
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
        then product -> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> dateAdjustments exists or tradeDate < product -> economicTerms -> effectiveDate -> adjustableDate -> adjustedDate

    condition FpML_cd_8: <"FpML validation rule cd-8 - If condition LongForm is true, and if scheduledTerminationDate exists then scheduledTerminationDate/dateAdjustments exists.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> masterConfirmationType is absent
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
        then product -> economicTerms -> terminationDate -> adjustableDate -> dateAdjustments exists

    condition FpML_cd_11: <"FpML validation rule cd-11 - If condition LongForm is true, and if condition ISDA2003 is true, then allGuarantees must exist.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> masterConfirmationType is absent
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualDefinitionsType any = ContractualDefinitionsEnum -> ISDA2003CreditDerivatives
        then product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees exists

    condition FpML_cd_19: <"FpML validation rule cd-19 - If the condition ISDA1999Credit is true, then the following elements must not exist: protectionTerms/creditEvents/creditEventNotice/businessCenter, protectionTerms/creditEvents/restructuring/multipleHolderObligation, protectionTerms/creditEvents/restructuring/multipleCreditEventNotices, generalTerms/referenceInformation/allGuarantees, generalTerms/indexReferenceInformation, generalTerms/substitution, generalTerms/modifiedEquityDelivery.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualDefinitionsType any = ContractualDefinitionsEnum -> ISDA1999CreditDerivatives
        then product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> businessCenter is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleHolderObligation is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleCreditEventNotices is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> substitution is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> modifiedEquityDelivery is absent

    condition FpML_cd_20: <"FpML validation rule cd-20 - If the condition ISDA2003 is true, then protectionTerms/obligations/notContingent must not exist.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualDefinitionsType any = ContractualDefinitionsEnum -> ISDA2003CreditDerivatives
        then product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations -> notContingent is absent

    condition FpML_cd_23: <"FpML validation rule cd-23 - If the condition LongForm is true, then cashSettlementTerms or physicalSettlementTerms must exist.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> masterConfirmationType is absent
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
        then product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> cashSettlementTerms exists
                or product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms exists

    condition FpML_cd_24: <"FpML validation rule cd-24 - If the condition LongForm is true, then the following elements must exist: protectionTerms/creditEvents/creditEventNotice, protectionTerms/obligations, generalTerms/referenceInformation/referencePrice.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> masterConfirmationType is absent
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
        then product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> protectionTerms -> obligations exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referencePrice exists

    condition FpML_cd_25: <"FpML validation rule cd-25 - If the condition LongForm is true, and if physicalSettlementTerms exists, then physicalSettlementTerms must contain settlementCurrency, physicalSettlementPeriod, escrow and deliverableObligations/accruedInterest.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> masterConfirmationType is absent
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms exists
        then product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> settlementCurrency exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> physicalSettlementPeriod exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> escrow exists
                and product -> economicTerms -> payout -> CreditDefaultPayout -> settlementTerms -> physicalSettlementTerms -> deliverableObligations -> accruedInterest exists

    condition FpML_cd_32: <"FpML validation rule cd-32 - If condition LongForm is true, and if fixedAmountCalculation/calculationAmount exists, then fixedAmountCalculation/dayCountFraction must exist.">
        if contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> masterConfirmationType is absent
                and contractDetails -> documentation -> legalAgreementIdentification -> agreementName -> contractualMatrix is absent
                and product -> economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
                and product -> economicTerms -> payout -> InterestRatePayout -> priceQuantity exists
                and tradeLot -> priceQuantity -> quantity -> value exists
        then product -> economicTerms -> payout -> InterestRatePayout -> dayCountFraction exists

    condition FpML_ird_8: <"FpML validation rule ird-8 - If the same party is specified as the payer and receiver, then different accounts must be specified.">
        if product -> economicTerms -> payout -> InterestRatePayout exists
        then FpmlIrd8(item, account) = True

    condition ExtraordinaryEvents: <"Extraordinary events provisions must be associated with an equity payout or an equity option payout.">
        if contractDetails -> documentation -> agreementTerms -> agreement -> transactionAdditionalTerms -> equityAdditionalTerms -> extraordinaryEvents exists
        then (product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists
                    or product -> economicTerms -> payout -> OptionPayout exists)
                and Qualify_AssetClass_Equity(product -> economicTerms)

    condition DisruptionEventsDeterminingParty:
        if contractDetails -> documentation -> agreementTerms -> agreement -> transactionAdditionalTerms -> equityAdditionalTerms -> extraordinaryEvents -> additionalDisruptionEvents -> determiningParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> DisruptionEventsDeterminingParty
                and if ancillaryParty -> role contains AncillaryRoleEnum -> DisruptionEventsDeterminingParty
                    then contractDetails -> documentation -> agreementTerms -> agreement -> transactionAdditionalTerms -> equityAdditionalTerms -> extraordinaryEvents -> additionalDisruptionEvents -> determiningParty exists

type ExecutionDetails: <"Defines specific attributes that relate to trade executions.">
    [metadata key]

    executionType ExecutionTypeEnum (1..1) <"Identifies the type of execution, e.g. via voice, electronically...">
    executionVenue LegalEntity (0..1) <"Represents the venue on which a trade was executed.">
    packageReference IdentifiedList (0..1) <"A reference to the package linking the trade with other trades, in case the trade was executed as part of a package (hence this attribute is optional).">

    condition ExecutionVenue: <"When the execution type is set to 'Electronically', the execution venue must be specified.">
        if executionType = ExecutionTypeEnum -> Electronic
        then executionVenue exists

type ContractDetails: <"Defines specific attributes that relate to contractual details of trades.">
    [metadata key]
    documentation LegalAgreement (0..*) <"Represents the legal document(s) that governs a trade and associated contractual product terms, either as a reference to such documents when specified as part of the CDM, or through identification of some of the key terms of those documents, such as the type of document, the document identifier, the publisher, the document vintage and the agreement date.">
    governingLaw GoverningLawEnum (0..1) <"Represents the law governing the trade and associated contractual product terms.">
        [metadata scheme]

    condition ExecutedAgreement: <"Contract details can only only point to  executed legal agreements.">
        if documentation exists
        then documentation -> agreementDate exists

type Lineage: <"A class to provide lineage information across lifecycle events through a pointer or set of pointers into the event(s), contract(s) and, possibly, payout components that the event is dependent on or relates to. As an example, if an contractFormation event is corrected, the correction event will have a lineage into the initial event, which takes the form of a globalKey into that initial contract formation event. Two referencing mechanisms are provided as part of the CDM: either the globalKey, which corresponds to the hash value of the CDM class which is referred to, or a reference qualifier which is meant to provide support for the ingestion of xml documents with id/href mechanisms. The CDM recommends the use of the globalKey and provides a default implementation which is accessible in the generated code through org.isda.cdm.globalKey.GlobalKeyHashCalculator. If implementers want to use an alternative hashing mechanism, the API in which they need to plug it is com.rosetta.model.lib.HashFunction.">
    tradeReference Trade (0..*)
        [metadata reference]
    eventReference WorkflowStep (0..*) <"The reference to the instantiation of an Event object, either through a globalKey or an xml-derived id/href mechanism. The definition associated to the Lineage class provides more details with respect to those referencing approaches, their expected usage and available implementation.">
        [metadata reference]
    portfolioStateReference PortfolioState (0..*) <"The reference to the previous state of a Portfolio, in a chain of Events leading up to a build of that Portfolio as the holding of Product(s) in specific Quantity(ies). As part of the PortfolioState object, a pointer to the previous PortfolioState is provided through a Lineage object, together with pointer(s) to the Event or set of Events leading up to the current (new) state.">
        [metadata reference]

type StockSplitInstruction: <"Data required to perform a stock split business event.">

    adjustmentRatio number (1..1) <"The number that denotes the cumulative quantity of post-split shares issued to shareholders versus the quantity of pre-split shares previously issued to shareholders.  This number will be multiplied by existing shares in an equity derivative contract or other positions to determine the post-split number of shares.  With regard to any reference to price, the pre-split reference price will be divided by this number to determine the post-split reference price.">
    effectiveDate date (1..1) <"The effective date of the stock split, also known as the ex-date. This is the date on which the additional shares are paid to the shareholders, or in the case of a reverse stock split, the number shares held by each shareholder is proportionally reduced.  Equity derivative transactions can be amended in firms' internal systems on such date.   In most markets, the listed stock price is reduced (or increased for a reverse stock split) to account for the split on the same date, but in some markets the price adjustment occurs on a later date.  In either case, equity derivative transactions should be amended on the date that the stocks are paid to the shareholders (or consolidated).">

type CreditEvent: <"Specifies the relevant data regarding a credit event.">
    creditEventType CreditEventTypeEnum (1..1) <"The type of credit event taking place.">
    eventDeterminationDate date (1..1) <"The date in which the credit event is determined by the Credit Derivatives Determinations Comitee.">
    auctionDate date (0..1) <"The date on which the auction is scheduled to occur.">
    finalPrice Price (0..1) <"The final price resulting from the auction.">
    recoveryPercent number (0..1) <"The percentage of the original value of the asset affected by the credit event that can be recovered.">
    publiclyAvailableInformation Resource (0..*) <"A public information source, e.g. a particular newspaper or electronic news service, that may publish relevant information used in the determination of whether or not a credit event has occurred.">
    referenceInformation ReferenceInformation (1..1) <"The reference entity, part of a credit basket, impacted by the credit event.">

type CorporateAction: <"Specifies the relevant data regarding a corporate action">
    corporateActionType CorporateActionTypeEnum (1..1) <"The type of corporate action taking place.">
    exDate date (1..1) <"The date on which the corporate action is known to have taken place.">
    payDate date (1..1) <"The date on which resulting from the corporate action are delivered.">
    recordDate date (0..1) <"The date on which the account phyical balance and related underlier ownership is recorded by the custodian.">
    announcementDate date (0..1) <"The date on which the corporate action is announced by the issuer.">
    underlier Underlier (1..1) <"The underlier impacted by the corporate action.">
    adjustmentFactor AdjustmentFactor (0..1) <"Specifies any additional details e.g. further descriptions depending on the particular type of Corporate Action, adjustmentFactor, calculations">
    informationSource InformationSource (0..1) <"A class defining the source of data used in an Observation for any purposes. The data is either sourced from a Provider, or from a Party.">
    dividendObservation PriceSchedule (0..1) <"To record observations of dividends.">
    bespokeEventDescription string (0..1) <"Corporate action triggered by the occurrence of an event which description is seperatly agreed between the parties and/or described in any referenced agreement (for instance bespoke term described in any string type objects present in most root attributes of Agreement type).">

    condition DividendObservation: <"Price type is restricted to record observations of dividends.">
        if dividendObservation exists
        then dividendObservation -> priceType = PriceTypeEnum -> Dividend

    condition CorporateActionTypeBespoke: <"When Enum value does not corresponds to standard terms, then bespoke description must be populated.">
        if corporateActionType = CorporateActionTypeEnum -> BespokeEvent
        then bespokeEventDescription exists

    condition: <"If intent is to record dividend observation per se with no relation to an adjustment (typically when such observation is made, looking forward dividend passthrough payments) then no adjustment is expected, and vice-versa. For the avoidance of doubts, in the case dividend terms are involved in the calculation or the occurrence of an adjustment calculation, then such information shall be defined at such proper level i.e. precisely as an attribute of the adjustmentFactorCalculation.">
        optional choice adjustmentFactor, dividendObservation

type AdjustmentFactor: <"Describes the terms involved for adjusting the price of the underlier impacted by a Corporate Action.">

    value number (1..1) <"The multipler value applied to the price of the underlier impacted by a Corporate Action.">
    calculationTerms AdjustmentFactorCalculationTerms (0..1) <"Describes the input terms involved in the calculation of the adjustment factor applied to the price of the underlier impacted by a Corporate Action.">

type AdjustmentFactorCalculationTerms: <"Describes the input terms involved in the calculation of the adjustment factor applied to the price of the underlier impacted by a Corporate Action.">
    shareForShareRatio number (0..1) <"Multiple value, say 'M/N' where 'M' is the number of shares after the event and 'N' is the number of shares prior to the event. ">
    shareForRightsRatio number (0..1) <"Multiple value, say 'M/N' where 'M' is the number of rights after the event, and 'N' of shares prior to the event. ">
    rightsSubscriptionPrice Price (0..1) <"The price to pay per each right.">
    dividendRatio number (0..1) <"Multipler value (e.g. 85 %, etc.) to calculate net dividend amount, given gross amount before taking into account the relevant fiscal features.">
    spinOff SpinOff (0..1) <"Defines the underlier for both the Parent Company and the Child Compagny involved in Spin Off corporate action, as well as the respective price observation for each.">
    merger Merger (0..1) <"Defines the underlier for both the Purchaser Company and the Acquired Compagny involved in Spin Off corporate action, as well as the respective price observation for each.">
    accrualFactor AccrualFactor (0..1) <"The accrual rate and related terms, to adjust the price of an underlier impacted by a Corporate Action when economic impact consists in freezing the underlier price to last fixing and applying accruals for each remaining underlier price fixing date required i.e. for each, adjustedPrice = lastFixingPrice x (1 + accrualRate x DCF).">
    lastFixingPriceBeforeAdjustment Price (0..1) <"The last fixing price of the Underlier affected by the CorporateAction, before any adjustment with regards to the CorporateAction.">
    dividendObservation PriceSchedule (0..1) <"To record observations of dividends.">
    bespokeCalculationFormula string (0..1) <"To describe the formula used to calculate the Adjustment Factor."> // temporary place holder -> plan is to re-use BespokePayoutFormula type designed by Structured Product WG
    condition SpinOffOrMergerOrAccrual:
        optional choice spinOff, merger, accrualFactor

    condition DividendObservation: <"Price type is restricted to record observations of dividends.">
        if dividendObservation exists
        then dividendObservation -> priceType = PriceTypeEnum -> Dividend

    condition ShareRatio:
        optional choice shareForShareRatio, shareForRightsRatio

type AccrualFactor: <"The accrual rate and related terms, to adjust the price of an underlier impacted by a Corporate Action when economic impact consists in freezing the underlier price to the last fixing then applying accruals per each remaining underlier price fixing date required i.e. for each fixing date, adjustedPrice = lastFixingPrice x accrualFactor, where: accrualFactor = (1 + accrualRateValue x DCF).">
    value PriceSchedule (1..1) <"The rate to be applied to the last fixing price, for price accrual calculation purposes. DatedValue may be used for the purpose of representing Price series if such calculation is required for multiple dates.">
        [metadata location]
    calculationTerms AccrualFactorCalculationTerms (0..1) <"Describes the input terms involved in the calculation of the accrual factor.">

    condition AccrualPriceIsRate:
        value -> priceType = PriceTypeEnum -> InterestRate

type AccrualFactorCalculationTerms: <"Describes the input terms involved in the calculation of the accrual factor. Optionnally, long and short stub interpolation rates can be specified.">
    tenorTillMaturity number (1..1) <"The duration between last fixing date and the payment date of accruals, calculated in accordance with the appropriate DayCountFraction.">
    dayCountFraction DayCountFractionEnum (1..1) <"The enumerated values to specify the day count fraction.">
    interpolationTerms StubValue (0..1) <"Describes the rate, tenor, period duration for the short and long stubs, when the accrualRate optionnaly results from an interpolation method.">

type SpinOff: <"Defines the underlier for both the Parent Company and the Child Compagny involved in Spin Off corporate action, as well as th respective price observation for each.">
    parentSecurity Security (1..1) <"Defines the underlier for the Parent Company involved in Spin Off corporate action.">
    parentSecurityPrice Price (1..1) <"The price observation that relates to underlier for the Parent Company.">
    childSecurity Security (1..1) <"Defines the underlier for the Child Company involved in Spin Off corporate action.">
    childSecurityPrice Price (1..1) <"The price observation that relates to underlier for the Child Company.">

    condition EquityPrice: <"Each attribute shall define both the equity instrument and the price at stake.">
        parentSecurity -> instrumentType = InstrumentTypeEnum -> Equity
            and childSecurity -> instrumentType = InstrumentTypeEnum -> Equity

type Merger: <"Defines the underlier for both the Purchaser Company and the Acquired Compagny involved in Merger corporate action, as well as th respective price observation for each.">
    purchaserSecurity Security (1..1) <"Defines the underlier for the Purchaser Company involved in Merger corporate action.">
    purchaserSecurityPrice Price (1..1) <"The price observation that relates to underlier for the Purchaser Company.">
    acquiredSecurity Security (1..1) <"Defines the underlier for the Acquired Company involved in Merger corporate action.">
    acquiredSecurityPrice Price (1..1) <"The price observation that relates to underlier for the Acquired Company.">

    condition EquityPrice: <"Each attribute shall define both the equity instrument and the price at stake.">
        purchaserSecurity -> instrumentType = InstrumentTypeEnum -> Equity
            and acquiredSecurity -> instrumentType = InstrumentTypeEnum -> Equity

type ClearingInstruction: <"All information required to perform the clear life cycle event; the clearing party (CCP), the two parties facing each other on the alpha contract, and optionally the parties acting as clearing members.">
    alphaContract TradeState (1..1) <"The contract that will be submitted to the clearing house for clearing. The contract should indicate that it should be cleared by assigning a clearing organisation as a party role.">
    clearingParty Party (1..1) <"The Central Counter party (CCP) that the contract will be submitted to for clearing.">
    party1 Party (1..1) <"First party facing the CCP if it is clearing for its own account.">
    party2 Party (1..1) <"Second party facing the CCP if it is clearing for its own account.">
    clearerParty1 Party (0..1) <"Optional party facing the CCP, acting as clearing member for party1.">
    clearerParty2 Party (0..1) <"Optional party facing the CCP, acting as clearing member for party2.">
    isOpenOffer boolean (0..1) <"Open Offer">

type ExerciseEvent: <"A data defining:  the adjusted dates associated with a particular exercise event.">
    [deprecated]
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which the option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedRelevantSwapEffectiveDate date (1..1) <"The effective date of the underlying swap associated with a given exercise date. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (0..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (0..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business day convention.">
    adjustedExerciseFeePaymentDate date (0..1) <"The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business day convention.">

type ReturnInstruction: <"Specifies the information required to create the return of a Security Finance Transaction.">
    quantity Quantity (1..*) <"Specifies the quantity of shares and cash to be returned in a partial return event.">

type SecurityLendingInvoice: <"Specifies the information required for inclusion in a securities lending billing invoice.">
    [rootType]
    [metadata key]
    sendingParty Party (1..1) <"The party issuing the invoice">
    receivingParty Party (1..1) <"The party receiving the invoice">
    billingStartDate date (1..1) <"The starting date of the period described by this invoice">
    billingEndDate date (1..1) <"The ending date of the period described by this invoice">
    billingRecord BillingRecord (1..*) <"The billing records contained within the invoice">
    billingSummary BillingSummary (1..*) <"The billing summaries contained within the invoice">

type BillingInstruction: <"Specifies the instructions for creation of a Security Lending billing invoice.">
    sendingParty Party (1..1) <"The party issuing the invoice">
    receivingParty Party (1..1) <"The party receiving the invoice">
    billingStartDate date (1..1) <"The starting date of the period described by this invoice">
    billingEndDate date (1..1) <"The ending date of the period described by this invoice">
    billingRecordInstruction BillingRecordInstruction (1..*) <"Instructions for creating the billing records contained within the invoice">
    billingSummary BillingSummaryInstruction (0..*) <"The billing summaries contained within the invoice">

type BillingRecordInstruction: <"Specifies the instructions for creation of a billing record.">
    tradeState TradeState (1..1) <"The trade for the individual billing record.">
        [metadata reference]
    observation Observation (1..*) <"The observations used to calculate the billing amount.">
    recordStartDate date (1..1) <"The starting date of the period described by this record">
    recordEndDate date (1..1) <"The ending date of the period described by this record">
    settlementDate date (1..1) <"The date for settlement of the transfer.">

type BillingSummaryInstruction: <"Specifies the instructions for creation of a billing summary.">
    summaryAmountType RecordAmountTypeEnum (1..1) <"The account level for the billing summary.">

type BillingRecord: <"Specifies individual records within a billing invoice.">
    tradeState TradeState (1..1) <"The trade for the individual billing record.">
        [metadata reference]
    recordTransfer Transfer (1..1) <"The settlement terms for the billing record">
    recordStartDate date (1..1) <"The starting date of the period described by this record">
    recordEndDate date (1..1) <"The ending date of the period described by this record">
    minimumFee Money (0..1) <"Indicates the minimum fee amount applied to the billing record, if any.">

type BillingSummary: <"Specifies individual summaries within a billing invoice.">
    summaryTransfer Transfer (0..1) <"The settlement terms for the billing summary">
    summaryAmountType RecordAmountTypeEnum (1..1) <"The account level for the billing summary.">

    condition GrandTotal:
        if summaryAmountType = RecordAmountTypeEnum -> GrandTotal
        then summaryTransfer exists and summaryTransfer -> payerReceiver is absent

    condition ParentTotal:
        if summaryAmountType = RecordAmountTypeEnum -> ParentTotal
        then summaryTransfer -> payerReceiver exists
                and summaryTransfer -> payerReceiver -> payerAccountReference is absent
                and summaryTransfer -> payerReceiver -> receiverAccountReference is absent

    condition AccountTotal:
        if summaryAmountType = RecordAmountTypeEnum -> AccountTotal
        then summaryTransfer -> payerReceiver -> payerAccountReference exists
                and summaryTransfer -> payerReceiver -> receiverAccountReference exists

type TradePricingReport: <"The attributes that are specific for consensus based pricing reporting.">
    trade Trade (1..1) <"Represents the cosensus based pricing parameters on a trade basis.">
    pricingTime TimeZone (1..1) <"The regional exchange close time for the underlying contract,including time zone, at which the trades should be priced. This provides an indication for which regional snapshot should be used for pricing primarily for Global markets where there are multiple regional close times.">
    discountingIndex FloatingRateIndexEnum (0..1) <"It specifies the interest payable on collateral delivered under a CSA covering the trade.">

type MarginCallBase: <"Represents common attributes required for Issuance and Response to a Margin Call action as a result of a demand for delivery or return of collateral determined under a legal agreement such as a credit support document or equivalent.">
    instructionType MarginCallInstructionType (1..1) <"Identifies the enumeration values to specify the call notification type, direction, specific action type.">
    party Party (0..*) <"Represents the parties to the margin call. The cardinality is optional to address the case where both parties of the event are specified and a third party if applicable.">
    partyRole PartyRole (0..*) <"Represents the role each specified party takes in the margin call. further to the principal roles, payer and receiver.">
    clearingBroker Party (0..1) <"Indicates the name of the Clearing Broker FCM/DCM.">
    callIdentifier Identifier (0..1) <"Represents a unique Identifier for a margin call message, that can be referenced throughout all points of the process.">
    callAgreementType AgreementName (1..1) <"Specifies the legal agreement type the margin call is generated from and governed by.">
    agreementMinimumTransferAmount Money (0..1) <"Specifies the collateral legal agreement minimum transfer amount in base currency.">
    agreementThreshold Money (0..1) <"Specifies the collateral legal agreement threshold amount in base currency.">
    agreementRounding Money (0..1) <"Specifies the collateral legal agreement rounding in base currency.">
    regMarginType RegMarginTypeEnum (1..1) <"Identifies margin type and if related regulatory mandate">
    regIMRole RegIMRoleEnum (0..1) <"Indicates the role of the party in an regulatory initial margin call instruction (i.e Pledgor party or Secured party).">
    baseCurrencyExposure MarginCallExposure (0..1) <"Represents the current mark to market value or IM calculation value of the trade portfolio as recorded by the principle (in base currency), to be referenced in a margin call.">
    collateralPortfolio CollateralPortfolio (0..1) <"Represents attributes to define the details of collateral assets within a collateral portfolio to be used in margin call messaging and contribute to collateral balances e.g securities in a collateral account recorded by the principal as held or posted.">
        [metadata reference]
    independentAmountBalance CollateralBalance (0..1) <"Represents additional credit support amount over and above mark to market value.">

    condition RegIMRoleIMOnly: <"Specifies a condition to ensure that RegIMRole (Pledgor or Secured Party)is only applicable if the Reg margin type is defined as RegIM (Regulatory Initial Margin).">
        if regIMRole exists
        then regMarginType = RegMarginTypeEnum -> RegIM

type Exposure: <"Represents the current mark to market value or IM calculation value of the trade portfolio as recorded by the principle (in base currency).">
    tradePortfolio PortfolioState (1..1) <"Represents a Portfolio that describes all the positions held at a given time, in various states which can be either traded, settled, etc., with lineage information to the previous state.">
        [metadata reference]
    aggregateValue Money (1..1) <"Represents the aggregate value of the portfolio in base currency.">
    calculationDateTime zonedDateTime (0..1) <"Indicates the date when the exposure is calculated if different from valuation date.">
    valuationDateTime zonedDateTime (1..1) <"Indicates the valuation date of the exposure underlying the calculation.">
// possible function/instructions needed for calculation of portfolio and aggregating to a base currency value//
type MarginCallExposure extends MarginCallBase: <"Represents attributes required for mark to market value or IM calculation value of the trade portfolio as recorded by the principle (in base currency).">
    overallExposure Exposure (1..1) <"Represents the whole overall mark to market value or IM calculation value of the trade portfolio as recorded by the principle (in base currency).">
    simmIMExposure Exposure (0..1) <"Represents Initial Margin (IM) exposure derived from ISDA SIMM calculation.">
    scheduleGridIMExposure Exposure (0..1) <"Represents Initial Margin (IM) exposure derived from schedule or Grid calculation.">

    condition OverallExposureSumOfSimmAndScheduleIM: <"Represents a condition to ensure that if Simm IM exposure and Schedule/Grid IM exposure are specified the sum value must equate to overall exposure amount.">
        if simmIMExposure exists and scheduleGridIMExposure exists
        then (overallExposure -> aggregateValue -> value = simmIMExposure -> aggregateValue -> value + scheduleGridIMExposure -> aggregateValue -> value)
                and (overallExposure -> aggregateValue -> unit -> currency = simmIMExposure -> aggregateValue -> unit -> currency)
                and (overallExposure -> aggregateValue -> unit -> currency = scheduleGridIMExposure -> aggregateValue -> unit -> currency)

    condition ExposureSimmAndScheduleIMOnly: <"Specifies a condition to ensure that if margin exposure is defined as Simm IM and Schedule/Grid IM Exposure this is only applicable if the Reg margin type is defined as RegIM (Regulatory Initial Margin).">
        if simmIMExposure exists and scheduleGridIMExposure exists
        then regMarginType = RegMarginTypeEnum -> RegIM

type CollateralBalance: <"Represents common attributes to define a collateral balance recorded by the principal as held or posted.">
    collateralBalanceStatus CollateralStatusEnum (0..1) <"Defines the collateral balance breakdown of settlement status.">
    haircutIndicator HaircutIndicatorEnum (0..1) <"Indicates if the collateral balance amount is based on pre or post haircut, if a haircut is associated with the collateral asset">
    amountBaseCurrency Money (1..1) <"Specifies the collateral balance amount in base currency determined within a collateral legal agreement, or defined for reporting purposes.">
    payerReceiver PartyReferencePayerReceiver (1..1) <"Specifies each of the parties in the collateral balance and its perspective with regards to the direction of the collateral balance, posted or received.">

type CollateralPortfolio: <"Represents common attributes to define the details of collateral assets, to be used in margin call messaging and contribute to collateral balances e.g securities in a collateral account.">
    [metadata key]
    [rootType]
    portfolioIdentifier Identifier (0..1) <"Specifies a unique identifier for a set of collateral positions in a portfolio.">
    collateralPosition CollateralPosition (0..*) <"Specifies the individual components of the collateral positions in the collateral portfolio.">
    collateralBalance CollateralBalance (0..*) <"Represents the populated or calculated collateral aggregate balance amount for the collateral portfolio.">
    legalAgreement LegalAgreement (0..1) <" The specification of a legal agreement between two parties governing the collateral relationship such as Credit Support Agreement or Collateral Transfer Agreement etc. (NB: this can be provided by reference to a global key for each LegalAgreement object).">
        [metadata reference]

type CollateralPosition extends Position: <"Specifies the individual components of collateral positions.">

    treatment CollateralTreatment (0..1) <"Specifies if there is any treatment to be applied to collateral, such as percentage discount which will impact collateral value.">
    collateralPositionStatus CollateralStatusEnum (0..1) <"Indicates the collateral positions settlement status.">

    condition CollateralPositionStatusSettledOrInTransitOnly: <"Represents a condition to ensure that if a status is defined for a collateral position you must only indicate 'Settled Amount' or 'In Transit' amount from the available enumerations.">
        if collateralPositionStatus exists
        then collateralPositionStatus = CollateralStatusEnum -> SettledAmount
                or collateralPositionStatus = CollateralStatusEnum -> InTransitAmount

type MarginCallIssuance extends MarginCallBase: <"Represents common attributes required for a Margin Call Issuance under a legal agreement such as a credit support document or equivalent.">
    callAmountInBaseCurrency Money (1..1) <"Specifies the amount of margin being called for which accounts for margin calculation inclusive of exposure, independent amount,threshold,collateral balance, MTA, rounding increments (in base currency detailed in supporting collateral agreement).">
    recallNonCashCollateralDescription EligibleCollateralCriteria (0..*) <"Specifies the details to describe or identify non-cash collateral eligible assets for recall purposes.">

type MarginCallInstructionType: <"Represents enumeration values to specify the call notification type, direction, specific action type.">
    callType CallTypeEnum (1..1) <"Indicates the status of the call message type, such as expected call, notification of a call or an actionable margin call.">
    visibilityIndicator boolean (0..1) <"Indicates the choice if the call instruction is visible or not to the other party.">

    condition CallTypeExpectedVisibility: <"Represents a condition to ensure that a visibility indicator is specifies then the call type must be an expected call.">
        if callType = CallTypeEnum -> ExpectedCall
        then visibilityIndicator exists

type MarginCallResponseAction: <"Specifies the margin call action details, including collateral to be moved and its direction.">

    collateralPositionComponent CollateralPosition (1..*) <"Specifies the collateral to be moved and its direction.">
    marginCallAction MarginCallActionEnum (1..1) <"Specifies the margin call action details, specified as either Delivery or Return.">

type MarginCallResponse extends MarginCallBase: <"Represents common attributes required for a Margin Call Response under a legal agreement such as a credit support document or equivalent.">

    marginCallResponseAction MarginCallResponseAction (1..*) <"Specifies the margin call action details, including collateral to be moved and direction.">
    marginResponseType MarginCallResponseTypeEnum (1..1) <"Indicates the response type, such as, is the margin call response a 'full' 'part' agreement or 'dispute'.">
    agreedAmountBaseCurrency Money (1..1) <"Indicates the amount that posting entity agrees to remit in response to margin call (in base currency).">

type ClosedState: <" A class to qualify the closed state of an execution or a contract through the combination or a state (e.g. terminated, novated) and a set of dates: activity date, effective date and, when relevant, last payment date.">

    state ClosedStateEnum (1..1) <"The qualification of what gave way to the contract or execution closure, e.g. allocation, termination, ...">
    activityDate date (1..1) <"The activity date on which the closing state took place, i.e. either the event date of the closing event (e.g. option exercise, contract early termination) or the contractual termination date.">
    effectiveDate date (0..1) <"The date on which the closing event contractually takes effect, when different from the activity date. When an explicit event effective date attribute is associated with the closing event, it will be that date. In the case of a cancellation event, it will be the date on which the cancelled event took place.">
    lastPaymentDate date (0..1) <"The date associated with the last payment in relation to the artefact (e.g. contract) to which this closed state applies. As an example, in the case of an early termination event, it would be the settlement date of the associated fee, if applicable.">


================================================================================
FILE: rosetta-source/src/main/rosetta/event-position-enum.rosetta
================================================================================

namespace cdm.event.position : <"Position concepts: portfolio and portfolio aggregation.">
version "${project.version}"

enum PositionStatusEnum: <"Enumeration to describe the different (risk) states of a Position, whether executed, settled, matured...etc">
    Executed <"The position has been executed, which is the point at which risk has been transferred.">
    Formed <"Contract has been formed, in case position is on a contractual product.">
    Settled <"The position has settled, in case product is subject to settlement after execution, such as securities.">
    Cancelled <"The position has been cancelled, in case of a cancellation event following an execution.">
    Closed <"The position has been closed, in case of a termination event.">

enum AvailableInventoryTypeEnum: <"Enumeration to describe the type of AvailableInventory">
    AvailableToLend <"Where a lender is broadcasting the securities that they have available to lend">
    RequestToBorrow <"Where a party is asking a lender if they have specific securities available for them to borrow">


================================================================================
FILE: rosetta-source/src/main/rosetta/event-position-func.rosetta
================================================================================

namespace cdm.event.position : <"Position concepts: portfolio and portfolio aggregation.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.product.template.*

func FxMarkToMarket: <"Representation of sample mark to market calculation provided by a member firm.">
    inputs:
        trade Trade (1..1)
    output:
        value number (1..1)

    alias settlementPayout: <"Alias to the forward pay out.">
        trade -> product -> economicTerms -> payout -> SettlementPayout only-element

    alias quotedCurrency: <"The quoted currency.">
        trade -> tradeLot -> priceQuantity -> price -> unit -> currency
            distinct
            only-element

    alias baseCurrency: <"The base currency.">
        trade -> tradeLot -> priceQuantity -> price -> perUnitOf -> currency
            distinct
            only-element

    alias quantities: <"Quantity list. Only works in the case of a single trade lot.">
        trade -> tradeLot only-element -> priceQuantity -> quantity

    alias quotedQuantity: <"Quoted quantity amount.">
        FilterQuantityByCurrency(quantities, quotedCurrency) only-element -> value

    alias baseQuantity: <"Base quantity amount.">
        FilterQuantityByCurrency(quantities, baseCurrency) only-element -> value

    alias interpolatedRate: InterpolateForwardRate(settlementPayout)

    condition SettlementPayoutExists: <"The settlementPayout on the contract must exist.">
        trade -> product -> economicTerms -> payout -> SettlementPayout exists

    set value: (quotedQuantity / interpolatedRate - baseQuantity) * interpolatedRate

func InterpolateForwardRate:
    [codeImplementation]
    inputs:
        settlementPayout SettlementPayout (1..1)
    output:
        result number (1..1)

func EvaluatePortfolioState: <"Function specification to evaluate a portfolio's aggregation parameters and return a new portfolio state containing aggregated positions.">
    [codeImplementation]
    inputs:
        portfolio Portfolio (1..1) <"Portfolio containing the aggregation parameters to be used to calculate the new portfolio state.">
    output:
        portfolioState PortfolioState (1..1) <"Portfolio state containing the aggregated positions based on the input aggregation parameters.">

func IsValidPartyRole:
    inputs:
        partyRoles PartyRole (0..*)
        validRoles PartyRoleEnum (1..*)
    output:
        isValid boolean (1..1)
    set isValid:
        partyRoles
            extract (validRoles contains role)
            then all = True


================================================================================
FILE: rosetta-source/src/main/rosetta/event-position-type.rosetta
================================================================================

namespace cdm.event.position : <"Position concepts: portfolio and portfolio aggregation.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.observable.asset.*
import cdm.product.collateral.*
import cdm.product.template.*

type ContractBase: <"Encapsulates data features common to trade and position.">
    contractDetails ContractDetails (0..1) <"Represents information specific to trades or positions involving contractual products.">
        [metadata reference]
    executionDetails ExecutionDetails (0..1) <"Defines specific attributes that relate to trade or position executions.">
        [metadata reference]
    collateral Collateral (0..1) <"Represents the collateral obligations of a party.">
        [metadata reference]

type CounterpartyPosition extends ContractBase: <"A Position describes the accumulated effect of a set of securities or financial transactions.">
    positionIdentifier PositionIdentifier (0..*) <"Represents the identifier(s) that uniquely identify a position for an identity issuer. A position can include multiple identifiers, for example an internal position identifer and a UTI (Unique Trade Identifier).">
    openDateTime dateTime (0..1) <"The date and time when the position was opened.">
    tradeReference TradeState (0..*) <"Reference to all the trades that constitute the position.">
        [metadata reference]
    party Party (0..*) <"The parties involved in the position, including the Clearing Organization.">
    partyRole PartyRole (0..*) <"Represents the role each specified party takes in the position.">
    positionBase TradableProduct (1..1) <"Encapsulates the core constituents that characterize a position.">

type Position: <"A Position describes how much of a given Product is being held and constitutes the atomic element of a Portfolio.">

    priceQuantity PriceQuantity (1..*) <"Position with many price quantities.">
    product Product (1..1) <"The product underlying the position.">
    cashBalance Money (0..1) <"The aggregate cost of proceeds">
    tradeReference TradeState (0..1) <"Reference to the Contract, in case product is contractual and the contract has been formed">
        [metadata reference]

type PortfolioState: <"State-full representation of a Portfolio that describes all the positions held at a given time, in various states which can be either traded, settled, etc., with lineage information to the previous state">
    [metadata key]

    positions Position (0..*) <"The list of positions, each containing a Quantity and a Product.">
    lineage Lineage (1..1) <"Pointer to the previous PortfolioState and new Event(s) leading to the current (new) state. Previous PortfolioState in the Lineage can be Null in case this is the start of the chain of Events.">

    condition Initialisation: <"When the PortfolioState is the starting state of the Portfolio, as identified by a Null state in the Lineage, Positions must be empty and the reference to the latest Event is also empty. This is how a Portfolio gets initialised.">
        if lineage -> portfolioStateReference is absent
        then positions is absent and lineage -> eventReference is absent

    condition NonTransferable: <"The Product in a PortfolioState should be a nonTransferableProduct.">
        positions -> product -> NonTransferableProduct exists

type AggregationParameters: <" Parameters to be used to filter events that are relevant to a given portfolio in order to calculate the state of this portfolio. The attributes correspond to all the possible aggregation criteria that can be used and these criteria can be combined. All the attributes are optional.">
    dateTime zonedDateTime (1..1) <"To aggregate as of a particular date">
    totalPosition boolean (0..1) <"Specifies whether to calculate total position to given date, or only daily position for the given date.">
    positionStatus PositionStatusEnum (0..1) <"To aggregate based on position status (EXECUTED, SETTLED etc)">
    party Party (0..*) <"To aggregate based on a selection of party(ies) / legal entity(ies).">
        [metadata reference]
    product NonTransferableProduct (0..*) <"To aggregate based on a selection of products.">
    productQualifier string (0..*) <"To aggregate based on a selection of product type(s).">
    tradeReference Trade (0..*)
        [metadata reference]

type Portfolio: <" A Portfolio represents an aggregation of multiple Positions, by describing the parameters that this Portfolio should be aggregated based on. The resulting PortfolioState is calculated using these aggregation parameters as inputs, by aggregating all the Events that are relevant to this Portfolio. The concept of Portfolio works at all levels in the model: from the highest for a given LegalEntity for instance, to the lowest to account for security substitutions in a secutity financing transaction. As such, Portfolio can be used either above or below the Contract level.">
    aggregationParameters AggregationParameters (1..1) <"Describes the portfolio by describing how to aggregate all its relevant Events.">
    portfolioState PortfolioState (1..1) <"Describes the state of the Portfolio as a list of Positions resulting from the aggregation.">

type Inventory: <"A data type that can be used to describe an inventory of securities.">
    inventoryRecord InventoryRecord (0..*) <"An array holding the list of inventory being described. Each element in the inventoryRecord array represents an individual piece of inventory i.e. a security.">

type InventoryRecord: <"An individual piece of inventory. This represents a single security.">
    identifer AssignedIdentifier (1..1) <"Unique identifier for this record. This can be used to uniquely identify a specific piece of inventory.">
    security Security (1..1) <"The security details.">

type AvailableInventory: <"A data type that can be used to describe the inventory of securities that a party holds. The securities are held in the AvailableInventoryRecord, with each item in the array being an individual security and its associated criteria. Criteria can include the quantity available, the rate at which the security is available to borrow at, as well as other details that can affect the decision as to whether a party wants to utilise the securities listed.">
    availableInventoryType AvailableInventoryTypeEnum (1..1) <"Defines the purpose of this inventory.">
    messageInformation MessageInformation (0..1) <"Allows details related to the availability messaging use case to be defined">
    party Party (0..*) <"Defines all parties involved for the list of inventory records in this set of inventory. For example, when used to describe securities lending availability, this could hold the sender of the availability, the intended recipient, the beneficial owner(s), the lender (which may differ from the sender as the lender may have the same piece of availability going through multiple agents), an agent or a venue.">
    partyRole PartyRole (0..*) <"Defines the role(s) that party(ies) may have in relation to the inventory.">
    availableInventoryRecord AvailableInventoryRecord (0..*) <"An array holding the list of inventory being described. Each element in the inventoryRecord array represents an individual piece of inventory i.e. a security.">

    condition ValidPartyRole: <"Restrict roles to be only those that would be associated to the overall list of availability">
        IsValidPartyRole(
                partyRole,
                [PartyRoleEnum -> AgentLender, PartyRoleEnum -> BeneficialOwner, PartyRoleEnum -> Borrower, PartyRoleEnum -> Custodian, PartyRoleEnum -> Lender]
            )

type AvailableInventoryRecord extends InventoryRecord: <"An individual piece of available inventory. This represents a single security and its associated criteria. The criteria are used to describe any restrictions on the securities.">
    expirationDateTime zonedDateTime (0..1) <"There may be a set period/time restriction associated to the security.">
    collateral CollateralProvisions (0..*) <"The type of collateral can often be required when determining if the piece of availability being described is suitable for a party.">
    partyRole PartyRole (0..*) <"An individual security may be held by several agents. Including the party role at this level allows us to reference the party holding this specific item.">
    quantity Quantity (0..1) <"The quantity of the security">
    interestRate Price (0..1) <"An optional element which can be used to hold a rate associated to this piece of availability.">

    condition InterestRate: <"Where an Interest Rate has been specified then the Price Type must be set to interest rate">
        if interestRate exists
        then interestRate -> priceType = PriceTypeEnum -> InterestRate

    condition ValidPartyRole: <"Restrict roles to be only those that would be associated to an individual piece of availability">
        IsValidPartyRole(
                partyRole,
                [PartyRoleEnum -> AgentLender, PartyRoleEnum -> BeneficialOwner, PartyRoleEnum -> Custodian, PartyRoleEnum -> Lender]
            )

type SecurityLocate extends AvailableInventory: <"A locate is an approval from a broker that needs to be obtained prior to effecting a short sale in an equity security. Similar to security availability, a borrower can request a single or multiple securities, but at least one must be requested.">

    condition RequestOneSecurityMinimum: <"A locate must request the availability of at least one security.">
        availableInventoryRecord exists


================================================================================
FILE: rosetta-source/src/main/rosetta/event-qualification-func.rosetta
================================================================================

namespace cdm.event.qualification
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.observable.asset.*

isEvent root BusinessEvent;

func Qualify_Adjustment: <"This qualification function is used to qualify adjustment of the collateral amount when a transaction is repriced.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTrade: ExtractBeforeTrade(businessEvent)

    alias afterTrade: ExtractAfterTrade(businessEvent)

    alias beforeTradePurchasePrice: ExtractTradePurchasePrice(beforeTrade)

    alias afterTradePurchasePrice: ExtractTradePurchasePrice(afterTrade)

    alias beforeTradeCollateralQuantity: ExtractTradeCollateralQuantity(beforeTrade)

    alias afterTradeCollateralQuantity: ExtractTradeCollateralQuantity(afterTrade)

    alias beforeTradeCollateralPrice: ExtractTradeCollateralPrice(beforeTrade)

    alias afterTradeCollateralPrice: ExtractTradeCollateralPrice(afterTrade)

    alias beforeEconomicterms: ExtractBeforeEconomicTerms(businessEvent)

    alias openEconomicTerms: ExtractOpenEconomicTerms(businessEvent)

    set is_event:
        businessEvent -> after -> trade -> product -> economicTerms -> payout -> InterestRatePayout exists
            and openEconomicTerms -> payout = beforeEconomicterms -> payout
            and beforeTradePurchasePrice exists
            and afterTradePurchasePrice exists
            and afterTradePurchasePrice = beforeTradePurchasePrice
            and beforeTradeCollateralQuantity <> afterTradeCollateralQuantity
            and beforeTradeCollateralPrice <> afterTradeCollateralPrice
            and beforeEconomicterms exists
            and openEconomicTerms exists
            and openEconomicTerms -> terminationDate = beforeEconomicterms -> terminationDate
            and openEconomicTerms -> effectiveDate <> beforeEconomicterms -> effectiveDate

func Qualify_Allocation: <"The qualification of allocation event from the fact that (i) the only primitives are split and contract formation (ii) the number of split executions and the number of contract formations are equal.  Note that SplitPrimitive type has a condition to check that the post-split quantities sum to the pre-split quantity.  Also note that it is expected that an allocation can result in a single contract.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates(businessEvent -> after)
    alias openTradeStates: FilterOpenTradeStates(businessEvent -> after)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> Allocation
            and closedTradeStates count = 1
            and openTradeStates count >= 1
            and businessEvent -> instruction -> primitiveInstruction -> split exists
                // before trade counterparties should match closed after trade counterparties
            and beforeTradeState -> trade -> counterparty -> partyReference = closedTradeStates only-element -> trade -> counterparty -> partyReference
                // before trade counterparties should not match open after trade counterparties
            and openTradeStates
                extract [
                    item -> trade -> counterparty -> partyReference <> beforeTradeState -> trade -> counterparty -> partyReference
                ] all = True

func Qualify_Cancellation: <"Qualification of an cancellation event.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias closedEconomicTerms:
        FilterClosedTradeStates(businessEvent -> after) only-element -> trade -> product -> economicTerms
    alias openEconomicTerms:
        FilterOpenTradeStates(businessEvent -> after) only-element -> trade -> product -> economicTerms

    set is_event:
        businessEvent -> instruction -> before count = 1
            and closedEconomicTerms exists
            and openEconomicTerms exists
                // and openEconomicTerms -> payout = closedEconomicTerms -> payout
                // and openEconomicTerms -> collateral = closedEconomicTerms -> collateral
            and (if openEconomicTerms -> terminationDate exists
                        and closedEconomicTerms -> terminationDate exists
                then openEconomicTerms -> terminationDate -> adjustableDate -> unadjustedDate < closedEconomicTerms -> terminationDate -> adjustableDate -> unadjustedDate
                else openEconomicTerms -> terminationDate exists)

func Qualify_CashAndSecurityTransfer: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias transfersForDate:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
    set is_event:
        transfersForDate -> quantity -> unit -> currency exists
            and transfersForDate -> quantity -> unit -> financialUnit exists
            and transfersForDate count = 2
            and FilterCashTransfers(transfersForDate) only-element -> payerReceiver -> payerPartyReference = FilterSecurityTransfers(
                    transfersForDate
                )
                only-element -> payerReceiver -> payerPartyReference

func Qualify_CashTransfer: <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias transferInstructions:
        businessEvent -> instruction -> primitiveInstruction -> transfer
    alias beforeTransfers: businessEvent -> instruction -> before -> transferHistory
    alias afterTransfers: businessEvent -> after -> transferHistory
    set is_event:
        (businessEvent -> instruction
                extract primitiveInstruction -> transfer only exists
                ) all = True
            and beforeTransfers count + transferInstructions count = afterTransfers count
            and transferInstructions -> transferState -> transfer -> quantity -> unit -> currency exists

func Qualify_ClearedTrade:
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates(businessEvent -> after)
    alias openTradeStates: FilterOpenTradeStates(businessEvent -> after)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> Clearing
            and closedTradeStates count = 1
            and openTradeStates count = 2
            and businessEvent -> instruction -> primitiveInstruction -> split exists
            and beforeTradeState -> trade -> counterparty -> partyReference = closedTradeStates only-element -> trade -> counterparty -> partyReference
            and openTradeStates
                extract [
                    item -> trade -> counterparty -> partyReference <> beforeTradeState -> trade -> counterparty -> partyReference
                        and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier
                        and item -> trade -> partyRole -> role contains PartyRoleEnum -> ClearingOrganization
                ] all = True

func Qualify_Compression: <"The qualification of a compression event from the fact that (i) the quantityChange primitive exists, and (ii) there are multiple contracts (or contract references) specified in the before state.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    set is_event:
        businessEvent -> instruction -> primitiveInstruction -> execution count = 1 and businessEvent -> instruction -> primitiveInstruction -> quantityChange count > 1

func Qualify_ContractFormation: <"Qualifies a business event as a contract formation from the fact that the only component is a single Contract Formation Primitive.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias primitiveInstruction:
        businessEvent -> instruction -> primitiveInstruction only-element
    set is_event:
        (primitiveInstruction -> contractFormation) only exists
            or (primitiveInstruction -> contractFormation, primitiveInstruction -> transfer) only exists
            or (primitiveInstruction -> execution, primitiveInstruction -> contractFormation) only exists
            or (primitiveInstruction -> execution, primitiveInstruction -> contractFormation, primitiveInstruction -> transfer) only exists
            or (primitiveInstruction is absent and businessEvent -> intent = EventIntentEnum -> ContractFormation)

func Qualify_CorporateActionDetermined: <"The qualification of the ocurrence of a corporate action form the fact that a corporate action is present in either the observation or the observation history structures.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    set is_event:
        businessEvent -> instruction -> primitiveInstruction -> observation -> observationEvent -> corporateAction exists
            or businessEvent -> instruction -> before -> observationHistory -> corporateAction exists
            or businessEvent -> after -> observationHistory -> corporateAction exists

func Qualify_CreditEventDetermined: <"The qualification of the ocurrence of a credit event determination from the fact that a credit event is present in either the observation or observation history structures.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    set is_event:
        businessEvent -> instruction -> primitiveInstruction -> observation -> observationEvent -> creditEvent exists
            or businessEvent -> instruction -> before -> observationHistory -> creditEvent exists
            or businessEvent -> after -> observationHistory -> creditEvent exists

func Qualify_Execution: <"The qualification of an execution event from the fact that the only component is an execution.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias primitiveInstruction:
        businessEvent -> instruction -> primitiveInstruction only-element
    set is_event:
        businessEvent -> intent is absent
            and (primitiveInstruction -> execution only exists
                or (primitiveInstruction -> execution, primitiveInstruction -> transfer) only exists)

func Qualify_Exercise: <"The qualification of an exercise event from the fact that (i) the only primitive is the exercise, and (ii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias primitiveInstruction:
        businessEvent -> instruction -> primitiveInstruction only-element
    set is_event:
        businessEvent -> intent = EventIntentEnum -> OptionExercise
            and ((businessEvent -> instruction count = 1
                    and (businessEvent -> instruction -> primitiveInstruction -> quantityChange exists and businessEvent -> instruction -> primitiveInstruction -> transfer exists))
                or (businessEvent -> instruction count = 2
                    and (businessEvent -> instruction -> primitiveInstruction -> quantityChange exists and businessEvent -> instruction -> primitiveInstruction -> execution exists))
                or (businessEvent -> instruction count = 1
                    and businessEvent -> instruction -> primitiveInstruction -> exercise exists))

func Qualify_FullReturn: <"The qualification of a full return event from the fact that (i) a quantityChange primitive and a transfer primitive exists, (ii) an assetPayout exists, (iii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias transfer:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
            only-element
    set is_event:
        (businessEvent -> intent is absent)
            and businessEvent -> after -> trade -> product -> economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout exists
            and (businessEvent -> instruction count = 1
                    and businessEvent -> instruction -> primitiveInstruction -> quantityChange exists
                or (businessEvent -> instruction -> primitiveInstruction -> quantityChange exists and transfer exists))
            and QuantityDecreasedToZero(
                    businessEvent -> instruction -> before,
                    businessEvent -> after
                ) = True
            and businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated

func Qualify_Increase: <"The qualification of a increase event from the fact that (i) the intent is Increase when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract increases.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias primitiveInstruction:
        businessEvent -> instruction -> primitiveInstruction only-element
    alias transfer:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
    set is_event:
        businessEvent -> intent is absent
            and ((primitiveInstruction -> quantityChange only exists
                    or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
                and (QuantityIncreased(
                        businessEvent -> instruction -> before only-element,
                        businessEvent -> after
                    ) = True or businessEvent -> instruction -> before -> trade -> tradeLot count < businessEvent -> after -> trade -> tradeLot count))

func Qualify_IndexTransition: <"The qualification of an index transition event based on (i) adjustment spread applied and (ii) floating rate index changed.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias after: businessEvent -> after only-element -> trade

    alias before: businessEvent -> instruction -> before -> trade

    alias floatingRateIndexChanged:
        before -> tradeLot -> priceQuantity -> observable -> Index -> InterestRateIndex exists
            and before -> tradeLot -> priceQuantity -> observable -> Index -> InterestRateIndex disjoint after -> tradeLot -> priceQuantity -> observable -> Index -> InterestRateIndex

    alias spread:
        FilterPrice(
                after -> tradeLot -> priceQuantity -> price,
                PriceTypeEnum -> InterestRate,
                [ArithmeticOperationEnum -> Add, ArithmeticOperationEnum -> Subtract],
                empty
            )

    alias adjustmentSpreadAdded:
        if spread exists then spread -> value <> 0 else True

    set is_event:
        businessEvent -> intent = EventIntentEnum -> IndexTransition
            and floatingRateIndexChanged = True
            and adjustmentSpreadAdded = True

func Qualify_Novation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and a contract formation exist, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Novated, (v) the stepped-in contract has a different contract identifier than the novated contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates(businessEvent -> after)
    alias openTradeStates: FilterOpenTradeStates(businessEvent -> after)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> Novation
            and closedTradeStates count = 1
            and openTradeStates count = 1
            and businessEvent -> instruction -> primitiveInstruction -> split exists
            and beforeTradeState -> trade -> counterparty -> partyReference = closedTradeStates only-element -> trade -> counterparty -> partyReference
            and beforeTradeState -> trade -> counterparty -> partyReference <> openTradeStates only-element -> trade -> counterparty -> partyReference
            and beforeTradeState -> trade -> tradeIdentifier <> openTradeStates -> trade -> tradeIdentifier

func Qualify_OnDemandPayment: <"Qualification of a on-demand payment.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias instruction: businessEvent -> instruction only-element
    alias afterTradeStates: FilterOpenTradeStates(businessEvent -> after)
    alias transfer:
        businessEvent -> instruction -> primitiveInstruction -> transfer -> transferState -> transfer

    set is_event:
        businessEvent -> instruction count = 1
            and businessEvent -> after count = 1
            and afterTradeStates count = 1
            and instruction -> primitiveInstruction -> transfer only exists
            and transfer -> transferExpression -> scheduledTransfer -> transferType all = NetInterest

func Qualify_OnDemandRateChange: <"The qualification of on an-demand rate change event from the fact that the only primitive is the reset.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTrade: businessEvent -> instruction only-element -> before -> trade
    alias beforeProduct: beforeTrade -> product
    alias beforeEconomicterms: beforeProduct -> economicTerms
    alias openTrade: FilterOpenTradeStates(businessEvent -> after) only-element -> trade
    alias openEconomicTerms: openTrade -> product -> economicTerms
    alias closedTradeState: FilterClosedTradeStates(businessEvent -> after)

    alias beforePriceQuantityRateOnly: <"The rate value before. There must be 1 and only 1.">
        beforeTrade -> tradeLot only-element -> priceQuantity
            extract price
            then flatten
            then filter priceType = PriceTypeEnum -> InterestRate
            then extract value

    alias openPriceQuantityRateOnly: <"The rate value after. There must be 1 and only 1, and it must be different from the rate before.">
        openTrade -> tradeLot only-element -> priceQuantity
            extract price
            then flatten
            then filter priceType = PriceTypeEnum -> InterestRate
            then extract value

    alias beforePriceQuantityNoRate: <"The price and quantity attributes before, excluding any rate price.">
        beforeTrade -> tradeLot only-element -> priceQuantity
            extract
                PriceQuantity {
                    price: price
                        filter p [ p -> priceType <> PriceTypeEnum -> InterestRate ],
                    quantity: quantity,
                    observable: observable,
                    ...
                }

    alias openPriceQuantityNoRate: <"The price and quantity attributes after, excluding any rate price. They must be equal to the price and quantity before, excluding any rate price">
        openTrade -> tradeLot only-element -> priceQuantity
            extract
                PriceQuantity {
                    price: price
                        filter p [ p -> priceType <> PriceTypeEnum -> InterestRate ],
                    quantity: quantity,
                    observable: observable,
                    ...
                }

    set is_event:
        // The first 2 conditions imply that there is 1 and only 1 before and 1 open thanks to the "only-element" modifier
        beforeEconomicterms exists
            and openEconomicTerms exists
            and closedTradeState count = 1
            and // openEconomicTerms -> payout = beforeEconomicterms -> payout and
            openEconomicTerms -> collateral = beforeEconomicterms -> collateral
            and beforePriceQuantityRateOnly count = 1
            and openPriceQuantityRateOnly count = 1
            and beforePriceQuantityRateOnly only-element
                <> openPriceQuantityRateOnly only-element
            and beforePriceQuantityNoRate = openPriceQuantityNoRate

func Qualify_OpenOfferClearedTrade:
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias beforeTradeState: businessEvent -> instruction -> before
    alias openTradeStates: FilterOpenTradeStates(businessEvent -> after)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> Clearing
            and businessEvent -> instruction count = 2
            and businessEvent -> instruction -> primitiveInstruction -> execution exists
            and businessEvent -> instruction -> primitiveInstruction -> contractFormation exists
            and openTradeStates count = 2
            and openTradeStates
                extract [
                    item -> trade -> counterparty -> partyReference <> beforeTradeState -> trade -> counterparty -> partyReference
                        and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier
                        and item -> trade -> partyRole -> role contains PartyRoleEnum -> ClearingOrganization
                ] all = True

func Qualify_PairOff: <"Qualifies an event as a pair-off when all the details of the existing trades are maintained, except for their execution details which are updated to include a package component. This package component must be unique across all trades.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias openTradeState: FilterOpenTradeStates(businessEvent -> after)

    alias newTradeInstruction: <"New trade instructions, that contain only an execution primitive and (optionally) a contract formation primitive.">
        businessEvent -> instruction
            filter NewTradeInstructionOnlyExists(item -> primitiveInstruction)

    alias packageRef: <"Package details on the new trades.">
        openTradeState -> trade -> executionDetails -> packageReference

    set is_event:
        // The first condition asserts that there are only new executions
        newTradeInstruction count = businessEvent -> instruction count
                // All the trade details (except the execution instructions) are unchanged
                // and openTradeNoExecutionDetails = beforeTradeNoExecutionDetails
            and openTradeState -> trade -> product = newTradeInstruction -> before -> trade -> product
            and openTradeState -> trade -> tradeLot = newTradeInstruction -> before -> trade -> tradeLot
            and openTradeState -> trade -> counterparty = newTradeInstruction -> before -> trade -> counterparty
            and openTradeState -> trade -> ancillaryParty = newTradeInstruction -> before -> trade -> ancillaryParty
            and openTradeState -> trade -> adjustment = newTradeInstruction -> before -> trade -> adjustment
                // All open trades are associated to a package, and that package is the same across all trades
            and packageRef count = openTradeState count
            and packageRef distinct count = 1

func Qualify_PartialDelivery: <"Qualification of a partial delivery which constitutes a change in quantity and open with the remaining quantity and termination date.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeEconomicterms: ExtractBeforeEconomicTerms(businessEvent)

    alias openEconomicTerms: ExtractOpenEconomicTerms(businessEvent)

    alias openTrades: FilterOpenTradeStates(businessEvent -> after) -> trade
    alias closedTradeState: FilterClosedTradeStates(businessEvent -> after)

    alias beforeTrade: ExtractBeforeTrade(businessEvent)

    alias afterTrade: ExtractAfterTrade(businessEvent)

    alias beforeTradeCollateralQuantity:
        ExtractTradeCollateralQuantity(beforeTrade) only-element

    alias afterTradeCollateralQuantity:
        ExtractTradeCollateralQuantity(afterTrade) only-element

    set is_event:
        beforeEconomicterms exists
            and openEconomicTerms exists
            and openTrades count = 1
            and closedTradeState count = 1
            and openEconomicTerms -> payout -> InterestRatePayout = beforeEconomicterms -> payout -> InterestRatePayout
            and openEconomicTerms -> collateral = beforeEconomicterms -> collateral
            and beforeTradeCollateralQuantity > afterTradeCollateralQuantity
            and openEconomicTerms -> terminationDate = beforeEconomicterms -> terminationDate
            and openEconomicTerms -> effectiveDate = beforeEconomicterms -> effectiveDate

func Qualify_PartialNovation: <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and contractFormation exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates(businessEvent -> after)
    alias openTradeStates: FilterOpenTradeStates(businessEvent -> after)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> Novation
            and closedTradeStates count = 0
            and openTradeStates count = 2
            and businessEvent -> instruction -> primitiveInstruction -> split exists
            and openTradeStates
                extract [
                    // before trade counterparties should not match open after trade counterparties, and neither should trade identifiers
                    (item -> trade -> counterparty -> partyReference <> beforeTradeState -> trade -> counterparty -> partyReference
                            and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier)
                        or // before trade counterparties match open after trade counterparties, and match trade identifiers, but with decreased quantity
                        (item -> trade -> counterparty -> partyReference = beforeTradeState -> trade -> counterparty -> partyReference
                            and item -> trade -> tradeIdentifier = beforeTradeState -> trade -> tradeIdentifier
                            and QuantityDecreased(beforeTradeState, [item]))
                ] all = True

func Qualify_PartialTermination: <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias primitiveInstruction:
        businessEvent -> instruction -> primitiveInstruction only-element
    alias transfers:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
    set is_event:
        businessEvent -> intent is absent
            and (primitiveInstruction -> quantityChange only exists
                or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
            and (QuantityDecreased(businessEvent -> instruction -> before only-element, businessEvent -> after) = True)
            and businessEvent -> after -> state -> closedState is absent

func Qualify_PortfolioRebalancing: <"The qualification of a portfolio rebalancing event from the fact that (i) the intent is PortfolioRebalancing, and (ii) the execution primitive exists">
    // Pending to enhance the logic once portfolios are supported in the model
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> PortfolioRebalancing
            and businessEvent -> instruction -> primitiveInstruction -> execution exists

func Qualify_Reallocation: <"The qualification of a reallocation event from the fact that (i) a quantity change primitive exists, (ii) a split primitive exists, and (iii) the intent is Reallocation.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias closedTradeStates: FilterClosedTradeStates(businessEvent -> after)
    alias openTradeStates: FilterOpenTradeStates(businessEvent -> after)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> Reallocation
            and closedTradeStates count = 0
            and openTradeStates count = 2
            and businessEvent -> instruction -> primitiveInstruction -> split exists
            and openTradeStates
                extract [
                    // before trade counterparties should not match open after trade counterparties, and neither should trade identifiers
                    (item -> trade -> counterparty -> partyReference <> beforeTradeState -> trade -> counterparty -> partyReference
                            and item -> trade -> tradeIdentifier <> beforeTradeState -> trade -> tradeIdentifier)
                        or // before trade counterparties match open after trade counterparties, and match trade identifiers, but with decreased quantity
                        (item -> trade -> counterparty -> partyReference = beforeTradeState -> trade -> counterparty -> partyReference
                            and item -> trade -> tradeIdentifier = beforeTradeState -> trade -> tradeIdentifier
                            and QuantityDecreased(beforeTradeState, [item]))
                ] all = True

func Qualify_Renegotiation: <"The qualification of a renegotiation event from the fact that (i) the intent is Renegotiation when specified, and (ii) the associated primitives instructions are the TermsChange, QuantityChange and the cash transfer.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias transfers:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
    set is_event:
        (businessEvent -> intent is absent or businessEvent -> intent = EventIntentEnum -> ContractTermsAmendment)
            and (businessEvent -> instruction
                extract
                    (primitiveInstruction -> termsChange only exists or (primitiveInstruction -> termsChange, primitiveInstruction -> quantityChange) only exists)) all = True
            and (QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = False)
            and businessEvent -> after -> state -> closedState is absent

func Qualify_Reprice: <"This qualification function is used to qualify repricing of a contractual product with an interest rate payout and assetPayout.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias openTrades: FilterOpenTradeStates(businessEvent -> after) -> trade
    alias closedTradeState: FilterClosedTradeStates(businessEvent -> after)

    alias beforeTrade: ExtractBeforeTrade(businessEvent)

    alias afterTrade: ExtractAfterTrade(businessEvent)

    alias beforeTradePurchasePrice: ExtractTradePurchasePrice(beforeTrade)

    alias afterTradePurchasePrice: ExtractTradePurchasePrice(afterTrade)

    alias beforeTradeCollateralQuantity: ExtractTradeCollateralQuantity(beforeTrade)

    alias afterTradeCollateralQuantity: ExtractTradeCollateralQuantity(afterTrade)

    alias beforeTradeCollateralPrice: ExtractTradeCollateralPrice(beforeTrade)

    alias afterTradeCollateralPrice: ExtractTradeCollateralPrice(afterTrade)

    alias beforeEconomicterms: ExtractBeforeEconomicTerms(businessEvent)

    alias openEconomicTerms: ExtractOpenEconomicTerms(businessEvent)

    set is_event:
        businessEvent -> after -> trade -> product -> economicTerms -> payout -> InterestRatePayout exists
            and openTrades count = 1
            and closedTradeState count = 1
            and beforeTradePurchasePrice exists
            and afterTradePurchasePrice exists
            and afterTradePurchasePrice <> beforeTradePurchasePrice
            and beforeTradeCollateralQuantity = afterTradeCollateralQuantity
            and beforeTradeCollateralPrice <> afterTradeCollateralPrice
            and beforeEconomicterms exists
            and openEconomicTerms exists
            and openEconomicTerms -> terminationDate = beforeEconomicterms -> terminationDate

func Qualify_Repurchase: <"The qualification of a repurchase event from the fact that (i) a quantityChange instruction exists, (ii) an assetPayout exists, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Terminated, and (v) the intent of the event is 'Repurchase'.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    set is_event:
        businessEvent -> intent = EventIntentEnum -> Repurchase
            and businessEvent -> after -> trade -> product -> economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout exists
            and (businessEvent -> instruction count = 1
                and businessEvent -> instruction
                    only-element
                    extract
                        (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
            and QuantityDecreasedToZero(
                    businessEvent -> instruction -> before,
                    businessEvent -> after
                ) = True
            and businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated

func Qualify_Reset: <"The qualification of a reset event from the fact that the only primitive is the reset.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTradeState: businessEvent -> instruction -> before only-element
    alias afterTradeState: businessEvent -> after only-element
    set is_event:
        businessEvent -> after count = 1
            and beforeTradeState -> trade = afterTradeState -> trade
            and beforeTradeState -> resetHistory count + 1 = afterTradeState -> resetHistory count

func Qualify_Roll: <"Qualification of a roll event based on: (i) terminating a single existing trade, (ii) entering into a new trade with the same details as the old trade, except for the effective and termination date where the effective date. The roll qualification does not make any assumption on the resulting quantity which may change compared to the original trade (it may only be partially rolled). The price is also likely different as market conditions may have evolved.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeEconomicterms:
        businessEvent -> instruction only-element -> before -> trade -> product -> economicTerms
    alias openEconomicTerms:
        FilterOpenTradeStates(businessEvent -> after) only-element -> trade -> product -> economicTerms
    alias closedTradeState: FilterClosedTradeStates(businessEvent -> after)

    set is_event:
        // The first 2 conditions imply that there is 1 and only 1 before and 1 open thanks to the "only-element" modifier
        beforeEconomicterms exists
            and openEconomicTerms exists
            and closedTradeState count = 1
            and openEconomicTerms -> payout = beforeEconomicterms -> payout
            and openEconomicTerms -> collateral = beforeEconomicterms -> collateral
            and openEconomicTerms -> effectiveDate = beforeEconomicterms -> terminationDate
            and openEconomicTerms -> terminationDate <> beforeEconomicterms -> terminationDate

func Qualify_SecuritySettlement: <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias transfers:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
    set is_event:
        transfers -> asset -> Instrument -> Security exists
            and transfers -> quantity -> unit -> currency exists
            and FilterCashTransfers(transfers) only-element -> payerReceiver -> payerPartyReference = FilterSecurityTransfers(
                    transfers
                )
                only-element -> payerReceiver -> receiverPartyReference

func Qualify_SecurityTransfer: <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias transfer:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
            only-element
    set is_event:
        transfer -> asset -> Instrument -> Security exists
            and transfer -> quantity -> unit -> financialUnit only exists

func Qualify_Shaping: <"The qualification of a shaping event from the fact that (i) the only primitive is a split where the original trade is closed, (ii) the parties before and after the split remain the same (by contrast with an allocation, for instance) and (iii) the split trades contain a package component in their execution details. This package ties together the resulting shapes trades' identifiers and must be the same across all shaped trades. Note that SplitPrimitive type has a condition to check that the post-split quantities sum to the pre-split quantity.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias instruction: businessEvent -> instruction only-element
    alias beforeTradeState: instruction -> before
    alias closedTradeState: FilterClosedTradeStates(businessEvent -> after) only-element
    alias openTradeStates: FilterOpenTradeStates(businessEvent -> after)

    alias packageRef: <"Package details on the new trades.">
        openTradeStates -> trade -> executionDetails -> packageReference
    alias openTradeNoExecutionDetails: <"List of open trades with no execution details on, for comparison.">
        openTradeStates extract TradeNoExecutionDetails(item -> trade)

    set is_event:
        // There is a single before trade with a split instruction, resulting in a single closed trade and multiple open trades
        beforeTradeState exists
            and closedTradeState exists
            and openTradeStates count > 1
            and instruction -> primitiveInstruction -> split only exists
                // Open trade counterparties should match before trade counterparties
            and openTradeStates
                extract [
                    item -> trade -> counterparty -> partyReference = beforeTradeState -> trade -> counterparty -> partyReference
                ] all = True
                // All open trades are associated to a package, and that package is the same across all trades
            and packageRef count = openTradeNoExecutionDetails count
            and packageRef distinct count = 1

func Qualify_StockSplit: <"The qualification of StockSplit business event based on (i) an unchanged before/after currency amount (ii) the same adjustment ratio applied to the before/after cash price and number of units.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)

    alias beforeTradeState: businessEvent -> instruction -> before only-element

    alias afterTradeState: businessEvent -> after only-element

    alias beforeQuantities:
        beforeTradeState -> trade -> tradeLot only-element -> priceQuantity -> quantity

    alias beforeNoOfUnits:
        FilterQuantityByFinancialUnit(beforeQuantities, FinancialUnitEnum -> Share)
            only-element -> value

    alias afterQuantities: afterTradeState -> trade -> tradeLot -> priceQuantity -> quantity

    alias afterNoOfUnits:
        FilterQuantityByFinancialUnit(afterQuantities, FinancialUnitEnum -> Share)
            only-element -> value

    alias beforeCurrencyAmount:
        FilterQuantityByCurrencyExists(beforeQuantities) -> value distinct only-element

    alias afterCurrencyAmount:
        FilterQuantityByCurrencyExists(afterQuantities) -> value distinct only-element

    alias beforePrice: <"Only works in the case of a single trade lot and price.">
        beforeTradeState -> trade -> tradeLot only-element -> priceQuantity -> price
            filter perUnitOf -> financialUnit = FinancialUnitEnum -> Share
            then extract value
            then only-element

    alias afterPrice: <"Only works in the case of a single trade lot and price.">
        afterTradeState -> trade -> tradeLot only-element -> priceQuantity -> price
            filter perUnitOf -> financialUnit = FinancialUnitEnum -> Share
            then extract value
            then only-element

    alias currencyAmountUnchanged:
        if beforeCurrencyAmount exists and afterCurrencyAmount exists
        then beforeCurrencyAmount = afterCurrencyAmount
        else False

    alias noOfUnitsChanged:
        if beforeNoOfUnits exists and afterNoOfUnits exists
        then afterNoOfUnits <> beforeNoOfUnits
        else False

    alias cashPriceChanged:
        if beforePrice exists and afterPrice exists
        then beforePrice <> afterPrice
        else False

    alias adjustmentRatioMatches:
        if beforeNoOfUnits exists
                and beforeNoOfUnits > 0
                and afterNoOfUnits exists
                and beforePrice exists
                and afterPrice exists and afterPrice > 0
        then afterNoOfUnits / beforeNoOfUnits = beforePrice / afterPrice
        else False

    set is_event:
        currencyAmountUnchanged = True
            and noOfUnitsChanged = True
            and cashPriceChanged = True
            and adjustmentRatioMatches = True

func Qualify_Termination: <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the closedState of the contract is Terminated.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias primitiveInstruction:
        businessEvent -> instruction -> primitiveInstruction only-element
    alias transfer:
        TransfersForDate(
                businessEvent -> after -> transferHistory -> transfer,
                businessEvent -> eventDate
            )
            only-element
    set is_event:
        businessEvent -> intent is absent
            and (primitiveInstruction -> quantityChange only exists
                or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
            and (QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = True)
            and (businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated)

func Qualify_ValuationUpdate: <"The qualification of a valuation update from the fact that the only component is a valuation.">
    [qualification BusinessEvent]
    inputs:
        businessEvent BusinessEvent (1..1)
    output:
        is_event boolean (1..1)
    alias instruction: businessEvent -> instruction only-element
    set is_event: instruction -> primitiveInstruction -> valuation only exists



================================================================================
FILE: rosetta-source/src/main/rosetta/event-workflow-enum.rosetta
================================================================================

namespace cdm.event.workflow : <"Workflow concepts (orthogonal to business event): time stamp, credit limit, trade warehouse info and associated function specifications.">
version "${project.version}"

enum CreditLimitTypeEnum: <"The enumeration values to qualify the type of credit limits.">
    CS01 <"The type of credit line expressed in CS01. The sensitivity with respect to changes in the CDS spread.">
    DV01 <"The type of credit line expressed in DV01. The dollar value of a one basis point decrease in interest rates. It shows the change in a bond's price compared to a decrease in the bond's yield.">
    IM <"The type of credit line expressed in Initial Margin value.">
    Notional <"The type of credit line expressed in Notional amount.">
    NPV <"The type of credit line expressed as a Net Present Value.">
    PV01 <"The type of credit line expressed in PV01. The value of a one dollar or one basis point annuity.">

enum EventTimestampQualificationEnum: <"The enumeration values to qualify the timestamps that can be associated with a lifecycle event. The reason for such approach is that the experience of integrating the DTCC and CME data representations suggests that a wide set of timestamps are currently utilized among service providers, while there is not at present an objective set of criteria that could help suggest a defined set of timestamps as part of the CDM. Implementers are expected to evaluate the current enumeration values to determine whether those meet their requirements. If not, they are expected to engage with the CDM team to evaluate the addition of further value(s) to this enumeration, which will then participate to the development of a compendium for further evaluation at a later point in order to determine whether this modeling is appropriate.">
    clearingDateTime <"The date and time on the trade was cleared.">
    clearingConfirmationDateTime <"The date and time on which trade was confirmed as cleared.">
    clearingReceiptDateTime <"The date and time on which trade was received by Clearing Body.">
    clearingSubmissionDateTime <"The date and time on which the event was submitted for clearing.">
    confirmationDateTime <"The date and time on which the event was confirmed.">
    eventCreationDateTime <"The date and time on which the event was created.">
    eventExpirationDateTime <"The date and time on which the event will be considered expired.">
    eventProcessingDateTime <"The date and time on which the event was processed.">
    eventSentDateTime <"The date and time on which the event was sent.">
    eventSubmittedDateTime <"The date and time on which the event was submitted.">
    executionDateTime <"The date and time on which the trade execution was performed.">
    transactionCreationDateTime <"The date and time on which the transaction has been created. This timestamp is specified as such by the CME ClearPort Matched IRS Trade submission API specification: 'The transaction date time of the trade. Represents the date & time on which the trade was initially generated either by CME Clearing or firm. The transaction date time may be assigned by CME Clearing at the point the trade is reported as cleared. Transaction date time can also be provided by an external submitter of the trade at the point the trade is submitted.'">

enum LimitLevelEnum: <"The enumeration values to specify the level at which the limit is set: customer business, proprietary business or account level. This is part of the CME specification for clearing credit limits, although not specified as a set of enumerated values as part of the clearing confirmation specification.">
    Account <"The limit is set in relation to the proprietary business undertaken by the clearing counterparty.">
    Customer <"The limit is set in relation to the customer business undertaken by the clearing counterparty.">
    House <"The limit is set at the account level in relation to the clearing counterparty.">

enum WarehouseIdentityEnum:
    DTCC_TIW_Gold <"The DTCC Trade Information Warehouse Gold service">

enum WorkflowStatusEnum:
    Accepted
    Alleged
    Amended
    Cancelled
    Certain
    Cleared
    Pending
    Rejected
    Submitted
    Terminated
    Uncertain
    Unconfirmed
    Affirmed
    Confirmed


================================================================================
FILE: rosetta-source/src/main/rosetta/event-workflow-func.rosetta
================================================================================

namespace cdm.event.workflow : <"Workflow concepts (orthogonal to business event): time stamp, credit limit, trade warehouse info and associated function specifications.">
version "${project.version}"

import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*

annotation creation: <"Annotation to describe the intent of a function">
    [prefix Create]

    BusinessEvent BusinessEvent (0..1) <"A business event function should take as its inputs the after state of previous business event or in case where the is no before state, all of the inputs required to produce the outcome BusinessEvent.">
    WorkflowStep WorkflowStep (0..1) <"Create a proposed, accepted or rejected WorkflowStep with details about the message, identifiers, event timestamps, parties and accounts involved in the step and allow the action to be set to New, Correct or Cancel.">

func Create_WorkflowStep: <"Function to create a workflow step with a business event and associated details about the message, identifiers, event timestamps, parties and accounts involved in the step. The function should be used when there is already a fully formed business event with the action set to signify that the step is new, or a correction/cancellation of a previous step. The action is constrained so that when a previous workflow step is specified, the valid actions are as follows; New -> New, New -> Correct, New -> Cancel, Correct -> Correct and Correct -> Cancel. When a previous workflow is not specified, the action must be New.">
    [creation WorkflowStep]
    inputs:
        messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header.">
        timestamp EventTimestamp (1..*) <"The dateTime and qualifier associated with this event.">
        eventIdentifier Identifier (1..*) <"The identifiers that uniquely identify this lifecycle event.">
        party Party (0..*) <"The specification of the parties involved in the WorkflowStep.">
        account Account (0..*) <"Optional account information that could be associated to the event.">
        previousWorkflowStep WorkflowStep (0..1) <"Optional previous WorkflowStep that provides lineage to WorkflowStep that precedes it. If specified, the previous action is used to constrain the actions allows to the resulting workflow step.">
        action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation. When a previous workflow step is specified, the allowed actions are as follows; New -> New, New -> Correct, New -> Cancel, Correct -> Correct and Correct -> Cancel. When a previous workflow is not specified, the action must be New. Two consecutive workflow steps with action New, is valid when you have multiple steps e.g. new execution -> new contract formation">
        businessEvent BusinessEvent (0..1) <"Life cycle event for the step. The business event must be specified if the action is new or corrected, and must be absent in the case of a cancel where the previous step would provide the lineage to the business event.">
    output:
        workflowStep WorkflowStep (1..1) <"Workflow step with a business event (in the event of action being new or correct) and associated details about the message, identifiers, event timestamps, parties and accounts involved in the step.">

    condition PreviousBusinessEventExists: <"The previous workflow step must contain a business event. Use Create_AcceptedWorkflowStep when the previous workflow step is a proposal.">
        if previousWorkflowStep exists
        then previousWorkflowStep -> businessEvent exists

    condition ActionEnumChange: <"Valid action transitions are: New -> New, New -> Correct, New -> Cancel, Correct -> New, Correct -> Correct and Correct -> Cancel">
        if (previousWorkflowStep -> action = ActionEnum -> New or previousWorkflowStep -> action = ActionEnum -> Correct)
        then (action = ActionEnum -> New or action = ActionEnum -> Correct or action = ActionEnum -> Cancel)

    condition CancelledPreviousStep: <"You cannot create a business event on a cancelled previous step">
        previousWorkflowStep -> action <> ActionEnum -> Cancel

    condition NewAction: <"Action must be New if there is no previous step">
        if (previousWorkflowStep is absent or previousWorkflowStep -> action is absent)
        then (action = ActionEnum -> New)

    set workflowStep -> action: <"Assign the workflowStep action.">
        action

    set workflowStep -> messageInformation: <"Assign the workflowStep action.">
        messageInformation

    add workflowStep -> timestamp: <"Assign the dateTime and qualifier associated with this event.">
        timestamp

    add workflowStep -> eventIdentifier: <"Assign the identifiers that uniquely identify this lifecycle event.">
        eventIdentifier

    add workflowStep -> party: <"Assign the parties involved in the WorkflowStep.">
        party

    add workflowStep -> account: <"Assign the account information that could be associated to the event.">
        account

    set workflowStep -> previousWorkflowStep: <"Assign the key of the previous step to resulting step providing lineage.">
        if previousWorkflowStep exists then previousWorkflowStep as-key

    set workflowStep -> businessEvent: <"Assign the business event corresponding to the workflow step.">
        businessEvent

func Create_AcceptedWorkflowStep: <"Represents the acceptance of a proposed instruction that results in a workflow step containing a business event, message details, identifiers, event timestamps, parties and accounts. The previous workflow step input must exist to provide workflow lineage. The instruction from the previous workflow step should be used with a [creation BusinessEvent] function to create the input business event passed into this function e.g. PartyChangeInstruction from the previous step is used with Create_PartyChange to produce the business event which should used as an input to this step.">
    [creation WorkflowStep]
    inputs:
        messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header.">
        timestamp EventTimestamp (1..*) <"The dateTime and qualifier associated with this event.">
        eventIdentifier Identifier (1..*) <"The identifiers that uniquely identify this lifecycle event.">
        party Party (0..*) <"The specification of the parties involved in the WorkflowStep.">
        account Account (0..*) <"Optional account information that could be associated to the event.">
        proposedWorkflowStep WorkflowStep (1..1) <"Required previous WorkflowStep that provides lineage to WorkflowStep that precedes it.">
        businessEvent BusinessEvent (1..1) <"Life cycle event for the step">
    output:
        acceptedWorkflowStep WorkflowStep (1..1) <"Accepted WorkflowStep populated with the business event and associated details about the message, identifiers, event timestamps, parties and accounts involved in the step.">

    condition ProposedEventExists: <"The previous step being accepted must be a proposed step containing an instruction.">
        proposedWorkflowStep -> proposedEvent exists

    condition CancelledProposedStep: <"You cannot accept a business event on a cancelled previous step.">
        proposedWorkflowStep -> action <> ActionEnum -> Cancel

    condition RejectedProposedStep: <"The previous step cannot be rejected.">
        proposedWorkflowStep -> rejected <> True

    set acceptedWorkflowStep -> messageInformation: <"Assign the workflowStep action.">
        messageInformation

    add acceptedWorkflowStep -> timestamp: <"Assign the dateTime and qualifier associated with this event.">
        timestamp

    add acceptedWorkflowStep -> eventIdentifier: <"Assign the identifiers that uniquely identify this lifecycle event.">
        eventIdentifier

    add acceptedWorkflowStep -> party: <"Assign the parties involved in the WorkflowStep.">
        party

    add acceptedWorkflowStep -> account: <"Assign the account information that could be associated to the event.">
        account

    set acceptedWorkflowStep -> previousWorkflowStep: <"Set the reference to the previous WorkflowStep to provide lineage">
        proposedWorkflowStep as-key

    set acceptedWorkflowStep -> businessEvent: <"Assign the business event corresponding to the workflow step.">
        businessEvent

func Create_AcceptedWorkflowStepFromInstruction: <"Represents the acceptance of a proposed instruction that results in a workflow step containing a business event, message details, identifiers, event timestamps, parties and accounts. The previous workflow step input must exist to provide workflow lineage. The instruction from the previous workflow step should be used with a [creation BusinessEvent] function to create the input business event passed into this function e.g. PartyChangeInstruction from the previous step is used with Create_PartyChange to produce the business event which should used as an input to this step.">
    [creation WorkflowStep]
    inputs:
        proposedWorkflowStep WorkflowStep (1..1) <"WorkflowStep as instruction.">
    output:
        acceptedWorkflowStep WorkflowStep (1..1) <"Accepted WorkflowStep populated with the business event and associated details about the message, identifiers, event timestamps, parties and accounts involved in the step.">

    condition ProposedEventExists: <"The previous step being accepted must be a proposed step containing an instruction.">
        proposedWorkflowStep -> proposedEvent exists

    condition CancelledProposedStep: <"You cannot accept a business event on a cancelled previous step.">
        proposedWorkflowStep -> action <> ActionEnum -> Cancel

    condition RejectedProposedStep: <"The previous step cannot be rejected.">
        proposedWorkflowStep -> rejected <> True

    set acceptedWorkflowStep -> action: proposedWorkflowStep -> action
    set acceptedWorkflowStep -> messageInformation:
        proposedWorkflowStep -> messageInformation
    add acceptedWorkflowStep -> timestamp: proposedWorkflowStep -> timestamp
    add acceptedWorkflowStep -> eventIdentifier: proposedWorkflowStep -> eventIdentifier
    set acceptedWorkflowStep -> previousWorkflowStep: proposedWorkflowStep as-key
    set acceptedWorkflowStep -> nextEvent: proposedWorkflowStep -> nextEvent

    set acceptedWorkflowStep -> businessEvent: <"Assign the business event corresponding to the workflow step.">
        Create_BusinessEvent(
                proposedWorkflowStep -> proposedEvent -> instruction,
                proposedWorkflowStep -> proposedEvent -> intent,
                proposedWorkflowStep -> proposedEvent -> eventDate,
                proposedWorkflowStep -> proposedEvent -> effectiveDate
            )

    add acceptedWorkflowStep -> party:
        acceptedWorkflowStep -> businessEvent -> after -> trade -> party distinct
    add acceptedWorkflowStep -> account:
        acceptedWorkflowStep -> businessEvent -> after -> trade -> account distinct

func Create_ProposedWorkflowStep: <"Represents the proposal to create a business event that results in a workflow step containing an instruction, message details, identifiers, event timestamps, parties and accounts. The optional previous workflow step input provides workflow lineage to where there has been a correction or cancellation to the proposed step. The action is constrained so that when a previous workflow step is specified, the valid actions are as follows; New -> Correct and Correct -> Cancel. When a previous workflow is not specified, the action must be New.">
    [creation WorkflowStep]
    inputs:
        messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header">
        timestamp EventTimestamp (1..*) <"The dateTime and qualifier associated with this event.">
        eventIdentifier Identifier (1..*) <"The identifiers that uniquely identify this lifecycle event.">
        party Party (0..*) <"The specification of the parties involved in the WorkflowStep.">
        account Account (0..*) <"Optional account information that could be associated to the event.">
        previousWorkflowStep WorkflowStep (0..1) <"Optional previous WorkflowStep that provides lineage to WorkflowStep that precedes it.">
        action ActionEnum (1..1) <"Specifies whether the event is new or a correction. The action cannot be a cancellation or new if the previous step is also new.">
        proposedEvent EventInstruction (1..1) <"The proposed instruction for the step to initiate a workflow e.g. Clearing Instruction or Allocation Instruction">
        approval WorkflowStepApproval (0..*) <"The approval status of all parties on the proposed event.">
    output:
        proposedWorkflowStep WorkflowStep (1..1) <"Proposed WorkflowStep populated with the proposed instruction">

    condition CorrectAction: <"When the previous step is new or corrected and contains an instruction (proposed), the following action can only be correct.">
        if (previousWorkflowStep -> proposedEvent exists and (previousWorkflowStep -> action = ActionEnum -> New or previousWorkflowStep -> action = ActionEnum -> Correct))
        then action = ActionEnum -> Correct

    condition NewAction: <"When the previous step contains a business event, the following action can only be new.">
        if (previousWorkflowStep is absent or previousWorkflowStep -> businessEvent exists)
        then action = ActionEnum -> New

    set proposedWorkflowStep -> messageInformation: <"Assign the workflowStep action.">
        messageInformation

    add proposedWorkflowStep -> timestamp: <"Assign the dateTime and qualifier associated with this event.">
        timestamp

    add proposedWorkflowStep -> eventIdentifier: <"Assign the identifiers that uniquely identify this lifecycle event.">
        eventIdentifier

    add proposedWorkflowStep -> party: <"Assign the parties involved in the WorkflowStep.">
        party

    add proposedWorkflowStep -> account: <"Assign the account information that could be associated to the event.">
        account

    set proposedWorkflowStep -> previousWorkflowStep: <"Set the reference to the previous WorkflowStep to provide lineage">
        previousWorkflowStep as-key

    set proposedWorkflowStep -> proposedEvent: proposedEvent

    add proposedWorkflowStep -> approval: <"Assign the party approval statuses for this WorkflowStep">
        approval

func Create_RejectedWorkflowStep: <"Represents the rejection of a proposed instruction that results in a workflow step containing the rejection flag, message details, identifiers, event timestamps, parties and accounts involved in the step. The previous workflow step input must exist to provide workflow lineage. This function will be further developed to provide the reasons for rejection.">
    [creation WorkflowStep]
    inputs:
        messageInformation MessageInformation (0..1) <"Contains all information pertaining the messaging header">
        timestamp EventTimestamp (1..*) <"The dateTime and qualifier associated with this event.">
        eventIdentifier Identifier (1..*) <"The identifiers that uniquely identify this lifecycle event.">
        proposedWorkflowStep WorkflowStep (1..1) <"Required previous WorkflowStep that provides lineage to WorkflowStep that precedes it.">
    output:
        rejectedWorkflowStep WorkflowStep (1..1) <"Rejected WorkflowStep with lineage to the proposed step that preceded it.">

    condition ProposedEventExists: <"The previous proposed step being rejected must exist">
        proposedWorkflowStep -> proposedEvent exists

    set rejectedWorkflowStep -> messageInformation: <"Assign the workflowStep action.">
        messageInformation

    add rejectedWorkflowStep -> timestamp: <"Assign the dateTime and qualifier associated with this event.">
        timestamp

    add rejectedWorkflowStep -> eventIdentifier: <"Assign the identifiers that uniquely identify this lifecycle event.">
        eventIdentifier

    set rejectedWorkflowStep -> previousWorkflowStep: <"Set the reference to the previous WorkflowStep to provide lineage">
        proposedWorkflowStep as-key

    set rejectedWorkflowStep -> rejected: <"Set the rejected flag to True">
        True

func Create_Workflow: <"Function to create a Workflow from a list of WorkflowStep.">
    inputs:
        steps WorkflowStep (1..*)
    output:
        workflow Workflow (1..1)
    add workflow -> steps: steps


================================================================================
FILE: rosetta-source/src/main/rosetta/event-workflow-type.rosetta
================================================================================

namespace cdm.event.workflow : <"Workflow concepts (orthogonal to business event): time stamp, credit limit, trade warehouse info and associated function specifications.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*

type CreditLimitInformation: <"A class to represent the credit limit utilisation information.">

    limitApplicable LimitApplicableExtended (1..*)

type CreditLimitUtilisation: <"Credit limit utilisation breakdown by executed trades and pending orders.">

    executed CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to executed trades.">
    pending CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to pending unexecuted orders.">

type CreditLimitUtilisationPosition:

    shortPosition number (0..1) <"Credit limit utilisation attributable to short positions.">
    longPosition number (0..1) <"Credit limit utilisation attributable to long positions.">
    global number (0..1) <"Global credit limit utilisation amount, agnostic of long/short position direction.">

type CustomisedWorkflow: <"In its initial iteration, this class is meant to support the DTCC TIW workflow information.">

    itemName string (1..1) <"In this initial iteration, this corresponds to the DTCC TIW element name.">
    itemValue string (1..1) <"In this initial iteration, this corresponds to the DTCC value.">

type WorkflowStepApproval: <"Party approvals associated to the current WorkflowStep. ">
    [metadata key]
    approved boolean (1..1) <"Flag denoting whether the workflow step is approved or not">
    party Party (1..1) <"Reference to the Party who is approving/rejecting this workflow step">
        [metadata reference]
    rejectedReason string (0..1) <"Optional reason for rejecting the workflow step">
    timestamp EventTimestamp (1..1) <"Timestamp of the approval">

type WorkflowStep: <"A workflow step represents the state of a business event. The workflow step contains a reference to a previous WorkflowStep in order to preserve lineage. A workflow step is accepted if it contains a business event, proposed if proposedEvent is present and is rejected if the rejected flag is set.">
    [metadata key]
    [rootType]

    businessEvent BusinessEvent (0..1) <"Life cycle event for the step. The businessEvent is optional when a proposedEvent or rejection are present.">
    counterpartyPositionBusinessEvent CounterpartyPositionBusinessEvent (0..1) <"Documents the life cycle event for a position.">
    proposedEvent EventInstruction (0..1) <"The proposed event for a workflow step. The proposedEvent is optional when the businessEvent or rejection are present">
    rejected boolean (0..1) <"Flags this step as rejected.">
    approval WorkflowStepApproval (0..*) <"Optional party approvals for the current workflow step. A workflow step can have any number of parties associated to it, thus this object is represented as a list. All parties that are expected to provide approval should have an item in this list that references them.">
    previousWorkflowStep WorkflowStep (0..1) <"Optional previous workflow step that provides lineage to workflow steps that precedes it.">
        [metadata reference]
    nextEvent EventInstruction (0..1) <"The intended next event can be specified, even if the instructions are not known yet.">
    messageInformation MessageInformation (0..1) <"Contains all information pertaining the FpML messaging header ">
    timestamp EventTimestamp (1..*) <"The set of timestamp(s) associated with the event as a collection of [dateTime, qualifier].">
    eventIdentifier Identifier (1..*) <"The identifier(s) that uniquely identify a lifecycle event. The unbounded cardinality is meant to provide the ability to associate identifiers that are issued by distinct parties. As an example, each of the parties to the event may choose to associate their own identifiers to the event.">
    action ActionEnum (0..1) <"Specifies whether the event is a new, a correction or a cancellation.">
    party Party (0..*) <"The specification of the event parties. This attribute is optional, as not applicable to certain events (e.g. most of the observations).">
    account Account (0..*) <"Optional account information that could be associated to the event.">
    lineage Lineage (0..1) <"The lineage attribute provides a linkage among lifecycle events through the globalKey hash value. One example is when a given lifecycle event is being corrected or cancelled. In such case, each subsequent event will have lineage into the prior version of that event. The second broad use case is when an event has a dependency upon either another event (e.g. the regular payment associated with a fix/float swap will have a lineage into the reset event, which will in turn have a lineage into the observation event for the floating rate and the contract) or a contract (e.g. the exercise of an option has a lineage into that option).">
        [deprecated]
    creditLimitInformation CreditLimitInformation (0..1)
    workflowState WorkflowState (0..1) <"The event workflow information, i.e. the workflow status, the associated comment and the partyCustomisedWorkflow which purpose is to provide the ability to associate custom workflow information to the CDM.">

    condition WorkflowStepStatus:
        (businessEvent exists and nextEvent -> instruction is absent and rejected is absent)
            or (nextEvent -> instruction exists and businessEvent is absent and rejected is absent)
            or (rejected exists and businessEvent is absent and nextEvent is absent)
            or (proposedEvent exists and nextEvent is absent and rejected is absent)
            or (previousWorkflowStep exists and action = ActionEnum -> Cancel)

    condition CounterpartyPositionBusinessEventOrBusinessEventChoice: <"Choice rule to control that either positionBusinessEvent is present or businessEvent is present, but not both at the same time.">
        required choice counterpartyPositionBusinessEvent, businessEvent

type Workflow: <"A collection of workflow steps which together makeup an entire workflow sequence.">

    steps WorkflowStep (1..*)

type EventInstruction: <"Specifies instructions to create a BusinessEvent.">

    intent EventIntentEnum (0..1) <"The intent attribute is meant to be specified when the event qualification cannot be programmatically inferred from the event features. As a result it is only associated with those primitives that can give way to such ambiguity, the quantityChange being one of those. An example of such is a reduction in the trade notional, which could be interpreted as either a trade correction (unless a maximum period of time post-event is specified as part of the qualification), a partial termination or a portfolio rebalancing in the case of an equity swap. On the other hand, an event such as the exercise is not expected to have an associated intent as there should not be ambiguity.">
    corporateActionIntent CorporateActionTypeEnum (0..1)
    eventDate date (0..1) <"Specifies the date on which the event is taking place. This date is equal to the trade date in the case of a simple execution.  However it can be different from the trade date, for example in the case of a partial termination.">
    effectiveDate date (0..1) <"The date on which the event contractually takes effect, when different from the event date.">
    packageInformation IdentifiedList (0..1) <"Specifies the package information in case the business event represents several trades executed as a package (hence this attribute is optional). The package information is only instantiated once at the business event level to preserve referential integrity, whereas individual trades make reference to it to identify that they are part of a package.">
    instruction Instruction (0..*) <"Specifies the instructions to create the Business Event.">

    condition CorporateAction:
        if corporateActionIntent exists
        then intent = EventIntentEnum -> CorporateActionAdjustment

type EventTimestamp: <"A class to represent the various set of timestamps that can be associated with lifecycle events, as a collection of [dateTime, qualifier].">

    dateTime zonedDateTime (1..1) <"The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">
    qualification EventTimestampQualificationEnum (1..1) <"The timestamp qualifier is specified through an enumeration because the experience of integrating the DTCC and CME data representations suggests that a wide set of timestamps are currently utilized among service providers, while there is not at present an objective set of criteria that could help suggest a defined set of timestamps as part of the CDM. At some future point, one possible baseline could be developed from the review of the set of timestamps specified across regulatory regimes and regulations (incl. regulations such as high frequency trading). Also, the integration with a further set of implementations and the specification of business workflows such as clearing as part of the CDM development should help confirm the implementation approach in this respect.">

type WorkflowState: <"A class to specify workflow information, which is conceptually applicable to all lifecycle events.">

    workflowStatus WorkflowStatusEnum (1..1) <"The workflow status indicator, e.g. Accepted, Rejected, ...">
    comment string (0..1) <"A comment field to be associated with the workflow, e.g. to specify why a transaction event was rejected by a party.">
    partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Workflow data that is specific to certain market participants and is expressed as part of the CDM in a very generic manner, which can be party-specific. The initial use cases have been derived from the CME clearing and the DTCC TIW submissions.">
    warehouseIdentity WarehouseIdentityEnum (0..1) <"The identity of the warehouse, if any, that is executing that workflow step.">

type LimitApplicable:

    limitType CreditLimitTypeEnum (0..1) <"Standard code to indicate which type of credit line is being referred to - i.e. IM, DV01, PV01, CS01, Notional, Clip Size, Notional, maximumOrderQuantity.">
        [metadata scheme]
    clipSize int (0..1) <"This element is required in FpML, optional in CDM for the purpose of accommodating the CME data representation while making reference to the FpML one.">
    amountUtilized number (0..1) <"The limit utilised by all the cleared trades for the limit level and limit type. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
    utilization CreditLimitUtilisation (0..1)
    amountRemaining number (0..1) <"The limit remaining for the limit level and limit type. This does not take into account any pending trades. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
    currency string (0..1) <"The currency in which the applicable limit is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]
    velocity Velocity (0..1)

    condition LimitApplicableChoice: <"Choice rule to represent an FpML choice construct.">
        optional choice amountUtilized, utilization

type LimitApplicableExtended extends LimitApplicable: <"A class to represent the CDM attributes that are not part of the FpML standard. Once broader usage is confirmed, it is expected that those two classes can be collapsed.">

    limitLevel LimitLevelEnum (0..1) <"The level at which the limit is set: customer business, proprietary business or account level. This attribute is specified as a string as part of the CME clearing confirmation specification.">
        [metadata scheme]
    limitAmount number (0..1) <"The total limit available for the limit level and limit type. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">
    limitImpactDueToTrade number (0..1) <"The limit utilized by this specific trade. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">

type MessageInformation: <"This class corresponds to the components of the FpML MessageHeader.model.">

    messageId string (1..1) <"A unique identifier assigned to the message.">
        [metadata scheme]
    sentBy string (0..1) <"The identifier for the originator of a message instance.">
        [metadata scheme]
    sentTo string (0..*) <"The identifier(s) for the recipient(s) of a message instance.">
        [metadata scheme]
    copyTo string (0..*) <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">
        [metadata scheme]

type PartyCustomisedWorkflow: <"A class to specify a party-related, non-standardized data in a generic form.">

    partyReference Party (0..1) <"Reference to the party to which the workflow pertains to.">
        [metadata reference]
    partyName string (0..1) <"The party name to which the workflow pertains to.">
    customisedWorkflow CustomisedWorkflow (1..*) <"Non-standardized data in a generic form.">

    condition PartyCustomisedWorkflowChoice: <"The identification of the party to which the PartyCustomisedWorkflow pertains to can be done through either a party reference or the party name.">
        required choice partyName, partyReference

type Velocity:

    periodMultiplier int (0..1)
    period PeriodTimeEnum (0..1)


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-common-enum.rosetta
================================================================================

namespace cdm.legaldocumentation.common : <"Common legal agreement concepts.">
version "${project.version}"

import cdm.mapping.config.*

enum ContractualDefinitionsEnum: <"The enumerated values to specify a set of standard contract definitions relevant to the transaction.">
    ISDA1991InterestRate <"ISDA 1991 Interest Rate Definitions">
    ISDA1993CommodityDerivatives <"ISDA 1993 Commodity Derivatives Definitions">
    ISDA1996EquityDerivatives <"ISDA 1996 Equity Derivatives Definitions">
    ISDA1997Bullion <"ISDA 1997 Bullion Definitions">
    ISDA1997GovernmentBondOption <"ISDA 1997 Government Bond Option Definitions">
    ISDA1998FxAndCurrencyOption <"ISDA 1998 FX and Currency Option Definitions">
    ISDA1999CreditDerivatives <"ISDA 1999 Credit Derivatives Definitions">
    ISDA2000 <"ISDA 2000 Definitions">
    ISDA2002EquityDerivatives <"ISDA 2002 Equity Derivatives Definitions">
    ISDA2003CreditDerivatives <"ISDA 2003 Credit Derivatives Definitions">
    ISDA2004Novation <"ISDA 2004 Novation Definitions">
    ISDA2005Commodity <"ISDA 2005 Commodity Definitions">
    ISDA2006 <"ISDA 2006 Definitions">
    ISDA2006InflationDerivatives <"ISDA 2006 Inflation Derivatives Definitions">
    ISDA2008InflationDerivatives <"ISDA 2008 Inflation Derivatives Definitions">
    ISDA2011EquityDerivatives <"ISDA 2011 Equity Derivatives Definitions">
    ISDA2014CreditDerivatives <"ISDA 2014 Credit Derivatives Definitions">
    ISDA2021InterestRateDerivatives <"ISDA 2021 Interest Rate Derivatives Definitions">
    ISDA2022VerifiedCarbonCredit <"ISDA 2022 Verified Carbon Credit Transactions Definitions">
    ISDA2023DigitalAssetDerivatives <"ISDA 2023 Digital Asset Derivatives Definitions">

enum ContractualSupplementTypeEnum: <"The enumerated values to define the supplements to a base set of ISDA Definitions that are applicable to the transaction.">
    ABX <"Standard Terms Supplement for ABX Transactions.">
    ABXTranche <"Standard Terms Supplement for Asset-Backed Tranche Transactions.">
    CDSonLeveragedLoans <"ISDA Standard Terms Supplement for use with Credit Derivative Transactions on Leveraged Loans.">
    CDSonMBS <"ISDA Standard Terms Supplement for use with Credit Derivative Transactions on Mortgage-backed Security with Pay-As-You-Go or Physical Settlement.">
    CDX <"Standard Terms Supplement for CDX Untranched Transactions.">
    CDXEmergingMarkets <"Standard Terms Supplement for CDX Emerging Markets Untranched Transactions.">
    CDXEmergingMarketsDiversified <"Standard Terms Supplement for CDX Emerging Markets Diversified Untranched Transactions..">
    CDXSwaption <"Standard Terms Supplement for CDX Swaption Transactions.">
    CDXTranche <"Standard Terms Supplement for Dow Jones CDX Tranche Transactions.">
    CMBX <"Standard Terms Supplement for CMBX Transactions.">
    EuropeanCMBS <"Standard Terms Supplement for Single Name European CMBS Transactions.">
    EuropeanRMBS <"Standard Terms Supplement for Single Name European RMBS Transactions.">
    IOS <"Standard Terms Supplement for IOS Transactions.">
    ISDA1999CreditConvertibleExchangeableAccretingObligations <"Supplement to the 1999 ISDA Credit Derivatives Definitions Relating to Convertible, Exchangeable or Accreting Obligations dated November 9, 2001.">
    ISDA1999CreditRestructuring <"Restructuring Supplement to the 1999 ISDA Credit Derivatives Definitions dated May 11, 2001.">
    ISDA1999CreditSuccessorAndCreditEvents <"Supplement Relating to Successor and Credit Events to the 1999 ISDA Credit Derivatives Definitions dated November 28, 2001.">
    ISDA2003AdditionalProvisionsLPN <"Additional Provisions for LPN dated December 6, 2007.">
    ISDA2003ContingentCreditSpreadTransaction <"Additional Provisions for Contingent Credit Spread Transactions dated August 15, 2008.">
    ISDA2003Credit2005MatrixSupplement <"2005 Matrix Supplement to the 2003 ISDA Credit Derivatives.">
    ISDA2003CreditArgentineRepublic <"Additional Provisions for the Argentine Republic: Excluded Obligations and Excluded Deliverable Obligations dated December 21, 2005.">
    ISDA2003CreditAuctionSupplement <"ISDA Credit Derivatives Determinations Committees and Auction Settlement Supplement to the 2003 ISDA Credit Derivatives Definitions (published on [TBD]).">
    ISDA2003CreditMay2003 <"May 2003 Supplement to the 2003 ISDA Credit Derivatives Definitions.">
    ISDA2003CreditMonolineInsurers <"Additional Provisions for Physically Settled Default Swaps Monoline Insurer as Reference Entity dated May 9, 2003.">
    ISDA2003CreditMonolineInsurers2005 <"Additional Provisions for Physically Settled Default Swaps Monoline Insurer as Reference Entity dated January 21, 2005.">
    ISDA2003CreditRepublicOfHungary <"Additional Provisions for the Republic of Hungary: Obligation Characteristics and Deliverable Obligation Characteristics dated August 13, 2004.">
    ISDA2003CreditRepublicOfHungary2005 <"Additional Provisions for the Republic of Hungary: Obligation Characteristics and Deliverable Obligation Characteristics dated February 14, 2005. ">
    ISDA2003CreditRussianFederation <"Additional Provisions for the Russian Federation: Obligation Characteristics and Deliverable Obligation Characteristics dated August 13, 2004.">
    ISDA2003CreditUSMunicipals <"Additional Provisions for Credit Derivative Transactions - U.S. Municipal Entity as Reference Entity dated September 17, 2004.">
    ISDA2003STMicroelectronicsNV <"Additional Provisions for STMicroelectronics NV dated December 6, 2007.">
    ISDA2007FullLookthroughDepositoryReceiptSupplement <"2007 Full Lookthrough Depository Receipt Supplement to the 2002 Equity Derivatives Definitions.">
    ISDA2007PartialLookthroughDepositoryReceiptSupplement <"2007 Partial Lookthrough Depository Receipt Supplement to the 2002 ISDA Equity Derivatives Definitions.">
    ISDACreditMonolineInsurers <"Additional Provisions for Physically Settled Default Swaps Monoline Insurer.">
    ISDADeliveryRestrictions <"Additional Provisions for Fixed Recovery Credit Default Swap Transactions">
    ISDAFixedRecovery <"Additional Provisions for Fixed Recovery Credit Default Swap Transactions.">
    ISDALPNReferenceEntities <"Additional Provisions for LPN Reference Entities.">
    ISDAMarch2004EquityCanadianSupplement <"Canadian Supplement to the 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement dated March 29, 2004.">
    ISDARecoveryLock <"Additional Provisions for Recovery Lock Credit Default Swap Transactions.">
    ISDASecuredDeliverableObligationCharacteristic <"Additional Provisions for Secured Deliverable Obligation Characteristic.">
    LCDX <"Standard Terms Supplement for Syndicated Secured Loan Credit Default Swap Index Transactions.">
    LCDXTranche <"Standard Terms Supplement for Syndicated Secured Loan Credit Default Swap Index Tranche Transactions.">
    MBX <"Standard Terms Supplement for MBX Transactions.">
    MCDX <"Standard Terms Supplement for Municipal CDX Untranched Transactions.">
    PO <"Standard Terms Supplement for PO Index Transactions.">
    PrimeX <"Standard Terms Supplement for PrimeX Transactions.">
    StandardCDXTranche <"Standard Terms Supplement for Standard CDX Tranche Transactions.">
    StandardLCDS <"Standard Syndicated Secured Loan Credit Default Swap Standard Terms Supplement.">
    StandardLCDSBullet <"Standard Terms Supplement for Standard Syndicated Secured Loan Credit Default Swap Bullet Transactions.">
    StandardLCDXBullet <"Standard Terms Supplement for Standard Syndicated Secured Loan Credit Default Swap Index Bullet Transactions.">
    StandardLCDXBulletTranche <"Standard Terms Supplement for Standard Syndicated Secured Loan Credit Default Swap Index Bullet Tranche Transactions.">
    StandardiTraxxEuropeTranche <"Standard Terms Supplement for Standard iTraxx Europe Tranched Transactions.">
    SyndicatedSecuredLoanCDS <"Syndicated Secured Loan Credit Default Swap Standard Terms Supplement.">
    TRX <"Standard Terms Supplement for TRX Transactions.">
    TRX_II displayName "TRX.II" <"Standard Terms Supplement for TRX.II Transactions.">
    iTraxxAsiaExJapan <"Standard Terms Supplement for iTraxx Asia Excluding Japan.">
    iTraxxAsiaExJapanSwaption <"Standard Terms Supplement for iTraxx Asia Ex-Japan Swaption Transactions.">
    iTraxxAsiaExJapanTranche <"Standard Terms Supplement for iTraxx Asia Excluding Japan Tranched Transactions.">
    iTraxxAustralia <"Standard Terms Supplement for iTraxx Australia.">
    iTraxxAustraliaSwaption <"Standard Terms Supplement for iTraxx Australia Swaption Transactions.">
    iTraxxAustraliaTranche <"Standard Terms Supplement for iTraxx Australia Tranched Transactions.">
    iTraxxCJ <"Standard Terms Supplement for iTraxx CJ.">
    iTraxxCJTranche <"Standard Terms Supplement for iTraxx CJ Tranched Transactions.">
    iTraxxEurope <"Standard Terms Supplement for iTraxx Europe Transactions.">
    iTraxxEuropeDealer <"Standard Terms Supplement for iTraxx Europe Dealer Form.">
    iTraxxEuropeNonDealer <"Standard Terms Supplement for iTraxx Europe Non-Dealer Form.">
    iTraxxEuropeSwaption <"Standard Terms Supplement for iTraxx Europe Swaption Transactions.">
    iTraxxEuropeTranche <"Standard Terms Supplement for iTraxx Europe Tranched Transactions.">
    iTraxxJapan <"Standard Terms Supplement for iTraxx Japan.">
    iTraxxJapanSwaption <"Standard Terms Supplement for iTraxx Japan Swaption Transactions.">
    iTraxxJapanTranche <"Standard Terms Supplement for iTraxx Japan Tranched Transactions.">
    iTraxxLevX <"Standard Terms Supplement for iTraxx LevX.">
    iTraxxSDI75Dealer <"Standard Terms Supplement for iTraxx SDI 75 Dealer Transactions.">
    iTraxxSDI75NonDealer <"Standard Terms Supplement for iTraxx SDI 75 Non-Dealer Transactions.">
    iTraxxSovX <"Standard Terms Supplement for iTraxx SovX.">

enum GoverningLawEnum: <"The enumerated values to specify the law governing the contract or legal document.">
    AsSpecifiedInMasterAgreement <"The Governing Law is determined by reference to the relevant master agreement.">
    BE <"Belgian law">
    CAAB <"Alberta law">
    CABC <"British Columbia Law">
    CAMN <"Manitoba law">
    CAON <"Ontario law">
    CAQC <"Quebec law">
    DE <"German law">
    FR <"French law">
    GBEN <"English law">
        [synonym AcadiaSoft_AM_1_0 value "ENGLISH"]
    GBGY <"The law of the island of Guernsey">
    GBIM <"The law of the Isle of Man">
    GBJY <"The law of the island of Jersey">
    GBSC <"Scottish law">
    IE <"Irish law">
    JP <"Japanese law">
        [synonym AcadiaSoft_AM_1_0 value "JAPAN"]
    LU <"Luxembourg law">
    RelatedMasterAgreement <"As agreed in the ISDA Master Agreement">
    USCA <"Californian law">
    USDE <"Delaware law">
    USIL <"Illinois law">
    USNY <"New York law">
        [synonym AcadiaSoft_AM_1_0 value "NY"]

enum LengthUnitEnum: <"The enumerated values to specify the length unit in the Resource type.">
    Pages
    TimeUnit

enum MatrixTermEnum: <"The enumerated values to specify a scheme of transaction types specified in the Equity Derivatives Settlement Matrix.">
    AsiaCorporate <"Matrix Transaction Type of ASIA CORPORATE.">
    AsiaFinancialCorporate <"Matrix Transaction Type of ASIA FINANCIAL CORPORATE.">
    AsiaSovereign <"Matrix Transaction Type of ASIA SOVEREIGN.">
    AustraliaCorporate <"Matrix Transaction Type of AUSTRALIA CORPORATE.">
    AustraliaFinancialCorporate <"Matrix Transaction Type of AUSTRALIA FINANCIAL CORPORATE.">
    AustraliaSovereign <"Matrix Transaction Type of AUSTRALIA SOVEREIGN.">
    EmergingEuropeanAndMiddleEasternSovereign <"Matrix Transaction Type of EMERGING EUROPEAN AND MIDDLE EASTERN SOVEREIGN.">
    EmergingEuropeanCorporate <"Matrix Transaction Type of EMERGING EUROPEAN CORPORATE.">
    EmergingEuropeanCorporateLPN <"Matrix Transaction Type of EMERGING EUROPEAN CORPORATE LPN.">
    EmergingEuropeanFinancialCorporate <"Matrix Transaction Type of EMERGING EUROPEAN FINANCIAL CORPORATE.">
    EmergingEuropeanFinancialCorporateLPN <"Matrix Transaction Type of EMERGING EUROPEAN FINANCIAL CORPORATE LPN.">
    EuropeanCoCoFinancialCorporate <"Matrix Transaction Type of EUROPEAN COCO FINANCIAL CORPORATE.">
    EuropeanCorporate <"Matrix Transaction Type of EUROPEAN CORPORATE.">
    EuropeanFinancialCorporate <"Matrix Transaction Type of EUROPEAN FINANCIAL CORPORATE.">
    EuropeanSeniorNonPreferredFinancialCorporate <"Matrix Transaction Type of EUROPEAN SENIOR NON PREFERRED FINANCIAL CORPORATE.">
    IVS1OpenMarkets <"The ISDA-published 2011 Index Volatility Swap Agreement for Open Markets.">
    JapanCorporate <"Matrix Transaction Type of JAPAN CORPORATE.">
    JapanFinancialCorporate <"Matrix Transaction Type of JAPAN FINANCIAL CORPORATE.">
    JapanSovereign <"Matrix Transaction Type of JAPAN SOVEREIGN.">
    LatinAmericaCorporate <"Matrix Transaction Type of LATIN AMERICA CORPORATE.">
    LatinAmericaCorporateBond <"Matrix Transaction Type of LATIN AMERICA CORPORATE B.">
    LatinAmericaCorporateBondOrLoan <"Matrix Transaction Type of LATIN AMERICA CORPORATE BL.">
    LatinAmericaFinancialCorporateBond <"Matrix Transaction Type of LATIN AMERICA FINANCIAL CORPORATE B.">
    LatinAmericaFinancialCorporateBondOrLoan <"Matrix Transaction Type of LATIN AMERICA FINANCIAL CORPORATE BL.">
    LatinAmericaSovereign <"Matrix Transaction Type of LATIN AMERICA SOVEREIGN.">
    NewZealandCorporate <"Matrix Transaction Type of NEW ZEALAND CORPORATE.">
    NewZealandFinancialCorporate <"Matrix Transaction Type of NEW ZEALAND FINANCIAL CORPORATE.">
    NewZealandSovereign <"Matrix Transaction Type of NEW ZEALAND SOVEREIGN.">
    NorthAmericanCorporate <"Matrix Transaction Type of NORTH AMERICAN CORPORATE.">
    NorthAmericanFinancialCorporate <"Matrix Transaction Type of NORTH AMERICAN FINANCIAL CORPORATE.">
    SingaporeCorporate <"Matrix Transaction Type of SINGAPORE CORPORATE.">
    SingaporeFinancialCorporate <"Matrix Transaction Type of SINGAPORE FINANCIAL CORPORATE.">
    SingaporeSovereign <"Matrix Transaction Type of SINGAPORE SOVEREIGN.">
    StandardAsiaCorporate <"Matrix Transaction Type of STANDARD ASIA CORPORATE.">
    StandardAsiaFinancialCorporate <"Matrix Transaction Type of STANDARD ASIA FINANCIAL CORPORATE.">
    StandardAsiaSovereign <"Matrix Transaction Type of STANDARD ASIA SOVEREIGN.">
    StandardAustraliaCorporate <"Matrix Transaction Type of STANDARD AUSTRALIA CORPORATE.">
    StandardAustraliaFinancialCorporate <"Matrix Transaction Type of STANDARD AUSTRALIA FINANCIAL CORPORATE.">
    StandardAustraliaSovereign <"Matrix Transaction Type of STANDARD AUSTRALIA SOVEREIGN.">
    StandardEmergingEuropeanAndMiddleEasternSovereign <"Matrix Transaction Type of STANDARD EMERGING EUROPEAN AND MIDDLE EASTERN SOVEREIGN.">
    StandardEmergingEuropeanCorporate <"Matrix Transaction Type of STANDARD EMERGING EUROPEAN CORPORATE.">
    StandardEmergingEuropeanCorporateLPN <"Matrix Transaction Type of STANDARD EMERGING EUROPEAN CORPORATE LPN.">
    StandardEmergingEuropeanFinancialCorporate <"Matrix Transaction Type of STANDARD EMERGING EUROPEAN FINANCIAL CORPORATE.">
    StandardEmergingEuropeanFinancialCorporateLPN <"Matrix Transaction Type of STANDARD EMERGING EUROPEAN FINANCIAL CORPORATE LPN.">
    StandardEuropeanCoCoFinancialCorporate <"Matrix Transaction Type of STANDARD EUROPEAN COCO FINANCIAL CORPORATE.">
    StandardEuropeanCorporate <"Matrix Transaction Type of STANDARD EUROPEAN CORPORATE.">
    StandardEuropeanFinancialCorporate <"Matrix Transaction Type of STANDARD EUROPEAN FINANCIAL CORPORATE.">
    StandardEuropeanSeniorNonPreferredFinancialCorporate <"Matrix Transaction Type of STANDARD EUROPEAN SENIOR NON PREFERRED FINANCIAL CORPORATE.">
    StandardJapanCorporate <"Matrix Transaction Type of STANDARD JAPAN CORPORATE.">
    StandardJapanFinancialCorporate <"Matrix Transaction Type of STANDARD JAPAN FINANCIAL CORPORATE.">
    StandardJapanSovereign <"Matrix Transaction Type of STANDARD JAPAN SOVEREIGN.">
    StandardLatinAmericaCorporateBond <"Matrix Transaction Type of STANDARD LATIN AMERICA CORPORATE B.">
    StandardLatinAmericaCorporateBondOrLoan <"Matrix Transaction Type of STANDARD LATIN AMERICA CORPORATE BL.">
    StandardLatinAmericaFinancialCorporateBond <"Matrix Transaction Type of STANDARD LATIN AMERICA FINANCIAL CORPORATE B.">
    StandardLatinAmericaFinancialCorporateBondOrLoan <"Matrix Transaction Type of STANDARD LATIN AMERICA FINANCIAL CORPORATE BL.">
    StandardLatinAmericaSovereign <"Matrix Transaction Type of STANDARD LATIN AMERICA SOVEREIGN.">
    StandardNewZealandCorporate <"Matrix Transaction Type of STANDARD NEW ZEALAND CORPORATE.">
    StandardNewZealandFinancialCorporate <"Matrix Transaction Type of STANDARD NEW ZEALAND FINANCIAL CORPORATE.">
    StandardNewZealandSovereign <"Matrix Transaction Type of STANDARD NEW ZEALAND SOVEREIGN.">
    StandardNorthAmericanCorporate <"Matrix Transaction Type of STANDARD NORTH AMERICAN CORPORATE.">
    StandardNorthAmericanFinancialCorporate <"Matrix Transaction Type of STANDARD NORTH AMERICAN FINANCIAL CORPORATE.">
    StandardSingaporeCorporate <"Matrix Transaction Type of STANDARD SINGAPORE CORPORATE.">
    StandardSingaporeFinancialCorporate <"Matrix Transaction Type of STANDARD SINGAPORE FINANCIAL CORPORATE.">
    StandardSingaporeSovereign <"Matrix Transaction Type of STANDARD SINGAPORE SOVEREIGN.">
    StandardSubordinatedEuropeanInsuranceCorporate <"Transaction Type of STANDARD SUBORDINATED EUROPEAN INSURANCE CORPORATE.">
    StandardSukukFinancialCorporate <"Matrix Transaction Type of STANDARD SUKUK FINANCIAL CORPORATE.">
    StandardUSMunicipalFullFaithAndCredit <"Matrix Transaction Type of STANDARD U.S. MUNICIPAL FULL FAITH AND CREDIT.">
    StandardUSMunicipalGeneralFund <"Matrix Transaction Type of STANDARD U.S. MUNICIPAL GENERAL FUND.">
    StandardUSMunicipalRevenue <"Matrix Transaction Type of STANDARD U.S. MUNICIPAL REVENUE.">
    StandardWesternEuropeanSovereign <"Matrix Transaction Type of STANDARD WESTERN EUROPEAN SOVEREIGN.">
    SubordinatedEuropeanInsuranceCorporate <"Matrix Transaction Type of SUBORDINATED EUROPEAN INSURANCE CORPORATE.">
    SukukCorporate <"Matrix Transaction Type of SUKUK CORPORATE.">
    SukukFinancialCorporate <"Matrix Transaction Type of SUKUK FINANCIAL CORPORATE.">
    SukukSovereign <"Matrix Transaction Type of SUKUK SOVEREIGN.">
    USMunicipalFullFaithAndCredit <"Matrix Transaction Type of U.S. MUNICIPAL FULL FAITH AND CREDIT.">
    USMunicipalGeneralFund <"Matrix Transaction Type of U.S. MUNICIPAL GENERAL FUND.">
    USMunicipalRevenue <"Matrix Transaction Type of U.S. MUNICIPAL REVENUE.">
    WesternEuropeanSovereign <"Matrix Transaction Type of WESTERN EUROPEAN SOVEREIGN.">

enum MatrixTypeEnum: <"The enumerated values to specify the identification the form of applicable matrix.">
    CreditDerivativesPhysicalSettlementMatrix <"The ISDA-published Credit Derivatives Physical Settlement Matrix.">
    EquityDerivativesMatrix <"The ISDA-published Equity Derivatives Matrix.">
    SettlementMatrix <"The ISDA-published 2000 ISDA Definitions Settlement Matrix for Early Terminations and Swaptions.">

enum ResourceTypeEnum: <"The enumerated values to specify the type of a resource (e.g. document).">
    Confirmation <"Document describing the legal terms of a transaction.">
    SupplementalMaterialEconomicTerms <"Document providing supplemental material economic terms to the FpML data representation. The initial intended usage is to fulfill the CFTC Part 45 rule requirement to report ‘Any other terms(s) of the swap matched or affirmed by the counterparties in verifying the swap’ when the reporting is done via the generic FpML representation.">
    TermSheet <"Document describing the economic characteristics of a transaction.">

enum LegalAgreementTypeEnum: <"The enumerated values to specify the legal agreement type.">
    [synonym AcadiaSoft_AM_1_0 value "DocumentNameEnum"]

    BrokerConfirmation <"A Broker Confirmation.">
    Confirmation <"A Transaction Confirmation.">
    CreditSupportAgreement <"A Credit Support Agreement.">
    MasterAgreement <"A Master Agreement.">
    MasterConfirmation <"A Master Confirmation.">
    SecurityAgreement <"A Security Agreement related to a Collateral Transfer Agreement (CTA).">
    Other <"Another type of agreement.">

enum LegalAgreementPublisherEnum: <"The enumerated values to specify the legal agreement publisher.">
    [synonym AcadiaSoft_AM_1_0 value "PublisherEnum"]

    AFB <"Association Française des Banques.">
    BNYM <"BNY Mellon">
    ISDAClearstream <"ISDA and Clearstream">
    EMTA <"Emerging Markets Traders Association">
    TheFXCommittee <"The Foreign Exchange Committee">
    ISDAEuroclear <"ISDA and Euroclear">
    ISDA <"International Swaps and Derivatives Association, Inc.">
        [synonym AcadiaSoft_AM_1_0 value "ISDA"]
    ISLA <"International Securities Lending Association">
    JPMorgan <"JP Morgan">
    ICMA <"International Capital Markets Association">

enum ExecutionLocationEnum: <"The enumerated values to specify the Execution Location of a Security Agreement">
    ExecutedOutsideBelgium <"The Agreement was executed outside of Belgium">
    ExecutedInBelgium <"The Agreement was executed outside of Belgium">
    OtherLocation <"An alternative approach is described in the document as follows.">

enum CreditSupportDocumentTermsEnum: <"The enumerated values to specify the Credit Support Document Terms">
    Specified <"A specified Credit Support Document is provided">
    Any <"Any guarantee, collateral arrangement and/or other agreement or arrangement which provides for credit support with respect to the party’s obligations under this Agreement.">
    None <"No Credit Support Document is specified.">

enum CreditSupportProviderTermsEnum: <"The enumerated values to specify the Credit Support Provider Terms">
    Specified <"A specified Credit Support Provider is provided">
    Any <"Any party or parties who now or in the future may provide a Credit Support Document or other form of credit support.">
    None <"No Credit Support Provider is specified.">

enum SpecifiedEntityClauseEnum: <"The enumerated values to specify the Event of Default or Termination event for which Specified Entities terms are being defined.">
    DefaultUnderSpecifiedTransaction
    CrossDefault
    Bankruptcy
    CreditEventUponMerger

enum SpecifiedEntityTermsEnum: <"The enumerated values to specify the specified entity terms for the Event of Default or Termination Event specified.">
    None <"No Specified Entity is provided">
    AnyAffiliate <"Any Affiliate is a Specified Entity.">
    NamedSpecifiedEntity <"The Specified Entity is provided.">
    MaterialSubsidiary <"Any Material Subsidiary.">
    OtherSpecifiedEntity <"Non standard Specified Entity terms are provided.">

enum TerminationCurrencyConditionEnum:
    PaymentsDue <"A currency in which payments would be due under one or more Transactions.">
    FreelyAvailable <"A currency that is freely available.">
    PaymentsDueAndFreelyAvailable <"A currency in which payments would be due under one or more Transactions and that is freely available.">
    Specified <"Termination Currency Conditions are specified.">


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-common-type.rosetta
================================================================================

namespace cdm.legaldocumentation.common : <"Common legal agreement concepts.">
version "${project.version}"

import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.legaldocumentation.csa.*
import cdm.legaldocumentation.master.*
import cdm.legaldocumentation.transaction.*
import cdm.mapping.config.*
import cdm.product.collateral.*

type ContractualMatrix:

    matrixType MatrixTypeEnum (1..1) <"Identifies the form of applicable matrix.">
        [metadata scheme]
    matrixTerm MatrixTermEnum (0..1) <"Defines any applicable key into the relevant matrix. For example, the Transaction Type would be the single term required for the Credit Derivatives Physical Settlement Matrix. This element should be omitted in the case of the 2000 ISDA Definitions Settlement Matrix for Early Termination and Swaptions.">
        [metadata scheme]

type ContractualTermsSupplement: <"A contractual supplement (such as those published by ISDA) and its publication date that will apply to the trade.">

    contractualTermsSupplementType ContractualSupplementTypeEnum (1..1) <"Identifies the form of applicable contractual supplement.">
        [metadata scheme]
    publicationDate date (0..1) <"Specifies the publication date of the applicable version of the contractual supplement.">

type OtherAgreement: <"A class for defining an agreement executed between parties.">

    identifier string (0..1) <"An identifier that has been created to identify the agreement.">
        [metadata scheme]
    otherAgreementType string (1..1) <"The agreement executed between the parties and intended to govern product-specific derivatives transactions between those parties.">
        [metadata scheme]
    version string (0..1) <"The version of the agreement.">
        [metadata scheme]
    date date (0..1) <"The date on which the agreement was signed.">

type Resource: <"Describes the resource that contains the media representation of a business event (i.e used for stating the Publicly Available Information). For example, can describe a file or a URL that represents the event. This type is an extended version of a type defined by RIXML (www.rixml.org).  Rosetta restricts the FpML implementation by not providing the ability to associated a document in hexadecimalBinary or base64Binary until such time that actual use cases will come up.">

    resourceId string (1..1) <"The unique identifier of the resource within the event. FpML specifies this element of type resourceIdScheme but with no specified value.">
        [metadata scheme]
    resourceType ResourceTypeEnum (0..1) <"A description of the type of the resource, e.g. a confirmation.">
        [metadata scheme]
    language string (0..1) <"Indicates the language of the resource, described using the ISO 639-2/T Code.">
        [metadata scheme]
    sizeInBytes number (0..1) <"Indicates the size of the resource in bytes. It could be used by the end user to estimate the download time and storage needs.">
    length ResourceLength (0..1) <"Indicates the length of the resource. For example, if the resource were a PDF file, the length would be in pages.">
    mimeType string (0..1) <"Indicates the type of media used to store the content. mimeType is used to determine the software product(s) that can read the content. MIME Types are described in RFC 2046.">
        [metadata scheme]
    name string (0..1) <"The name of the resource.  It is specified as a NormalizedString in FpML.">
    comments string (0..1) <"Any additional comments that are deemed necessary. For example, which software version is required to open the document? Or, how does this resource relate to the others for this event?">
    string string (0..1) <"Provides extra information as string. In case the extra information is in XML format, a CDATA section must be placed around the source message to prevent its interpretation as XML content.">
    url string (0..1) <"Indicates where the resource can be found, as a URL that references the information on a web server accessible to the message recipient.">

    condition ResourceChoice: <"Choice rule to represent an FpML choice construct. Note that FpML also provides the ability to have hexadecimalBinary or base64Binary, which have not been implemented in Rosetta until we see actual use cases.">
        optional choice string, url

type ResourceLength: <"A class to indicate the length of the resource.">

    lengthUnit LengthUnitEnum (1..1) <"The length unit of the resource. For example, pages (pdf, text documents) or time (audio, video files).">
    lengthValue number (1..1) <"The length value of the resource.">

type AgreementTerms: <"Specification of the content of a legal agreement.">

    agreement Agreement (1..1) <"Specification of the standard set of terms that define a legal agreement.">
    clauseLibrary boolean (0..1) <"Specification of whether the agreement terms have been negotiated using the clause library methodology.">
    counterparty Counterparty (2..2) <"Specification of the roles of the counterparties to the agreement.">

type LegalAgreement extends LegalAgreementBase: <"The specification of a legal agreement between two parties, being negotiated or having been executed. This includes the baseline information and the optional specialised elections">
    [metadata key]
    [rootType]

    agreementTerms AgreementTerms (0..1) <"Specification of the content of the legal agreement.">
    relatedAgreements LegalAgreement (0..*) <"Specifies the agreement(s) that govern the agreement, either as a reference to such agreements when specified as part of the CDM, or through identification of some of the key terms of those agreements, such as the type of agreement, the publisher, the vintage, the agreement identifier and the agreement date.">
    umbrellaAgreement UmbrellaAgreement (0..1) <"The determination of whether Umbrella Agreement terms are applicable (True) or Not Applicable (False).">

    condition ConsistentlyExecutedAgreements: <"An executed agreement can only point to executed related agreements if any.">
        if relatedAgreements exists and agreementDate exists
        then relatedAgreements -> agreementDate exists

    condition AgreementVerification: <"A validation rule to ensure that the agreement elections are associated with the correct legal agreement type as specified.">
        if agreementTerms -> agreement -> securityAgreementElections exists
        then legalAgreementIdentification -> agreementName -> agreementType = LegalAgreementTypeEnum -> SecurityAgreement
        else if agreementTerms -> agreement -> creditSupportAgreementElections exists
        then legalAgreementIdentification -> agreementName -> creditSupportAgreementType = CreditSupportAgreementTypeEnum -> CreditSupportAnnex
                or legalAgreementIdentification -> agreementName -> creditSupportAgreementType = CreditSupportAgreementTypeEnum -> CreditSupportDeed
        else if agreementTerms -> agreement -> collateralTransferAgreementElections exists
        then legalAgreementIdentification -> agreementName -> creditSupportAgreementType = CreditSupportAgreementTypeEnum -> CollateralTransferAgreement
        else if agreementTerms -> agreement -> masterAgreementSchedule exists
        then legalAgreementIdentification -> agreementName -> agreementType = LegalAgreementTypeEnum -> MasterAgreement

type LegalAgreementBase: <"Specifies the legal agreement baseline information, being negotiated or having been executed. It excludes specialized elections">
    agreementDate date (0..1) <"The date on which the legal agreement has been agreed between the parties. This corresponds to the Date of Deed in an English Law document.">
    effectiveDate date (0..1) <"The date on which, or as of which, the agreement is effective, if different from the agreement date. It is expected that it will most often correspond to the agreement date, although there could be situations where the parties will explicitly agree on a distinct effective date.">
    identifier Identifier (0..*) <"The legal agreement identifier. Several identifiers can be specified.">
    legalAgreementIdentification LegalAgreementIdentification (1..1) <"The type of legal agreement, identified via a set of composable attributes: agreementName, publisher, governing law and version, e.g. ISDA 2013 Standard Credit Support Annex English Law.">
    contractualParty Party (2..2) <"The two contractual parties to the legal agreement, which reference information is positioned as part of the partyInformation attribute.">
        [metadata reference]
    otherParty PartyRole (0..*) <"The role(s) that other party(ies) may have in relation to the legal agreement, further to the contractual parties.">
    attachment Resource (0..*) <"A human readable document, for example a confirmation.">

type LegalAgreementIdentification: <"Specifies the type of legal agreement, identified via a set of composable attributes: agreementName, publisher, governing law and version, e.g. ISDA 2013 Standard Credit Support Annex English Law.">

    governingLaw GoverningLawEnum (0..1) <"The law governing the legal agreement, e.g. English Law, New York Law or Japanese Law.">
        [synonym AcadiaSoft_AM_1_0 value "governingLaw"]
    agreementName AgreementName (1..1) <"The legal agreement name, e.g. Credit Support Annex for Variation Margin.">
        [synonym AcadiaSoft_AM_1_0 value "documentName"]
    publisher LegalAgreementPublisherEnum (0..1) <"The legal agreement publisher, e.g. ISDA.">
        [synonym AcadiaSoft_AM_1_0 value "publisher"]
    vintage int (0..1) <"In the case where successive definitions of the legal agreement have been developed, the vintage identification. This is typically (but not necessarily) done by referencing the year, e.g. 2013 in the case of the ISDA 2013 Standard Credit Support Annex.">
        [synonym AcadiaSoft_AM_1_0 value "csaVersion"]

    condition CSAMarginType: <"A condition to ensure that CSA margin type is only specified if a credit support agreemnt type is specified and its published vintage year is equal to or after 2016.">
        if agreementName -> creditSupportAgreementMarginType exists
        then agreementName -> creditSupportAgreementType exists and vintage >= 2016

type AgreementName: <"Specifies the agreement name through an agreement type and optional detailed sub agreement type.">
    agreementType LegalAgreementTypeEnum (1..1) <"Specification of the legal agreement type.">
    creditSupportAgreementType CreditSupportAgreementTypeEnum (0..1) <"Specification of the credit support agreement type.">
        [metadata scheme]
    creditSupportAgreementMarginType CollateralMarginTypeEnum (0..1) <"specifies the type of margin for which a legal agreement is named.">
    contractualDefinitionsType ContractualDefinitionsEnum (0..*) <"The definitions such as those published by ISDA that will define the terms of the trade.">
        [metadata scheme]
    contractualTermsSupplement ContractualTermsSupplement (0..*) <"A contractual supplement (such as those published by ISDA) that will apply to the trade.">
    contractualMatrix ContractualMatrix (0..*) <"A reference to a contractual matrix of elected terms/values (such as those published by ISDA) that shall be deemed to apply to the trade. The applicable matrix is identified by reference to a name and optionally a publication date. Depending on the structure of the matrix, an additional term (specified in the matrixTerm element) may be required to further identify a subset of applicable terms/values within the matrix.">
    masterAgreementType MasterAgreementTypeEnum (0..1) <"Specification of the master agreement type.">
        [metadata scheme]
    masterConfirmationType MasterConfirmationTypeEnum (0..1) <"The type of master confirmation executed between the parties.">
        [metadata scheme]
    masterConfirmationAnnexType MasterConfirmationAnnexTypeEnum (0..1) <"The type of master confirmation annex executed between the parties.">
        [metadata scheme]
    otherAgreement string (0..1) <"Definition of an agreement that is not enumerated in the CDM.">
    brokerConfirmationType BrokerConfirmationTypeEnum (0..1)

    condition AgreementType: <"A condition to ensure that the agreement type specified is consistent with the detailed documentation identified.">
        if agreementType <> LegalAgreementTypeEnum -> Other
        then otherAgreement is absent
        else if agreementType <> LegalAgreementTypeEnum -> MasterAgreement
        then masterAgreementType is absent
        else if agreementType <> LegalAgreementTypeEnum -> MasterConfirmation
        then masterConfirmationType is absent and masterConfirmationAnnexType is absent
        else if agreementType <> LegalAgreementTypeEnum -> Confirmation
        then contractualDefinitionsType is absent
                and contractualTermsSupplement is absent
                and contractualMatrix is absent

    condition CreditSupportAgreement: <"A condition to ensure that the credit supoort agreement type is specified when required.">
        if agreementType = LegalAgreementTypeEnum -> CreditSupportAgreement
        then creditSupportAgreementType exists

    condition MasterConfirmation: <"If a master confirmation annex type is specified a master confirmation type must exist.">
        if masterConfirmationAnnexType exists
        then masterConfirmationType exists

    condition CSAMarginType: <"A condition to ensure that CSA margin type is only specified if a credit support agreemnt type is specified.">
        if creditSupportAgreementMarginType exists
        then creditSupportAgreementType exists

type UmbrellaAgreement: <"A class to specify a set of legal entities which are part of a legal agreement beyond the two contracting parties to that agreement. This data representation reflects the ISDA Create representation.">

    isApplicable boolean (1..1) <"The determination of whether Umbrella Agreement terms are Applicable (True), or Not Applicable (False)">
    language string (0..1) <"The language associated with the umbrella agreement, and which applies to all the parties to the umbrella agreement.">
    parties UmbrellaAgreementEntity (0..*) <"Underlying principals to the umbrella agreement.">

    condition UmbrellaAgreementExists: <"Umbrella Agreement language and parties should not exist when Umbrella Agreement terms are Not Applicable.">
        if isApplicable = True then language exists and parties exists

type UmbrellaAgreementEntity extends LegalEntity: <"A class to specify the legal entities that are part of the umbrella agreement.">

    terms string (0..1) <"The terms that might be associated with each party to the umbrella agreement.">

type AddressForNotices: <"Specification of the address and other details for notices.">
    primaryNotices ContactElection (1..1) <"Specification of primary notice details">
    additionalNotices PartyContactInformation (0..*) <"The optional specification of additional information when a party requires notices to be delivered to more than one address.">

type OtherAgreementTerms: <"A class to specify a related legal agreement. For example, ISDA 2016 Credit Support Annex for Initial Margin, paragraph 13, General Principles, (s): Other CSA and Japanese Law CSA (VM). | ISDA 2016 Credit Support Annex for Variation Margin, paragraph 13, (o): Other CSA.">

    isSpecified boolean (1..1) <"The qualification of whether some other related agreement is specified (True) or not (False).">
    legalDocument string (0..1) <"The specification of this other agreement, when the qualification is True.">

    condition LegalDocumentNotSpecified: <"A data rule to enforce that the related legal agreement should not be referenced if it is deemed as not specified as part of the boolean attribute.">
        if isSpecified = False then legalDocument is absent

    condition LegalDocumentSpecified: <"A data rule to enforce that the related legal agreement should be referenced if it is deemed as specified as part of the boolean attribute.">
        if isSpecified = True then legalDocument exists

type Agreement: <"Specification of the standard set of terms that define a legal agreement.">
    creditSupportAgreementElections CreditSupportAgreementElections (0..1) <"Elections to specify a Credit Support Annex or Credit Support Deed for Intial or Variation Margin.">
    collateralTransferAgreementElections CollateralTransferAgreementElections (0..1) <"Elections to specify a Collateral Transfer Agreement.">
    securityAgreementElections SecurityAgreementElections (0..1) <"Elections to specify a Security agreement.">
    masterAgreementSchedule MasterAgreementSchedule (0..1) <"Elections to specify a Master Agreement Schedule.">
    transactionAdditionalTerms TransactionAdditionalTerms (0..1) <"Any additional terms which mainly intend to specify the extraordinary events that may affect a trade and the related contractual rights and obligation of the parties when this happens">
    masterAgreementElections MasterAgreementElections (0..1) <"A legal representation of the different possible master agreements">
    condition:
        one-of


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-csa-enum.rosetta
================================================================================

namespace cdm.legaldocumentation.csa
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*

enum RecalculationOfValueElectionEnum: <"Values to specify the procedure under which the market value of posted collateral will be recalculated.">
    ConsulationProcedure <"The parties agree to consult.">
    OtherRegulatoryCSAProcedure <"The procedures specified in an Other Regulatory CSA.">
    NotApplicable <"Description to be added.">
    Specified <"Bespoke Recalculation of value terms are specified in the agreement.">

enum SimmExceptionApplicableEnum: <"Values to specify the SIMM normalized exception approaches.">
    [docReference ISDA CSA_IM_2018 paragraph "13 General Principles"]
    FallBackToMandatoryMethod <"The ISDA Standard Initial Margin Model exception is applicable as a Fallback to Mandatory Method.">
    MandatoryMethod <"The ISDA Standard Initial Margin Model exception is applicable as a Mandatory Method.">
    OtherMethod <"An alternative approach is described in the document.">

enum ExceptionEnum: <"Values to specify the normalized exceptions applicable to an Initial Margin CSA.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles"]
    [docReference ISDA CSA_IM_2018 paragraph "13 General Principles"]
    Applicable <"The election is applicable.">
    NotApplicable <"The election is not applicable.">
    Other <"An alternative approach is described in the document as follows.">

enum SensitivitiesEnum: <"Values to specify the methodology according to which sensitivities to (i) equity indices, funds and ETFs, and (ii) commodity indices are computed.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(gg)(2)"]
    Alternative <"The parties agree that in respect of the relevant sensitivities, the delta is allocated back to individual constituents.">
    Standard <"The relevant sensitivities are addressed by the standard preferred approach where the entire delta is put into the applicable asset class/category.">

enum RegulatoryRegimeEnum: <"Values to specify the regulatory regimes.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" name "Regime"]
    [docReference ISDA CSA_IM_2018 paragraph "13 General Principles" name "Regime"]
    AustraliaMarginRules displayName "Australia" <"Australian Prudential Standard CPS 226 Margining and risk mitigation for non-centrally cleared derivatives.">
    CanadaMarginRules displayName "Canada" <"Guideline E-22, Margin Requirements for Non-Centrally Cleared Derivatives issued by the Canadian Office of the Superintendent of Financial Institutions in February 2016.">
    CFTC_MarginRules displayName "CFTC" <"Margin requirements adopted by the U.S. Commodity Futures Trading Commission pursuant to CEA  4s(e).">
    EMIR_MarginRules displayName "EMIR" <"Regulation (EU) No 648/2012 of the European Parliament and of the Council of 4 July 2012 on OTC derivatives, central counterparties and trade repositories (including the EMIR RTS, which means the published regulatory technical standards on risk-mitigation techniques for OTC-derivative contracts not cleared by a CCP under Article 11(15) of EMIR).">
    HongKongMarginRules displayName "Hong Kong" <"Chapter CR-G-14 'Non-centrally Cleared OTC Derivatives Transactions  Margin and Other Risk Mitigation Standards' in the Banking Supervisory Policy Manual issued by the Hong Kong Monetary Authority.">
    JapanMarginRules displayName "Japan" <"Margin rules adopted by the Financial Services Agency of Japan pursuant to Article 40, Item 2 of the Financial Instruments and Exchange Act (kinyuu shouhin torihiki hou) (Act No. 25 of 1948) and by the Ministry of Agriculture, Forestry and Fisheries and the Ministry of Economy, Trade and Industry pursuant to the Commodity Derivatives Act (shouhin sakimono torihiki hou) (Act No. 239 of 1950) (including their subordinated regulations and the related supervisory guidelines).">
    US_PrudentialMarginRules displayName "Prudential" <"Margin requirements adopted by a 'prudential regulator' (as defined in CEA  1a(39)) pursuant to CEA  4s(e) and Exchange Act  15F(e).">
    SEC_MarginRules displayName "SEC" <"Margin requirements adopted by the U.S. Securities and Exchange Commission pursuant to Exchange Act  15F(e).">
    SingaporeMarginRules displayName "Singapore" <"Guidelines on Margin Requirements for Non-centrally Cleared OTC Derivatives Contracts issued by the Monetary Authority of Singapore (MAS) pursuant to section 321 of the Securities and Futures Act, Chapter 289 of Singapore.">
    SwitzerlandMarginRules displayName "Switzerland" <"Margin rules adopted by the Swiss Federal Council pursuant to Article 110-111 of the Financial Market Infrastructure Act as well as Articles 100 to 107 and Annexes 3 to 5 of the Financial Market Infrastructure Ordinance.">
    BrazilMarginRules displayName "Brazil" <"The Central Bank of Brazil margin requirements adopted pursuant to Resolution no. 4,662, of 25 May 2018, enacted by the National Monetary Council.">
    UnitedKingdomMarginRules displayName "United Kingdom" <"EMIR (including, for the avoidance of doubt, the EMIR RTS) as it forms part of UK domestic law by virtue of section 3 of the European Union (Withdrawal) Act 2018 (as amended) (the EUWA) (including any amendments made to such legislation when it is brought into UK domestic law pursuant to section 8 of the EUWA or any regulations made thereunder), and which, for the avoidance of doubt, shall be subject to the interpretation provision in Paragraph [11(g)].3.">
    SouthAfricaMarginRules displayName "South Africa" <"the requirements contained in Joint Standard 2 of 2020 made in terms of the South African Financial Sector Regulation Act, 2017.">
    SouthKoreaMarginRules displayName "South Korea" <"Margin requirements adopted by the Korean Financial Services Commission and Financial Supervisory Service pursuant to the Guidelines on Margin Requirements for Non-Centrally Cleared OTC Derivatives Transactions, which are expected to be incorporated into the Financial Investment Services and Capital Markets Act.">
    HongKongSFCMarginRules displayName "Hong Kong SFC" <"Part III of Schedule 10 to Code of Conduct for Persons Licensed by or Registered with the Securities and Futures Commission of Hong Kong.">

enum MarginApproachEnum: <"Values to specify the margin approach specific to Initial Margin agreements.">
    [docReference ISDA CSA_IM_NewYork_2018 paragraph "13"]
    Distinct <"Distinct Margin Flow (IM) Approach.">
    Allocated <"Allocated Margin Flow (IM/IA) Approach.">
    GreaterOf <"Greater of Margin Flow (IM/IA) Approach.">

enum InterestAdjustmentPeriodicityEnum: <"Values to specify the interest adjustment periodicity election through standard language.">
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(n)(ii)"]
    LastLocalBusinessDayOfMonth <"The interest adjustment takes place on the last local business day of each calendar month.">
    EachDay <"The interest adjustment takes place each day.">

enum IndependentAmountEligibilityEnum: <"The enumerated values to specify the instances where the independent amount eligible collateral is not defined as a set of eligible collateral assets.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/independent-amount-eligibility"]

    None <"None.">
    NoneUnlessSpecifiedInConfirmation <"None, unless otherwise specified in a Confirmation.">

enum HoldingPostedCollateralEnum: <"The enumerated values to specify condition(s) required by a party from the other party to hold its posted collateral.">
    [docReference ISDA CSA_VM_2016 paragraph "13 General Principles" clause "(h)(i)" name "Eligibility to Hold Posted Collateral (VM); Custodians (VM)"]
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/holding-posted-collateral"]
    AcceptableCustodian <"The custodian is acceptable to the other party to the agreement.">

enum CollateralAssetDefinitionsEnum:
    [docReference ISDA CollateralAssetDefinitions_2003]
    AU_CASH <"Australian Dollar (AUD) Cash.">
    AU_CIB displayName "AU-CIB" <"Australian Government Securities Capital-Indexed Bonds.">
    AU_FIB displayName "AU-FIB" <"Australian Semi-Government Securities Fixed Interest Bonds.">
    AU_FRB displayName "AU-FRB" <"Australian Government Securities Fixed Rate Bonds.">
    AU_ILB displayName "AU-ILB" <"Australian Semi-Government Securities Index Linked Bonds.">
    AU_NOTE displayName "AU-NOTE" <"Australian Government Securities Treasury Notes.">
    AU_STATENOTE displayName "AU-STATENOTE" <"Australian Semi-Government Securities Treasury Notes.">
    AU_TAB displayName "AU-TAB" <"Australian Government Securities Treasury Adjustable Rate Bonds.">
    BE_BEL20 displayName "BE-BEL20" <"BEL20 Equity Securities.">
    BE_CERT displayName "BE-CERT" <"Belgian Treasury Certificates.">
    BE_LINEAR displayName "BE-LINEAR" <"Belgian Linear Obligations.">
    BE_NOTE displayName "BE-NOTE" <"Belgian Treasury notes.">
    BE_REGIONGT displayName "BE-REGIONGT" <"Public sector issues guaranteed by Regional Authorities.">
    BE_STATEGT displayName "BE-STATEGT" <"Public sector issues guaranteed by the Belgian State.">
    BE_STATELOAN displayName "BE-STATELOAN" <"Belgian State Loans.">
    CA_BOND displayName "CA-BOND" <"Canada Bonds.">
    CA_CASH displayName "CA-CASH" <"Canadian Dollar (CAD) Cash.">
    CA_RRB displayName "CA-RRB" <"Government of Canada Real Return Bonds.">
    CA_TBILL displayName "CA-TBILL" <"Government of Canada Treasury Bills.">
    CH_CANTON displayName "CH-CANTON" <"Public Authority Bond.">
    CH_CASH displayName "CH-CASH" <"Swiss Franc (CHF) Cash.">
    CH_FEDBOND displayName "CH-FEDBOND" <"Federal Bond.">
    DE_BILL displayName "DE-BILL" <"Unverzinsliche Schatzanweisungen (Bills).">
    DE_BOND displayName "DE-BOND" <"Bundesanleihen (Bonds).">
    DE_ERBLAST displayName "DE-ERBLAST" <"Negotiable Debt Obligations issued by or taken over and since serviced and managed by the Erblasttilgungsfond (Redemption Fund for Inherited Liabilities) backed by Federal Republic of Germany, including but not limited to former issues of the Treuhandanstalt, the Bundesbahn, the Bundespost, the Economic Recovery Program (ERP), the privatised Federal Railway (Bahn AG), the telecommunications element of the Federal Post Office (Telekom) and the German Unity Fund.">
    DE_MUNI displayName "DE-MUNI" <"Kommunalschuldverschreib\tungen (Municipal Bonds).">
    DE_NOTE2 displayName "DE-NOTE2" <"Bundesschatzanweisungen (Notes).">
    DE_NOTE5_5 displayName "DE-NOTE5.5" <"Bundesobligationen (Notes).">
    DE_PFAND displayName "DE-PFAND" <"Hypothekenpfandbriefe (Mortgage Bonds).">
    DK_BILL displayName "DK-BILL" <"Skatkammerbeviser (Treasury Bills).">
    DK_BOLIGX displayName "DK-BOLIGX" <"BoligX obligationer.">
    DK_BOND displayName "DK-BOND" <"Statsobligationer (Government Bonds).">
    DK_CALLMORT displayName "DK-CALLMORT" <"Callable Mortgage Bonds.">
    DK_CASH displayName "DK-CASH" <"Danish Krone (DKK) Cash.">
    DK_KFX displayName "DK-KFX" <"KFX Equity Securities.">
    DK_MORT displayName "DK-MORT" <"Non-callable Mortgage Bonds.">
    DK_NOTE displayName "DK-NOTE" <"Statsgaeldsbeviser (Treasury Notes).">
    ES_BILL displayName "ES-BILL" <"Treasury Bills - Letras del Tesoro.">
    ES_BOND displayName "ES-BOND" <"Public Government Debt.">
    ES_CEDULAS displayName "ES-CEDULAS" <"Cedulas.">
    ES_CORP displayName "ES-CORP" <"Corporate Bonds.">
    ES_EQUITY displayName "ES-EQUITY" <"Equity securities issued by a Spanish company, and listed as an IBEX 35 constituent company as reported by the Sociedad de Bolsas, each share representing the minimum unit of participation of a shareholder in the stock capital of the company.">
    EU_CASH displayName "EU-CASH" <"Euro (EUR) Cash.">
    EU_EURO100 displayName "EU-EURO100" <"FTSE Euro 100 Index Equity Securities.">
    EU_EUROTOP300 displayName "EU-EUROTOP300" <"FTSE Eurotop 300 Index Equity Securities.">
    EU_STOXX50 displayName "EU-STOXX50" <"EuroSTOXX 50 Index Equity Securities.">
    EU_STOXX600 displayName "EU-STOXX600" <"STOXX 600 Index Equity Securities.">
    FI_BILL displayName "FI-BILL" <"Treasury bills.">
    FI_BOND displayName "FI-BOND" <"Serial bonds (Finnish Government Bond).">
    FI_HEX displayName "FI-HEX" <"HEX Equity Securities.">
    FR_BDT displayName "FR-BDT" <"Commercial Paper: (Billet de Trsorerie).">
    FR_BTAN displayName "FR-BTAN" <"Treasury Notes: Bons du Trsor  Taux Annuel (BTAN).">
    FR_BTF displayName "FR-BTF" <"Treasury Bills: Bons du Trsor  Taux Fixe (BTF).">
    FR_OAT displayName "FR-OAT" <"Government bonds: Obligations Assimilables du Trsor (OAT).">
    FR_STRIP displayName "FR-STRIP" <"STRIPS.">
    GA_AU_GOV displayName "GA-AU-GOV" <"Generally Accepted Australian Government Obligations.">
    GA_BE_GOV displayName "GA-BE-GOV" <"Generally Accepted Belgian Government Obligations.">
    GA_CA_GOV displayName "GA-CA-GOV" <"Generally Accepted Canadian Government Obligations.">
    GA_CH_GOV displayName "GA-CH-GOV" <"Generally Accepted Swiss Government Obligations.">
    GA_DE_GOV displayName "GA-DE-GOV" <"Generally Accepted German Government Obligations.">
    GA_DK_GOV displayName "GA-DK-GOV" <"Generally Accepted Danish Government Obligations.">
    GA_ES_GOV displayName "GA-ES-GOV" <"Generally Accepted Spanish Government Obligations.">
    GA_EUROZONE_GOV displayName "GA-EUROZONE-GOV" <"Generally Accepted Euro Zone Government Securities.">
    GA_EU_GOV displayName "GA-EU-GOV" <"Generally Accepted EU Member State Government Securities.">
    GA_FI_GOV displayName "GA-FI-GOV" <"Generally Accepted Finnish Government Obligations.">
    GA_FR_GOV displayName "GA-FR-GOV" <"Generally Accepted French Government Obligations.">
    GA_G5_GOV displayName "GA-G5-GOV" <"Generally Accepted G5 Government Obligations.">
    GA_GB_GOV displayName "GA-GB-GOV" <"Generally Accepted British Government Obligations.">
    GA_HK_GOV displayName "GA-HK-GOV" <"Generally Accepted Hong Kong Government Obligations.">
    GA_IT_GOV displayName "GA-IT-GOV" <"Generally Accepted Italian Government Obligations.">
    GA_JP_GOV displayName "GA-JP-GOV" <"Generally Accepted Japanese Government Obligations.">
    GA_KR_GOV displayName "GA-KR-GOV" <"Generally Accepted Korean Government Obligations.">
    GA_NL_GOV displayName "GA-NL-GOV" <"Generally Accepted Netherlands Government Obligations.">
    GA_NO_GOV displayName "GA-NO-GOV" <"Generally Accepted Norwegian Government Obligations.">
    GA_NZ_GOV displayName "GA-NZ-GOV" <"Generally Accepted New Zealand Government Obligations.">
    GA_SE_GOV displayName "GA-SE-GOV" <"Generally Accepted Swedish Government Obligations.">
    GA_SG_GOV displayName "GA-SG-GOV" <"Generally Accepted Singaporean Government Obligations.">
    GA_US_AGENCY displayName "GA-US-AGENCY" <"Generally Accepted US Agency Obligations.">
    GA_US_GOV displayName "GA-US-GOV" <"Generally Accepted US Government Obligations.">
    GA_US_MORTGAGES displayName "GA-US-MORTGAGES" <"Generally Accepted US Mortgage-Backed Obligations.">
    GB_CASH displayName "GB-CASH" <"British Pound Sterling (GBP) Cash.">
    GB_DDGILT displayName "GB-DDGILT" <"Double-dated Gilts.">
    GB_FT100 displayName "GB-FT100" <"FTSE 100 Equity Securities.">
    GB_FT250 displayName "GB-FT250" <"FTSE 250 Equity Securities.">
    GB_FT350 displayName "GB-FT350" <"FTSE 350 Equity Securities.">
    GB_GILT displayName "GB-GILT" <"Conventional Gilts.">
    GB_INDEXGILT displayName "GB-INDEXGILT" <"Index-Linked Gilts.">
    GB_PERPGILT displayName "GB-PERPGILT" <"Undated or Perpetual Gilts.">
    GB_RUMPGILT displayName "GB-RUMPGILT" <"Rump Stock.">
    GB_SUPR1 displayName "GB-SUPR1" <"Bank of England Euro Bills.">
    GB_SUPR2 displayName "GB-SUPR2" <"Bank of England Euro Notes.">
    GB_TBILL displayName "GB-TBILL" <"UK Treasury Bills.">
    GB_ZEROGILT displayName "GB-ZEROGILT" <"Gilt Strips or Zero Coupon Gilts.">
    HK_BILL displayName "HK-BILL" <"Hong Kong Government Exchange Fund Bills.">
    HK_CASH displayName "HK-CASH" <"Hong Kong Dollar (HKD) Cash.">
    HK_NOTE displayName "HK-NOTE" <"Hong Kong Government Exchange Fund Notes.">
    IT_BOT displayName "IT-BOT" <"Botbuoni Ordinari del Tesoro (BOT) zero coupon debt securities issued by the Italian Treasury with maturities up to 365 days.">
    IT_BTP displayName "IT-BTP" <"Buoni del Tesoro Poliennali fixed interest semi-annual debt securities issued by the Italian Treasury with original maturities between 3 and 30 years.">
    IT_CCT displayName "IT-CCT" <"Certificati di Credito del Tesoro a Cedola Variable (CCT) or floating rate interest bearing debt securities issued by the Italian Treasury.">
    IT_CORP displayName "IT-CORP" <"Corporate bonds.">
    IT_CTZ displayName "IT-CTZ" <"Certificati del Tesoro zero coupon debt securities issued by the Italian Treasury with maturities between 18 and 24 months.">
    IT_MIB30 displayName "IT-MIB30" <"MIB30 Equity Securities.">
    IT_REP displayName "IT-REP" <"Debt securities issued and marketed by the Republic of Italy outside the Italian market, traded as Eurobonds.">
    JP_CASH displayName "JP-CASH" <"Japanese Yen (JPY) Cash.">
    JP_CORPORATE displayName "JP-CORPORATE" <"Corporate bonds including straight bonds.">
    JP_CP displayName "JP-CP" <"Commercial Paper.">
    JP_EQUITY displayName "JP-EQUITY" <"Equity securities issued by a Japanese company, each share representing the minimum unit of participation of a partner in the stock capital of the company.">
    JP_EUROBOND displayName "JP-EUROBOND" <"Yen-denominated foreign bonds.">
    JP_JGB displayName "JP-JGB" <"Japanese Government Bonds.">
    KR_BOND displayName "KR-BOND" <"Korean Treasury Bonds.">
    KR_CASH displayName "KR-CASH" <"Korean Won (KRW) Cash.">
    KR_EXIM displayName "KR-EXIM" <"Non Korean Won denominated Export-Import Bank of Korea bonds.">
    KR_KDICKRW displayName "KR-KDICKRW" <"Korean Development Insurance Corporation Bonds (Korean Won denominated).">
    KR_KDR displayName "KR-KDR" <"Non-Korean Won denominated Korea Development Bank bonds (KDBs).">
    KR_KEPCO displayName "KR-KEPCO" <"KEPCO bonds.">
    KR_MSB displayName "KR-MSB" <"Monetary Stabilisation Bonds.">
    KR_NHC displayName "KR-NHC" <"Non Korean Won denominated Korea National Housing Corporation bonds (KNHCs).">
    KR_ROK displayName "KR-ROK" <"Non-Korean Won denominated Republic of Korea bonds (ROKs).">
    NL_AEX displayName "NL-AEX" <"AEX Equity Securities.">
    NL_BILL displayName "NL-BILL" <"Dutch Treasury Certificates.">
    NL_BOND displayName "NL-BOND" <"Dutch State Loans.">
    NO_BOND displayName "NO-BOND" <"Norwegian Government Bonds.">
    NO_CASH displayName "NO-CASH" <"Norwegian Krone (NOK) Cash.">
    NO_OBX displayName "NO-OBX" <"OBX Equity Securities.">
    NO_TBILL displayName "NO-TBILL" <"Norwegian T-Bills.">
    NZ_BOND displayName "NZ-BOND" <"New Zealand Government Bonds.">
    NZ_CASH displayName "NZ-CASH" <"New Zealand Dollar (NZD) Cash.">
    NZ_TBILL displayName "NZ-TBILL" <"New Zealand Government Treasury Bills.">
    SE_CASH displayName "SE-CASH" <"Swedish Krona (SEK) Cash.">
    SE_GOVT displayName "SE-GOVT" <"Swedish Government Bonds (SGB).">
    SE_ILGOVT displayName "SE-ILGOVT" <"Swedish Index Linked Government bonds.">
    SE_MORT displayName "SE-MORT" <"Swedish Mortgage Bonds.">
    SE_OMX displayName "SE-OMX" <"OMX Equity Securities.">
    SE_TBILL displayName "SE-TBILL" <"Swedish Treasury Bills (STB).">
    SG_BOND displayName "SG-BOND" <"Singapore Government (SGS) Bonds.">
    SG_CASH displayName "SG-CASH" <"Singapore Dollar (SGD) Cash.">
    SG_TBILL displayName "SG-TBILL" <"Singapore Government T-Bills (T-Bills).">
    SU_IADB displayName "SU-IADB" <"Inter-American Development Bank Bonds.">
    SU_IBRDDN displayName "SU-IBRDDN" <"International Bank for Reconstruction and Development (World Bank) Discount Notes.">
    SU_IBRDGB displayName "SU-IBRDGB" <"International Bank for Reconstruction and Development (World Bank or IBRD) Global Benchmark Bonds.">
    US_ARM displayName "US-ARM" <"Adjustable Rate Mortgage (ARM) Bonds.">
    US_CASH displayName "US-CASH" <"United States of America Dollar (USD) Cash.">
    US_DERIV displayName "US-DERIV" <"REMICs, CMOs and other derivative structures.">
    US_DOW displayName "US-DOW" <"Dow Jones Industrial Average Equity Securities.">
    US_DOW_COMP displayName "US-DOW-COMP" <"Dow Jones Composite Average Equity Securities.">
    US_DOW_TRAN displayName "US-DOW-TRAN" <"Dow Jones Transportation\tAverage Equity Securities.">
    US_DOW_UTIL displayName "US-DOW-UTIL" <"Dow Jones Utilities Average Equity Securities.">
    US_FAMC displayName "US-FAMC" <"Federal Agricultural Mortgage Corp (Farmer Mac) Bonds.">
    US_FCS displayName "US-FCS" <"Farm Credit System (FCS) Bonds.">
    US_FCSFAC displayName "US-FCSFAC" <"Farm Credit System Financial Assistance Corporation (FCSFAC) Bonds.">
    US_FHLB displayName "US-FHLB" <"Callable Agency Debt  Federal Home Loan Bank (FHLB).">
    US_FHLBNC displayName "US-FHLBNC" <"Non-Callable Federal Home Loan Bank Debt.">
    US_FHLBNCDN displayName "US-FHLBNCDN" <"Non-Callable Federal Home Loan Bank Discount Notes.">
    US_FHLMC displayName "US-FHLMC" <"Callable Agency Debt  the Federal Home Loan Mortgage Corporation (FHLMC or Freddie Mac).">
    US_FHLMCMBS displayName "US-FHLMCMBS" <"Federal Home Loan Mortgage Corporation Certificates  Mortgage Backed Securities.">
    US_FICO displayName "US-FICO" <"Financing Corp (FICO) Bonds.">
    US_FNMA displayName "US-FNMA" <"Callable Agency Debt  Federal National Mortgage Association (FNMA or Fannie Mae).">
    US_FNMAMBS displayName "US-FNMAMBS" <"Federal National Mortgage Association Certificates  Mortgage Backed Securities.">
    US_GNMA displayName "US-GNMA" <"Callable Agency Debt  Government National Mortgage Association (GNMA).">
    US_GNMAMBS displayName "US-GNMAMBS" <"Government National Mortgage Association Certificates  Mortgage Backed Securities (GNMA or Ginnie Mae).">
    US_LEHM_BOND displayName "US-LEHM-BOND" <"Lehman Brothers Credit Bond Index Debt Securities.">
    US_NAS_100 displayName "US-NAS-100" <"NASDAQ-100 Index Equity Securities.">
    US_NAS_COMP displayName "US-NAS-COMP" <"NASDAQ Composite Index Equity Securities.">
    US_NCAD displayName "US-NCAD" <"Non-Callable Agency Debt  Various Issuers.">
    US_NCADN displayName "US-NCADN" <"Non-Callable Agency Discount Notes  Various Issuers.">
    US_NYSE_COMP displayName "US-NYSE-COMP" <"NYSE Composite Index Equity Securities.">
    US_REFCORP displayName "US-REFCORP" <"Resolution Funding Corp (REFCorp) Bonds.">
    US_SLMA displayName "US-SLMA" <"Student Loan Marketing Association (Sallie Mae) Bonds.">
    US_STRIP displayName "US-STRIP" <"US Treasury Strips.">
    US_S_P100 displayName "US-S&P100" <"Standard & Poors 100 Index Equity Securities.">
    US_S_P400 displayName "US-S&P400" <"Standard & Poors Midcap 400 Equity Securities. corporations that are included within the Standard And Poor's Midcap 400 Index published by Standard And Poor's, a division of The McGraw-Hill Companies, Inc.">
    US_S_P500 displayName "US-S&P500" <"Standard & Poors 500 Index Equity Securities.">
    US_S_P600 displayName "US-S&P600" <"Standard & Poors Smallcap 600 Index Equity Securities.">
    US_TBILL displayName "US-TBILL" <"US Treasury Bills.">
    US_TBOND displayName "US-TBOND" <"US Treasury Bonds.">
    US_TIPS displayName "US-TIPS" <"US Treasury Inflation Protected Issues (TIPS).">
    US_TNOTE displayName "US-TNOTE" <"US Treasury Notes.">
    US_TVA displayName "US-TVA" <"Tennessee Valley Authority (TVA) Bonds.">

enum AmendmentEffectiveDateEnum: <"The enumerated values to specify the effective date of the Amendment to Termination Currency when specified as a specific date (e.g. the annex date).">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(t)"]
    AnnexDate <"The effective date corresponds to the Annex date.">
    DeedDate <"The effective date corresponds to the Deed date.">
    AgreementDate <"The effective date corresponds to the Agreement date.">
    AmendmentEffectiveDate <"The effective date corresponds to the Amendment Effective Date (IM).">

enum AdditionalTypeEnum: <"The enumerated values to specify the Additional Type of transaction that can require the collection or delivery of initial margin under a given regulatory regime for the purposes of Covered Transactions.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(b)(B)"]
    NotApplicable <"No Additional Type of transaction is applicable to the regulatory regulatory regime.">
    EquityOptionOrIndexOption <"Single stock equity option or index option transaction as referred to in the transitional provisions (if any) of the EMIR RTS.">
    Other

enum ElectiveAmountEnum: <"The enumerated values to specify an elective amount.">
    Zero <"The elective amount is zero.">
    Unlimited <"The elective amount has no upper limit.">

enum SecurityInterestObligationsEnum: <"The enumerated values applicable for Security Interest for Obligations.">
    NotApplicable <"Security Interest for Obligations is not applicable to the Party.">
    AllObligationsOfPartyA displayName "All Obligations of Party A" <"All Obligations of Party A.">
    AllObligationsOfPartyB displayName "All Obligations of Party B" <"All Obligations of Party B.">
    Other <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

enum SecurityInterestObligeeEnum: <"The enumerated values applicable for Security Interest for Obligations Obligee.">
    PartyA <"Party A.">
    PartyAOrAffiliate displayName "Party A or any Affiliate of Party A" <"Party A or any Affiliate of Party A.">
    PartyB <"Party B.">
    PartyBOrAffiliate displayName "Party B or any Affiliate of Party B" <"Party B or any Affiliate of Party B.">
    Other <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

enum ThresholdZeroEventEnum: <"The enumerated values for defining the relevant trigger(s) for the threshold to fall to zero.">
    EventOfDefault <"An Event of Default.">
    TerminationEvent <"A Termination Event.">
    TerminationEventAllAffectedTransactions displayName "A Termination Event in respect of which all Transactions are Affected Transactions" <"A Termination Event in respect of which all Transactions are Affected Transactions.">
    PotentialEventOfDefault <"A Potential Event of Default.">
    AdditionalTerminationEvent <"An Additional Termination Event (ATE).">
    Other <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

enum ThresholdRatedPartyEnum: <"The enumerated values applicable where a Rated Party is defined within the Threshold clause.">
    Party <"Party.">
    CreditSupportProvider <"Credit Support Provider.">
    NamedEntity <"A Named Entity.">
    PartyOrCreditSupportProvider <"The Party or Credit Support Provider.">
    NamedAffiliate <"A Named Affiliate of the Party.">
    AllAffiliates displayName "All Affiliates to the Party" <"All Affiliates to the Party.">

enum MTAZeroEventEnum: <"The enumerated values for defining the relevant trigger(s) for the Minimum Transfer Amount (MTA) to fall to zero.">
    EventOfDefault <"An Event of Default.">
    TerminationEvent <"A Termination Event.">
    TerminationEventAllAffectedTransactions displayName "A Termination Event in respect of which all Transactions are Affected Transactions" <"A Termination Event in respect of which all Transactions are Affected Transactions.">
    PotentialEventOfDefault <"A Potential Event of Default.">
    AdditionalTerminationEvent <"An Additional Termination Event (ATE).">
    Other <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

enum MTARatedPartyEnum: <"The enumerated values applicable where a Rated Party is defined within the Minimum Transfer Amount (MTA) clause.">
    Party <"Party.">
    CreditSupportProvider <"Credit Support Provider.">
    NamedEntity <"An Named Entity.">
    PartyOrCreditSupportProvider <"The Party or Credit Support Provider.">
    NamedAffiliate <"An Named Affiliate of the Party.">
    AllAffiliates displayName "All Affiliates to the Party" <"All Affiliates to the Party.">

enum RatingTypeEnum: <"The relevant rating type.">
    LongTerm <"Long Term Ratings are applicable for the stated Rating Agency.">
    ShortTerm <"Short Term Ratings are applicable for the stated Rating Agency.">

enum NotRatedByEnum: <"The enumerated values applicable to define the what conditions apply to trigger a Not Rated condition.">
    All <"No rating is available for the Party for any of the stated Rating Agencies.">
    One <"No rating is available for the Party for any one of the stated Rating Agencies.">
    Two <"No rating is available for the Party for any two of the stated Rating Agencies.">

enum NumberOfRatingAgenciesEnum: <"The enumerated values to define the number of Rating Agencies that must be considered to meet the rating condition.">
    All <"Ratings for all defined Rating Agencies will be considered.">
    AnyOne <"Ratings for Any 1 stated Rating Agency will be applicable.">
    AnyTwo <"Ratings for Any 2 stated Rating Agencies will be applicable.">
    Other <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

enum LegacyDeliveryReturnAmountEnum: <"In respect of a Valuation Date, the amount of collateral which a party is entitled to demand to be transferred to it as a Delivery or Return Amount.">
    Standard <"Standard definition applies.">
    NonStandardRatings <"Election includes non-standard ratings-based langauge.">
    NonStandardOther <"Election includes non-standard bespoke language.">

enum ValuationTimeEnum: <"The type of time specified for the Valuation Time.">
    CloseOfBusiness <"The valuation time should be at close of business.">
    SpecificTime <"The valuation time should be at a specific time.">
    AsSelected <"The valuation time should be as selected.">

enum ValuationTimeDayEnum: <"The day at which the value of the collateral and obligations to transfer or return collateral are to be calculated relative to the Valuation Date.">
    PreviousLocalBusinessDay displayName "Previous Local Business Day" <"Should be calculated relative to the previous local business day.">
    PreviousLocalBusinessDayMarket displayName "Previous Local Business Day (Relevant Market)" <"Should be calculated relative to the previous local business day in the Relevant Market).">
    PreviousLocalBusinessDayCityOfAgent displayName "Previous Local Business Day (City of Valuation Agent)" <"Should be calculated relative to the previous local business day in the city of the Valuation Agent.">
    ValuationDate displayName "Valuation Date" <"Should be calculated on the Valuation Date.">
    AsSelected displayName "As Selected" <"Should be calculated relative to the previous local business day as selected.">

enum ValuationDateDateEnum: <"Defines whether the date of a Valuation is defined by a certain day of the week or a particular date in the month.">
    Each <"Specific Valuation date frequency.">
    Last <"Specific Valuation date frequency.">
    Secondlast displayName "2nd Last" <"Specific Valuation date frequency.">
    Thirdlast displayName "3rd Last" <"Specific Valuation date frequency.">
    Fourthlast displayName "4th Last" <"Specific Valuation date frequency.">
    CalendarDay <"A specific day of the calendar, defined.">
    AsSelected displayName "As Selected" <"As Selected.">

enum ValuationDateDayEnum extends DayOfWeekEnum: <"Defines the conditions for the day for a Valuation Date.">
    LocalBusinessDay <"The Date must be a day on which commercial banks are open for general business in the local market.">
    CalendarDay <"The Date can be a given day on the regular calendar.">
    NewYorkBankingDay displayName "New York Banking Day" <"The Date must be a New York Banking Day, that is a day, other than a Saturday or Sunday, on which banks are open for general commercial business in New York, USA.">

enum ValuationDateFrequencyEnum: <"The regularity of the event for the Valuation Date.">
    Daily
    Weekly
    Fortnightly
    Monthly
    AsAgreed
    AsSelected

enum ValuationAgentPartyEnum: <"Specification of which party calculating the value of collateral to be delivered or returned.">
    Party1 displayName "Party 1" <"Party 1 will calculate the value of collateral to be delivered or returned.">
    Party2 displayName "Party 2" <"Party 2 will calculate the value of collateral to be delivered or returned.">
    PartyMakingDemand displayName "Party Making the Demand" <"The party making the demand will calculate the value of collateral to be delivered or returned.">

enum LegacyValuationAgentEnum: <"Specifies how the Valuation Agent is determined.">
    SoleValuationAgent <"There is only a Sole Valuation Agent.">
    SwitchUponDefault <"Switch of Valuation Agent can occur upon Default.">
    SwitchUponFailureToPerform <"Switch of Valuation Agent can occur upon failure to perform.">
    FixedPartyForDisputes <"There is a fixed party for disputes.">

enum LegacyVMCustodianEnum: <"Details of how the Custodian is determined.">
    NotApplicable <"Not Applicable.">
    NamedEntity <"A named entity is specified as the Custodian.">
    AsAdvised1to2 displayName "As advised by Party 1 to Party 2" <"The Custodian as advised by Party 1 to Party 2.">
    AsAdvised2to1 displayName "As advised by Party 2 to Party 1" <"The Custodian as advised by Party 2 to Party 1.">
    Party1toParty2 displayName "Party 1 will notify Party 2" <"Party 1 will notify Party 2 of the custodian.">
    Party2toParty1 displayName "Party 2 will notify Party 1" <"Party 2 will notify Party 1 of the custodian.">

enum LegacyConsentEnum: <"Details of the consent requirements (if any) for Substitution.">
    ConsentRequired <"Consent is required for Substitution.">
    NoConsent <"No consent is required for Substitution.">
    ConsentRequiredNoDelay <"Consent is required, with no unreasonable delay, for Substitution.">
    TimesAdjusted <"Times adjusted.">
    NoticeConditions <"Notice conditions apply for Substitution.">
    CostsApportioned <"Costs apportioned for Substitution.">

enum ExposureScopeProductEnum: <"Description of the relevant derivative transactions excluded from the calculation of exposure.">
    FXTransactions displayName "FX Transactions" <"FX Transactions.">
    FXSettlementDate displayName "FX Transaction with Settlement Date" <"FX Transactions with Settlement date.">
    CurrencyOptionTransactions displayName "Currency Option Transactions" <"Currency Option Transactions.">

enum CreditSupportAmountEnum: <"Specifies whether the meaning of credit support amount follows the pre-print definition or deviates from the standard (either based on a rating or some other methodology).">
    Standard displayName "Standard" <"The standard definition of the credit support amount applies.">
    IAFloorGIA displayName "Non-Standard - IA Floor (Less GiverIA)"
    IAFloorGIATIA displayName "Non-Standard - IA Floor (Less GiverIA and TakerIA)"
    NonStandardRatings displayName "Non-Standard - Ratings"
    NonStandardOther displayName "Non-Standard - Other"

enum LegacyResolutionAlternativeEnum: <"Details of the alternative dispute resolution procedure (if any).">
    NoAlternative <"No Alternative dispute resolution procedure is defined.">
    SplitDifference <"A split the difference resolution procedure applies.">
    AdditionalConditions <"Additional Conditions are defined.">

enum ValueCashEnum: <"Details of how cash collateral is valued when resolving disputes.">
    CashAmount displayName "Cash - Amount Thereof" <"Cash - Amount thereof.">
    CashPercentage displayName "Cash - Amount Thereof multiplied by Valuation Percentage" <"Cash - amount thereof multiplied by Valuation Percentage.">
    CashPercentageLessHaircut displayName "Cash - Amount Thereof multiplied by (Valuation Percentage - FX Haircut)" <"Cash - Amount Thereof multiplied by (Valuation Percentage - FX Haircut).">
    Other <"Exception value.">

enum ValueSecuritiesEnum: <"Details of how securities collateral is valued when resolving disputes.">
    BidPricePercentage displayName "Securities - Bid Price multiplied by Valuation Percentage" <"Securities collateral is valued using the bid price multiplied by the valuation percentage.">
    BidPricePercentageLessHaircut displayName "Securities - Bid Price multiplied by (Valuation Percentage - FX Haircut)" <"Securities collateral is valued using the bid price multiplied by the valuation percentage less the FX haircut.">
    MidPricePercentage displayName "Securities - Mid Price multiplied by Valuation Percentage" <"Securities collateral is valued using the mid price multiplied by the valuation percentage.">
    MidPricePercentageLessHaircut displayName "Securities - Mid Price multiplied by (Valuation Percentage - FX Haircut)" <"Securities collateral is valued using the mid price multiplied by the valuation percentage less the FX haircut.">
    Other <"Exception value.">

enum CashCTSTimeEnum: <"Details the day on which cash collateral is required to be transferred relative to the Notification Time.">
    Same <"The cash collateral should be transferred on the same day.">
    Next <"The cash collateral should be transferred on the next day.">
    FirstLBD displayName "First Local Business Day" <"The cash collateral should be transferred on the first local business day.">
    SecondLBD displayName "Second Local Business Day" <"The cash collateral should be transferred on the second local business day.">
    Other <"Exception value.">

enum SecuritiesCTSTimeEnum: <"Details the day on which securities collateral is required to be transferred relative to the Notification Time.">
    Same <"The securities collateral should be transferred on the same day.">
    Next <"The securities collateral should be transferred on the next day.">
    FirstDay displayName "First Local Business Day" <"The securities collateral should be transferred on the first local business day.">
    SecondDay displayName "Second Local Business Day" <"The securities collateral should be transferred on the second local business day.">
    ThirdDay displayName "Third Local Business Day" <"The securities collateral should be transferred on the third local business day.">
    Other <"Exception value.">


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-csa-func.rosetta
================================================================================

namespace cdm.legaldocumentation.csa
version "${project.version}"

import cdm.base.*
import cdm.base.math.*
import cdm.observable.asset.*

func PostedCreditSupportItemAmount: <"Calculates the Value for the given Posted Credit Support item.">
    [docReference ISDA CSA_IM_NewYork_2018 paragraph "13"]
    [calculation]
    inputs:
        postedItem PostedCreditSupportItem (1..1) <"Posted Credit Support Item.">
        baseCurrency string (1..1) <"Base Currency means the currency specified as such in Paragraph 13.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
    output:
        result Money (1..1)

    alias cashOrSecurityValue: postedItem -> cashOrSecurityValue -> value

    alias haircutPercentage: postedItem -> haircutPercentage

    alias fxHaircutPercentage: postedItem -> fxHaircutPercentage

    alias additionalHaircutPercentage: postedItem -> fxHaircutPercentage

    alias postedCreditSupportAmount:
        cashOrSecurityValue * (1.00 - (haircutPercentage + fxHaircutPercentage + additionalHaircutPercentage))

    condition CurrencyMatches:
        baseCurrency = postedItem -> cashOrSecurityValue -> unit -> currency
            and baseCurrency = postedItem -> disputedCashOrSecurityValue -> unit -> currency

    set result -> value:
        postedCreditSupportAmount - postedItem -> disputedCashOrSecurityValue -> value

    set result -> unit -> currency: baseCurrency

func UndisputedAdjustedPostedCreditSupportAmount: <"Calculates the value for Undisputed Adjusted Posted Credit Support Item.">
    [calculation]
    inputs:
        postedCreditSupportItems PostedCreditSupportItem (0..*) <"Posted Credit Support Items.">
        priorDeliveryAmountAdjustment Money (1..1) <"The adjustment value to include any prior Delivery Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(a)(ii)"]
        priorReturnAmountAdjustment Money (1..1) <"The adjustment value to exclude any prior Return Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(a)(ii)"]
        disputedTransferredPostedCreditSupportAmount Money (1..1) <"The disputed value of any Transfer of Eligible Credit Support.">
            [docReference ISDA CSA_IM_2018 paragraph "5"]
        baseCurrency string (1..1) <"Base Currency means the currency specified as such in Paragraph 13.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
    output:
        result Money (1..1)

    alias totalPostedCreditSupportAmount:
        postedCreditSupportItems
            extract PostedCreditSupportItemAmount(item, baseCurrency) -> value
            then sum

    alias adjustedPostedCreditSupportAmount:
        totalPostedCreditSupportAmount + priorDeliveryAmountAdjustment -> value - priorReturnAmountAdjustment -> value

    condition CurrencyMatches:
        (baseCurrency = priorDeliveryAmountAdjustment -> unit -> currency)
            and (baseCurrency = priorReturnAmountAdjustment -> unit -> currency)
            and (baseCurrency = disputedTransferredPostedCreditSupportAmount -> unit -> currency)

    set result -> value:
        adjustedPostedCreditSupportAmount - disputedTransferredPostedCreditSupportAmount -> value

    set result -> unit -> currency: baseCurrency

func CreditSupportAmount: <"Calculates the Credit Support Amount.">
    [calculation]
    inputs:
        marginAmount Money (1..1) <"The Base Currency Equivalent of an amount equal to the sum of the initial margin amounts.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(i)"]
        threshold Money (1..1) <"With respect to a party, the Base Currency Equivalent of the amount specified for that party, if no amount is specified, zero.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
        marginApproach MarginApproachEnum (1..1) <"Specifies the margin approach specific to Initial Margin agreements.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(iii)" name "Margin Approach"]
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(iii)"]
        marginAmountIA Money (0..1) <"The Base Currency Equivalent of an amount equal to the sum of the Independent Amounts.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(iii)" name "Margin Approach"]
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(ii)"]
        baseCurrency string (1..1) <"Base Currency means the currency specified as such in Paragraph 13.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
    output:
        result Money (1..1)

    alias creditSupportAmountCalc: Max(marginAmount -> value - threshold -> value, 0.0)

    condition CurrencyMatches:
        (baseCurrency = marginAmount -> unit -> currency)
            and (baseCurrency = threshold -> unit -> currency)
            and (if marginAmountIA exists then baseCurrency = marginAmountIA -> unit -> currency else True)

    condition MarginAmountIA:
        if marginApproach = MarginApproachEnum -> Distinct
                or marginApproach = MarginApproachEnum -> Allocated
        then marginAmountIA is absent
        else if marginApproach = MarginApproachEnum -> GreaterOf
        then marginAmountIA exists

    set result -> value:
        if marginApproach = MarginApproachEnum -> Distinct
                or marginApproach = MarginApproachEnum -> Allocated
        then creditSupportAmountCalc
        else if marginApproach = MarginApproachEnum -> GreaterOf
        then Max(creditSupportAmountCalc, marginAmountIA -> value)

    set result -> unit -> currency: baseCurrency

func ReturnAmount:
    [docReference ISDA CSA_IM_2018 paragraph "3" clause "(b)"]
    [calculation]
    inputs:
        postedCreditSupportItems PostedCreditSupportItem (0..*)
        priorDeliveryAmountAdjustment Money (1..1) <"The adjustment value to include any prior Delivery Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(a)(ii)"]
        priorReturnAmountAdjustment Money (1..1) <"The adjustment value to exclude any prior Return Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(a)(ii)"]
        disputedTransferredPostedCreditSupportAmount Money (1..1) <"The disputed value of any Transfer of Eligible Credit Support.">
            [docReference ISDA CSA_IM_2018 paragraph "5"]
        marginAmount Money (1..1) <"The Base Currency Equivalent of an amount equal to the sum of the initial margin amounts.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(i)"]
        threshold Money (1..1) <"With respect to a party, the Base Currency Equivalent of the amount specified for that party, if no amount is specified, zero.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
        marginApproach MarginApproachEnum (1..1) <"Specifies the margin approach specific to Initial Margin agreements.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(iii)"]
        marginAmountIA Money (0..1) <"The Base Currency Equivalent of an amount equal to the sum of the Independent Amounts.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(ii)"]
        minimumTransferAmount Money (1..1) <"With respect to a party, the Base Currency Equivalent of the amount specified for that party, if no amount is specified, zero.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
        rounding CollateralRounding (1..1) <"Rounding methodology applicable to the Delivery Amount and the Return Amount in terms of nearest integral multiple of Base Currency units">
            [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principals" clause "(d)(vi)(C)" name "Rounding"]
            [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principals" clause "(d)(vi)(C)" name "Rounding"]
            [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principals" clause "(d)(vi)(C)" name "Rounding"]
        disputedReturnAmount Money (1..1) <"If a party (a 'Disputing Party') disputes the Calculation Agent (IM)s calculation of a Return Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "5"]
        baseCurrency string (1..1) <"Base Currency means the currency specified as such in Paragraph 13.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
    output:
        result Money (1..1)

    alias undisputedAdjustedPostedCreditSupportAmount:
        UndisputedAdjustedPostedCreditSupportAmount(
                postedCreditSupportItems,
                priorDeliveryAmountAdjustment,
                priorReturnAmountAdjustment,
                disputedTransferredPostedCreditSupportAmount,
                baseCurrency
            )

    alias creditSupportAmount:
        CreditSupportAmount(
                marginAmount,
                threshold,
                marginApproach,
                marginAmountIA,
                baseCurrency
            )

    alias returnAmount:
        Max(
                undisputedAdjustedPostedCreditSupportAmount -> value - creditSupportAmount -> value,
                0.0
            )

    alias undisputedReturnAmount: Max(returnAmount - disputedReturnAmount -> value, 0.0)

    condition CurrencyMatches:
        (baseCurrency = minimumTransferAmount -> unit -> currency)
            and (baseCurrency = disputedReturnAmount -> unit -> currency)

    set result -> value:
        if undisputedReturnAmount >= minimumTransferAmount -> value
        then RoundToNearest(
                    undisputedReturnAmount,
                    rounding -> returnAmount,
                    RoundingModeEnum -> Down
                )
        else 0.0

    set result -> unit -> currency: baseCurrency

func DeliveryAmount:
    [docReference ISDA CSA_IM_2018 paragraph "3" clause "a" name "Delivery Amount"]
    [calculation]
    inputs:
        postedCreditSupportItems PostedCreditSupportItem (0..*)
        priorDeliveryAmountAdjustment Money (1..1) <"The adjustment value to include any prior Delivery Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(a)(ii)"]
        priorReturnAmountAdjustment Money (1..1) <"The adjustment value to exclude any prior Return Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(a)(ii)"]
        disputedTransferredPostedCreditSupportAmount Money (1..1) <"The disputed value of any Transfer of Eligible Credit Support.">
            [docReference ISDA CSA_IM_2018 paragraph "5"]
        marginAmount Money (1..1) <"The Base Currency Equivalent of an amount equal to the sum of the initial margin amounts.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(i)"]
        threshold Money (1..1) <"With respect to a party, the Base Currency Equivalent of the amount specified for that party, if no amount is specified, zero.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
        marginApproach MarginApproachEnum (1..1)
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(iii)"]
        marginAmountIA Money (0..1) <"The Base Currency Equivalent of an amount equal to the sum of the Independent Amounts.">
            [docReference ISDA CSA_IM_2018 paragraph "3" clause "(c)(ii)"]
        minimumTransferAmount Money (1..1) <"With respect to a party, the Base Currency Equivalent of the amount specified for that party, if no amount is specified, zero.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
        rounding CollateralRounding (1..1) <"Rounding methodology applicable to the Delivery Amount and the Return Amount in terms of nearest integral multiple of Base Currency units.">
            [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principals" clause "(d)(vi)(C)" name "Rounding"]
            [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principals" clause "(d)(vi)(C)" name "Rounding"]
            [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principals" clause "(d)(vi)(C)" name "Rounding"]
        disputedDeliveryAmount Money (1..1) <"If a party (a 'Disputing Party') disputes the Calculation Agent (IM)s calculation of a Delivery Amount (IM).">
            [docReference ISDA CSA_IM_2018 paragraph "5"]
        baseCurrency string (1..1) <"Base Currency means the currency specified as such in Paragraph 13.">
            [docReference ISDA CSA_IM_2018 paragraph "13"]
    output:
        result Money (1..1)

    alias undisputedAdjustedPostedCreditSupportAmount:
        UndisputedAdjustedPostedCreditSupportAmount(
                postedCreditSupportItems,
                priorDeliveryAmountAdjustment,
                priorReturnAmountAdjustment,
                disputedTransferredPostedCreditSupportAmount,
                baseCurrency
            )

    alias creditSupportAmount:
        CreditSupportAmount(
                marginAmount,
                threshold,
                marginApproach,
                marginAmountIA,
                baseCurrency
            )

    alias deliveryAmount:
        Max(
                creditSupportAmount -> value - undisputedAdjustedPostedCreditSupportAmount -> value,
                0.0
            )

    alias undisputedDeliveryAmount:
        Max(deliveryAmount - disputedDeliveryAmount -> value, 0.0)

    condition CurrencyMatches:
        (baseCurrency = minimumTransferAmount -> unit -> currency
            and (baseCurrency = disputedDeliveryAmount -> unit -> currency))

    set result -> value:
        if undisputedDeliveryAmount >= minimumTransferAmount -> value
        then RoundToNearest(
                    undisputedDeliveryAmount,
                    rounding -> deliveryAmount,
                    RoundingModeEnum -> Up
                )
        else 0.0

    set result -> unit -> currency: baseCurrency


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-csa-type.rosetta
================================================================================

namespace cdm.legaldocumentation.csa : <"Credit support concepts: CSA, collateral, elections, initial margin, threshold, minimum transfer amount.">
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.legaldocumentation.common.*
import cdm.observable.asset.*
import cdm.product.collateral.*

corpus Deed "ISDA 2016 English Law Credit Support Deed for Initial Margin" CSD_IM_English_2016
corpus Deed "ISDA 2018 English Law Credit Support Deed for Initial Margin" CSD_IM_English_2018
corpus Deed "1995 English Law Credit Support Deed" CSD_English_1995
corpus Annex "ISDA 2016 Japanese Law Credit Support Annex for Initial Margin" CSA_IM_Japanese_2016
corpus Annex "ISDA 2016 New York Law Credit Support Annex for Initial Margin" CSA_IM_NewYork_2016
corpus Annex "ISDA 2018 New York Law Credit Support Annex for Initial Margin" CSA_IM_NewYork_2018
corpus Annex "ISDA 2018 Credit Support Annex For Initial Margin" CSA_IM_2018
corpus Annex "ISDA 2016 Credit Support Annex for Initial Margin" CSA_IM_2016
corpus Annex "ISDA 2016 Credit Support Annex for Variation Margin" CSA_VM_2016
corpus Annex "1995 English Law Credit Support Annex" CSA_English_1995
corpus Annex "2016 English Law Variation Margin Credit Support Annex" CSA_VM_English_2016
corpus Annex "2016 New York Law Variation Margin Credit Support Annex" CSA_VM_NewYork_2016
corpus Annex "1994 New York Law Credit Support Annex" CSA_NewYork_1994
corpus Annex "Initial Margin Credit Support Annex" CSA_IM
corpus Annex "Variation Margin Credit Support Annex" CSA_VM
corpus Annex "ISDA Japanese Law Credit Support Annex" CSA_Japanese
corpus Annex "ISDA Japanese Law Credit Support Annex for Variation Margin" CSA_VM_Japanese
corpus Definition "2003 ISDA Collateral Asset Definitions" CollateralAssetDefinitions_2003

segment paragraph
segment clause
segment name

type CreditSupportAgreementElections: <"The set of elections which specify a Credit Support Annex or Deed.">
    regime Regime (1..1) <"The Regime Table provision , which determines the regulatory regime(s) applicable to each of the parties to the agreement.">
    oneWayProvisions OneWayProvisions (1..1) <"The determination of whether the One Way Provisions are applicable (true) or not applicable (false).">
    generalSimmElections GeneralSimmElections (0..1) <"The specification of the ISDA SIMM Method for all Covered Transactions with respect to all Regimes.">
    identifiedCrossCurrencySwap boolean (0..1) <"The qualification of whether cross-currency swaps need to be identified in the Confirmation so that the obligations to exchange principal be disregarded for the purpose of determining the Delivery Amount or Return Amount.">
    sensitivityMethodologies SensitivityMethodologies (1..1) <"The specification of methodologies to compute sensitivities specific to the agreement.">
    fxHaircutCurrency FxHaircutCurrency (0..1) <"The reference currency for the purpose of specifying the FX Haircut relating to a posting obligation, as being either the Termination Currency or an FX Designated Currency.">
    postingObligations PostingObligations (1..1) <"The security providers posting obligations.">
    substitutedRegime SubstitutedRegime (0..*) <"The specification of Additional regimes for purposes of determining whether a Regulatory Event has occurred.">
    baseAndEligibleCurrency BaseAndEligibleCurrency (1..1) <"The base and eligible currency(ies) for the document as specified by the parties to the agreement.">
    additionalObligations string (0..1) <"The additional obligations that might be specified by the parties to a Credit Support Agreement.">
    coveredTransactions CoveredTransactions (1..1) <"The specification of transactions covered by the terms of the agreement.">
    creditSupportObligations CreditSupportObligations (1..1) <"The Credit Support Obligations applicable to the agreement.">
    exchangeDate string (0..1) <"The bespoke exchange date terms that might be specified by the parties to the agreement.">
    calculationAndTiming CalculationAndTiming (1..1) <"The set of elections for determining Valuation and Timing terms specific to the agreement.">
    conditionsPrecedent ConditionsPrecedent (0..1) <"The set of elections that may overwrite the default Condition Precedent provision, and the set of provisions that are deemed Access Condition.">
    substitution Substitution (1..1) <"The conditions under which the Security Provider can substitute posted collateral.">
    disputeResolution DisputeResolution (1..1) <"The election terms under which a party disputes (i) the Calculation Agents calculation of a Delivery Amount or a Return Amount, or (ii) the Value of any Transfer of Eligible Credit Support or Posted Credit Support.">
    holdingAndUsingPostedCollateral HoldingAndUsingPostedCollateral (1..1) <"The elections for the holding and using of posted collateral by the respective parties to the Credit Support Annex for Variation Margin.">
    rightsEvents RightsEvents (1..1) <"The bespoke provisions that might be specified by the parties to the agreement to specify the rights of Security Taker and/or Security Provider when an Early Termination or Access Condition event has occurred.">
    custodyArrangements CustodyArrangements (0..1) <"The Custodian and Segregated Account details in respect of each party to the agreement.">
    distributionAndInterestPayment DistributionAndInterestPayment (0..1) <"The Distributions and Interest Payment terms specified as part of the agreement.">
    creditSupportOffsets boolean (1..1) <"The specification of whether the standard Credit Support Offset provisions are applicable (true) or not applicable (false).">
    additionalRepresentations AdditionalRepresentations (1..1) <"The specification Additional Representations that may be applicable to the agreement.">
    otherEligibleAndPostedSupport OtherEligibleAndPostedSupport (1..1) <"The Other Eligible Support elections associated with margin agreements.">
    demandsAndNotices ContactElection (0..1) <"The optional specification of address where the demands, specifications and notices will be communicated to for each of the parties to the agreement.">
    addressesForTransfer ContactElection (0..1) <"The optional specification of address for transfer as specified by the respective parties to the agreement.">
    otherAgreements OtherAgreements (0..1) <"The bespoke definition of other agreement terms as specified by the parties to the agreement.">
    terminationCurrencyAmendment TerminationCurrencyAmendment (1..1) <"The bespoke provision that might be specified by the parties to the agreement applicable to Termination Currency.  Unless specified the definition of Termination Currency has the meaning specified in the Schedule to the ISDA Master Agreement.">
    minimumTransferAmountAmendment MinimumTransferAmountAmendment (1..1) <"The bespoke provision that might be specified by the parties to the agreement applicable to Minimum Transfer Amount.  Unless specified the definition of Minimum Transfer Amount in any Other Regulatory CSA has the meaning specified in such Other Regulatory CSA.">
    interpretationTerms string (0..1) <"The bespoke provision that might be specified by the parties to the agreement applicable to Interpretations.">
    processAgent ProcessAgent (0..1) <"The Process Agent that might be appointed by the parties to the agreement.">
    appropriatedCollateralValuation AppropriatedCollateralValuation (0..1) <"The election for the Valuation of Appropriate Collateral.">
    jurisdictionRelatedTerms JurisdictionRelatedTerms (0..1) <"The jurisdiction specific terms relevant to the agreement.">
    additionalAmendments string (0..1) <"Any additional amendments that might be specified by the parties to the agreement.">
    additionalBespokeTerms string (0..1) <"Any additional terms that might be specified applicable.">
    trustSchemeAddendum boolean (1..1) <"The qualification of whether Trust Scheme Addendum is applicable (True) or not applicable (False).">
    securityInterestForObligations SecurityInterestForObligations (1..1) <"The party to whom obligations under the Master Agreement are owed and secured by the credit support arrangements. Applicable to 1994 NY CSA, 1995 English Law CSD and 2016 New York Law VM CSA.">
    singlePostingParty SinglePostingParty (0..1) <"Where only a single  party is explicitly designated to post collateral, the party which is specified as the sole poster of collateral.">
    datedAsOfDate DatedAsOfDate (0..1) <"Defines the dates agreed by the parties as the date of the Credit Support Annex or Credit Support Deed.">
    cass string (0..1) <"Details of language relating to Client Asset and Money Rules.">
    otherCSA string (0..1) <"A clause detailing the prescence of another collateralisation arrangement within the Master Agreement between the parties to this Collateral Arrangement.">
    legacyAdditionalRepresentations string (0..1) <"Details of any Additional Representations given by the relevant parties in relation to the collateral arrangement.">
    value CollateralValueMethod (0..1) <"Details how particular types of collateral are valued (other than in respect of a default).">

type CollateralTransferAgreementElections: <"The set of elections which specify a Collateral Transfer Agreement.">
    regime Regime (1..1) <"The Regime Table provision , which determines the regulatory regime(s) applicable to each of the parties to the agreement.">
    oneWayProvisions OneWayProvisions (1..1) <"The determination of whether the One Way Provisions are applicable (true) or not applicable (false).">
    generalSimmElections GeneralSimmElections (1..1) <"The specification of the ISDA SIMM Method for all Covered Transactions with respect to all Regimes.">
    identifiedCrossCurrencySwap boolean (0..1) <"The qualification of whether cross-currency swaps need to be identified in the Confirmation so that the obligations to exchange principal be disregarded for the purpose of determining the Delivery Amount or Return Amount.">
    sensitivityMethodologies SensitivityMethodologies (1..1) <"The specification of methodologies to compute sensitivities specific to the agreement.">
    fxHaircutCurrency FxHaircutCurrency (0..1) <"The reference currency for the purpose of specifying the FX Haircut relating to a posting obligation, as being either the Termination Currency or an FX Designated Currency.">
    postingObligations PostingObligations (1..1) <"The security providers posting obligations.">
    substitutedRegime SubstitutedRegime (1..*) <"The specification of Additional regimes for purposes of determining whether a Regulatory Event has occurred.">
    baseAndEligibleCurrency BaseAndEligibleCurrency (1..1) <"The base and eligible currency(ies) for the document as specified by the parties to the agreement.">
    creditSupportObligations CreditSupportObligations (1..1) <"The Credit Support Obligations applicable to the agreement.">
    calculationAndTiming CalculationAndTiming (1..1) <"The set of elections for determining Valuation and Timing terms specific to the agreement.">
    conditionsPrecedent ConditionsPrecedent (1..1) <"The set of elections that may overwrite the default Condition Precedent provision, and the set of provisions that are deemed Access Condition.">
    substitution Substitution (0..1) <"The conditions under which the Security Provider can substitute posted collateral.">
    disputeResolution DisputeResolution (1..1) <"The election terms under which a party disputes (i) the Calculation Agents calculation of a Delivery Amount or a Return Amount, or (ii) the Value of any Transfer of Eligible Credit Support or Posted Credit Support.">
    rightsEvents RightsEvents (0..1) <"The bespoke provisions that might be specified by the parties to the agreement to specify the rights of Security Taker and/or Security Provider when an Early Termination or Access Condition event has occurred.">
    custodyArrangements CustodyArrangements (1..1) <"The Custodian and Segregated Account details in respect of each party to the agreement.">
    additionalRepresentations AdditionalRepresentations (1..1) <"The specification Additional Representations that may be applicable to the agreement.">
    demandsAndNotices ContactElection (0..1) <"The optional specification of address where the demands, specifications and notices will be communicated to for each of the parties to the agreement.">
    addressesForTransfer ContactElection (0..1) <"The optional specification of address for transfer as specified by the respective parties to the agreement.">
    otherCsa string (0..1) <"The bespoke definition of Other CSA as specified by the parties to the agreement.">
    terminationCurrencyAmendment TerminationCurrencyAmendment (1..1) <"The bespoke provision that might be specified by the parties to the agreement applicable to Termination Currency.  Unless specified the definition of Termination Currency has the meaning specified in the Schedule to the ISDA Master Agreement.">
    minimumTransferAmountAmendment MinimumTransferAmountAmendment (0..1) <"The bespoke provision that might be specified by the parties to the agreement applicable to Minimum Transfer Amount.  Unless specified the definition of Minimum Transfer Amount in any Other Regulatory CSA has the meaning specified in such Other Regulatory CSA.">
    interpretationTerms string (0..1) <"The bespoke provision that might be specified by the parties to the agreement applicable to Interpretations.">
    processAgent ProcessAgent (0..1) <"The Process Agent that might be appointed by the parties to the agreement.">
    jurisdictionRelatedTerms JurisdictionRelatedTerms (0..1) <"The jurisdiction specific terms relevant to the agreement.">
    additionalAmendments string (0..1) <"Any additional amendments that might be specified by the parties to the agreement.">
    additionalBespokeTerms string (0..1) <"Any additional terms that might be specified applicable.">
    pledgeeRepresentativeRider PledgeeRepresentativeRider (0..1) <"The terms of the Rider for the ISDA Euroclear 2019 Collateral Transfer Agreement with respect to the use of a Pledgee Representative attached to this Agreement.">
    finalReturns FinalReturns (1..1) <"A clause providing that final return collateral is to be provided without consideration of any Minimum Transfer Amount and collateral haircut.">

type SecurityAgreementElections: <"The set of elections which specify a Security Agremeent.">
    pledgedAccount Account (0..1) <"The pledged account associated with the agreement.">
    enforcementEvent EnforcementEvent (0..1) <"Enforcement Events specific to the agreement.">
    deliveryInLieuRight boolean (0..1) <"Delivery In Lieu rights.">
    fullDischarge boolean (0..1) <"Full Discharge condition.">
    appropriatedCollateralValuation AppropriatedCollateralValuation (0..1) <"The election for the Valuation of Appropriate Collateral.">
    processAgent ProcessAgent (0..1) <"The Process Agent that might be appointed by the parties to the agreement.">
    jurisdictionRelatedTerms JurisdictionRelatedTerms (0..1) <"The jurisdiction specific terms.">
    additionalAmendments string (0..1) <"Any additional amendments that might be specified by the parties to the agreement.">
    additionalBespokeTerms string (0..1) <"Any additional terms that might be specified applicable.">
    executionTerms ExecutionTerms (0..1) <"The location and language of execution to determine duty to be paid.">

type PostedCreditSupportItem: <"Posted Credit Support item with corresponding Valuation Percentage, FX Haircut Percentage and any related disputed Posted Credit Support valuation.">
    cashOrSecurityValue Money (1..1) <"The Base Currency Equivalent of Cash or Security.">
    haircutPercentage number (1..1) <"Valuation Percentage means, for any item of Eligible Collateral (IM), the percentage specified in accordance with Paragraph 13.">
    fxHaircutPercentage number (0..1) <"FX Haircut Percentage means, for any item of Eligible Collateral (IM), the percentage specified in accordance with Paragraph 13.">
    additionalHaircutPercentage number (0..1) <"Percentage value of any additional haircut to be applied to a collateral asset,the percentage value is expressed as the discount haircut to the value of the collateral- as an example a 5% haircut would be expressed as 0.05.">
    disputedCashOrSecurityValue Money (1..1) <"Paragraph 5. If a party (a 'Disputing Party') disputes the Value of any Posted Credit Support (IM).">

type AccessConditions: <"A class to specify each party's election with respect to the Termination Events that will be deemed an Access Condition (Initial Margin CSA) or a Specified Condition (Variation Margin CSA).">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(e) (ii)"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(f) (ii)"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(e) (ii)"]
    [docReference ISDA CSA_VM_2016 paragraph "13" clause "(e)" name "Conditions Precedent and Secured Partys Rights and Remedies."]
    partyElection AccessConditionsElections (2..2) <"The parties' Access Condition (Initial Margin CSA) or a Specified Condition (Variation Margin CSA) election.">
    additionalTerminationEvent AdditionalTerminationEvent (0..*) <"Additional Termination Events applicable to the agreement.">

type AccessConditionsElections: <"A class to specify the Termination Events that will be deemed an Access Condition or a Specified Condition.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(e) (ii)"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(f) (ii)"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(e) (ii)"]
    [docReference ISDA CSA_VM_2016 paragraph "13" clause "(e)" name "Conditions Precedent and Secured Partys Rights and Remedies."]
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    illegality boolean (1..1) <"Represents an illegality Termination Event.">
    forceMajeure boolean (1..1) <"Represents a force Majeure Termination Event.">
    taxEvent boolean (1..1) <"Represents a Tax Termination Event.">
    taxEventUponMerger boolean (1..1) <"Represents a Tax Event Upon Merger Termination Event.">
    creditEventUponMerger boolean (1..1) <"Represents a Credit Event Upon Merger Termination Event.">

type AdditionalRepresentation: <"A class to specify the Additional Representation.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(o)" name "Additional Representations(s)"]
    partyElection AdditionalRepresentationElection (2..2) <"A qualification as to whether the Additional Representation is applicable.">
    customElection string (0..1) <"A supplemental custom election that might be specified by the parties for the purpose of specifying the Additional Representation.">

type AdditionalRepresentationElection: <"A class to specify the parties' Additional Representation(s) election.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    isApplicable boolean (1..1) <"The Additional Representation is applicable when True, and not applicable when False.">

type AdditionalRepresentations: <"A class to specify Additional Representations that may be applicable to an agreement.">
    additionalRepresentation AdditionalRepresentation (0..1) <"The specification of the Additional Representation that may be applicable to the agreement.">
    regulatoryComplianceRepresentation boolean (0..1) <"The qualification of whether Additional Information related to Regulatory Compliance and Concentration Limits is applicable or not.">

    condition:
        one-of

type AdditionalRightsEvent: <"A class to specify the Pledgor/Obligor/Chargor Additional Rights Event election.">
    [docReference ISDA CSD_IM_English_2016 paragraph  "13 General Principles" clause "(k)" name "Chargor Additional Rights Event"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph  "13 General Principles" clause "(k)" name "Obligor Additional Rights Event"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph  "13 General Principles" clause "(k)" name "Pledgor Additional Rights Event"]
    isApplicable boolean (1..1) <"The Pledgor Additional Rights Event election is applicable when True, and not applicable when False.">
    qualification string (0..1) <"The qualification of the Pledgor Additional Rights Event election, when specified.">

    condition Qualification: <"The Pledgor/Obligor/Chargor Additional Rights should be qualified only when the Pledgor Additional Rights Event election is specified as applicable.">
        if qualification exists then isApplicable = True

type AdditionalTerminationEvent: <"A class to specify an optional termination event, additional to the Termination Events that will be deemed an Access Condition (Initial Margin CSA) or a Specified Condition (Variation Margin CSA).">
    name string (1..1) <"The name of the additional termination event.">
    applicableParty CounterpartyRoleEnum (1..2) <"Whether the additional termination event is applicable for the relevant party.">

type AdditionalType: <"The specification of the Additional Type of transaction that can require the collection or delivery of initial margin under a given regulatory regime for the purposes of Covered Transactions.">
    [docReference ISDA CSA_IM_2016 paragraph  "13 General Principles" clause "(b)(B)"]
    standardValue AdditionalTypeEnum (1..1) <"The qualification of the Additional Type of transaction that can require the collection or delivery of initial margin when specified as a standard value.">
    customValue string (0..1) <"The qualification of the Additional Type of transaction that can require the collection or delivery of initial margin when specified as a custom value by the parties to the legal agreement.">

    condition CustomValue: <"The specification of a custom value by the parties to the legal agreement takes place alongside the qualification of the `Other` value as part of the AdditionalTypeEnum.">
        if standardValue = AdditionalTypeEnum -> Other
        then customValue exists

    condition StandardValue: <"The specification of a standard value by the parties to the legal agreement is done through the qualification of a value distinct than `Other` as part of the AdditionalTypeEnum, and implies that the customerValue is not being qualified.">
        if standardValue <> AdditionalTypeEnum -> Other
        then customValue is absent

type AmendmentEffectiveDate: <"A class to specify the effective date of the Amendment to Termination Currency. This date can be specified as either an actual date, a specific date (e.g. the annex date) or as a custom provision.">

    date date (0..1) <"The effective date of the Amendment to Termination Currency when specified as an actual date.">
    specificDate AmendmentEffectiveDateEnum (0..1) <"The effective date of the Amendment to Termination Currency when specified as relative to another date (e.g. the annex date).">
    customProvision string (0..1) <"The effective date of the Amendment to Termination Currency when specified as a non normalized custom provision.">

    condition:
        one-of

type ApplicableRegime: <"A class to specify the applicable regulatory regime(s) that parties to a legal agreement, such as the ISDA 2016 and 2018 CSA for Initial Margin, might be subject to.">

    regime RegulatoryRegimeEnum (0..1) <"The applicable regulatory regime, as specified through an enumeration.">
    additionalRegime string (0..1) <"The additional regulatory regime as specified by the parties.">
    regimeTerms RegimeTerms (2..2) <"A class that is used by the ApplicableRegime and the AdditionalRegime classes to specify the terms that are specific to each party and regime which are referred to in the Regime Table as part of certain legal agreements, such as the ISDA 2016 and 2018 CSA for Initial Margin.">
    additionalType AdditionalTypeEnum (0..1)
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(b)(B)"]
    additionalTerms string (0..1) <"The bespoke Additional Type for the purposes of Covered Transactions (IM).">

    condition ApplicableRegimeChoice: <"The applicable regime should be specified either as an enumeration or as an additional regime specified by the parties.">
        required choice regime, additionalRegime

type AppropriatedCollateralValuation: <"A class to specify the Valuation of Appropriated Collateral.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(u)" name "Valuation of Appropriated Collateral"]

    isSpecified boolean (1..1) <"The qualification of whether the Valuation of Appropriate Collateral provision is applicable (True) or not applicable (False).">
    election string (0..1) <"The parties' election that qualify the Valuation of Appropriate Collateral in the case where it is deemed applicable.">

    condition Specified: <"The Valuation of Appropriate Collateral election must be specified when it is applicable.">
        if isSpecified = True then election exists

    condition NotSpecified: <"The Valuation of Appropriate Collateral election cannot be specified when it is not applicable.">
        if isSpecified = False then election is absent

type BespokeCalculationDate: <"A class to specify bespoke Calculation Date terms for the purposes of Initial Margin.">

    isApplicable boolean (1..1) <"Additional Calculation Date terms are applicable when True and not applicable when False.">
    calculationDateImTerms string (0..1) <"The Additional Calculation Date terms for the purposes of Initial Margin.">

    condition CalculationDateImTerms: <"A data rule to enforce that Additional Calculation Date Terms should be absent when not applicable.">
        if isApplicable = False then calculationDateImTerms is absent

type BespokeCalculationTime: <"A class to specify additional Calculation Time terms for the purposes of Initial Margin.">

    asCalculationAgent boolean (1..1) <"If set to True, the Calculation Time for Initial Margin is the time as of which the Calculation Agent (IM) computes its end of day valuations of derivatives transactions.">
    bespokeCalculationTimeTerms string (0..1) <"Additional Terms applicable to Calculation Time for Initial Margin.">

    condition AsCalculationAgentIm: <"A data rule to enforce that the terms applicable to Calculation Time for Initial Margin should be specified when the computation time is not as per Calculation Agent.">
        if asCalculationAgent = True
        then bespokeCalculationTimeTerms is absent

    condition BespokeCalculationTimeTerms: <"A data rule to enforce that the Calculation Time for Initial Margin shouldn't be specified when the Control Agreement isn't deemed a Credit Support Document with respect to the party(ies).">
        if asCalculationAgent = False
        then bespokeCalculationTimeTerms exists

type BespokeTransferTiming: <"A class to specify any bespoke Transfer Timing language by each party to the agreement.">

    isApplicable boolean (1..1) <"A boolean flag to specify whether bespoke transfer terms are applicable or not.">
    bespokeTransferTimingTerms string (0..1) <"The bespoke transfer timing terms applicable to the agreement.">

type CalculationAgentTerms: <"A class to specify Calculation Agent for purposes of Initial or Variation Margin agreements.">

    party CounterpartyRoleEnum (0..2) <"The party which is specified as Calculation Agent for Initial Margin.">
    bespokeCalculationAgentTerms string (0..1) <"The Calculation Agent (IM) terms when specified.">

    condition:
        one-of

type CalculationAndTiming: <"A class to specify the Calculation, Valuation and Timing terms specific to the agreement.">

    calculationAgentTerms CalculationAgentTerms (0..1) <"The calculation agent terms applicable to the agreement.">
    bespokeCalculationDate BespokeCalculationDate (0..1) <"The specification of bespoke Calculation Date terms for the purposes of Initial or Variation Margin by the parties to the agreement.">
    bespokeCalculationTime BespokeCalculationTime (0..1) <"Bespoke terms to describe the time as of which such party (or the Calculation Agent (IM) (if applicale)) computes its end of day valuations of derivatives transactions.">
    calculationDateLocation CalculationDateLocation (0..1) <"The specified location where the credit exposure will be calculated by the respective parties.">
    notificationTime NotificationTime (1..1) <"The time by which a demand for the Transfer of Eligible Credit Support (IM) or Posted Credit Support (IM) needs to be made in order for the transfer to take place in accordance with the Transfer Timing provisions.">
    collateralValuationAgent CollateralValuationAgent (0..1) <"The bespoke Collateral Valuation Agent terms applicable to the agreement.">
    cashSettlementDay string (0..1)
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "4" clause "(b)(i)"]
    securitiesSettlementDay string (0..1)
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "12"]
    legacyValuationDate LegacyValuationDate (0..1) <"Details of the days on which calculations are to be made to determine the Delivery Amount and/or Return Amount.">
    legacyValuationTime LegacyValuationTime (0..1) <"The time by which the value of the collateral and obligations to transfer or return collateral are to be calculated relative to the Valuation Date.">
    legacyValuationAgent LegacyValuationAgent (0..1) <"Details of the party calculating the value of collateral to be delivered or returned.">

type CalculationCurrencyElection: <"A class to specify the ISDA SIMM Calculation Currency.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(ee)(3"]
    party CounterpartyRoleEnum (1..1) <"The party which the SIMM Calculation Currency qualification applies to.">
    isBaseCurrency boolean (1..1) <"The SIMM Calculation Currency (also known as SIMM Reporting Currency) means the Base Currency when True. It means a different currency when False. In that latter case, the SIMM Calculation Currency is specified as part of the currency attribute.">
    currency string (0..1) <"The currency in which the ISDA SIMM Calculation is denominated, when different from the Base Currency. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]

    condition BaseCurrency: <"A data rule to enforce that, when the SIMM calculation currency is specified as the Base Currency and vice versa.">
        if isBaseCurrency = True
        then currency is absent
        else currency exists

type CalculationDateLocation: <"A class to specify the Calculation Date Location election for the respective parties to the legal agreement.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(d)(i)" name "Calculation Date Location"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(e)(i)" name "Calculation Date Location"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(d)(i)" name "Calculation Date Location"]
    partyElection CalculationDateLocationElection (2..2) <"The parties' calculation date location election.">

type CalculationDateLocationElection: <"A class to specify each of the party elections with respect to the Calculation Date Location.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(d)(i)" name "Calculation Date Location"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(e)(i)" name "Calculation Date Location"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(d)(i)" name "Calculation Date Location"]
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    businessCenter BusinessCenterEnum (0..1) <"The Calculation Date Location when specified as a business center which corresponds to the FpML list of business centers or can be mapped to it.">
        [metadata scheme]
    customLocation string (0..1) <"The Calculation Date Location when specified a location which doesn't correspond to the FpML list of business centers or cannot be mapped to it.">

    condition Choice: <"The Calculation Date Location is specified either as a standard business center or as a custom location.">
        required choice businessCenter, customLocation

type CollateralAccessBreach: <"A class to specify Collateral Access Breach language.">
    isApplicable boolean (1..1) <"Collateral Access Breach terms are applicable when True and not applicable when False.">
    cabEndDateElection boolean (0..1) <"Determination of whether the Collateral Access Breach end date is a number of days (True) or specified (False).">
    cabEndDate number (0..1) <"The business days following the related Collateral Access Breach when the additional terms end.">
    cabEndDateTerms string (0..1) <"Specific terms for when Collateral Access Breach terms end.">

    condition CabEndDateTerms: <"A condition to require Collateral Access Breach End Date Terms when a specification is required.">
        if cabEndDateElection = True then cabEndDateTerms is absent

type CollateralManagementAgreement: <"A class to specify the Collateral Management Agreement election.">
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(b)(i)" name "Collateral Management Agreement"]
    partyElection CollateralManagementAgreementElection (2..2) <"The parties' Collateral Management Agreement election.">

type CollateralManagementAgreementElection: <"A class to specify the Collateral Management Agreement election.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(b(i)" name "Collateral Management Agreement"]
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    collateralManagementAgreement string (1..1) <"The designated Collateral Management Agreement with respect to the elective party as the Obligee.">

type CollateralRounding: <"A class to specify the rounding methodology applicable to the Delivery Amount and the Return Amount.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(c)(vi)( C )" name "Rounding"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(d)(vi)( C )" name "Rounding"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(c)(vi)( C )" name "Rounding"]
    deliveryAmount number (1..1) <"The nearest integral multiple of Base Currency units to which the Delivery Amount will be rounded in accordance with the specified rounding direction.">
    deliveryDirection RoundingModeEnum (1..1) <"The rounding rule applicable to the Delivery Amount (which can be (i) up to nearest; (ii) down to nearest).">
    returnAmount number (1..1) <"The nearest integral multiple of Base Currency units to which the Return Amount will be rounded in accordance with the specified rounding direction.">
    returnDirection RoundingModeEnum (1..1) <"The rounding rule applicable to the Return Amount (which can be (i) up to nearest; (ii) down to nearest).">
    currency ISOCurrencyCodeEnum (1..1) <"The currency in which the Delivery Amount and Return Amount rounding amounts are specified.">
    other string (0..1) <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

type CollateralValuationAgent: <"A class to specify Collateral Valuation Agent terms.">
    partyElection CollateralValuationAgentElection (0..2) <"The parties Collateral Valuation Agent Elections.">

type CollateralValuationAgentElection: <"A class to specify Collateral Valuation Agent language.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

type ConditionsPrecedent: <"A class to specify the two set of elections that may overwrite the default Condition Precedent provision.">
    [docReference ISDA CSA_IM_2016 paragraph "4" clause "(a)"]
    [docReference ISDA CSA_VM_2016 paragraph "4" clause "(a)"]
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(e)" name " Conditions Precedent"]
    [docReference ISDA CSD_IM_English_2018 paragraph "13 General Principles" clause "(e)" name " Conditions Precedent"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(f)" name " Conditions Precedent"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(e)" name " Conditions Precedent"]
    [docReference ISDA CSA_VM_2016 paragraph "13" clause "(e)" name "Conditions Precedent and Secured Partys Rights and Remedies"]
    conditionsPrecedentElection ExceptionEnum (0..1) <"The election to specify whether the standard Conditions Precedent apply.">
    customProvision string (0..1) <"The custom provisions that might be specified by the parties to the agreement for the purpose of overwriting the default Condition Precedent provision specified in the CSA.">
        [docReference ISDA CSA_IM_2016 paragraph "4" clause "(a)"]
        [docReference ISDA CSA_VM_2016 paragraph "4" clause "(a)"]
        [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(e)(i)"]
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(f)(i)"]
        [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(e)(i)"]
        [docReference ISDA CSA_VM_2016 paragraph "13" name "Conditions Precedent and Secured Partys Rights and Remedies"]
    accessConditions AccessConditions (1..1) <"The parties' election with respect to the Termination Events that will be deemed an Access Condition (Initial Margin CSA) or a Specified Condition (Variation Margin CSA).">
        [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(e)(ii)"]
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(f)(ii)"]
        [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(e)(ii)"]
        [docReference ISDA CSA_VM_2016 paragraph "13" clause "(e)" name "Conditions Precedent and Secured Partys Rights and Remedies."]

    condition CustomProvision: <"When a Custom Provision is specified then the Conditions Precedent Election should be absent.">
        if customProvision exists
        then conditionsPrecedentElection = ExceptionEnum -> Other

type ControlAgreement: <"A class to specify the relationship between the Control Agreement and the Credit Support Agreement.">
    partyElection ControlAgreementElections (2..2) <"The party specific elections.">

type ControlAgreementElections: <"A class to specify the Control Agreement election sby each party to the agreement.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    controlAgreementAsCsd boolean (1..1) <"The identification of whether the Control Agreement is a Credit Support Document with respect to each party.">
    consistencyWithControlAgreement boolean (0..1) <"Unless specified as inapplicable in the event of any inconsistency between this Deed and the Control Agreement, this Deed will prevail over the Control Agreement.">
    relationshipWithControlAgreement boolean (0..1) <"Unless specified as inapplicable the parties recognise that the Control Agreement is a means by which the parties can perform their obligations.">

type ControlAgreementNecEvent: <"A class to specify Control Agreement language related to delivery of a Notice of Exclusive Control.">
    controlAgreementNecEventElection ControlAgreementNecEventElection (2..2) <"Indicates party specific Control Agreement language related to delivery of a Notice of Exclusive Control.">

type ControlAgreementNecEventElection: <"A class to specify party specific Control Agreement language related to delivery of a Notice of Exclusive Control.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    necEvent boolean (1..1) <"Indicates Control Agreement language related to delivery of a Notice of Exclusive Control.">

type CreditSupportObligationsVariationMargin: <"A class to specify the Credit Support Obligations applicable to the Variation Margin Credit Support Annex.">
    [docReference ISDA CSA_VM_2016 paragraph "13" clause "(c) " name "Credit Support Obligations"]
    ineligibleCreditSupport IneligibleCreditSupport (0..1) <"The parties to which the provisions of the Credit Support Annex for Variation Margin will apply to.">
        [docReference ISDA CSA_VM_2016 paragraph "13 " clause "(c)(iii)" name "Legally Ineligible Credit Support (VM"]
    majorCurrency string (0..*) <"The additional currencies that are specified as Major Currency for the purpose of applying the FX Haircut Percentage.">
        [docReference ISDA CSA_VM_2016 paragraph "13" clause "(c)(v)(B)" name "FX Haircut Percentage"]
        [metadata scheme]
    fxHaircut string (0..1) <"The alternative definition for FX haircut percentage that applies to each party and item of Eligible Collateral unless this item is denominated in a Major Currency or in the Base Currency.">
        [docReference ISDA CSA_VM_2016 paragraph "13" clause "(c)(v)(B)" name "FX Haircut Percentage"]

type Custodian: <"A class to specify the custodian and custody account details for each party to the agreement.">
    partyElection CustodianElection (2..2) <"The party specific elections.">

type CustodianElection: <"A class to specify the custodian and custody account details for each party to the agreement.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    custodian LegalEntity (0..1) <"The custody agent. While CreateiQ only specifies the custodian's name, specifying the legal entity as part of the CDM is deemed more appropriate, while this will still provide the ability to accommodate situations where only the entity name is available, as the entityId attribute is optional as part of the LegalEntity class.">
    segregatedCashAccount Account (0..1) <"The identification of the segregated cash account for the purpose of holding cash collateral.">
    segregatedSecurityAccount Account (0..1) <"The identification of the segregated security account for the purpose of holding security collateral.">
    legacyVMCustodian LegacyVMCustodianEnum (0..1) <"Details how the Custodian is determined.">
    legacyNamedEntity LegalEntity (0..1) <"The identity of the relevant custodian where Named Entity is elected.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition NamedEntity: <"The entity should be named if this is specified in the determination.">
        if legacyVMCustodian = LegacyVMCustodianEnum -> NamedEntity
        then legacyNamedEntity exists

    condition AdditionalLanguage: <"If no Custodian determination methodology is defined, additional language must be specified.">
        if legacyVMCustodian is absent then additionalLanguage exists

type CustodianEvent: <"A class to specify the Custodian Event.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(n)(iii)" name " Custodian Event"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(m)(ii)" name "Collateral Manager Event"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(n)(iii)" name "Custodian Event"]

    isApplicable boolean (1..1) <"The qualification as to whether the Custodian Event (English Law & New York Law ISDA CSA) or the Collateral Manager Event (Japanese Law ISDA CSA) is applicable.">
    endDate CustodianEventEndDate (0..1) <"The qualification of the Custodian Event (English Law & New York Law ISDA CSA) or Collateral Manager Event (Japanese Law ISDA CSA) End Date.">

type CustodianEventEndDate: <"A class to specify the Custodian Event.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(n)(iii)" name "CE End Date"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(m)(ii)" name "CME End Date"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(n)(iii)" name "CE End Date"]

    daysAfterCustodianEvent CustomisableOffset (1..1) <"Election to specify the number of days after the occurrence of the Custodian Event/Collateral Management Event for the purpose of qualifying the CE/CME End Date.">
        [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(n)(iii)" name " Custodian Event"]
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(m)(ii)" name "Collateral Manager Event"]
        [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(n)(iii)" name " Custodian Event"]
    releaseDate CustomisableOffset (1..1) <"Election to specify the number of days prior to the termination of the Control Agreement /Collateral Management Event for the purpose of qualifying the CE/CME End Date, in the case where advance notice is given.">
        [docReference ISDA CSD_IM_English_2016]
        [docReference ISDA CSA_IM_Japanese_2016]
        [docReference ISDA CSA_IM_NewYork_2016]
    safekeepingPeriodExpiry CustomisableOffset (0..1) <"The parties' election to specify the number of days prior to the end of the safekeeping period (Clearstream CTA) purpose of qualifying the CE/CME End Date, in the case where advance notice is given.">
    dateOfTimelyStatement CustomisableOffset (1..1) <"The parties' election to specify the number of days one party has effectively provided the Timely Statement to the other party.">

type CustodianRisk: <"A class to specify the Custodian Risk elections specific to a Credit Support Agreement.">

    partyElection CustodianRiskElection (1..2) <"The party specific elections.">

type CustodianRiskElection: <"A class to specify the Custodian Risk.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(n)(ii)" name "Custodian (IM) Risk"]
    [docReference ISDA CSD_IM_English_2018 paragraph "13 General Principles" clause "(n)(ii)" name "Custodian (IM) Risk"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(m)(ii)" name "Collateral Manager Risk"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(n)(ii)" name "Custodian (IM) Risk"]

    party CounterpartyRoleEnum (0..1) <"The elective party.">
    isSpecified boolean (1..1) <"The qualification as to whether the risk is deemed as Specified.">
    qualification string (0..1) <"The Custodian Risk or Collateral Manager Risk qualification.">
        [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(n)(ii)" name "Custodian (IM) Risk"]
        [docReference ISDA CSD_IM_English_2018 paragraph "13 General Principles" clause "(n)(ii)" name "Custodian (IM) Risk"]
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(m)(ii)" name "Collateral Manager Risk"]
        [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(n)(ii)" name "Custodian (IM) Risk"]

    condition Specified: <"The Custodian Risk (English Law and New York Law ISDA CSA) or Collateral Manager Risk (Japanese Law ISDA CSA) should only be qualified if that risk is deemed 'specified'.">
        if isSpecified = False then qualification is absent

type CustodianTerms: <"A class to specify the requirements applicable to the custodian with respect to the holding of posted collateral.">
    [docReference ISDA CSA_VM_2016 paragraph "13" clause " (h)(i)" name "Eligibility to Hold Posted Collateral (VM) Custodians (VM)"]

    minimumAssets Money (0..1) <"The minimal level of assets requirement with respect to the custody agent.">
    minimumRating CreditNotation (0..1) <"The minimal rating requirement with respect to the custody agent.">
    initialDesignation LegalEntity (0..1) <"Election to specify the initial custodian.">
        [docReference ISDA CSA_VM_2016]

type CustodyArrangements: <"A class to specify the Custody Arrangements for the agreement.">

    isCreditSupportDocument boolean (0..1) <"Unless specified as True, the Control Agreement is not a Credit Support Document under the agreement with respect to a party.">
        [docReference ISDA CSA_VM_2016 paragraph "Paragraph 6" clause " (e) " name "The Control Agreement as a Credit Support Document"]
    hasControlAgreementLanguage boolean (0..1) <"Control Agreement language is specified when True.">
    otherProvisions string (0..1) <"Other Custom Provisions of Custody Arrangements.">
        [docReference ISDA CSA_IM_2016 paragraph "3 General Principles" clause "(n)(vii)" name "Other Provisions"]
    collateralAccessBreach CollateralAccessBreach (0..1) <"The elections specific to Collateral Access Breach language.">
    custodianRisk CustodianRisk (0..1) <"The qualification of the Custodian Risk.">
        [docReference ISDA CSA_IM_2016 paragraph "3 General Principles" clause "(n)(ii)" name "Custodian (IM) Risk"]
    controlAgreement ControlAgreement (0..1) <"The party-specific election with respect to the control agreement.">
    custodianEvent CustodianEvent (1..1) <"Specifies if and until when a Custodian Event clause applies.">
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(m)(iii)" name "Custodian Event"]
    custodian Custodian (0..1) <"The custodian and segregated account details for each party to the agreement.">
    collateralManagementAgreement CollateralManagementAgreement (0..1)
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(b)(i)" name "Collateral Management Agreement"]

type DisputeResolution: <"A class to specify the election terms under which a party disputes the Value of any Transfer of Eligible Credit Support or Posted Credit Support.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(g)" name "Dispute Resolution"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(h)" name "Dispute Resolution"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(g)" name "Dispute Resolution"]

    resolutionTime BusinessCenterTime (0..1) <"The time by which the dispute needs to be resolved, failure of which would trigger a recalculation alongside a process that is specified as part of the agreement.">
        [docReference ISDA CSA_IM_2016 paragraph "3 General Principles" clause "(g)(i)" name "Resolution Time"]
        [docReference ISDA CSA_VM_2016 paragraph "13" clause "(g)(i)" name "Resolution Time"]
    otherTerms string (0..1) <"The custom Resolution Time election that might be specified by the parties.">
    valueTerms string (1..1) <"The method of calculation for determining value for the purposes of a Variation Margin agreement.">
    alternativeTerms string (0..1) <"The alternative dispute resolution procedure if specified.">
    recalculationOfValue RecalculationOfValue (0..1) <"The elections to specify terms for recalculation of the market value of posted collateral.">
    legacyResolutionTime BusinessCenterTime (0..1) <"Definition of a point of time un the following LBD to the date of notice in the resolution process at which the recalculation of the disputed amount(s) begins if the consultation process has not resolved the dispute.">
    legacyAlternative LegacyResolutionAlternative (0..1) <"Alternative procedures to those in the pre-print for resolving collateral related disputes.">
    legacyValue LegacyResolutionValue (0..1) <"Methodology for resolving disputes in respect of the determination of the value of collateral.">

type ElectiveAmountElection: <"A class to specify the party elective amounts which can be used for the purpose of specifying elections such as the ISDA CSA Threshold and Minimum Transfer Amount.">

    party CounterpartyRoleEnum (1..1) <"The elective party.">
    electiveAmount ElectiveAmountEnum (0..1) <"Specifies an enumerated election to express the elective amount.">
    amount Money (0..1) <"The elective amount when expressed as a currency amount. The associated PartyElectiveAmount_amount data rule enforces that the currency amount is actually greater than 0.">
    customElection string (0..1) <"The elective amount when expressed as a custom election by the party.">

    condition NonZeroAmount: <"When the elective amount is not zero either a currency amount or a custom election must exist.">
        if electiveAmount is absent
        then amount exists or customElection exists

type EligibilityToHoldCollateral: <"A class to specify the conditions under which a party and its custodian(s) are entitled to hold collateral.">
    [docReference ISDA CSA_VM_2016 paragraph "13" clause " (h)(i)" name "Eligibility to Hold Posted Collateral (VM) Custodians (VM)"]

    partyTerms HoldingPostedCollateralEnum (1..*) <"The condition(s) required by a party from the other party to hold its posted collateral.">
    custodianTerms CustodianTerms (0..1) <"The restrictions that might be required by a party from the other party's custodian agent to hold its posted collateral.">
    eligibleCountry string (0..*) <"The restrictions that might be required by a party from the other party in terms of country(ies) where collateral can be held.">
        [metadata scheme]

type EnforcementEvent: <"A class to specify Enforcement Events specific to Security Agreements.">

    earlyTerminationDate boolean (1..1) <"The early termination election.">
    failureToPay boolean (0..1) <"The failure to pay election.">

type ExecutionLanguage: <"A class to specify execution language terms of a Security Agreement.">

    standardLanguage boolean (1..1) <"A boolean attribute to determine if standard language is applicable or not.">
    numberOfOriginals string (0..1) <"The number of original documents.">
    otherLanguage string (0..1) <"Bespoke execution language to be included when specified.">

    condition NumberOfOriginals: <"A data rule to enforce that the number of original documents should only be specified when standard execution language is used.">
        if standardLanguage = False then numberOfOriginals is absent

    condition OtherLanguage: <"A data rule to enforce that bespoke execution language must be included if non-standard execution language is specified.">
        if standardLanguage = False then otherLanguage exists

type ExecutionLocation: <"A class to specify execution location terms of a Security Agreement.">

    executionLocation ExecutionLocationEnum (1..1) <"The execution location of the agreement.">
    otherLanguage string (0..1) <"Bespoke execution location language to be included when specified.">
    dutyPayer string (0..1) <"The payer of documentary duty.">
    dutyPayerLanguage string (0..1) <"Bespoke terms specific to the payment of documentary duty.">
    dutyPaymentDate date (0..1) <"The date that documentary duty will be paid.">
    dutyPaymentLanguage string (0..1) <"Bespoke terms specific to the date that documentary duty will be paid.">

    condition DutyPayerLanguage: <"A data rule to enforce that Duty Payer Language should only be specified when required.">
        if dutyPayer = "Specify" then dutyPayerLanguage exists

    condition DutyPaymentLanguage: <"A data rule to enforce that Duty Payment Language should be absent when a Duty Payment date is provided.">
        if dutyPaymentDate exists then dutyPaymentLanguage is absent

    condition OtherLanguage: <"A data rule to enforce that bespoke execution language must be included if non-standard execution language is specified.">
        if executionLocation = ExecutionLocationEnum -> OtherLocation
        then otherLanguage exists

type ExecutionTerms: <"A class to specify execution location and language of execution to determine duty to be paid.">

    executionLanguage ExecutionLanguage (1..1) <"The bespoke execution language election.">
    executionLocation ExecutionLocation (1..1) <"The bespoke execution location election.">

type FrenchLawAddendum: <"A class to specify party specific elections when a Collateral Transfer Agreement is governed by French Law.">

    isApplicable boolean (1..1) <"The qualification of whether the French Law Addendum is deemed applicable by the parties (True) or not (False).">
    partyElection FrenchLawAddendumElection (0..2) <"The parties French Law Addendum Elections.">

    condition Applicable: <"A data rule to enforce that the French Law Addendum party elections must be specified when applicable.">
        if isApplicable = True then partyElection count = 2

type FrenchLawAddendumElection: <"A class to specify party specific French Law Addendum language.">

    party CounterpartyRoleEnum (1..1) <"The elective party.">
    isApplicable boolean (1..1) <"The qualification of whether the party elects specific language.">
    addendumLanguage string (0..1) <"The party specific language to be included in the agreement.">

    condition AddendumLanguage: <"A data rule to enforce that the French Law Addendum party language must be specified when applicable.">
        if isApplicable = True
        then addendumLanguage exists
        else if isApplicable = False
        then addendumLanguage is absent

type FxHaircutCurrency: <"A class to specify the reference currency for the purpose of specifying the FX Haircut relating to a posting obligation, as being either the Termination Currency or an FX Designated Currency.">

    isTerminationCurrency boolean (1..1) <"The reference currency for the purpose of specifying the FX Haircut relating to a posting obligation is the Termination Currency when the Boolean value is set to True.">
    fxDesignatedCurrency string (0..1) <"When specified, the reference currency for the purpose of specifying the FX Haircut relating to a posting obligation. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]

    condition TerminationCurrency: <"The FX Designated Currency shouldn't be specified when the reference currency for the purpose of specifying the FX Haircut relating to a posting obligation is specified as the Termination Currency.">
        if isTerminationCurrency = True
        then fxDesignatedCurrency is absent

    condition FxDesignatedCurrency: <"The FX Designated Currency should be specified when the reference currency for the purpose of specifying the FX Haircut relating to a posting obligation is specified as not being the Termination Currency.">
        if isTerminationCurrency = False
        then fxDesignatedCurrency exists

type GeneralSimmElections: <"A class to specify the ISDA SIMM as the Method for all Covered Transactions with respect to all Regimes.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(ee)"]
    simmVersion SimmVersion (0..1) <"The qualification of the ISDA SIMM version that is specified for all Covered Transactions.">
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(ee)(1)"]
    simmCalculationCurrency SimmCalculationCurrency (1..1) <"The SIMM Calculation Currency, as specified for each of the parties to the CSA Initial Margin.">
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(ee)(3)"]

type HoldingAndUsingPostedCollateral: <"A class to specify the elections for the holding and using of posted collateral.">
    [docReference ISDA CSA_VM_2016 paragraph "13" clause " (h)" name "Holding and Using Posted Collateral (VM)"]

    partyElection HoldingAndUsingPostedCollateralElection (2..2) <"The parties' elections for the holding and using of posted collateral.">

type HoldingAndUsingPostedCollateralElection: <"A class to specify the parties' elections related to the holding and using of posted collateral.">
    [docReference ISDA CSA_VM_2016 paragraph "13" clause " (h)" name "Holding and Using Posted Collateral (VM)"]

    party CounterpartyRoleEnum (1..1) <"The elective party.">
    eligibilityToHoldCollateral EligibilityToHoldCollateral (1..1) <"The specification of the conditions under which a party and its custodian(s) are entitled to hold posted collateral.">
    useOfPostedCollateral boolean (1..1) <"Specifies whether the party to the agreement has the right to rehypothecate the collateral held (True).">
        [docReference ISDA CSA_VM_2016 paragraph "13" clause "(h)(ii)" name "Use of Posted Collateral (VM)"]

type IneligibleCreditSupport: <"A class to specify the parties to which the provisions of the Credit Support Annex for Variation Margin will apply to.">
    [docReference ISDA CSA_VM_2016 paragraph "13" clause "(c)(iii)" name "Legally Ineligible Credit Support (VM)"]

    totalIneligibilityDate string (0..1) <"Total Ineligibility Date has the meaning specified in Paragraph 11(g), unless otherwise specified here.">
    transferIneligibilityDate string (0..1) <"Transfer Ineligibility Date has the meaning specified in Paragraph 11(g), unless otherwise specified here.">
    specifiedParty Party (0..2) <"The parties to which the provisions of the CSA will apply to, as the Secured Party.">
        [docReference ISDA CSA_VM_2016 paragraph "13" clause "(c)(iii)" name "Legally Ineligible Credit Support (VM)"]
        [metadata reference]

type InterestAdjustment: <"A class to specify whether the Interest Adjustment is applicable and what its periodicity is.">
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(n)(ii)"]

    isApplicable boolean (1..1) <"The Interest Adjustment is applicable when True and not applicable when False.">
    periodicity InterestAdjustmentPeriodicity (1..1) <"The qualification of the Interest Adjustment periodicity.">

type InterestAdjustmentPeriodicity: <"A class to specify the Interest Adjustment periodicity.">
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(n)(ii)"]

    standardElection InterestAdjustmentPeriodicityEnum (0..1) <"The Interest Adjustment periodicity when specified through a standardized election.">
    customElection string (0..1) <"The Interest Adjustment periodicity when specified through a custom election.">

    condition:
        one-of

type InterestAmount: <"A class to specify the application of Interest Amount with respect to the Delivery Amount and the Return Amount.">
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(n)(ii)"]

    returnAmount ReturnAmount (1..1) <"The application of Interest Amount with respect the Return Amount.">
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(n)(ii)"]
    deliveryAmount DeliveryAmount (1..1) <"The application of Interest Amount with respect the Delivery Amount.">
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(n)(ii)"]

type JapaneseSecuritiesProvisions: <"A class to specify Japanese Securities Provision elections.">
    isApplicable boolean (1..1) <"Japanese Securities Provisions are applicable when True and Not Applicable when False.">
    relevantProvisionsElection boolean (0..1) <"Recommended Japanese Securities Provisions are applicable when True, additional Provisions are specified when False.">
    relevantProvisionsTerms string (0..1) <"Specific terms applicable to Recommended Japanese Securities Provisions.">
    amendmentsToJapaneseProvisions boolean (0..1) <"Additional Amendments to Japanese Securities Provisions are specified when True, and not specified when False.">
    amendmentsToJapaneseProvisionsTerms string (0..1) <"Specific terms applicable to Additional Amendments to Japanese Securities Provisions.">
    clearstreamAmendmentToJapaneseProvisions boolean (0..1) <"Specification of whether Clearstream Event amendment language is included (true) or excluded (false).">

    condition RelevantProvisionsElection: <"A data rule to enforce that the specific terms applicable to Recommended Japanese Securities Provisions should be specified when required.">
        if relevantProvisionsElection = True
        then relevantProvisionsTerms is absent

    condition AmendmentsToJapaneseProvisions: <"A data rule to enforce that the specific terms applicable to Additional Amendments to Japanese Securities Provisions should be specified when required.">
        if amendmentsToJapaneseProvisions = False
        then amendmentsToJapaneseProvisionsTerms is absent

type JurisdictionRelatedTerms: <"A class to specify terms jurisdiction related terms.">
    japaneseSecuritiesProvisions JapaneseSecuritiesProvisions (0..1) <"The Japanese Securities Provisions election.">
    exclusiveJurisdiction boolean (0..1) <"Classification of optional exclusive jurisdiction terms.">
    juryWaiver boolean (0..1) <"The Jury Waiver conditions specific to the agreement.">
    frenchLawAddendum FrenchLawAddendum (0..1) <"The French Law Addendum Provisions specific to the agreement.">
    belgianLawSecurityAgreement boolean (0..1) <"The qualification of whether the Belgian Law Security Agreement Addendum is deemed applicable by the parties (True) or not (False).">

type MarginApproach: <"A class for selection of Margin Approach.">
    marginApproach MarginApproachEnum (1..1) <"Specifies the margin approach specific to Initial Margin agreements.">

type MinimumTransferAmount: <"A class to specify amount of exposure reached before collateral has to be posted or returned.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(c)(vi)(B)" name "Minimum Transfer Amount"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(d)(vi)(B)" name "Minimum Transfer Amount"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(c)(vi)(B)" name "Minimum Transfer Amount"]

    partyElection ElectiveAmountElection (2..2) <"The parties' minimum transfer amount elections.">

type MinimumTransferAmountAmendment: <" A class to specify whether Amendment to Minimum Transfer Amount language is applicable or not.">
    isApplicable boolean (1..1) <"The definition of Minimum Transfer Amount in any Other Regulatory CSA will be amended when applicable.">
    effectiveDate AmendmentEffectiveDate (0..1) <"The effective date of the Amendment to Termination Currency.">
    partyElections ElectiveAmountElection (0..2) <"The party elective amounts.">

    condition AmendmentNotApplicable: <"A data rule to enforce that the Effective Date and Party Elections should be absent when the Minimum Transfer Amount Amendment is stated as not specified for the agreement.">
        if isApplicable = False
        then effectiveDate is absent and partyElections is absent

type NotificationTime: <"A class to specify the time by which a demand for the Transfer of Eligible Credit Support (IM) or Posted Credit Support (IM) needs to be made in order for the transfer to take place in accordance with the Transfer Timing provisions.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(d)(iii)" name "Notification Time"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(e)(iii)" name "Notification Time"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(d)(iii)" name "Notification Time"]

    partyElections NotificationTimeElection (2..2) <"The parties' Notification Time election.">
    disputeNotificationReference boolean (0..1) <"The determination of whether reference is made to dispute resolution notification timing in the agreement.">
    transferTimingProviso boolean (0..1) <"The determination of whether transfer timing language is applicable or not.">

type NotificationTimeElection: <"A class to specify the notification time election by the respective parties to the agreement.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(d)(iii)" name "Notification Time"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(e)(iii)" name "Notification Time"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(d)(iii)" name "Notification Time"]

    party CounterpartyRoleEnum (1..1) <"The elective party.">
    notificationTime BusinessCenterTime (0..1) <"The Notification Time as a time that is qualified as a standard business center.">
    customNotification string (0..1) <"The Notification Time as a bespoke election.">
    localBusinessDay boolean (0..1) <"Whether the Notification Time is precluded on the day being a local business day.">

    condition NotificationTimeElectionChoice: <"The Notification Time is specified either as a time that is qualified by a standard business center or as a custom election.">
        required choice notificationTime, customNotification

type OneWayProvisions: <"A class to specify whether One Way Provisions apply.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(aa)" name "One Way Provisions"]

    isApplicable boolean (1..1) <"The determination of whether the One Way Provisions are applicable (true) or not applicable (false).">
    postingParty CounterpartyRoleEnum (0..1) <"The Posting Party for the purposes of One Way Provisions. It is specified in the case where the One Way Provision is deemed applicable.">

    condition PostingPartyExists: <"A data rule to enforce that the Posting Party must be specified in the case where the One Way Provision is deemed applicable.">
        if isApplicable = True then postingParty exists

    condition PostingPartyAbsent: <"A data rule to enforce that the Posting Party must not be specified in the case where the One Way Provision is not deemed applicable.">
        if isApplicable = False then postingParty is absent

type OtherAgreements: <"The bespoke definition of other agreement terms as specified by the parties to the agreement.">
    otherCsa OtherAgreementTerms (0..1) <"The bespoke definition of Other CSA as specified by the parties to the agreement.">
    japaneseLawCsa OtherAgreementTerms (0..1) <"The bespoke definition of whether Japanese Law CSA (VM) are specified by the parties to the agreement.">
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(s)(ii)" name "Japanese Law CSA (VM)"]

type OtherEligibleAndPostedSupport: <"A class to specify the Other Eligible Support elections associated Initial and Variation margin agreements.">
    applicableValue boolean (1..1) <"The definition of 'Value' with respect to Other Eligible Support (IM) and Other Posted Support (IM).">
    applicableTransfer boolean (0..1) <"The definition of 'Transfer' with respect to Other Eligible Support (IM) and Other Posted Support (IM).">

type PartyAgreementIdentifier: <"A class defining a legal agreement identifier issued by the indicated party.">
    [metadata key]
    partyReference Party (1..1) <"Party that issued the document identifier.">
        [metadata reference]
    documentIdentifier Identifier (1..*) <"While FpML specifies the document identifier with a value and an associated scheme, the CDM makes use of the Identifier, which has an explicit issuer. The issuer of this identifier is not necessarily the same as the party reference.">
        [metadata scheme]

type PostingObligations: <"A class to specify the collateral posting obligations of the security provider or security providers as specified in the corresponding agreement.">
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(ii)" name ""]
    securityProvider string (1..1) <"The security provider party(ies) to which the posting obligations apply to, which can be either one of the parties to the legal agreement, or both of those.">
    partyElection PostingObligationsElection (1..2) <"The specification of the collateral posting obligations for the security provider party(ies).">
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(ii)"]

type PostingObligationsElection: <"A class to specify the collateral posting obligations for the security provider party(ies).">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(ii)"]

    party CounterpartyRoleEnum (1..1) <"The elective party.">
    asPermitted boolean (1..1) <"If set to True, the Control Agreement is a Credit Support Document with respect to the party(ies).">
        [docReference ISDA CSA_IM_2016 paragraph "6" clause "(e)"]
    eligibleCollateral EligibleCollateralCriteria (0..*) <"The eligible collateral as specified in relation to the pledgor/chargor/obligor(s) posting obligation.">
        [docReference ISDA CSA_IM_2016 name "Eligible Credit Support (IM) Schedule"]
    excludedCollateral string (0..1) <"The excluded collateral as specified in relation to the pledgor/chargor/obligor(s) posting obligation.">
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(ii)(B)(i)"]
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition AsPermitted: <"A data rule to enforce that the eligible collateral should be specified when the Control Agreement is a Credit Support Document with respect to the party(ies).">
        if asPermitted = True then eligibleCollateral is absent

    condition EligibleCollateral: <"A data rule to enforce that the eligible collateral shouldn't be specified when the Control Agreement isn't deemed a Credit Support Document with respect to the party(ies).">
        if asPermitted = False then eligibleCollateral exists

    condition ConsistentParty: <"A data rule to ensure that the elective party is only set on the agreement and not in the eligible collateral criteria.">
        if eligibleCollateral exists
        then eligibleCollateral -> appliesTo count = 0

type ProcessAgent: <"A class to specify the Process Agent that might be appointed by the parties as part of a Credit Support Annex/Deed or Collateral Transfer Agreement.">
    partyElection ProcessAgentElection (2..2) <"The parties' Process Agent election.">

type ProcessAgentElection: <"A class to specify the parties' respective elections with respect to the Process Agent.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    isApplicable boolean (1..1) <"The qualification of whether the Process Agent is applicable (True) or not applicable (False).">
    processAgent PartyContactInformation (0..1) <"The Process Agent specification, when applicable.">

    condition Applicable: <"A data rule to enforce that the Process Agent must be specified when it is applicable.">
        if isApplicable = True then processAgent exists

    condition NotApplicable: <"A data rule to enforce that the Process Agent cannot be specified if deemed not applicable.">
        if isApplicable = False then processAgent is absent

type RecalculationOfValue: <"A class to specify terms for Recalculation of the Market Value of Posted Collateral when a dispute has been failed to be resolved by Resolution Time.">

    partyElection RecalculationOfValueElection (2..2) <"The parties' Recalculation of Value terms.">

type RecalculationOfValueElection: <"A class to specify Recalculation of Value terms that will be applicable.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    recalculationOfValueElection RecalculationOfValueElectionEnum (1..1) <"The procedure for Recalculation of Value.">
    recalculationOfValueTerms string (0..1) <"Additional Recalculation of Value terms when specified.">

type Regime: <"A class to specify one or more regimes that may be specified as relevant to a legal agreement.">
    [docReference ISDA CSA_IM_2016 name "Regime"]
    [docReference ISDA CSA_IM_2018 name "Regime"]

    applicableRegime ApplicableRegime (1..*) <"A class to specify the regime(s) that parties to a legal agreement, such as the ISDA 2016 and 2018 CSA for Initial Margin, might agree to apply to one or both parties when acting as collateral taker, and specific terms associated with that application.">
    fallbackToMandatoryMethodDays number (0..1) <"The specification of the number of days after effective delivery of notice that Mandatory method fallback applies. Specification is only required when one or more Regimes have Fall Back to Mandatory Method elected as a SIMM exception.">

type RegimeTerms: <"A class that is used by the ApplicableRegime and the AdditionalRegime classes to specify the regulatory regime terms.">
    [docReference ISDA CSA_IM_2016 name "Regime"]
    [docReference ISDA CSA_IM_2018 name "Regime"]

    party CounterpartyRoleEnum (1..1) <"The party for which the regime terms are being specified when acting as collateral taker.">
    isApplicable ExceptionEnum (0..1) <"The specification of whether the regime is elected as applicable to the party when acting as collateral taker.">
    asSpecified string (0..1) <"The bespoke party specific Regime term elections applicable when specified.">
    simmException SimmException (0..1) <"The election for SIMM exception to the regulatory regime clause.">
        [docReference ISDA CSA_IM_2016 paragraph "13"]
    retrospectiveEffect RetrospectiveEffect (0..1) <"Specifies the retrospective effect exception to the regulatory regime clause of Initial Margin documents as either a normalized value specified as part of an enumeration or a customized value specified of type string.">
        [docReference ISDA CSA_IM_2016 paragraph "13" clause "(b)(i)"]

type PledgeeRepresentativeRider: <"The terms of the Rider for the ISDA Euroclear 2019 Collateral Transfer Agreement with respect to the use of a Pledgee Representative attached to this Agreement.">
    isApplicable boolean (1..1) <"Identification of whether the representative CTA provisions are applicable (True) or not applicable (False).">
    party CounterpartyRoleEnum (0..1) <"Identification of the represented party.">
    representativeTerms string (0..1) <"The specific representative terms applicable when specified.">
    representativeEvent ExceptionEnum (0..1) <"The specification of whether the representative event terms are applicable.">
    representativeEventTerms string (0..1) <"The specific representative event terms applicable when specified.">
    representativeEndDate CustomisableOffset (0..1) <"The definition of representative end date in relation to a representative event.">

    condition RepresentativeParty: <"A data rule to enforce that representative terms and a represented party are specified when representative provisions are applicable.">
        if isApplicable = True
        then party exists
                and representativeTerms exists
                and representativeEvent exists
                and representativeEndDate exists

    condition RepresentativeEventTerms: <"A data rule to enforce that representative event terms are specified when applicable.">
        if representativeEvent = ExceptionEnum -> Other
        then representativeEventTerms exists

type RetrospectiveEffect: <"A class to specify the retrospective effect exception to the regulatory regime clause of Initial Margin documents as either a normalized value specified as part of an enumeration or a customized value specified of type string.">

    standardisedException ExceptionEnum (0..1) <"The Standard Initial Margin Model exception when specified by the party according to one of the enumerated values.">
    asSpecified string (0..1) <"The Standard Initial Margin Model exception when specified as a customized approach by the party.">

type RightsEvents: <"A class to specify the rights of Security Taker and/or Security Provider when an Early Termination or Access Condition event has occurred.">

    securityTakerRightsEvent SecuredPartyRightsEvent (1..1) <"The bespoke provisions that might be specified by the parties to the agreement applicable to a Security Taker Rights Event.">
    controlAgreementNecEvent ControlAgreementNecEvent (0..1) <"The bespoke provisions that might be specified by the parties to the agreement applicable to a Notice of Exclusive Control Event.">
    securityProviderRightsEvent SecurityProviderRightsEvent (1..1) <"The bespoke provisions that might be specified by the parties to the agreement applicable to a Security Provider Rights Event.">
    deliveryInLieuRight boolean (0..1) <"The specification of whether Delivery In Lieu language is applicable to the agreement (true) or not (false).">
    additionalRightsEvent AdditionalRightsEvent (0..1) <"The Additional Rights Event election.">

type SecuredPartyRightsEvent: <"A class to specify Secured Party Rights Event language.">

    securedPartyRightsEventElection SecuredPartyRightsEventElection (0..2)
    earlyTerminationDateOptionalLanguage boolean (1..1) <"A boolean attribute to specify whether Failure to Pay Early Termination language is included (True) or excluded (False) from the agreement.">
    failureToPayEarlyTermination boolean (0..1) <"A boolean attribute to specify whether Failure to Pay Early Termination language in the agreement is deemed applicable or not.">

    condition FailureToPayLanguage: <"A data rule to enforce that the applicability of Failure to Pay language is only applied when Early Termination language is included.">
        if earlyTerminationDateOptionalLanguage = False
        then failureToPayEarlyTermination is absent

type SecuredPartyRightsEventElection: <"A class to specify party specific Secured Party Rights Event language.">

    party CounterpartyRoleEnum (1..1) <"The elective party.">
    rightsEvent boolean (1..1) <"A boolean attribute to specify whether a Secured Party Rights Event will only occur upon the occurrence of one or more of the event specified in a Control Agreement.">

type SecurityProviderRightsEvent: <"A class to specify the Pledgor/Obligor/Chargor Rights Event election.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(j)" name "Chargor Rights Event"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(j)" name "Obligor Rights Event"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(j)" name "Pledgor Rights Event."]

    partyElection SecurityProviderRightsEventElection (0..2)
    includeCoolingOffLanguage boolean (1..1) <"The Pledgor/Obligor/Chargor Rights Event election includes cooling off language when the attribute is set of True.">
    fullDischarge boolean (0..1) <"If specified as applicable here, a Pledgor/Obligor/Chargor Rights Event will not occur unless the Pledgor/Obligor/Chargor (A) has provided a statement to the Secured Party in respect of such Early Termination Date.">
    automaticSetOff boolean (0..1) <"The Automatic Set-Off provision applies when the value is set to True.">
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(l)" name "Modification to Obligors Rights and Remedies"]
    customElection string (0..1) <"A custom Pledgor/Obligor/Chargor Rights Event election might be specified by the parties.">

    condition RightsEvent_includeCoolingOffLanguage: <"A data rule to enforce that, when the Rights Event election includes cooling off language, no custom election should be specified.">
        if includeCoolingOffLanguage = True
        then customElection is absent

    condition RightsEvent_customElection: <"A data rule to enforce that, when the Rights Event is specified through a custom election, no standard cooling off language should be specified.">
        if customElection exists
        then includeCoolingOffLanguage = False

type SecurityProviderRightsEventElection: <"A class to specify party specific Secured Party Rights Event language.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    rightsEvent boolean (1..1) <"If True, the Rights Event language applies for the specified Party.">

type SensitivityMethodologies: <"A class to specificy methodologies to compute sensitivities specific to the agreement.">

    sensitivityToEquity SensitivityMethodology (1..1) <"The methodology to compute sensitivities to equity indices, funds and ETFs for the purpose of Initial Margin agreements.">
    sensitivityToCommodity SensitivityMethodology (1..1) <"The methodology to compute sensitivities to commodity indices for the purpose of Initial Margin agreements.">

type SensitivityMethodology: <"A class to specify the methodology according to which sensitivities are computed.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(gg)(2)"]

    specifiedMethodology SensitivitiesEnum (0..1) <"The methodology according to which sensitivities will be computed, when specified through a normalized election.">
    customMethodology string (0..1) <"The methodology according to which sensitivities will be computed, when specified through a custom election.">
    condition:
        one-of

type SimmCalculationCurrency: <"A class to specify the SIMM Calculation Currency elections by each party to the agreement.">

    partyElection CalculationCurrencyElection (2..2) <"The parties' SIMM Calculation Currency election.">

type SimmException: <"A class to specify the SIMM exception to the regulatory regime clause.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" name "Regime: SIMM Exception."]

    standardisedException ExceptionEnum (0..1) <"The Standard Initial Margin Model exception when specified by the party according to one of the enumerated values.">
    simmExceptionApplicable SimmExceptionApplicableEnum (0..1) <"The Standard Initial Margin model exception approach applicable when specified by the party according to one of the enumerated values.">
    asSpecified string (0..1) <"The Standard Initial Margin Model exception when specified as a customized approach by the party.">

type SimmVersion: <"A class to specify the ISDA SIMM version that applies to the ISDA 2018 CSA for Initial Margin.">
    [docReference ISDA CSA_IM_2018 paragraph "13 General Principles" clause "(ee)(1)"]

    isSpecified boolean (0..1) <"A boolean attribute to determine whether the SIMM version is specified for the purpose of the legal agreement.">
    partyVersion CounterpartyRoleEnum (0..1) <"The party which the specified SIMM version applies to.">
    asSpecified string (0..1) <"The SIMM version exception when specified as a customized approach by the party.">

    condition VersionNotSpecified: <"A data rule to enforce that the version attribute should be absent when the SIMM version is stated as not specified for the CSA.">
        if isSpecified = False then partyVersion is absent

    condition VersionSpecified: <"A data rule to enforce that the version attribute should be specified when the SIMM version is stated as specified for the CSA.">
        if isSpecified = True then partyVersion exists

type SubstitutedRegime: <"A class to specify each party's election with respect to the Substituted Regimes that will be applicable...">

    regime RegulatoryRegimeEnum (0..1) <"The applicable regulatory regime, as specified through an enumeration.">
    additionalRegime string (0..1) <"The additional regulatory regime as specified by the parties.">
    regimeTerms SubstitutedRegimeTerms (2..2) <"Specifies the applicability of the Substituted Regime as denoted in the Substituted Regime Table as part of certain legal agreements, such as the ISDA 2016 and 2018 CSA for Initial Margin.">

    condition SubstitutedRegimeChoice: <"The applicable regime should be specified either as an enumeration or as an additional regime specified by the parties.">
        required choice regime, additionalRegime

type SubstitutedRegimeTerms: <"Specifies the applicability of the Substituted Regime as denoted in the Substituted Regime Table as part of certain legal agreements, such as such as the ISDA 2016 and 2018 CSA for Initial Margin.">

    party CounterpartyRoleEnum (1..1) <"The party for which the regime terms are being specified when acting as collateral taker.">
    isApplicable boolean (1..1) <"The specification of whether the regime is elected as applicable to the party when acting as collateral taker.">

type Substitution: <"A class to specify the conditions under which the Security Provider can substitute posted collateral. The details required for 'Legacy' agreements are substantially different to those required for newer agreements; where the agreement is a 1994 or 1995 CSA, or 1995 CSD, the legacyConsent attribute needs to be used which contains additional values beyond a simple true/false value.">
    needsConsent boolean (1..1) <"The election as to whether the Pledgor/Obligor/Chargor must obtain the Secured Partys consent for any collateral substitution.">
        [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(f)(ii)" name "Consent"]
        [docReference ISDA CSA_VM_2016 paragraph "13" clause "(f)(ii)" name "Consent"]
    substitutionDateLanguage string (0..1) <"Substitution Date has the meaning specified in Paragraph4(d)(ii), unless otherwise specified.">
    specificConsentLanguage string (0..1) <"Specific consent language might be specified by the parties.">
    legacyConsent LegacyConsentEnum (0..1) <"The process for substituting/exchanging one form of collateral held by a party for a different form of collateral, used with legacy agreements.">

type TerminationCurrencyAmendment: <"A class to specify the Amendment to Termination Currency elections by the parties to the agreement.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(t)" name "Amendment to Termination Currency."]

    isApplicable boolean (1..1) <"The qualification of whether the Amendment to Termination Currency is deemed applicable by the parties (True) or not (False).">
    effectiveDate AmendmentEffectiveDate (0..1) <"The effective date of the Amendment to Termination Currency. This date can be specified as either an actual date, a specific date (e.g. the annex date) or as a custom provision.">
    partyElection TerminationCurrencyElection (0..3) <"The parties' Amendment Currency election.">

    condition Applicability: <"The Amendment to Termination Currency elections only apply when the Amendment to Termination Currency is deemed applicable by the parties.">
        if isApplicable = False
        then effectiveDate is absent and partyElection is absent

type TerminationCurrencyElection: <"A class to specify the Amendment to Termination Currency election by the parties to the agreement.">
    [docReference ISDA CSA_IM_2016 paragraph "13 General Principles" clause "(t)(A) & (B)"]

    party CounterpartyRoleEnum (1..2) <"The elective party.">
    isSpecified boolean (1..1) <"The qualification of whether the Termination Currency is specified in this document (True) or in an Eligible Support Credit Support (IM) Schedule (False).">
    currency string (0..1) <"The Termination Currency associated with the party that referenced as part of this class. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]

    condition CurrencyElection: <"A Termination Currency election should only exist when required by the affected parties election.">
        if isSpecified = False then currency is absent

type Threshold: <"A class to specify the unsecured credit exposure that each party to the agreement is prepared to accept before asking for collateral.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(c)(vi)(A)" name "Threshold"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(d)(vi)(A)" name "Threshold"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(c)(vi)(A)" name "Threshold"]

    partyElection ElectiveAmountElection (2..2) <"The parties' Threshold election.">

type AdditionalObligations: <"The election of party specific additional obligations applicable to the agreement.">
    party CounterpartyRoleEnum (1..1) <"The party that the additional obligations apply to.">
    additionalObligations string (1..1) <"The party specific additional obligations applicable to the agreement.">

type BaseAndEligibleCurrency: <"The base and eligible currency(ies) for the document as specified by the parties to the agreement.">
    baseCurrency ISOCurrencyCodeEnum (1..1) <"The common agreed currency into which relevant amounts of all collateral arrangements between the parties are converted, or if not an actual currency, the process through which this is determined. Where hardcoded (e.g. under the 1994 ISDA Credit Support Annex (Security Interest  NY Law)), the currency that effectively performs this function.">
    baseCurrencyTerminationCurrency boolean (1..1) <"A flag detailing whether the Base Currency is set to  the Termination Currency as defined in the related  Master Agreement.">
    baseCurrencyOther string (0..1) <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">
        [metadata scheme]
    eligibleCurrency ISOCurrencyCodeEnum (0..*) <"A definition of a currency agreed by the parties, typically to indicate the currencies of eligible cash collateral.">
    eligibleCurrencyInclBaseCurrency boolean (1..1) <"A flag detailing whether the Base Currency is included as an Eligible Currency.">
    eligibleCurrencyOther string (0..1) <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">
        [metadata scheme]

type CoveredTransactions: <"Specification of Transactions covered by the legal agreement.">
    inclusionDate date (1..1) <"Includes any Transaction specified below that is entered into on or after the specified date.">
    coveredTransactions ProductTaxonomy (1..*) <"Covered Transactions when expressed using the ISDA taxonomy.">
    bespokeCoveredTransactions string (1..*) <"Covered Transactions when not expressed using the ISDA taxonomy.">
    additionalObligations AdditionalObligations (0..2) <"The party specific additional obligations applicable to the document.">
    exposure string (0..1) <"The bespoke definition of exposure for Covered Transactions as part of the agreement.">
    legacyExposure ExposureScope (0..2) <"Specification of amendments to the calculation of Exposure in terms of the Transactions covered.">

type CreditSupportObligations: <"A class to specify the Credit Support Obligations applicable to the Initial Margin Credit Support Annex.">
    [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(c)" name "Credit Support Obligations"]
    [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(d)" name "Credit Support Obligations"]
    [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(c) " name "Credit Support Obligations"]

    deliveryAmount string (0..1) <"Delivery Amount (VM) has the meaning specified in Paragraph 3(a), unless otherwise specified here.">
    returnAmount string (0..1) <"Return Amount (VM) has the meaning specified in Paragraph 3(a), unless otherwise specified here.">
    marginApproach MarginApproach (0..1) <"The selection of Margin Approach applicable to the agreement.">
    otherEligibleSupport string (0..1) <"The Other Eligible Support election. If not specified, this election is deemed as not applicable.">
    threshold Threshold (1..1) <"The amount of net exposure that a party is willing to bear in relation to the other party before it requires asking for collateral.">
        [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(c )(vi)(A)" name "Threshold"]
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(d)(vi)(A)" name "Threshold"]
        [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(c )(vi)(A)" name "Threshold"]
    minimumTransferAmount MinimumTransferAmount (1..1) <"The net amount of exposure reached before collateral has to be posted or returned.">
        [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(c )(vi)(B)" name "Minimum Transfer Amount"]
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(d)(vi)(B)" name "Minimum Transfer Amount"]
        [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(c )(vi)(B)" name "Minimum Transfer Amount"]
    rounding CollateralRounding (0..1) <"The rounding methodology applicable to the Delivery Amount and the Return Amount in terms of nearest integral multiple of Base Currency units.">
        [docReference ISDA CSD_IM_English_2016 paragraph "13 General Principles" clause "(c)(vi)( C )" name "Rounding"]
        [docReference ISDA CSA_IM_Japanese_2016 paragraph "13 General Principles" clause "(d)(vi)( C )" name "Rounding"]
        [docReference ISDA CSA_IM_NewYork_2016 paragraph "13 General Principles" clause "(c)(vi)( C )" name "Rounding"]
    bespokeTransferTiming BespokeTransferTiming (0..1) <"The time by which the transfer of collateral must take place when different from the Regular Settlement Day as a result of parties' election.">
    creditSupportObligationsVariationMargin CreditSupportObligationsVariationMargin (0..1) <"The specification of Credit Support Obligations applicable to Variation Margin agreements.">
    legacyThreshold CSAThreshold (0..2)
        [docReference ISDA CSA_NewYork_1994]
        [docReference ISDA CSA_English_1995]
        [docReference ISDA CSD_English_1995]
        [docReference ISDA CSA_VM_English_2016]
        [docReference ISDA CSA_VM_NewYork_2016]
    legacyMinimumTransferAmount CSAMinimumTransferAmount (0..2)
        [docReference ISDA CSA_NewYork_1994]
        [docReference ISDA CSA_English_1995]
        [docReference ISDA CSD_English_1995]
        [docReference ISDA CSA_VM_English_2016]
        [docReference ISDA CSA_VM_NewYork_2016]
    legacyDeliveryAmount LegacyDeliveryAmount (1..1) <"In respect of a Valuation Date, the amount of collateral which a party is entitled to demand to be transferred to it as a Delivery Amount.">
    legacyReturnAmount LegacyReturnAmount (1..1) <"In respect of a Valuation Date, the amount of collateral which a party is entitled to demand to be recalled to it as a Return Amount.">
    creditSupportAmount CreditSupportAmount (1..1) <"The total amount one counterparty must deliver to the other at any time: the combination of the Exposure to that party and the net Independent Amounts it must post, minus any agreed Threshold.">
    collateralTransferTiming CollateralTransferTiming (0..1) <"Specification of transfer / settlement timing for cash and securities collateral assuming that the notice is provided before the Notification Time (and with a 1LBD lag introduced if the notice is delivered after the Notification Time), and that securities allow for a further Local Business Day for transfer / settlement.">

type SecurityInterestForObligations: <"Security Interest for Obligations clause applicable to 1994 NY CSA, 1995 English Law CSA, 1995 English Law Credit Support Deed, 2016 English Law VM CSA and 2016 New York Law VM CSA.">
    [docReference ISDA CSA_NewYork_1994 name "Security Interest for Obligations"]
        [docReference ISDA CSA_English_1995 name "Security Interest for Obligations"]
        [docReference ISDA CSD_English_1995 name "Security Interest for Obligations"]
        [docReference ISDA CSA_VM_English_2016 name "Security Interest for Obligations"]
        [docReference ISDA CSA_VM_NewYork_2016 name "Security Interest for Obligations"]

    party CounterpartyRoleEnum (2..2) <"The elective party to which the Security Interest for Obligations is applicable.">
    obligations SecurityInterestObligationsEnum (1..1) <"A description of any additional obligations secured by the credit support arrangements.">
    obligee SecurityInterestObligeeEnum (1..1) <"The party to whom obligations under the Master Agreement are owed and secured by the credit support arrangements.">
    other string (0..1) <"Exception value.">

type SinglePostingParty: <"Where only a single  party is explicitly designated to post collateral, the party which is specified as the sole poster of collateral.">
    party CounterpartyRoleEnum (0..1) <"The party acting as the Single Posting Party.">
    other string (0..1) <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

type CSAThreshold: 
    [docReference ISDA CSA_NewYork_1994 name "Threshold"]
        [docReference ISDA CSA_English_1995 name "Threshold"]
        [docReference ISDA CSD_English_1995 name "Threshold"]
        [docReference ISDA CSA_VM_English_2016 name "Threshold"]
        [docReference ISDA CSA_VM_NewYork_2016 name "Threshold"]
    thresholdType ThresholdType (1..1) <"Details whether the threshold is rating based, a fixed amount, or infinity.">

type ThresholdType: <"Details whether the threshold is rating based, a fixed amount, or infinity.">
    fixedAmount ThresholdFixedAmount (0..1) <"Defines that the Threshold is a Fixed Amount.">
    ratingsBased ThresholdRatingsBased (0..1) <"Defines that the Threshold is based on a Ratings condition(s).">
    infinity Infinity (0..1) <"Defines that the Threshold is Infinity.">
    other string (0..1) <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

type ThresholdFixedAmount: <"Defines that the Threshold is based on a Fixed Amount.">
    party CounterpartyRoleEnum (1..1) <"The party to which the threshold applies.">
    amount int (1..1) <"The amount value applicable to the Threshold.">
    currency ISOCurrencyCodeEnum (1..1) <"The Threshold currency code.">
    amountIsInfinity boolean (0..1) <"Flag detailing whether the collateral Threshold Amount is set to infinity for a particular party.">

type ThresholdRatingsBased: <"Defines that the Threshold is based on Ratings condition(s).">
    party CounterpartyRoleEnum (1..1) <"The party to which the threshold applies.">
    currency ISOCurrencyCodeEnum (1..1) <"The threshold currency code.">
    ratingType RatingTypeEnum (1..1) <"The relevant rating type.">
    variableSet CSAThresholdVariableSet (0..*) <"Defines a combination of Rating Agency, Rating Value, Threshold amount and Currency code.">
    ratedParty ThresholdRatedPartyEnum (0..1) <"The party to which a rating applies.">
    namedEntity string (0..1) <"Details the Named Entity where the Rated Party is Named Entity.">
    namedAffiliate string (0..1) <"Details the Named Affiliate where the Rated Party is Named Affiliate.">
    compare CreditNotationMismatchResolutionEnum (0..1) <"Where two ratings are specified whether the higher or lower rating prevails.">
    noRating boolean (1..1) <"What conditions apply where a party has no rating.">
    notRatedBy NotRatedByEnum (0..1) <"Defines where conditions apply if no Rating where ratings may not exist.">
    numberOfRatingAgencies NumberOfRatingAgenciesEnum (0..1) <"Defines the number of Rating Agencies that the Party must be rated by.">
    zeroEvent boolean (1..1) <"Whether a trigger applies for the threshold to fall to zero.">
    event ThresholdZeroEventEnum (0..*) <"The relevant trigger for the threshold to fall to zero.">

type Infinity: <"Defines that the Threshold is Infinity.">
    party CounterpartyRoleEnum (0..1) <"Elective Party to which the condition applies.">

type CSAThresholdVariableSet: <"Defines a combination of Rating Agency, Rating Value, Threshold amount and Currency code.">
    name CreditRatingAgencyEnum (0..1) <"The relevant rating agency.">
    value string (0..1) <"Rating applicable to the party from a given rating agency.">
    amount int (0..1) <"The amount value applicable to the Threshold.">

    condition NameMustExist: <"If we have a name then we must also have a value.">
        if name exists then value exists

    condition ValueMustExist: <"If we have a value then we must also have a name.">
        if value exists then name exists

type CSAMinimumTransferAmount:
    [docReference ISDA CSA_NewYork_1994 name "Minimum Transfer Amount"]
    [docReference ISDA CSA_English_1995 name "Minimum Transfer Amount"]
    [docReference ISDA CSD_English_1995 name "Minimum Transfer Amount"]
    [docReference ISDA CSA_VM_English_2016 name "Minimum Transfer Amount"]
    [docReference ISDA CSA_VM_NewYork_2016 name "Minimum Transfer Amount"]
    mtaType MTAType (1..1) <"Details whether the Minimum Transfer Amount (MTA) is rating based, a fixed amount, or infinity.">

type MTAType: <"Details whether the Minimum Transfer Amount is rating based, a fixed amount, or infinity.">
    fixedAmount MTAFixedAmount (0..1) <"Defines that the Minimum Transfer Amount (MTA) is a Fixed Amount.">
    ratingsBased MTARatingsBased (0..1) <"Defines that the Minimum Transfer Amount (MTA) is based on a Ratings condition(s).">
    other string (0..1) <"Utilised where the clause data structure is not able to capture a material aspect of the clause.">

type MTAFixedAmount: <"Defines that the Minimum Transfer Amount (MTA) is a Fixed Amount.">
    party CounterpartyRoleEnum (1..1) <"The party to which the Minimum Transfer Amount (MTA) applies.">
    amount int (1..1) <"The amount value applicable to the Minimum Transfer Amount (MTA).">
    currency ISOCurrencyCodeEnum (1..1) <"The minimum transfer amount currency code.">

type MTARatingsBased: <"Defines that the Minimum Transfer Amount (MTA) is based on a Ratings condition(s).">
    party CounterpartyRoleEnum (1..1) <"The party to which the Minimum Transfer Amount (MTA) applies.">
    currency ISOCurrencyCodeEnum (1..1) <"The minimum transfer amount currency code.">
    ratingType RatingTypeEnum (1..1) <"The relevant rating type.">
    variableSet CSAMTAVariableSet (0..*) <"Defines a combination of Rating Agency, Rating Value, amount and Currency code.">
    ratedParty MTARatedPartyEnum (0..1) <"The party to which a rating applies.">
    namedEntity string (0..1) <"Details the Named Entity where the Rated Party is Named Entity.">
    namedAffiliate string (0..1) <"Details the Named Affiliate where the Rated Party is Named Affiliate.">
    compare CreditNotationMismatchResolutionEnum (0..1) <"Where two ratings are specified whether the higher or lower rating prevails.">
    noRating boolean (1..1) <"What conditions apply where a party has no rating.">
    notRatedBy NotRatedByEnum (0..1) <"Defines where conditions apply if no Rating where ratings may not exist.">
    numberOfRatingAgencies NumberOfRatingAgenciesEnum (0..1) <"Defines the number of Rating Agencies that the Party must be rated by.">
    zeroEvent boolean (1..1) <"Whether a trigger applies for the threshold to fall to zero.">
    event MTAZeroEventEnum (0..*) <"The relevant trigger for the to fall to zero.">

type CSAMTAVariableSet: <"Defines a combination of Rating Agency, Rating Value, amount and Currency code.">
    name CreditRatingAgencyEnum (0..1) <"The name of the Rating Agency.">
    value string (0..1) <"The value assigned to the rating.">
    amount int (0..1) <"The Minimum Transfer Amount (MTA) applicable to the Rating.">
    amountIsInfinity boolean (0..1) <"A flag that defines the Minimum Transfer Amount (MTA) as Infinity.">

    condition NameMustExist: <"If we have a name then we must also have a value.">
        if name exists then value exists

    condition ValueMustExist: <"If we have a value then we must also have a name.">
        if value exists then name exists

type DatedAsOfDate: <"Defines the dates agreed by the parties as the date of the Credit Support Annex or Credit Support Deed.">
    csaDatedAsOfDate date (0..1) <"The date agreed by the parties as the Dated as of Date for the Credit Support Annex.">
    masterAgreementDatedAsOfDate date (0..1) <"The date agreed by the parties as the Dated as of Date for the Master Agreement.">
    csaMadeOn date (0..1) <"The date agreed by the parties as the Made On date of the Credit Support Deed.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

type LegacyDeliveryAmount: <"In respect of a Valuation Date, the amount of collateral which a party is entitled to demand to be transferred to it as a Delivery Amount.">
    legacyDeliveryAmount LegacyDeliveryReturnAmountEnum (1..1) <"Specifies whether the meaning of Delivery Amount follows the pre-print definition or deviates from this (either based on a rating or some other methodology).">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

type LegacyReturnAmount: <"In respect of a Valuation Date, the amount of collateral which a party is entitled to demand to be recalled to it as a Return Amount.">
    legacyReturnAmount LegacyDeliveryReturnAmountEnum (1..1) <"Specifies whether the meaning of Return Amount follows the pre-print definition or deviates from this (either based on a rating or some other methodology).">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

type LegacyValuationTime: <"The time by which the value of the collateral and obligations to transfer or return collateral are to be calculated relative to the Valuation Date.">
    day ValuationTimeDayEnum (0..1) <"The day in respect of which the Valuation Time is being specified. If not specified, addional language must be used to define the methodology.">
    location BusinessCenterEnum (0..*) <"The location relevant to the timezone for the Valuation Time.">
    time ValuationTimeEnum (0..1) <"The type of time specified for the Valuation Time.">
    hourminutetime time (0..1) <"A time specified in a 24-hour notation, e.g. 3pm would be represented as 15:00.">
    timezone BusinessCenterEnum (0..1) <"Any relevant time zone where specified.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition AdditionalLanguage: <"If no Day valuation methodology is defined, additional language must be specified.">
        if day is absent then additionalLanguage exists

    condition DayAndTime: <"Day and Time must be used together and neither can be used alone.">
        if day exists
        then time exists
        else time is absent
            and item -> location is absent
            and hourminutetime is absent
            and timezone is absent

type FinalReturns: <"A clause providing that final return collateral is to be provided without consideration of any Minimum Transfer Amount and collateral haircut.">
    applicable boolean (0..1) <"Defines if the clause is applicable to this agreement or any other exceptions.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition AdditionalLanguage: <"The additional language should be qualified only if the clause is specified as applicable.">
        if applicable then additionalLanguage exists

type LegacyValuationDate: <"Details of the days on which calculations are to be made to determine the Delivery Amount and/or Return Amount. For example the language in the document may state 'Valuation Date means each day which is a Local Business Day', to capture this the values would be: Date: EACH, Day: LBD, Frequency: NULL. Alternatively the language may state: 'Valuation Date means the 1st Local Business Day of each week', this would be captured as: Date: 1st, Day: LBD, Frequency: WEEKLY.">
    date ValuationDateDateEnum (0..1) <"Defines whether a date is defined by a certain day of the week or a particular date in the month. If not specified here, then additional language must be used.">
    day ValuationDateDayEnum (0..1) <"Specific day(s) or day of the week, if any, specified for Valuation Time.">
    calendarDay number (0..1) <"Defines the day of the calendar if this is specified for in the ValuationDateDateEnum.">
    frequency ValuationDateFrequencyEnum (0..1) <"Defines the regularity of the date specified for the Valuation Date.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition CalendarDay: <"If a specific calendar day is specified, it must be defined.">
        if date = ValuationDateDateEnum -> CalendarDay
        then calendarDay exists
        else calendarDay is absent

    condition AdditionalLanguage: <"If no methodology is defined, additional language must be specified.">
        if date is absent or frequency is absent
        then additionalLanguage exists

type LegacyValuationAgent: <"Details of the party calculating the value of collateral to be delivered or returned.">
    party ValuationAgentPartyEnum (0..1) <"The elective party.">
    valuationAgent LegacyValuationAgentEnum (0..1) <"Specifies how the Valuation Agent is determined.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition AdditionalLanguage: <"If no party is defined, additional language must be used to specify the elective party.">
        if party is absent then additionalLanguage exists

type ExposureScope: <"Optionally, for each party, specifies the amendments to the included coverage in the calculation of Exposure.">
    partyElection LegacyExposureScopeElection (0..2) <"Defines the electice scope for a specific party.">

type LegacyExposureScopeElection: <"Specification of amendments to the calculation of Exposure in terms of the Transactions and Products covered.">
    party CounterpartyRoleEnum (1..1) <"The elective party.">
    excludedTransactions boolean (1..1) <"A boolean flag to represent whether any transactions are excluded (ie True) or not (ie False).">
    excludedProducts ExcludedProducts (0..*) <"Description of the relevant derivative transactions excluded from the calculation of exposure.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

type ExcludedProducts: <"Description of the relevant derivative transactions excluded from the calculation of exposure.">
    product ExposureScopeProductEnum (0..*) <"Description of the relevant derivative transactions excluded from the calculation of exposure.">
    branch BusinessCenterEnum (0..*) <"Description of the specific branch entered into by the relevant party.">
    excluded boolean (1..1) <"A flag to indicate whether transactions entered into by a specific branch with respect to the relevant party are excluded; set to True if excluded, false if included.">

type CreditSupportAmount: <"The total amount one counterparty must deliver to the other at any time: the combination of the Exposure to that party and the net Independent Amounts it must post, minus any agreed Threshold.">
    creditSupportAmount CreditSupportAmountEnum (1..1) <"Specifies whether the meaning of credit support amount follows the pre-print definition or deviates from the standard (either based on a rating or some other methodology).">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition AdditionalLanguage: <"If a Non Standard Other definition is defined, additional language must be specified.">
        if creditSupportAmount = CreditSupportAmountEnum -> NonStandardOther
        then additionalLanguage exists

type LegacyResolutionAlternative: <"Alternative procedures to those in the pre-print for resolving collateral related disputes.">
    resolutionAlternative LegacyResolutionAlternativeEnum (0..1) <"Details of the alternative dispute resolution procedure (if any).">
    amount Money (0..1) <"The maximum amount to which the difference between the calculations by the valuation agent and disputing party can be split, where Split the Difference is elected.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition AdditionalLanguage: <"If no resolution alternative procedure is defined, additional language must be specified.">
        if resolutionAlternative is absent
        then additionalLanguage exists

    condition SplitDifferenceAmount: <"If the resolution is to split the difference, then the amount concerned should be specified.">
        if resolutionAlternative = LegacyResolutionAlternativeEnum -> SplitDifference
        then amount exists

type LegacyResolutionValue: <"Methodology for resolving disputes in respect of the determination of the value of collateral.">
    cash ValueCashEnum (0..1) <"Details of how cash collateral is valued when resolving disputes.">
    securities ValueSecuritiesEnum (0..1) <"Details of how securities collateral is valued when resolving disputes.">
    fallback boolean (0..1) <"A boolean flag to represent whether a fallback calculation method is applicable.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition OtherValues: <"Additional language is required when 'Other' values are used.">
        if cash = ValueCashEnum -> Other or securities = ValueSecuritiesEnum -> Other
        then additionalLanguage exists

type CollateralTransferTiming: <"Specification of transfer / settlement timing for cash and securities collateral assuming that the notice is provided before the Notification Time (and with a 1LBD lag introduced if the notice is delivered after the Notification Time), and that securities allow for a further Local Business Day for transfer / settlement.">
    transferSettlementTiming LegacyTransferSettlementTiming (0..1) <"Specification of transfer / settlement timing for cash and securities collateral assuming that the notice is provided before the Notification Time (and with a 1LBD lag introduced if the notice is delivered after the Notification Time), and that securities allow for a further Local Business Day for transfer / settlement.">
    legacyDefinition LegacyDefinition (0..1) <"Bespoke language removing the pre-print requirement to transfer legal title of securities collateral through written instructions to the relevant depository institution or other securities intermediaries solely for the purposes of the 1994 New York Law Credit Support Annex.">

type LegacyTransferSettlementTiming: <"Specification of transfer / settlement timing for cash and securities collateral assuming that the notice is provided before the Notification Time (and with a 1LBD lag introduced if the notice is delivered after the Notification Time), and that securities allow for a further Local Business Day for transfer / settlement.">
    cashCollateralTransferSettlementTime CashCTSTimeEnum (0..1) <"Details the day on which collateral is required to be transferred relative to the Notification Time.">
    securititesCollateralTransferSettlementTime SecuritiesCTSTimeEnum (0..1) <"Details the day on which collateral is required to be transferred relative to the Notification Time.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition OtherValues: <"Additional language is required when 'Other' values are used.">
        if cashCollateralTransferSettlementTime = CashCTSTimeEnum -> Other
                or securititesCollateralTransferSettlementTime = SecuritiesCTSTimeEnum -> Other
        then additionalLanguage exists

type LegacyDefinition: <"Bespoke language removing the pre-print requirement to transfer legal title of securities collateral through written instructions to the relevant depository institution or other securities intermediaries solely for the purposes of the 1994 New York Law Credit Support Annex.">
    isApplicable boolean (0..1) <"A boolean flag to represent bespoke amendment to the pre-print definition of Transfer.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition ApplicableLanguage: <"Additional language is required when a bespoke amendment is used.">
        if isApplicable = False then additionalLanguage exists

type CollateralValueMethod: <"Details how particular types of collateral are valued (other than in respect of a default).">
    cashCollateral ValueCashEnum (0..1) <"Details of how cash collateral is valued.">
    securitiesCollateral ValueSecuritiesEnum (0..1) <"Details of how securities collateral is valued.">
    additionalLanguage string (0..1) <"The additional language that might be specified by the parties to the legal agreement.">

    condition OtherValues: <"Additional language is required when 'Other' values are used.">
        if cashCollateral = ValueCashEnum -> Other
                or securitiesCollateral = ValueSecuritiesEnum -> Other
        then additionalLanguage exists

type CreditSupportDocument: <"Identification of party specific Credit Support Documents applicable to the document.">

    creditSupportDocumentElection CreditSupportDocumentElection (2..2) <"The party election of Credit Support Document(s), if any.">

type CreditSupportDocumentElection: <"The party election of Credit Support Provider(s), if any.">
    party Party (1..1) <"The elective party.">
    creditSupportDocumentTerms CreditSupportDocumentTermsEnum (1..1) <"Specification of the Credit Support Document terms.">
    creditSupportDocument LegalAgreement (0..*) <"The specified Credit Support Document(s), if any.">
    bespokeCreditSuppportDocument string (0..1) <"Specification of a document when not captured under RelatedAgreement.">

    condition CreditSupportDocument: <"A validation rule to ensure that a Credit Support Document is specified when required.">
        if creditSupportDocumentTerms = CreditSupportDocumentTermsEnum -> Specified
        then creditSupportDocument exists

type CreditSupportProvider: <"Identification of party specific Credit Support Providers applicable to the document.">

    creditSupportProviderElection CreditSupportProviderElection (2..2) <"The party election of Credit Support Provider(s), if any.">

type CreditSupportProviderElection: <"The party election of Credit Support Provider(s), if any.">
    party Party (1..1) <"The elective party.">
    creditSupportProviderTerms CreditSupportProviderTermsEnum (1..1) <"Specification of the Credit Support Provider terms.">
    creditSupportProvider LegalEntity (0..*) <"The specified Credit Support Provider(s), if any.">
    bespokeCreditSuppportProvider string (0..1) <"...">

    condition CreditSupportProvider: <"A validation rule to ensure that a Credit Support Provider is specified when required.">
        if creditSupportProviderTerms = CreditSupportProviderTermsEnum -> Specified
        then creditSupportProvider exists


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-desc.rosetta
================================================================================

namespace cdm.legaldocumentation : <"Credit support concepts: CSA, collateral, elections, initial margin, threshold, minimum transfer amount.">
version "${project.version}"


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-master-enum.rosetta
================================================================================

namespace cdm.legaldocumentation.master : <"Master agreement concepts.">
version "${project.version}"

import cdm.base.*

enum MasterAgreementTypeEnum: <"The enumerated values to specify the type of the master agreement governing the transaction.">
    // docReference removed due to from ISDA to ISDAMaster
    // [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/master-agreement-type"]
    AFB <"AFB Master Agreement for Foreign Exchange and Derivatives Transactions">
    Bespoke <"A Bespoke (custom) Master Agreement, including one-off agreements for transactions">
    CMA <"Clearing Master Agreement">
    CMOF <"Contrato Marco de Operaciones Financieras">
    EEIPower <"EEI Master Power Purchase and Sale Agreement">
    EFETElectricity <"EFET General Agreement Concerning the Delivery and Acceptance of Electricity">
    EFETGas <"EFET General Agreement Concerning The Delivery And Acceptance of Natural Gas">
    EMA <"European Master Agreement and the Derivatives Annex (Banking Federation of the European Union)">
    FBF <"Master Agreement Relating to transactions on Forward Financial Instruments (Federation Bancaire Francaise)">
    GasEDI <"GasEDI Base Contract for Short-term Sale and Purchase of Natural Gas">
    German <"German Master Agreement for Financial derivatives and Addendum for Options on Stock Exchange Indices or Securities">
    GMRA <"ICMA Global Master Agreement for REPO Trades">
    GMSLA <"ISLA Global Master Agreement for Securities Lending">
    GTMA <"FOA Grid Trade Master Agreement">
    ICOM <"International Currency Options Market Master Agreement">
    IETA_ERPA displayName "IETA-ERPA" <"International Emissions Trading Association Emissions Reduction Purchase Agreement">
    IETA_ETMA displayName "IETA-ETMA" <"International Emissions Trading Association Emissions Trading Master Agreement">
    IETA_IETMA displayName "IETA-IETMA" <"International Emissions Trading Association International Emissions Trading Master Agreement">
    IFEMA <"International Foreign Exchange Master Agreement">
    IFEOMA <"International Foreign Exchange and Options Master Agreement">
    ISDAMaster <"ISDA Master Agreement">
    ISDAFIA_CDEA displayName "ISDAFIA-CDEA" <"ISDA-FIA Cleared Derivatives Execution Agreement">
    ISDAIIFM_TMA displayName "ISDAIIFM-TMA" <"ISDA/IIFM Tahawwut (Hedging) Master Agreement (TMA)">
    JSCC <"Master agreement of Japan Securities Clearing Corporation">
    LBMA <"International Bullion Master Agreement Terms published by the London Bullion Market Association">
    LEAP <"Leadership in Energy Automated Processing">
    MCPSA <"CTA Master Coal Purchase and Sales Agreement">
    NAESBGas <"NAESB Base Contract for Sale and Purchase of Natural Gas">
    NBP <"Short Term Flat NBP Trading Terms and Conditions">
    RussianDerivatives <"Standard Documentation for Derivative Transactions on the Russian Financial Markets">
    RussianRepo <"Master Agreement and Contractual Terms for Repurchase Agreements on the Russian Financial Market">
    SCoTA <"globalCOAL Standard Coal Trading Agreement">
    Swiss <"Swiss Master Agreement for OTC Derivatives Instruments">
    TTF <"TTF Hub Natural Gas Trading Terms and Conditions">
    ZBT <"Zeebrugge Hub Natural Gas Trading Terms and Conditions">

enum MasterConfirmationAnnexTypeEnum: <"The enumerated values to specify the type of annex to be used with master confirmation agreement governing the transaction.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/master-confirmation-annex-type"]

    ISDA2004IndexVarianceSwapAmericasInterdealer <"The Index Variance Swap 2004 Annex to the ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement and to the Revised ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2004ShareVarianceSwapAmericasInterdealer <"The Share Variance Swap 2004 Annex to the ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement and to the Revised ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2007DispersionVarianceSwapEuropean <"The Dispersion Variance Swap Annex to the Revised 2007 ISDA European Variance Swap Master Confirmation Agreement applies.">
    ISDA2007EquityFinanceSwapEuropean <"The EFS (Equity Share Finance Swap) 2007 Annex to the ISDA 2007 European Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2007IndexVarianceSwapAmericasInterdealer <"The Index Variance Swap 2007 Annex to the Revised ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2007ShareVarianceSwapAmericasInterdealer <"The Share Variance Swap 2007 Annex to the Revised ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2007VarianceOptionEuropean <"The Variance Option Standard Terms Appendix to the Revised ISDA 2007 European Variance Swap Master Confirmation Agreement applies.">
    ISDA2008EquityFinanceSwapAsiaExcludingJapan <"The Cash-settled Open Market EFS (Equity Finance Share Swap) 2008 Annex to the ISDA 2008 AEJ (Asia Excluding Japan) Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2008EquityFinanceSwapAsiaExcludingJapanRev1 <"The Cash-settled Open Market EFS (Equity Finance Share Swap) Annex to the Revised ISDA 2008 AEJ (Asia Excluding Japan) Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2008EquityOptionAsiaExcludingJapan <"The Open Market Equity Option 2008 Annex to the ISDA 2008 AEJ (Asia Excluding Japan) Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2008EquityOptionAsiaExcludingJapanRev1 <"The Open Market Equity Option Annex to the Revised ISDA 2008 AEJ (Asia Excluding Japan) Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2008EquityOptionJapan <"The Equity Option 2008 Annex to the ISDA 2008 Japanese Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009ClosedMarketsOptionsAsiaExcludingJapan <"The Cash-settled Closed Market Index and Share Options 2009 Annex to the Revised ISDA 2008 AEJ (Asia Excluding Japan) Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009EquityEuropeanInterdealerSS <"The Interdealer Share Swap 2009 Annex to the ISDA 2009 European Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009EquityEuropeanIS <"The Index Swap 2009 Annex to the ISDA 2007 European Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009IndexShareOptionAmericas <"The Index and Share Options 2009 Annex to the ISDA 2009 Americas Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009IndexSwapEuropeanInterdealer <"The Interdealer Index Swap 2009 Annex to the ISDA 2009 European Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009IndexSwapPanAsiaInterdealer <"The Index Swap 2009 Annex to the ISDA 2009 Pan-Asia Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009ShareSwapPanAsia <"The Share Swap 2009 Annex to the ISDA 2009 Pan-Asia Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2010FairValueShareSwapEuropeanInterdealer <"The Fair Value Interdealer Share Swap 2010 Annex to the ISDA 2009 European Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2010IndexShareOptionEMEAInterdealer <"The Cash-settled Index Option/Cash/Physically-settled Share Option 2010 Annex to the ISDA 2010 EMEA EM Interdealer Master Equity Derivatives Confirmation Agreement applies.">

enum NationalizationOrInsolvencyOrDelistingEventEnum: <"Defines the consequences of nationalization, insolvency and delisting events relating to the underlying.">
    NegotiatedCloseout <"The parties may, but are not obliged, to terminate the transaction on mutually acceptable terms and if the terms are not agreed then the transaction continues.">
    CancellationAndPayment <"The trade is terminated.">

enum MasterConfirmationTypeEnum: <"The enumerated values to specify the type of master confirmation agreement governing the transaction. While FpML positions the date a prefix, the CDM positions it as the suffix to handle grammar type constraints.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/master-confirmation-type"]

    _2003CreditIndex displayName "2003CreditIndex" <"Used for CDS Index trades. Relevant Master Confirmation determined by the contents of the creditDefaultSwap element. Best practice is to use the most specific code that applies.">
    _2004EquityEuropeanInterdealer displayName "2004EquityEuropeanInterdealer" <"A privately negotiated European Interdealer Master Confirmation Agreement applies.">
    _2005VarianceSwapEuropeanInterdealer displayName "2005VarianceSwapEuropeanInterdealer" <"A privately negotiated European Interdealer Master Confirmation Agreement applies.">
    _2006DividendSwapEuropean displayName "2006DividendSwapEuropean" <"A European Interdealer Master Confirmation Agreement not defined by ISDA, and modified by the parties to the transaction applies.">
    _2006DividendSwapEuropeanInterdealer displayName "2006DividendSwapEuropeanInterdealer" <"A European Interdealer Master Confirmation Agreement not defined by ISDA applies.">
    _2014CreditAsia displayName "2014CreditAsia" <"Dummy MCA value mirroring the matrix term value AsiaCorporate.">
    _2014CreditAsiaFinancial displayName "2014CreditAsiaFinancial" <"Dummy MCA value mirroring the matrix term value AsiaFinancialCorporate.">
    _2014CreditAustraliaNewZealand displayName "2014CreditAustraliaNewZealand" <"Dummy MCA value mirroring the matrix term value AustraliaCorporate/NewZealandCorporate.">
    _2014CreditAustraliaNewZealandFinancial displayName "2014CreditAustraliaNewZealandFinancial" <"Dummy MCA value mirroring the matrix term value AustraliaFinancialCorporate/NewZealandFinancialCorporate.">
    _2014CreditEuropean displayName "2014CreditEuropean" <"Dummy MCA value mirroring the matrix term value EuropeanCorporate.">
    _2014CreditEuropeanCoCoFinancial displayName "2014CreditEuropeanCoCoFinancial" <"Dummy MCA value mirroring the matrix term value EuropeanCoCoFinancialCorporate.">
    _2014CreditEuropeanFinancial displayName "2014CreditEuropeanFinancial" <"Dummy MCA value mirroring the matrix term value EuropeanFinancialCorporate.">
    _2014CreditJapan displayName "2014CreditJapan" <"Dummy MCA value mirroring the matrix term value JapanCorporate.">
    _2014CreditJapanFinancial displayName "2014CreditJapanFinancial" <"Dummy MCA value mirroring the matrix term value JapanFinancialCorporate.">
    _2014CreditNorthAmerican displayName "2014CreditNorthAmerican" <"Dummy MCA value mirroring the matrix term value NorthAmericanCorporate.">
    _2014CreditNorthAmericanFinancial displayName "2014CreditNorthAmericanFinancial" <"Dummy MCA value mirroring the matrix term value NorthAmericanFinancialCorporate.">
    _2014CreditSingapore displayName "2014CreditSingapore" <"Dummy MCA value mirroring the matrix term values SingaporeCorporate.">
    _2014CreditSingaporeFinancial displayName "2014CreditSingaporeFinancial" <"Dummy MCA value mirroring the matrix term values SingaporeFinancialCorporate.">
    _2014CreditSovereignAsia displayName "2014CreditSovereignAsia" <"Dummy MCA value mirroring the matrix term value AsiaSovereign.">
    _2014CreditSovereignEmergingEuropeanAndMiddleEastern displayName "2014CreditSovereignEmergingEuropeanAndMiddleEastern" <"Dummy MCA value mirroring the matrix term value EmergingEuropeanAndMiddleEasternSovereign.">
    _2014CreditSovereignJapan displayName "2014CreditSovereignJapan" <"Dummy MCA value mirroring the matrix term value JapanSovereign.">
    _2014CreditSovereignLatinAmerican displayName "2014CreditSovereignLatinAmerican" <"Dummy MCA value mirroring the matrix term value LatinAmericaSovereign.">
    _2014CreditSovereignWesternEuropean displayName "2014CreditSovereignWesternEuropean" <"Dummy MCA value mirroring the matrix term value WesternEuropeanSovereign.">
    _2014StandardCreditAsia displayName "2014StandardCreditAsia" <"Dummy MCA value mirroring the matrix term values StandardAsiaCorporate.">
    _2014StandardCreditAsiaFinancial displayName "2014StandardCreditAsiaFinancial" <"Dummy MCA value mirroring the matrix term values StandardAsiaFinancialCorporate.">
    _2014StandardCreditAustraliaNewZealand displayName "2014StandardCreditAustraliaNewZealand" <"Dummy MCA value mirroring the matrix term values StandardAustraliaCorporate and StandardNewZealandCorporate.">
    _2014StandardCreditAustraliaNewZealandFinancial displayName "2014StandardCreditAustraliaNewZealandFinancial" <"Dummy MCA value mirroring the matrix term values StandardAustraliaFinancialCorporate and StandardNewZealandFinancialCorporate.">
    _2014StandardCreditEuropean displayName "2014StandardCreditEuropean" <"Dummy MCA value mirroring the matrix term value StandardEuropeanCorporate.">
    _2014StandardCreditEuropeanCoCoFinancial displayName "2014StandardCreditEuropeanCoCoFinancial" <"Dummy MCA value mirroring the matrix term value StandardEuropeanCoCoFinancialCorporate.">
    _2014StandardCreditEuropeanFinancial displayName "2014StandardCreditEuropeanFinancial" <"Dummy MCA value mirroring the matrix term value StandardEuropeanFinancialCorporate.">
    _2014StandardCreditJapan displayName "2014StandardCreditJapan" <"Dummy MCA value mirroring the matrix term values StandardJapanCorporate.">
    _2014StandardCreditJapanFinancial displayName "2014StandardCreditJapanFinancial" <"Dummy MCA value mirroring the matrix term value StandardJapanFinancialCorporate.">
    _2014StandardCreditNorthAmerican displayName "2014StandardCreditNorthAmerican" <"Dummy MCA value mirroring the matrix term value StandardNorthAmericanCorporate.">
    _2014StandardCreditNorthAmericanFinancial displayName "2014StandardCreditNorthAmericanFinancial" <"Dummy MCA value mirroring the matrix term value standardNorthAmericanFinancialCorporate.">
    _2014StandardCreditSingapore displayName "2014StandardCreditSingapore" <"Dummy MCA value mirroring the matrix term values StandardSingaporeCorporate.">
    _2014StandardCreditSingaporeFinancial displayName "2014StandardCreditSingaporeFinancial" <"Dummy MCA value mirroring the matrix term value StandardSingaporeFinancialCorporate.">
    _2014StandardCreditSovereignAsia displayName "2014StandardCreditSovereignAsia" <"Dummy MCA value mirroring the matrix term value StandardAsiaSovereign.">
    _2014StandardCreditSovereignEmergingEuropeanAndMiddleEastern displayName "2014StandardCreditSovereignEmergingEuropeanAndMiddleEastern" <"Dummy MCA value mirroring the matrix term value StandardEmergingEuropeanAndMiddleEasternSovereign.">
    _2014StandardCreditSovereignJapan displayName "2014StandardCreditSovereignJapan" <"Dummy MCA value mirroring the matrix term values StandardJapanSovereign.">
    _2014StandardCreditSovereignLatinAmerican displayName "2014StandardCreditSovereignLatinAmerican" <"Dummy MCA value mirroring the matrix term value StandardLatinAmericaSovereign.">
    _2014StandardCreditSovereignWesternEuropean displayName "2014StandardCreditSovereignWesternEuropean" <"Dummy MCA value mirroring the matrix term value StandardWesternEuropeanSovereign.">
    DJ_CDX_EM displayName "DJ.CDX.EM" <"Used for CDS Index trades executed under the Dow Jones CDX Emerging Markets Master Confirmation.">
    DJ_CDX_EM_DIV displayName "DJ.CDX.EM.DIV" <"Used for CDS Index trades executed under the Dow Jones CDX Emerging Markets Diversified Master Confirmation.">
    DJ_CDX_NA displayName "DJ.CDX.NA" <"Used for CDS Index trades executed under the Dow Jones CDX Master Confirmation that covers CDX.NA.IG, CDX.NA.HY, and CDX.NA.XO.">
    DJ_iTraxx_Europe displayName "DJ.iTraxx.Europe" <"Used for CDS Index trades executed under the Dow Jones iTraxx Europe Master Confirmation Agreement.">
    EquityAmericas <"A general reference to the types of Americas Master Confirmation Agreements. Use the more specific values to reference a specific type of Americas Master Confirmation Agreement.">
    EquityAsia <"A general reference to the types of Asia Master Confirmation Agreements. Use the more specific values to reference a specific type of Asia Master Confirmation Agreement.">
    EquityEuropean <"A general reference to the types of European Master Confirmation Agreements. Use the more specific values to reference a specific type of European Master Confirmation Agreement.">
    ISDA1999Credit <"ISDA 1999 Master Credit Derivatives Confirmation Agreement">
    ISDA2003CreditAsia <"ISDA 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Asia had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2003CreditAustraliaNewZealand <"ISDA 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Australia and New Zealand had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2003CreditEuropean <"ISDA 2003 Master Credit Derivatives Confirmation Agreement interpreted as if European had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2003CreditJapan <"ISDA 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Japan had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2003CreditNorthAmerican <"ISDA 2003 Master Credit Derivatives Confirmation Agreement interpreted as if North American had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2003CreditSingapore <"ISDA 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Singapore had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2003CreditSovereignAsia <"ISDA Sovereign 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Asia had been specified as the relevant Transaction Type in the Transaction Supplement. The 2003 Sovereign Master Confirmation has been superceded by the 2004.">
    ISDA2003CreditSovereignCentralAndEasternEurope <"ISDA Sovereign 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Central and Eastern Europe had been specified as the relevant Transaction Type in the Transaction Supplement. The 2003 Sovereign Master Confirmation has been superceded by the 2004.">
    ISDA2003CreditSovereignJapan <"ISDA Sovereign 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Japan had been specified as the relevant Transaction Type in the Transaction Supplement. The 2003 Sovereign Master Confirmation has been superceded by the 2004.">
    ISDA2003CreditSovereignLatinAmerica <"ISDA Sovereign 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Latin America had been specified as the relevant Transaction Type in the Transaction Supplement. The 2003 Sovereign Master Confirmation has been superceded by the 2004.">
    ISDA2003CreditSovereignMiddleEast <"ISDA Sovereign 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Middle East had been specified as the relevant Transaction Type in the Transaction Supplement. The 2003 Sovereign Master Confirmation has been superceded by the 2004.">
    ISDA2003CreditSovereignWesternEurope <"ISDA Sovereign 2003 Master Credit Derivatives Confirmation Agreement interpreted as if Western Europe had been specified as the relevant Transaction Type in the Transaction Supplement. The 2003 Sovereign Master Confirmation has been superceded by the 2004.">
    ISDA2003StandardCreditAsia <"Dummy MCA value mirroring the matrix term values StandardAsiaCorporate.">
    ISDA2003StandardCreditAustraliaNewZealand <"Dummy MCA value mirroring the matrix term values StandardAustraliaCorporate/Sovereign and StandardNewZealandCorporate/Sovereign.">
    ISDA2003StandardCreditEuropean <"Dummy MCA value mirroring the matrix term value StandardEuropeanCorporate.">
    ISDA2003StandardCreditJapan <"Dummy MCA value mirroring the matrix term values StandardJapanCorporate.">
    ISDA2003StandardCreditNorthAmerican <"Dummy MCA value mirroring the matrix term value StandardNorthAmericanCorporate.">
    ISDA2003StandardCreditSingapore <"Dummy MCA value mirroring the matrix term values StandardSingaporeCorporate/Sovereign.">
    ISDA2004CreditSovereignAsia <"ISDA Sovereign 2004 Master Credit Derivatives Confirmation Agreement interpreted as if Asia had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2004CreditSovereignEmergingEuropeanAndMiddleEastern <"ISDA Sovereign 2004 Master Credit Derivatives Confirmation Agreement interpreted as if Emerging European and Middle Eastern had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2004CreditSovereignJapan <"ISDA Sovereign 2004 Master Credit Derivatives Confirmation Agreement interpreted as if Japan had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2004CreditSovereignLatinAmerican <"ISDA Sovereign 2004 Master Credit Derivatives Confirmation Agreement interpreted as if Latin American had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2004CreditSovereignWesternEuropean <"ISDA Sovereign 2004 Master Credit Derivatives Confirmation Agreement interpreted as if Western European had been specified as the relevant Transaction Type in the Transaction Supplement.">
    ISDA2004EquityAmericasInterdealer <"The ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2004EquityAmericasInterdealerRev1 <"The Revised ISDA 2004 Americas Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2004StandardCreditSovereignAsia <"Dummy MCA value mirroring the matrix term values StandardAsiaSovereign.">
    ISDA2004StandardCreditSovereignEmergingEuropeanAndMiddleEastern <"Dummy MCA value mirroring the matrix term value StandardEmergingEuropeanAndMiddleEasternSovereign.">
    ISDA2004StandardCreditSovereignJapan <"Dummy MCA value mirroring the matrix term values StandardJapanSovereign.">
    ISDA2004StandardCreditSovereignLatinAmerican <"Dummy MCA value mirroring the matrix term value StandardLatinAmericaSovereign.">
    ISDA2004StandardCreditSovereignWesternEuropean <"Dummy MCA value mirroring the matrix term value StandardWesternEuropeanSovereign.">
    ISDA2005EquityAsiaExcludingJapanInterdealer <"ISDA 2005 AEJ (Asia Excluding Japan) Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2005EquityAsiaExcludingJapanInterdealerRev2 <"Second Revised ISDA 2005 AEJ (Asia Excluding Japan) Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2005EquityJapaneseInterdealer <"The ISDA 2005 Japanese Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2006VarianceSwapJapanese <"ISDA 2006 Variance Swap Japanese Confirmation Agreement applies.">
    ISDA2006VarianceSwapJapaneseInterdealer <"ISDA 2006 Variance Swap Japanese Interdealer Confirmation Agreement applies.">
    ISDA2007EquityEuropean <"The ISDA 2007 European Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2007VarianceSwapAmericas <"The ISDA 2007 Americas Master Variance Swap Confirmation Agreement applies.">
    ISDA2007VarianceSwapAsiaExcludingJapan <"The ISDA 2007 AEJ Master Variance Swap Confirmation Agreement applies.">
    ISDA2007VarianceSwapAsiaExcludingJapanRev1 <"The Revised ISDA 2007 AEJ Master Variance Swap Confirmation Agreement applies.">
    ISDA2007VarianceSwapAsiaExcludingJapanRev2 <"The Second Revised ISDA 2007 AEJ Master Variance Swap Confirmation Agreement applies.">
    ISDA2007VarianceSwapEuropean <"The ISDA 2007 European Variance Swap Master Confirmation Agreement applies.">
    ISDA2007VarianceSwapEuropeanRev1 <"The Revised ISDA 2007 European Variance Swap Master Confirmation Agreement applies.">
    ISDA2008DividendSwapJapan <"The ISDA 2008 Japanese Dividend Swap Master Confirmation Agreement applies.">
    ISDA2008DividendSwapJapaneseRev1 <"The Revised ISDA 2008 Japanese Dividend Swap Master Confirmation Agreement applies.">
    ISDA2008EquityAmericas <"The ISDA 2008 Americas Master Designated/Exchange-Traded Contract Option Confirmation Agreement applies.">
    ISDA2008EquityAsiaExcludingJapan <"The ISDA 2008 AEJ (Asia Excluding Japan) Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2008EquityAsiaExcludingJapanRev1 <"The Revised ISDA 2008 AEJ (Asia Excluding Japan) Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2008EquityJapan <"The ISDA 2008 Japanese Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009EquityAmericas <"The ISDA 2009 Americas Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009EquityEuropeanInterdealer <"The ISDA 2009 European Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2009EquityPanAsia <"2009 Pan-Asia Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2010EquityEMEAInterdealer <"The ISDA 2010 EMEA EM Interdealer Master Equity Derivatives Confirmation Agreement applies.">
    ISDA2013VolatilitySwapAmericas <"The ISDA 2013 Americas Master Volatility Swap Confirmation Agreement applies.">
    ISDA2013VolatilitySwapAsiaExcludingJapan <"The ISDA 2013 AEJ Master Volatility Swap Confirmation Agreement applies.">
    ISDA2013VolatilitySwapEuropean <"The ISDA 2013 European Volatility Swap Master Confirmation Agreement applies.">
    ISDA2013VolatilitySwapJapanese <"The ISDA 2013 Volatility Swap Japanese Confirmation Agreement applies.">

enum MasterAgreementClauseIdentifierEnum:
    ISLA_GMSLA_001 <"Date of Agreement">
    ISLA_GMSLA_002 <"Parties">
    ISLA_GMSLA_003 <"Specific Roles">
    ISLA_GMSLA_004 <"Eligible Collateral">
    ISLA_GMSLA_005 <"Margin">
    ISLA_GMSLA_006 <"Aggregation">
    ISLA_GMSLA_007 <"Collateral Disapplication">
    ISLA_GMSLA_008 <"Settlement Netting">
    ISLA_GMSLA_009 <"Notification Time">
    ISLA_GMSLA_010 <"Indemnity">
    ISLA_GMSLA_011 <"Base Currency">
    ISLA_GMSLA_012 <"Places of Business">
    ISLA_GMSLA_013 <"Value">
    ISLA_GMSLA_014 <"Automatic Early Termination">
    ISLA_GMSLA_015 <"Designated Offices">
    ISLA_GMSLA_016 <"Address for Notices">
    ISLA_GMSLA_017 <"Process Agent">
    ISLA_GMSLA_018 <"Party Acting as Agent">
    ISLA_GMSLA_019 <"Pooled Principal Transactions ">
    ISLA_GMSLA_020 <"Party Preparing the Agreement ">
    ISLA_GMSLA_021 <"Default Interest Rate">
    ISLA_GMSLA_022 <"Existing Transactions">
    ISLA_GMSLA_023 <"Automation">
    ISLA_GMSLA_024 <"Act of Insolvency">
    ISLA_GMSLA_025 <"Buy-In">
    ISLA_GMSLA_026 <"Currency Conversions">
    ISLA_GMSLA_027 <"Scope">
    ISLA_GMSLA_028 <"Collateral Delivery Timings">
    ISLA_GMSLA_029 <"Delivery">
    ISLA_GMSLA_030 <"Substitution of Collateral">
    ISLA_GMSLA_031 <"Manufactured Payments">
    ISLA_GMSLA_032 <"Corporate Actions">
    ISLA_GMSLA_033 <"Payment of Rates">
    ISLA_GMSLA_034 <"Rate Applicable to Loaned Securities">
    ISLA_GMSLA_035 <"Lender's Right to Terminate a Loan">
    ISLA_GMSLA_036 <"Borrower's Right to Terminate a Loan">
    ISLA_GMSLA_037 <"Failure to Deliver Event of Default">
    ISLA_GMSLA_038 <"Failure to Redeliver">
    ISLA_GMSLA_039 <"Assets Transferred to a Trustee">
    ISLA_GMSLA_040 <"Suspension Event of Default">
    ISLA_GMSLA_041 <"Costs and Expenses">
    ISLA_GMSLA_042 <"Set-Off">
    ISLA_GMSLA_043 <"Default Market Value Fallbacks">
    ISLA_GMSLA_044 <"Assignment">
    ISLA_GMSLA_045 <"Telephone Recordings">
    ISLA_GMSLA_046 <"Waiver of Immunity">
    ISLA_GMSLA_047 <"Agreement to Deliver Documents">
    ISLA_GMSLA_048 <"Collateral Transfer Details">
    ISLA_GMSLA_049 <"Confidentiality">
    ISLA_GMSLA_050 <"Correction">
    ISLA_GMSLA_051 <"Minimum Collateral Transfer Amount">
    ISLA_GMSLA_052 <"Non-Reliance Representation">
    ISLA_GMSLA_053 <"Records and Statements">
    ISLA_GMSLA_054 <"Recovery and Resolution">
    ISLA_GMSLA_055 <"Security Agreement Details">
    ISLA_GMSLA_056 <"Triparty Services">

enum MasterAgreementVariantIdentifierEnum:
    ISLA_GMSLA_001_01 <"Agreement is Undated">
    ISLA_GMSLA_001_02 <"Agreement is Dated">
    ISLA_GMSLA_002_01 <"Name and Place of Incorporation">
    ISLA_GMSLA_002_02 <"Names and Place of Incorporation plus Additional Information">
    ISLA_GMSLA_002_03 <"Defining the Party's Role as Lender or Borrower">
    ISLA_GMSLA_003_01 <"Non-specific Roles">
    ISLA_GMSLA_003_02 <"Specific Roles">
    ISLA_GMSLA_004_01 <"GMSLA Schedule">
    ISLA_GMSLA_004_02 <"Outside of GMSLA">
    ISLA_GMSLA_004_03 <"Additional Criteria">
    ISLA_GMSLA_005_01 <"GMSLA Schedule">
    ISLA_GMSLA_005_02 <"Outside of GMSLA">
    ISLA_GMSLA_006_01 <"Aggregation Applies">
    ISLA_GMSLA_006_02 <"Aggregation Does Not Apply">
    ISLA_GMSLA_006_03 <"Aggregation Applies Separately to Loan Groups">
    ISLA_GMSLA_006_04 <"Aggregation Applies to Some but Not All Loans">
    ISLA_GMSLA_006_05 <"Neither Aggregation nor Loan by Loan Applies">
    ISLA_GMSLA_007_01 <"Standard">
    ISLA_GMSLA_007_02 <"Collateral Disapplied">
    ISLA_GMSLA_008_01 <"Netting of Collateral Shall Apply">
    ISLA_GMSLA_008_02 <"Netting of Collateral Shall Not Apply">
    ISLA_GMSLA_008_03 <"Netting of Collateral Shall Apply with Multiple Payments or Delivery Options">
    ISLA_GMSLA_008_04 <"Netting of Collateral Shall Apply Separately per Group of Loans">
    ISLA_GMSLA_009_01 <"Specified Time">
    ISLA_GMSLA_009_02 <"Notification Time by Collateral Type">
    ISLA_GMSLA_009_03 <"Notification Time as Agreed">
    ISLA_GMSLA_009_04 <"No Notification Time">
    ISLA_GMSLA_010_01 <"Indemnity Applies">
    ISLA_GMSLA_010_02 <"Indemnity does not Apply">
    ISLA_GMSLA_011_01 <"Single Base Currency">
    ISLA_GMSLA_011_02 <"Single Base Currency with Fallback">
    ISLA_GMSLA_011_03 <"Single Base Currency with Multiple Fallback Options">
    ISLA_GMSLA_012_01 <"Locations are Specified Without Reference to Party">
    ISLA_GMSLA_012_02 <"Locations are Specified Separately per Party">
    ISLA_GMSLA_012_03 <"Not all Places of Business Have to be Open">
    ISLA_GMSLA_013_01 <"Standard Bid Price">
    ISLA_GMSLA_013_02 <"Standard Mid Price">
    ISLA_GMSLA_013_03 <"2018 Standard">
    ISLA_GMSLA_013_04 <"Borrowers Agreement to Pricing Source">
    ISLA_GMSLA_013_05 <"Pre-agreed Pricing Source">
    ISLA_GMSLA_013_06 <"Time Variation">
    ISLA_GMSLA_014_01 <"Automatic Early Termination does not Apply">
    ISLA_GMSLA_014_02 <"Automatic Early Termination Applies">
    ISLA_GMSLA_014_03 <"Automatic Early Termination Applies in Modified Form)">
    ISLA_GMSLA_014_04 <"Automatic Early Termination is specified separately for each Principal">
    ISLA_GMSLA_014_05 <"Automatic Early Termination is not applicable unless required due to the systems of law">
    ISLA_GMSLA_015_01 <"Party Specifies a Single Designated Office">
    ISLA_GMSLA_015_02 <"Party Specifies Multiple Designated Offices">
    ISLA_GMSLA_016_01 <"2000 Standard">
    ISLA_GMSLA_016_02 <"2010 Standard">
    ISLA_GMSLA_016_03 <"2018 Standard">
    ISLA_GMSLA_016_04 <"Plus Email">
    ISLA_GMSLA_016_05 <"Separate Address for Legal and Operational Notices">
    ISLA_GMSLA_016_06 <"Special Instructions">
    ISLA_GMSLA_017_01 <"No Process Agent">
    ISLA_GMSLA_017_02 <"Process Agent Specified">
    ISLA_GMSLA_017_03 <"Process Agent to be Appointed">
    ISLA_GMSLA_018_01 <"A Party will not act as Agent">
    ISLA_GMSLA_018_02 <"A Party may act as Agent">
    ISLA_GMSLA_018_03 <"A Party will always act as Agent">
    ISLA_GMSLA_019_01 <"Pooled Principal Transactions Shall Not Apply">
    ISLA_GMSLA_019_02 <"Pooled Principal Transactions Shall  Apply">
    ISLA_GMSLA_019_03 <"Pooled Principal Transactions May Apply">
    ISLA_GMSLA_020_01 <"Simple Election">
    ISLA_GMSLA_020_02 <"Election with Modifications">
    ISLA_GMSLA_021_01 <"Term Rate">
    ISLA_GMSLA_021_02 <"Overnight Rate">
    ISLA_GMSLA_021_03 <"Risk Free Rate">
    ISLA_GMSLA_021_04 <"Non-Defaulting Party Election">
    ISLA_GMSLA_021_05 <"Spread">
    ISLA_GMSLA_022_01 <"Agreement Covers Existing Loans">
    ISLA_GMSLA_022_02 <"Agreement Does Not Cover Existing Loans">
    ISLA_GMSLA_023_01 <"Automation Does Not Apply">
    ISLA_GMSLA_023_02 <"Automation May Apply">
    ISLA_GMSLA_024_01 <"Standard Pre-Print">
    ISLA_GMSLA_024_02 <"Grace Period Amendment">
    ISLA_GMSLA_024_03 <"Jurisdictional Amendments">
    ISLA_GMSLA_025_01 <"Transferor Pays Costs and Expenses">
    ISLA_GMSLA_025_02 <"Transferor Pays Costs and Expenses other than those arising from Negligence">
    ISLA_GMSLA_025_03 <"Transferor only Liable for Cost and Expenses if Reasonable Notice of Buy-in">
    ISLA_GMSLA_025_04 <"Buy-in Expanded to Cover Buy-in Exercised by an Exchange">
    ISLA_GMSLA_026_01 <"Standard">
    ISLA_GMSLA_026_02 <"Selecting Party other than Lender">
    ISLA_GMSLA_026_03 <"Variation of Exchange Rate Source">
    ISLA_GMSLA_027_01 <"Standard Scope">
    ISLA_GMSLA_027_02 <"Limited Scope">
    ISLA_GMSLA_028_01 <"Same Day">
    ISLA_GMSLA_028_02 <"Alternative Delivery Time">
    ISLA_GMSLA_028_03 <"Same Day with Notification Time">
    ISLA_GMSLA_028_04 <"Alternative Delivery Time with Notification Time">
    ISLA_GMSLA_028_05 <"Asset Dependent">
    ISLA_GMSLA_029_01 <"Simultaneous delivery of securities and collateral">
    ISLA_GMSLA_029_02 <"Collateral Delivery as specified in the Security Agreement">
    ISLA_GMSLA_029_03 <"Lender to Deliver Securities once Collateral is Delivered">
    ISLA_GMSLA_030_01 <"Borrower Request">
    ISLA_GMSLA_030_02 <"Borrower Request/Lender Consent">
    ISLA_GMSLA_030_03 <"Lender or Borrower Request">
    ISLA_GMSLA_030_04 <"Pre-approval of Alternative Collateral">
    ISLA_GMSLA_031_01 <"Manufactured Payment of Amount Such Party Would Be Entitled to Receive">
    ISLA_GMSLA_031_02 <"Manufactured Payment of Amount Such Lender Would Be Entitled to Receive">
    ISLA_GMSLA_031_03 <"Manufactured Payment Only in Relation to Loaned Securities">
    ISLA_GMSLA_031_04 <"Additional Sum to Be Paid to Cover Tax Relief">
    ISLA_GMSLA_031_05 <"Notice Requirement">
    ISLA_GMSLA_032_01 <"Standard">
    ISLA_GMSLA_032_02 <"Reasonable Notice Defined">
    ISLA_GMSLA_032_03 <"No Right to Instruct">
    ISLA_GMSLA_033_01 <"Payment Within a Week">
    ISLA_GMSLA_033_02 <"Payment Within 10 Days">
    ISLA_GMSLA_033_03 <"Payment Upon Maturity">
    ISLA_GMSLA_034_01 <"Such Rate as Agreed">
    ISLA_GMSLA_034_02 <"VAT Added">
    ISLA_GMSLA_034_03 <"No Deduction">
    ISLA_GMSLA_034_04 <"No Rate Payable">
    ISLA_GMSLA_035_01 <"Lender May Terminate a Loan at any Time">
    ISLA_GMSLA_035_02 <"Lender May Not Terminate a Loan">
    ISLA_GMSLA_036_01 <"Borrower May Terminate a Loan at Any Time">
    ISLA_GMSLA_036_02 <"Borrower May Terminate a Loan Subject to Notice">
    ISLA_GMSLA_036_03 <"Borrower May Terminate a Loan Subject to Limitations Concerning Corporate Actions">
    ISLA_GMSLA_036_04 <"Borrower May Terminate a Loan Subject to Paying the Rate for the Full Term">
    ISLA_GMSLA_037_01 <"Failure to Deliver Event of Default Applies">
    ISLA_GMSLA_037_02 <"Failure to Deliver Event of Default does not Apply">
    ISLA_GMSLA_037_03 <"Failure to Deliver Event of Default does not Apply to Lender">
    ISLA_GMSLA_038_01 <"2000 Standard">
    ISLA_GMSLA_038_02 <"2010 Standard">
    ISLA_GMSLA_038_03 <"2018 Standard">
    ISLA_GMSLA_038_04 <"2000 Modified No Lender Close Out">
    ISLA_GMSLA_039_01 <"2000 Standard">
    ISLA_GMSLA_039_02 <"2010/2018 Standard">
    ISLA_GMSLA_039_03 <"Hybrid">
    ISLA_GMSLA_040_01 <"2000 Standard">
    ISLA_GMSLA_040_02 <"2010/2018 Standard">
    ISLA_GMSLA_040_03 <"Hybrid">
    ISLA_GMSLA_041_01 <"Standard Costs and Expenses">
    ISLA_GMSLA_041_02 <"Limitation of Costs and Expenses">
    ISLA_GMSLA_041_03 <"Expansion of Costs and Expenses">
    ISLA_GMSLA_042_01 <"No Contractual Set-Off">
    ISLA_GMSLA_042_02 <"Simple Contractual Set-Off">
    ISLA_GMSLA_042_03 <"Set-Off with Unascertained Obligations Amendment">
    ISLA_GMSLA_043_01 <"Standard Paragraph 11.2(a)">
    ISLA_GMSLA_043_02 <"Amended Paragraph 11.2,(a) applies">
    ISLA_GMSLA_044_01 <"Consent">
    ISLA_GMSLA_044_02 <"Consent with Standard Exclusions">
    ISLA_GMSLA_044_03 <"Consent with Additional Exclusions">
    ISLA_GMSLA_044_04 <"Pre-approved Assignments">
    ISLA_GMSLA_045_01 <"Parties May Record All Conversations">
    ISLA_GMSLA_045_02 <"Parties Agree to Obtain Consent">
    ISLA_GMSLA_045_03 <"Parties Limit the Conversations that May be Recorded">
    ISLA_GMSLA_045_04 <"Submission as Evidence">
    ISLA_GMSLA_046_01 <"Standard Waiver of Immunity Applies">
    ISLA_GMSLA_046_02 <"Waiver of Immunity may Not Apply">
    ISLA_GMSLA_047_01 <"No Additional Documentation Required">
    ISLA_GMSLA_047_02 <"Additional Documentation Required">
    ISLA_GMSLA_048_01 <"Collateral Transfer Details not included">
    ISLA_GMSLA_048_02 <"Collateral Transfer Details included">
    ISLA_GMSLA_049_01 <"Confidentiality Clause">
    ISLA_GMSLA_049_02 <"Permitted Disclosure Clause">
    ISLA_GMSLA_050_01 <"Paragraph 20.1 Amended to Refer  Paragraph 6">
    ISLA_GMSLA_050_02 <"Paragraph 27.2 Amended to refer to the 2010 GMSLA">
    ISLA_GMSLA_051_01 <"MCTA  Delivery only">
    ISLA_GMSLA_051_02 <"MCTA  Delivery and Re-Delivery">
    ISLA_GMSLA_051_03 <"MCTA  Drops to Zero for a Defaulting Party">
    ISLA_GMSLA_052_01 <"No Non-Reliance Representation">
    ISLA_GMSLA_052_02 <"Non-Reliance Representation Added">
    ISLA_GMSLA_053_01 <"No Records and Statements Clause">
    ISLA_GMSLA_053_02 <"Records and Statements Clause Added">
    ISLA_GMSLA_054_01 <"Recovery and Resolution not Included">
    ISLA_GMSLA_054_02 <"Recovery and Resolution Included in GMSLA">
    ISLA_GMSLA_054_03 <"Recovery and Resolution Included by Protocol">
    ISLA_GMSLA_054_04 <"Recovery and Resolution Incorporated by Reference">
    ISLA_GMSLA_055_01 <"Security Agreement Details Included">
    ISLA_GMSLA_056_01 <"Triparty Services Not Referenced">
    ISLA_GMSLA_056_02 <"Triparty Services May Apply">


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-master-icma-type.rosetta
================================================================================

namespace cdm.legaldocumentation.master.icma
version "${project.version}"

import cdm.legaldocumentation.master.*

type GlobalMasterRepoAgreement extends MasterAgreementBase: <"The set of elections that define a GMRA">


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-master-isda-type.rosetta
================================================================================

namespace cdm.legaldocumentation.master.isda
version "${project.version}"

import cdm.base.*
import cdm.base.staticdata.party.*
import cdm.legaldocumentation.common.*
import cdm.legaldocumentation.csa.*
import cdm.legaldocumentation.master.*

corpus MasterAgreement "1998 Master Agreement" ISDA_MA_1998
corpus MasterAgreement "2002 Master Agreement" ISDA_MA_2002

segment section

type MasterAgreement extends MasterAgreementBase: <"The set of elections that define an ISDA Master Agreement.">
    automaticEarlyTermination AutomaticEarlyTermination (1..1) <"The specification of whether there is an automatic occurrence of an Early Termination Date in respect of Transactions upon the occurrence of certain bankruptcy / insolvency related events.">
    terminationCurrency TerminationCurrency (1..1) <"Specification of the currency in which the termination payment is made (including the process by which such currency is determined).">
    addressForNotices AddressForNotices (1..1) <"Specification of the address and other details for notices.">
    nonContractualObligations boolean (1..1) <"Specification of whether the Governing Law clause extends to Non-Contractual Obligations (True) or does not extend to Non-Contractual Obligations (False).">
    creditSupportDocument CreditSupportDocument (1..1) <"Identification of party specific Credit Support Documents applicable to the document.">
    creditSupportProvider CreditSupportProvider (1..1) <"Identification of party specific Credit Support Providers applicable to the document.">
    specifiedEntities SpecifiedEntities (4..4) <"A provision that allows each party to specify its Specified Entities for certain Events of Default and Termination Events.">

type AutomaticEarlyTermination: <"A class to specify the Automatic Early Termination provision applicable to a Master Agreement.">
    [docReference ISDA ISDA_MA_1998 section "6(a)"]
    [docReference ISDA ISDA_MA_2002 section "6(a)"]
    fallbackAET boolean (1..1) <"Specifies whether automatic termination applies in the event of certain bankruptcy events.">
    indemnity boolean (1..1) <"Specifies whether indemnity applies in the event AET is applicable to one or both of the parties.">
    partyElection AutomaticEarlyTerminationElection (0..2) <"The party election specific to the Automatic Early Termination Clause.">

    condition FallbackAET: <"The fallback Automatic Early Termination provision can only be specified as applicable if the Automatic Early Termination Clause is not applicable to one of the parties.">
        if fallbackAET = True
        then partyElection -> isApplicable all = False

    condition Indemnity: <"If Automatic Early Termination can never apply then indemnity cannot apply.">
        if fallbackAET = False and partyElection -> isApplicable all = False
        then indemnity = False

type AutomaticEarlyTerminationElection: <"A class to specify the party elections specific to the Automatic Early Termination Clause.">
    party Party (1..1) <"The party for which the Automatic Early Termination provisions are being specified.">
    isApplicable boolean (1..1) <"A boolean election to specify whether the Automatic Early Termination provisions of Section 6(a) are applicable (True) or not applicable (False).">

type TerminationCurrency: <"Specifies how the Termination Currency for the agreement will be determined.">
    statedTerminationCurrency TerminationCurrencySelection (0..1) <"Allows for specific Termination Currency(ies) and a fallback Termination Currency to be selected.">
    partyOptionTerminationCurrency PartyOptionTerminationCurrency (0..1) <"Provides that the Termination Currency will be determined by reference to a contractual mechanism when closing out the Agreement.">

type TerminationCurrencySelection: <"Specifies Termination Currency where a currency is stated at the time the agreement is entered into.">
    statedCurrency string (0..1) <"Specifies a single Termination Currency for the agreement.">
    fallbackCurrency string (0..1) <"Specifies a single fallback Termination Currency should the stated currency not be freely available.">
    partyElection PartyTerminationCurrencySelection (0..2) <"Specifies different termination currencies to apply depending on which party or parties are the Defaulting Party Affected Party(ies).">
    bothAffected string (0..1) <"Specifies fallback Termination Currency where both parties are Affected Parties.">

type PartyOptionTerminationCurrency: <"Specifies mechanism for Termination currency to be selected by the Non-defaulting Party/party which is not the Affected Party.">
    bothAffectedTermCurrencyOption string (0..1) <"Specifies termination currency where there are two Affected Parties and they cannot agree on the termination currency.">
    terminationCurrencySpecifiedCondition string (0..1) <"Specifies alternative conditions for selection of the termination currency.">
    terminationCurrencyCondition TerminationCurrencyConditionEnum (1..1) <"Specifies the enumerated conditions for selection of the termination currency.">

    condition TerminationCurrencyCondition: <"A validation rule to ensure that Termination Currency alternative conditions are specified when required.">
        if terminationCurrencyCondition = TerminationCurrencyConditionEnum -> Specified
        then terminationCurrencySpecifiedCondition exists

type PartyTerminationCurrencySelection: <"Specifies the termination currency to be used by a party when it is the Non-Defaulting Party or the Party which is not the Affected Party.">
    party Party (1..1) <"The elective party.">
    statedPartyCurrency string (1..1) <"Specifies termination Currency.">

type SpecifiedEntities: <"A provision that allows each party to specify its Specified Entities for certain Events of Default and Termination Events.">
    specifiedEntityClause SpecifiedEntityClauseEnum (1..1) <"The Event of Default or Termination event for which Specified Entities terms are being defined.">
    specifiedEntity SpecifiedEntity (2..2) <"The party specific election of Specified Entities for the Event of Default or Termination Event specified.">

type SpecifiedEntity: <"The party specific election of Specified Entities for the Event of Default or Termination Event specified.">
    party Party (1..1) <"The elective party.">
    specifiedEntityTerms SpecifiedEntityTermsEnum (1..1) <"The specified entity terms for the Event of Default or Termination Event specified.">
    specifiedEntity LegalEntity (0..*) <"The specified entities for the Event of Default or Termination Event specified.">
    materialSubsidiaryTerms string (0..1) <"The meaning of Material Subsidiary for the Event of Default or Termination Event specified.">
    otherSpecifiedEntityTerms string (0..1) <"The non standard terms for the Event of Default or Termination Event specified.">

    condition SpecifiedEntity: <"A validation rule to ensure that a SpecifiedEntity is specified when required.">
        if specifiedEntityTerms = SpecifiedEntityTermsEnum -> NamedSpecifiedEntity
        then specifiedEntity exists

    condition MaterialSubsidiary: <"A validation rule to ensure that Material Subsidiary terms are specified when required.">
        if specifiedEntityTerms = SpecifiedEntityTermsEnum -> MaterialSubsidiary
        then materialSubsidiaryTerms exists

    condition OtherSpecifiedEntity: <"A validation rule to ensure that non standard Specified Entity terms are provided when required.">
        if specifiedEntityTerms = SpecifiedEntityTermsEnum -> OtherSpecifiedEntity
        then otherSpecifiedEntityTerms exists


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-master-isla-type.rosetta
================================================================================

namespace cdm.legaldocumentation.master.isla
version "${project.version}"

import cdm.legaldocumentation.master.*

type GlobalMasterSecuritiesLendingAgreement extends MasterAgreementBase: <"The set of elections that define a GMSLA.">


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-master-type.rosetta
================================================================================

namespace cdm.legaldocumentation.master : <"Master agreement concepts.">
version "${project.version}"

import cdm.base.staticdata.party.*
import cdm.legaldocumentation.master.icma.* as icma
import cdm.legaldocumentation.master.isda.* as isda
import cdm.legaldocumentation.master.isla.* as isla

type MasterAgreementSchedule: <"The set of elections which specify a Master Agreement.">
    clause MasterAgreementClause (1..*) <"Clauses that have had elections made against them in this Master Agreement. There must be at least one clause defined in the agreement.">

type MasterAgreementClause: <"Defines clauses that make up a Master Agreement.">
    identifer MasterAgreementClauseIdentifierEnum (1..1) <"Unique identifier for the clause.">
    name string (0..1) <"Optional textual description of the clause.">
    counterparty CounterpartyRoleEnum (0..2) <"Optional counterparty role. This can be used where a clause needs to be assigned to a specific party on the agreement based upon their role i.e. Party A or Party B.">
    otherParty PartyRoleEnum (0..*) <"Optional party. This can be required for umbrella agreements where a clause may need to be assigned to a specific party who may or may not be on the agreement.">
    variant MasterAgreementClauseVariant (1..*) <"Allows multiple variants to be defined for a clause. This needs to be an array as some clauses can specify different variants for different parties. At least one variant must be specified for a clause.">

type MasterAgreementClauseVariant: <"Sets the details for a specific variant associated to a clause in a Master Agreement.">
    identifier MasterAgreementVariantIdentifierEnum (1..1) <"Unique identifier for this variant.">
    name string (0..1) <"Optional textual description of the variant.">
    counterparty CounterpartyRoleEnum (0..2) <"Optional counterparty role. This can be used where a clause needs to assign a different variant to the different parties on the agreement based upon their role i.e. Party A or Party B.">
    otherParty PartyRoleEnum (0..*) <"Optional party. This can be used where a clause needs to assign different variants to different parties who may or may not be on the agreement.">
    variableSet MasterAgreementVariableSet (0..*) <"For some variants of some clauses additional details are required to work out what has been elected. This array can be used to define the name and value of these variables. Please refer to the agreement documentation for more details of the variables that are available for any clause.">

type MasterAgreementVariableSet: <"Defines a type where additional variables associated to clauses and their variants can be described.">
    variableSet MasterAgreementVariableSet (0..*) <"For some variants a table of variables is required. To support this use case we need to be able to specify variables within variables. Including a variable set here gives us infinite nesting opportunities - realistically we are only ever expecting that a table would need to be defined for any particular clause, so we would expect two levels of nesting as a maximum i.e. variableSet->variableSet->name/value.">
    name string (0..1) <"The name of the variable.">
    value string (0..1) <"The value for this variable.">

    condition VariableSetExists: <"If we have a variableSet then we must not have any name/value pairs at this level.">
        if variableSet exists then name is absent and value is absent

    condition VariableSetNesting: <"We are only allowing two levels of nesting of variableSet for the time being. This is because we only need to support tables of data in the master agreement variants. This condition can be modified or deleted if we find we need more levels of nesting.">
        if variableSet -> variableSet exists
        then variableSet -> variableSet -> variableSet is absent

    condition NameMustExist: <"If we have a name then we must also have a value.">
        if name exists then value exists

    condition ValueMustExist: <"If we have a value then we must also have a name.">
        if value exists then name exists

type MasterAgreementBase: <"A set of elections that can be shared across master agreement types - this should be built upon for specific contracts.">

type MasterAgreementElections: <"A representation of a master agreement extended from a base agreement of shared elections.">
    islaGmsla isla.GlobalMasterSecuritiesLendingAgreement (0..1) <"The set of elections that define a GMSLA.">
    icmaGmra icma.GlobalMasterRepoAgreement (0..1) <"The set of elections that define a GMRA.">
    isdaMaster isda.MasterAgreement (0..1) <"The set of elections that define an ISDA Master Agreement.">
    condition:
        one-of


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-transaction-additionalterms-enum.rosetta
================================================================================

namespace cdm.legaldocumentation.transaction.additionalterms
version "${project.version}"

import cdm.base.*

enum DeterminationRoleEnum: <"Defines the enumerated values to specify the determination roles to the transaction. Such roles mostly address any determination that would be required when some Extraordinary Events would happen, for instance qualifying the effectiveness of such event, or when a calculation is required, etc. else any other kind of determination as need be.">
    CalculationAgent <"Specifies the party responsible for performing calculation agent duties as defined in the applicable product definition. As an indication, the role of Calculation Agent is key in regards of other roles, for mainly two reasons : first is that it is a fallback role i.e. whenever another role is not defined, then such role would be assumed by the Calculation Agent ; second is that related determination are not limited to Extraordinary Event per se i.e. any determinationr required in regards of Payout calculations for instance would fall on Calculation Agent, unless otherwise specified in Calculation Agent attached to Economic Terms.">
    HedgingParty <"Specifies the party responsible for performing related HedgingParty duties as defined in the applicable product definition, notably in regards of particular Extraordinary Events or Price Determination Methods which involve hedging considerations.">
    DeterminingParty <"Specifies the party responsible for performing related HedgingParty duties as defined in the applicable product definition, notably in regards of particular Disruption Events or Early Termination Terms which may involve the calculation of a liquidation or compensation value amount.">

enum FxIllegalityOrImpossibilityEnum: <"The enumerated values to specify whether such terms i.e. Illegality or Impossibility shall be treated either as defined per the documents applicable to the FX transaction.">
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(c).(i)"]
    ToBeTreatedAsDisruptionEvent
    ToBeTreatedAsIllegalityOrImpossibility

enum FxForceMajeureOrActOfSStateEnum: <"The enumerated values to specify whether such terms i.e. Force Majeure or Act Of State shall be treated either as defined per the documents applicable to the FX transaction.">
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(c).(ii)"]
    ToBeTreatedAsDisruptionEvent
    ToBeTreatedAsForceMajeureOrActOfSState

enum SpecifiedValueEnum:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.4.(w)"]
    OutstandingPrincipalBalance
    StatedPrincipalBalance
    FaceValue
    MarketValue

enum FxSubstitutionProvisionTypeEnum:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)"]
    LocalAssetSubstituteGross
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vi)"]
    LocalAssetSubstituteNet
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vii)"]
    LocalCurrencySubstitute
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(viii)"]


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-transaction-additionalterms-type.rosetta
================================================================================

namespace cdm.legaldocumentation.transaction.additionalterms
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.party.*
import cdm.legaldocumentation.transaction.*
import cdm.observable.asset.*
import cdm.observable.event.*

corpus Confirmation "2018 ISDA CDM Equity Confirmation for Security Equity Swap" SecurityEquitySwapConfirmation_2018
corpus Definitions "1998 FX and Currency Option Definitions" FXandCurrencyOptionsDefintions_1998
corpus Definitions "2002 ISDA Equity Derivatives Definitions" EquityDerivativesDefinitions_2002

segment section
segment paragraph
segment exhibit
segment clause
segment name

type FxAdditionalTerms: <"TransactionAdditionalTerms which apply to the CurrencyPair asset class.">
    disruptionEvents FxDisruptionEvents (0..1)
    determinationTerms DeterminationRolesAndTerms (0..1)
    noFaultTermination boolean (0..1)

    condition SpecificDeterminationRetrictionsForFx:
        determinationTerms -> determinationRole = DeterminationRoleEnum -> CalculationAgent

    condition NoFaultTerminationOrDisruptionTerms:
        (disruptionEvents exists and noFaultTermination is absent or noFaultTermination = False)
            or (disruptionEvents is absent and noFaultTermination = True)

type Representations:
    nonReliance boolean (1..1) <"If true, then non reliance is applicable.">
    agreementsRegardingHedging boolean (1..1) <"If true, then agreements regarding hedging are applicable.">
    indexDisclaimer boolean (0..1) <"If present and true, then index disclaimer is applicable.">
    additionalAcknowledgements boolean (0..1) <"If true, then additional acknowledgements are applicable.">
    additionalBespokeTerms Clause (0..*)

type IndexAdjustmentEvents: <"Defines the specification of the consequences of Index Events">
    [docReference ISDA EquityDerivativesDefinitions_2002]
    indexModification IndexEventConsequenceEnum (1..1) <"Consequence of index modification.">
    indexCancellation IndexEventConsequenceEnum (1..1) <"Consequence of index cancellation.">
    indexDisruption IndexEventConsequenceEnum (1..1) <"Consequence of index disruption.">

type DeterminationRolesAndTerms: <"Defines the roles and related terms which document the agreement of parties about any determination requirements ; mostly about Extraordinary Events, without being necessarily restricted to such scope, as further specified in the particular product at stake e.g. for instance when Calculation Agent is mentioned as the Price Determination Method enumarated value, etc.">
    determinationRole DeterminationRoleEnum (1..1) <"Defines the enumerated values to specify the determination roles to the transaction. Such roles mostly address any determination that would be required when some Extraordinary Events would happen, for instance qualifying the effectiveness of such event, or when a calculation is required, etc. else any other kind of determination as need be. Yet for clarity, other kinds of determination may be covered by such roles, which are not necessarily restricted to the scope of Extarordinary Events, depending on particular product specifications e.g. for instance when Calculation Agent is mentioned as the Price Determination Method enumarated value, etc.">
    whoToDetermine CounterpartyRoleEnum (1..2) <"Designates which Counterparty to the transaction is granted with the particular role ; cardinality of this object is 2, in case parties are both having the same role e.g. jointly CalculationAgent, jointly Determining Party, etc. ">
    disputingParty CounterpartyRoleEnum (0..1) <"Where the party who is not granted with the determination role at least has a right to dispute the determination given by the counterparty with such role. As an example, a given PartyA is the unique Counterparty with the Role of CalculationAgent, yet Party B could be Disputing Party in regard of such Role.">
    fallbackLanguageBespokeTerms Clause (0..1) <"Where parties may optionnaly describe any extra bespoke agreements about fallback procedure attached to a particular determination role. This fallback bespoke paragraph would typically address topics such as : delay for the Disputing Party to notify a disagreement when receiving a determination from the Calculation Agent ; Independent Third Party Dealers election terms e.g. number of Dealers to be jointly elected by the counterparties ; delay for joint election of Dealers by the counterparties ; further fallback election procedure in case of disagreement between parties to jointly elect all the Dealers e.g. typically each party designates 1 Dealer, each a Party Representant, which thus result in 2 Dealers in charge of joint election of 3 other Dealers who will be the final ones to provide the response, each a Final Dealer ; delay for joint election of the Final Dealers by the Party Representants ; fees repartition e.g. typically cost and fees incurred by the election of Dealers are equally shared by the parties ; etc.">

    condition DisputingPartyCannotHaveOriginalRole:
        whoToDetermine all <> disputingParty

type EquityCorporateEvents: <"A class for defining the merger events and their treatment.">
    [docReference ISDA SecurityEquitySwapConfirmation_2018]
    shareForShare ShareExtraordinaryEventEnum (1..1) <"Shall occur if a Merger Event occurs and the consideration for the relevant Security consists solely of Combined Consideration.">
    shareForOther ShareExtraordinaryEventEnum (1..1) <"Shall occur if a Merger Event occurs and the consideration for the relevant Security consists solely of Other Consideration.">
    shareForCombined ShareExtraordinaryEventEnum (1..1) <"Shall occur if a Merger Event occurs and the consideration for the relevant Security consists solely of Combined Consideration.">

type FxDisruptionEvents: <"Additional Provisions for a Confirmation of an FX or Currency Option Transaction">
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 exhibit "II-E"]
    illegalityOrImpossibility FxIllegalityOrImpossibilityEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(c).(i)"]
    forceMajeureOrActOfSState FxForceMajeureOrActOfSStateEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(c).(ii)"]
    eventCurrency EventCurrency (0..1) <"Additional Provisions for a Confirmation of an FX or Currency Option Transaction.">
        [docReference ISDA FXandCurrencyOptionsDefintions_1998]
    priceSourceDisruption FxPriceSourceDisruption (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(xi)"]
    benchmarkObligationDefault FxBenchmarkObligationDefault (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(i)"]
    dualExchangeRate FxDualExchangeRate (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(ii)"]
    inconvertibilityOrNonTransferability FxInconvertibilityOrNonTransferability (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(vii)"]
    governmentalAuthorityDefault GovernmentalAuthorityDefault (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(v)"]
    illiquidity Illiquidity (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(vi)"]
    materialChangeInCircumstance MaterialChangeInCircumstance (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(viii)"]
    nationalization Nationalization (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(ix)"]
    priceMateriality PriceMateriality (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(x)"]
    fallbackLanguageBespokeTerms Clause (0..1) <"Where parties may optionaly describe any extra bespoke agreements about fallback procedure attached to a particular determination role.">

type GovernmentalAuthorityDefault:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(v)"]
    governmentalAuthorityDefaultIsApplicable boolean (1..1)
    escrowArrangement EscrowArrangement (0..1)
    localSubstituteProvisionType FxSubstitutionProvisionTypeEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vi)" paragraph "(vii)" paragraph "(viii)"]
    specifiedValue SpecifiedValueEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.4.(w)"]
    maximumDaysOfDisruption ValuationPostponement (0..1)

type Illiquidity: 
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(vi)"]
    illiquidityIsApplicable boolean (1..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(vi)"]
    escrowArrangement EscrowArrangement (0..1)
    minimumAmount Quantity (0..1)
    fallbackReferencePrice SettlementRateOption (0..1) <"The method, prioritised by the order it is listed in this element, to get a replacement rate for the disrupted settlement rate option.">
    illiquidityValuationDate AdjustedRelativeDateOffset (0..1)

type MaterialChangeInCircumstance:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(viii)"]
    materialChangeInCircumstanceIsApplicable boolean (1..1)
    escrowArrangement EscrowArrangement (0..1)
    maximumDaysOfDisruption ValuationPostponement (0..1)

type Nationalization:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(ix)"]
    nationalizationIsApplicable boolean (1..1)
    relevantAffiliate AncillaryEntity (0..*)
    escrowArrangement EscrowArrangement (0..1)
    assignmentOfClaim boolean (0..1)
    maximumDaysOfDisruption ValuationPostponement (0..1)

    condition AssignmentOfClaim:
        if nationalizationIsApplicable = False
        then assignmentOfClaim is absent

type PriceMateriality:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(x)"]
    priceMaterialityIsApplicable boolean (1..1)
    escrowArrangement EscrowArrangement (0..1)
    fallbackReferencePrice SettlementRateOption (0..1) <"The method, prioritised by the order it is listed in this element, to get a replacement rate for the disrupted settlement rate option.">

type FxPriceSourceDisruption:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(xi)"]
    priceSourceDisruptionIsApplicable boolean (1..1)
    fallbackReferencePrice SettlementRateOption (0..1) <"The method, prioritised by the order it is listed in this element, to get a replacement rate for the disrupted settlement rate option.">
    escrowArrangement EscrowArrangement (0..1)

type FxBenchmarkObligationDefault:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(i)"]
    benchmarkObligationDefaultIsApplicable boolean (1..1)
    localSubstituteProvisionType FxSubstitutionProvisionTypeEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vi)" paragraph "(vii)" paragraph "(viii)"]
    specifiedValue SpecifiedValueEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.4.(w)"]
    escrowArrangement EscrowArrangement (0..1)

type FxDualExchangeRate:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(ii)"]
    dualExchangeRateIsApplicable boolean (1..1)
    fallbackReferencePrice FallbackReferencePrice (0..1) <"The method, prioritised by the order it is listed in this element, to get a replacement rate for the disrupted settlement rate option.">
    escrowArrangement EscrowArrangement (0..1)

type FxInconvertibilityOrNonTransferability:
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(vii)"]
    generalInconvertibility GeneralInconvertibility (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(iii)"]
    generalNonTransferability GeneralNonTransferability (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(iv)"]
    specificInconvertibility SpecificInconvertibility (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(xii)"]
    specificNonTransferability SpecificNonTransferability (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.1.(d).(xiii)"]

type GeneralInconvertibility:
    generalInconvertibilityIsApplicable boolean (1..1)
    localSubstituteProvisionType FxSubstitutionProvisionTypeEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vi)" paragraph "(vii)" paragraph "(viii)"]
    maximumDaysOfDisruption ValuationPostponement (0..1) <"Specifies how long to wait to get a quote from a settlement rate option upon a price source disruption.">
    nonDeliverableSubstitute NonDeliverableSubstitute (0..1)
    escrowArrangement EscrowArrangement (0..1) <"Refers to the segregation deposit procedure parties may want to commmit into during the time a Disruption Event is effective">
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c).(iv)"]

    condition SettlementPostponementExistence:
        if localSubstituteProvisionType = FxSubstitutionProvisionTypeEnum -> LocalCurrencySubstitute
        then maximumDaysOfDisruption exists

    condition SubstituteTermsChoice:
        if localSubstituteProvisionType exists
        then nonDeliverableSubstitute is absent
                or if nonDeliverableSubstitute exists
                    then localSubstituteProvisionType is absent

type GeneralNonTransferability:
    generalNonTransferabilityIsApplicable boolean (1..1)
    localSubstituteProvisionType FxSubstitutionProvisionTypeEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vi)" paragraph "(vii)" paragraph "(viii)"]
    maximumDaysOfDisruption ValuationPostponement (0..1) <"Specifies how long to wait to get a quote from a settlement rate option upon a price source disruption.">
    nonDeliverableSubstitute NonDeliverableSubstitute (0..1)
    escrowArrangement EscrowArrangement (0..1) <"Refers to the segregation deposit procedure parties may want to commmit into during the time a Disruption Event is effective">
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c).(iv)"]

    condition SettlementPostponementExistence:
        if localSubstituteProvisionType = FxSubstitutionProvisionTypeEnum -> LocalCurrencySubstitute
        then maximumDaysOfDisruption exists

    condition SubstituteTermsChoice:
        if localSubstituteProvisionType exists
        then nonDeliverableSubstitute is absent
                or if nonDeliverableSubstitute exists
                    then localSubstituteProvisionType is absent

type SpecificInconvertibility:
    specificInconvertibilityIsApplicable boolean (1..1)
    minimumAmount Quantity (0..1)
    relevantClass string (0..*)
    localSubstituteProvisionType FxSubstitutionProvisionTypeEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vi)" paragraph "(vii)" paragraph "(viii)"]
    maximumDaysOfDisruption ValuationPostponement (0..1) <"Specifies how long to wait to get a quote from a settlement rate option upon a price source disruption.">
    nonDeliverableSubstitute NonDeliverableSubstitute (0..1)
    escrowArrangement EscrowArrangement (0..1) <"Refers to the segregation deposit procedure parties may want to commmit into during the time a Disruption Event is effective">
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c).(iv)"]

    condition SettlementPostponementExistence:
        if localSubstituteProvisionType = FxSubstitutionProvisionTypeEnum -> LocalCurrencySubstitute
        then maximumDaysOfDisruption exists

    condition SubstituteTermsChoice:
        if localSubstituteProvisionType exists
        then nonDeliverableSubstitute is absent
                or if nonDeliverableSubstitute exists
                    then localSubstituteProvisionType is absent

type SpecificNonTransferability:
    specificNonTransferabilityIsApplicable boolean (1..1)
    relevantClass string (0..*)
    localSubstituteProvisionType FxSubstitutionProvisionTypeEnum (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c)" paragraph "(vi)" paragraph "(vii)" paragraph "(viii)"]
    maximumDaysOfDisruption ValuationPostponement (0..1)
    nonDeliverableSubstitute NonDeliverableSubstitute (0..1)
    escrowArrangement EscrowArrangement (0..1)
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c).(iv)"]

    condition SettlementPostponementExistence:
        if localSubstituteProvisionType = FxSubstitutionProvisionTypeEnum -> LocalCurrencySubstitute
        then maximumDaysOfDisruption exists

    condition SubstituteTermsChoice:
        if localSubstituteProvisionType exists
        then nonDeliverableSubstitute is absent
                or if nonDeliverableSubstitute exists
                    then localSubstituteProvisionType is absent

type EscrowArrangement: <"Refers to the segregation deposit procedure parties may want to commmit into during the time a Disruption Event is effective">
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.2.(c).(iv)"]
    escrowArrangementIsApplicable boolean (1..1)
    maximumDaysOfDisruption ValuationPostponement (0..1)
    bespokeEscrowArrangements Clause (0..1)

    condition SettlementPostponementExistence:
        if escrowArrangementIsApplicable = False
        then maximumDaysOfDisruption is absent
                and if escrowArrangementIsApplicable = True
                    then maximumDaysOfDisruption exists

type EventCurrency: <"Defines the currency referenced as such in any terms related to FX Disruption Events">
    [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.4.(c)"]
    eventCurrency string (1..1) <"Defines the currency referenced as such in any terms related to FX Disruption Events">
        [docReference ISDA FXandCurrencyOptionsDefintions_1998 section "5.4.(c)"]
        [metadata scheme]
    eventCurrentAmount Quantity (0..1) <"Defines the Event Currency Amount to be exchanged on the Settlement Date.">
    eventCurrencyBuyerSeller BuyerSeller (0..2) <"Unless otherwised specified, the Buyer is the party to which the Event Currency Amount is owed on the Settlement Date and the Seller is the party which owes the Event Currency Amount on the Settlement Date.">

type NonDeliverableSubstitute:
    nonDeliverableSubstituteIsApplicable boolean (1..1)
    valuationDate AdjustedRelativeDateOffset (0..1)
    settlementDate AdjustedRelativeDateOffset (0..1)
    settlementRateOption SettlementRateOption (0..1)


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-transaction-enum.rosetta
================================================================================

namespace cdm.legaldocumentation.transaction
version "${project.version}"

enum BrokerConfirmationTypeEnum: <"The enumerated values to specify the type of Broker Confirm that the FpML trade represents.">
    ABX <"Broker Confirmation Type representing ABX index trades.">
    AsiaCorporate <"Broker Confirmation Type of Asia Corporate.">
    AsiaSovereign <"Broker Confirmation Type of Asia Sovereign.">
    AustraliaCorporate <"Broker Confirmation Type of Australia Corporate.">
    AustraliaSovereign <"Broker Confirmation Type of Australia Sovereign.">
    CDSonLeveragedLoans <"Broker Confirmation Type for use with Credit Derivative Transactions on Leveraged Loans.">
    CDSonMBS <"Broker Confirmation Type for use with Credit Derivative Transactions on Mortgage-backed Security with Pay-As-You-Go or Physical Settlement.">
    CDXEmergingMarkets <"Broker Confirmation Type for CDX Emerging Markets Untranched Transactions.">
    CDXEmergingMarketsDiversified <"Broker Confirmation Type for CDX Emerging Markets Diversified Untranched Transactions.">
    CDXSwaption <"Broker Confirmation Type for CDX Swaption Transactions.">
    CDXTranche <"Broker Confirmation Type for Dow Jones CDX Tranche Transactions.">
    CMBX <"Broker Confirmation Type representing CMBX index trades.">
    DJ_CDX_EM_ displayName "DJ.CDX.EM " <"Broker Confirmation Type for CDS Index trades relating to Dow Jones CDX.EM index series.">
    DJ_CDX_NA displayName "DJ.CDX.NA" <"Broker Confirmation Type for CDS Index trades relating to Dow Jones CDX.NA.IG and Dow Jones CDX.NA.HY index series.">
    EmergingEuropeanAndMiddleEasternSovereign <"Broker Confirmation Type of Emerging European and Middle Eastern Sovereign.">
    EmergingEuropeanCorporate <"Broker Confirmation Type for EMERGING EUROPEAN CORPORATE.">
    EmergingEuropeanCorporateLPN <"Broker Confirmation Type for EMERGING EUROPEAN CORPORATE LPN.">
    EuropeanCMBS <"Broker Confirmation Type for Single Name European CMBS Transactions.">
    EuropeanCorporate <"Broker Confirmation Type of European Corporate.">
    EuropeanRMBS <"Broker Confirmation Type for Single Name European RMBS Transactions.">
    JapanCorporate <"Broker Confirmation Type of Japan Corporate.">
    JapanSovereign <"Broker Confirmation Type of Japan Sovereign.">
    LatinAmericaCorporate <"Broker Confirmation Type of Latin America Corporate.">
    LatinAmericaCorporateBond <"Broker Confirmation Type for LATIN AMERICA CORPORATE B.">
    LatinAmericaCorporateBondOrLoan <"Broker Confirmation Type for LATIN AMERICA CORPORATE BL.">
    LatinAmericaSovereign <"Broker Confirmation Type of Latin America Sovereign.">
    MBX <"Broker Confirmation Type for MBX Transactions.">
    MCDX <"Broker Confirmation Type for Municipal CDX Untranched Transactions.">
    NewZealandCorporate <"Broker Confirmation Type of New Zealand Corporate.">
    NewZealandSovereign <"Broker Confirmation Type of New Zealand Sovereign.">
    NorthAmericanCorporate <"Broker ConfirmationType of North American Corporate.">
    PO <"Broker Confirmation Type for PO Index Transactions.">
    SingaporeCorporate <"Broker Confirmation Type of Singapore Corporate.">
    SingaporeSovereign <"Broker Confirmation Type of Singapore Sovereign.">
    StandardAsiaCorporate <"Broker Confirmation Type of STANDARD ASIA CORPORATE.">
    StandardAsiaSovereign <"Broker Confirmation Type of STANDARD ASIA SOVEREIGN.">
    StandardAustraliaCorporate <"Broker Confirmation Type of STANDARD AUSTRALIA CORPORATE.">
    StandardAustraliaSovereign <"Broker Confirmation Type of STANDARD AUSTRALIA SOVEREIGN.">
    StandardCDXTranche <"Broker Confirmation Type for Standard CDX Tranche Transactions.">
    StandardEmergingEuropeanAndMiddleEasternSovereign <"Broker Confirmation Type of STANDARD EMERGING EUROPEAN AND MIDDLE EASTERN SOVEREIGN.">
    StandardEmergingEuropeanCorporate <"Broker Confirmation Type of STANDARD EMERGING EUROPEAN CORPORATE.">
    StandardEmergingEuropeanCorporateLPN <"Broker Confirmation Type of STANDARD EMERGING EUROPEAN CORPORATE LPN.">
    StandardEuropeanCorporate <"Broker Confirmation Type for STANDARD EUROPEAN CORPORATE.">
    StandardJapanCorporate <"Broker Confirmation Type of STANDARD JAPAN CORPORATE.">
    StandardJapanSovereign <"Broker Confirmation Type of STANDARD JAPAN SOVEREIGN.">
    StandardLCDS <"Standard Syndicated Secured Loan Credit Default Swap Broker Confirmation Type.">
    StandardLCDSBullet <"Broker Confirmation Type for Standard Syndicated Secured Loan Credit Default Swap Bullet Transactions.">
    StandardLCDXBullet <"Broker Confirmation Type for Standard Syndicated Secured Loan Credit Default Swap Index Bullet Transactions.">
    StandardLCDXBulletTranche <"Broker Confirmation Type for Standard Syndicated Secured Loan Credit Default Swap Index Bullet Tranche Transactions.">
    StandardLatinAmericaCorporateBond <"Broker Confirmation Type of STANDARD LATIN AMERICA CORPORATE B.">
    StandardLatinAmericaCorporateBondOrLoan <"Broker Confirmation Type of STANDARD LATIN AMERICA CORPORATE BL.">
    StandardLatinAmericaSovereign <"Broker Confirmation Type of STANDARD LATIN AMERICA SOVEREIGN.">
    StandardNewZealandCorporate <"Broker Confirmation Type of STANDARD NEW ZEALAND CORPORATE.">
    StandardNewZealandSovereign <"Broker Confirmation Type of STANDARD NEW ZEALAND SOVEREIGN.">
    StandardNorthAmericanCorporate <"Broker Confirmation Type for STANDARD NORTH AMERICAN CORPORATE.">
    StandardSingaporeCorporate <"Broker Confirmation Type of STANDARD SINGAPORE CORPORATE.">
    StandardSingaporeSovereign <"Broker Confirmation Type of STANDARD SINGAPORE SOVEREIGN.">
    StandardSubordinatedEuropeanInsuranceCorporate <"Broker Confirmation Type for STANDARD SUBORDINATED EUROPEAN INSURANCE CORPORATE.">
    StandardWesternEuropeanSovereign <"Broker Confirmation Type for STANDARD WESTERN EUROPEAN SOVEREIGN.">
    StandardiTraxxEuropeTranche <"Broker Confirmation Type for Standard iTraxx Europe Tranched Transactions.">
    SubordinatedEuropeanInsuranceCorporate <"Broker Confirmation Type of Subordinated European Insurance Corporate.">
    SukukCorporate <"Broker Confirmation Type of SUKUK CORPORATE.">
    SukukSovereign <"Broker Confirmation Type of SUKUK SOVEREIGN.">
    SyndicatedSecuredLoanCDS <"Syndicated Secured Loan Credit Default Swap Broker Confirmation Type.">
    TRX <"Broker Confirmation Type for TRX Transactions.">
    TRX_II displayName "TRX.II" <"Broker Confirmation Type for TRX.II Transactions.">
    USMunicipalFullFaithAndCredit <"Broker Confirmation Type for U.S. MUNICIPAL FULL FAITH AND CREDIT.">
    USMunicipalGeneralFund <"Broker Confirmation Type for U.S. MUNICIPAL GENERAL FUND.">
    USMunicipalRevenue <"Broker Confirmation Type for U.S. MUNICIPAL REVENUE.">
    WesternEuropeanSovereign <"Broker Confirmation Type of Western European Sovereign.">
    iTraxxAsiaExJapan <"Broker Confirmation Type for iTraxx Asia Excluding Japan.">
    iTraxxAsiaExJapanSwaption <"Broker Confirmation Type for iTraxx Asia Ex-Japan Swaption Transactions.">
    iTraxxAsiaExJapanTranche <"Broker Confirmation Type for iTraxx Asia Excluding Japan Tranched Transactions.">
    iTraxxAustralia <"Broker Confirmation Type for iTraxx Australia.">
    iTraxxAustraliaSwaption <"Broker Confirmation Type for iTraxx Australia Swaption Transactions.">
    iTraxxAustraliaTranche <"Broker Confirmation Type for iTraxx Australia Tranched Transactions.">
    iTraxxCJ <"Broker Confirmation Type for iTraxx CJ.">
    iTraxxCJTranche <"Broker Confirmation Type for iTraxx CJ Tranched Transactions.">
    iTraxxEurope <"Broker Confirmation Type for iTraxx Europe Transactions">
    iTraxxEuropeSwaption <"Broker Confirmation Type for iTraxx Europe Swaption Transactions.">
    iTraxxEuropeTranche <"Broker Confirmation Type for iTraxx Europe Tranched Transactions.">
    iTraxxJapan <"Broker Confirmation Type for iTraxx Japan.">
    iTraxxJapanSwaption <"Broker Confirmation Type for iTraxx Japan Swaption Transactions.">
    iTraxxJapanTranche <"Broker Confirmation Type for iTraxx Japan Tranched Transactions.">
    iTraxxLevX <"Broker Confirmation Type for iTraxx LevX.">
    iTraxxSDI75 <"Broker Confirmation Type for iTraxx SDI 75 Transactions.">
    iTraxxSovX <"Broker Confirmation Type for iTraxx SovX.">


================================================================================
FILE: rosetta-source/src/main/rosetta/legaldocumentation-transaction-type.rosetta
================================================================================

namespace cdm.legaldocumentation.transaction
version "${project.version}"

import cdm.base.*
import cdm.base.staticdata.party.*
import cdm.legaldocumentation.master.*
import cdm.legaldocumentation.transaction.additionalterms.*
import cdm.observable.asset.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*

corpus Confirmation "2018 ISDA CDM Equity Confirmation for Security Equity Swap" SecurityEquitySwapConfirmation_2018
corpus Definitions "2002 ISDA Equity Derivatives Definitions" EquityDerivativesDefinitions_2002

segment section
segment paragraph
segment exhibit
segment name

type TransactionAdditionalTerms: <"Additional specification for the extraordinary events that may affect a trade and the related contractual rights and obligation of the parties when this happens. Such terms are typically required to extend the economics terms, for the purpose of producing the final legal contractual form of the Transaction.">
    equityAdditionalTerms EquityAdditionalTerms (0..1)
    foreignExchangeAdditionalTerms FxAdditionalTerms (0..1)
    commoditiesAdditionalTerms string (0..1)
    creditAdditionalTerms string (0..1)
    interestRateAdditionalTerms string (0..1)
    digitalAssetAdditionalTerms string (0..1)

type EquityAdditionalTerms: <"Transaction AdditionalTerms that apply to Equity asset class.">
    extraordinaryEvents ExtraordinaryEvents (0..1)
    determinationTerms DeterminationRolesAndTerms (1..*)
    substitutionProvision UnderlierSubstitutionProvision (0..1)

type UnderlierSubstitutionProvision: <"Where parties describe any substitution terms.">
    whoMaySubstitute CounterpartyRoleEnum (1..2) <"Designates which Counterparty to the transaction who has the right to trigger a substitution or to provide related determination e.g. for instance to qualify the effectiveness of an Event which may be a trigger for substitution, determine the replacement Share to substitute, etc. ; cardinality of this object is 2, in case parties jointly have this role.">
    substitutionBeSpokeTerms Clause (0..*) <"Where parties describe any substitution terms e.g. for instance the election criteria for an Asset to be eligible as the Substitute Asset to the prior Affected Asset in terms of sector of activity, currency, market capitalisation, liquidity, volatility, or any additional features that parties would agree to take into considerations, etc.">
    substitutionTriggerEvents ExtraordinaryEvents (0..*) <"Where the parties may optionnally explictly specify the list of Events to be considered as a trigger for a Substitution.">
    disputingParty CounterpartyRoleEnum (0..1) <"Where the party who is not granted with the substitution role at least has a right to dispute the determination given by the counterparty with such role. As an example, a given PartyA is the unique Counterparty with the Role of WhoMaySubstitute, yet PartyB could be Disputing Party in regard of such Role.">

    condition DisputingPartyCannotHaveOriginalRole:
        whoMaySubstitute all <> disputingParty

type ExtraordinaryEvents: <"Where the underlying is shares, defines market events affecting the issuer of those shares that may require the terms of the transaction to be adjusted.">
    [docReference ISDA SecurityEquitySwapConfirmation_2018]
    [docReference ISDA EquityDerivativesDefinitions_2002]
    additionalBespokeTerms Clause (0..*) <"Where parties may optionnaly describe any extra bespoke agreements, in regards of the standardized Extraordinary Events.">
    mergerEvents EquityCorporateEvents (0..1)
    tenderOfferEvents EquityCorporateEvents (0..1)
    compositionOfCombinedConsideration boolean (0..1)
    indexAdjustmentEvents IndexAdjustmentEvents (0..1)
        [docReference ISDA EquityDerivativesDefinitions_2002 section "Adjustment to Indices"]
    additionalDisruptionEvents AdditionalDisruptionEvents (0..1)
    failureToDeliver boolean (0..1) <"If true, failure to deliver is applicable.">
    representations Representations (0..1)
    nationalizationOrInsolvency NationalizationOrInsolvencyOrDelistingEventEnum (0..1)
    delisting NationalizationOrInsolvencyOrDelistingEventEnum (0..1)

    condition ExtraordinaryEventsChoice: <"condition to represent an FpML choice construct.">
        required choice additionalDisruptionEvents, failureToDeliver

type AdditionalDisruptionEvents: <"A type for defining the Additional Disruption Events.">
    [docReference ISDA EquityDerivativesDefinitions_2002]
    changeInLaw boolean (0..1)
    failureToDeliver boolean (0..1)
    insolvencyFiling boolean (0..1)
    hedgingDisruption boolean (0..1)
    increasedCostOfHedging boolean (0..1)
    foreignOwnershipEvent boolean (0..1)
    lossOfStockBorrow boolean (0..1)
    maximumStockLoanRate number (0..1) <"Specifies the maximum stock loan rate for Loss of Stock Borrow. A percentage of 5% is represented as 0.05.">
    increasedCostOfStockBorrow boolean (0..1)
    initialStockLoanRate number (0..1) <"Specifies the initial stock loan per ISDA Def. A percentage of 5% is represented as 0.05.">
    determiningParty AncillaryRoleEnum (0..1) <"Specifies the party which determines additional disruption events.">
    additionalBespokeTerms Clause (0..*) <"Where parties may optionnaly describe any extra bespoke agreements, in regards of the standardized Extraordinary Events.">
    condition MaximumStockLoanRate: <" FpML specifies the maximumStockLoanRate as a RestrictedPercentage, meaning that its value is comprised between 0 and 1.">
        if maximumStockLoanRate exists
        then maximumStockLoanRate >= 0 and maximumStockLoanRate <= 1

    condition InitialStockLoanRate: <" FpML specifies the initialStockLoanRate as a RestrictedPercentage, meaning that its value is comprised between 0 and 1.">
        if initialStockLoanRate exists
        then initialStockLoanRate >= 0 and initialStockLoanRate <= 1

    condition DisruptionEventsDeterminingParty:
        if determiningParty exists
        then determiningParty = AncillaryRoleEnum -> DisruptionEventsDeterminingParty

type Clause: <"A type for documenting additional clause that cannot yet be represented with the model and yet needed for a digital representation of the agreement.">
    identifier string (0..1) <"The  name or identifier associated to this clause.">
    terms string (0..1) <"Content of this bespoke clause.">
    subcomponents Clause (0..*) <"Additional hierarchical components of the clause if relevant.">
    condition: <"The Clause should describe at least the additional terms,  additional subcomponents or both.">
        optional choice terms, subcomponents

type MasterConfirmationBase: <"Legal agreement specification for General Terms and Elections that are applicable across multiple confirmations and are referenced by these confirmations.">

type BrokerConfirmation: <"Identifies the market sector in which the trade has been arranged.">
    brokerConfirmationType BrokerConfirmationTypeEnum (1..1) <"The type of broker confirmation executed between the parties.">
        [metadata scheme]

type EquitySwapMasterConfirmation2018 extends EquityMasterConfirmation: <"Specification for the General Terms and Relationship Supplement Elections as provided in the 2018 ISDA CDM Equity Confirmation for Security Equity Swap.">

    typeOfSwapElection ReturnTypeEnum (1..1) <"Per Part 1 Section 4, 'Dividend Obligations', of the 2018 ISDA CDM Equity Confirmation, Para 4.2 'Dividend Returns'.">
    pricingMethodElection PriceReturnTerms (1..1) <"Per Part 1 Section 5, 'Pricing', of the 2018 ISDA CDM Equity Confirmation, Para 5.1.">
    linearInterpolationElection InterpolationMethodEnum (1..1) <"Per Part 1 Section 3, 'Floating Obligations', of the 2018 ISDA CDM Equity Confirmation. Para 3.3.">
    settlementTerms SettlementTerms (1..1) <"Per Part 1 Section 8, 'Settlement', of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap.">
    valuationDates ValuationDates (1..1) <"The parameters used to generate the 'Equity Valuation Dates' schedule, including the Effective Date and Termination Date for the Swap.">
    equityCashSettlementDates PaymentDates (1..1) <"The parameters used to generate the payment date schedule, relative to the equityCalculationPeriod. Per Part 1 Section 12, 'Definitions', of the 2018 ISDA CDM Equity Confirmation. Para 73.">

type EquityMasterConfirmation extends MasterConfirmationBase: <"Specification for General Terms and Elections of an Equity Master Confirmation that is applicable across multiple Equity confirmations and is referenced by each of these confirmations, an example of which being the 2018 ISDA CDM Equity Confirmation for Security Equity Swap.">


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-cme-synonym.rosetta
================================================================================

namespace cdm.mapping.cme
version "${project.version}"

import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.mapping.fpml.confirmation.workflowstep.*
import cdm.product.asset.*

synonym source CME_ClearedConfirm_1_17 extends CME_BASE
{
    WorkflowStep:
        + proposedEvent
            [value "clearingConfirmed"]
        + messageInformation
            [value "header" path "clearingConfirmed"]
        + timestamp
            [value "timestamps" path "clearingConfirmed->trade->tradeHeader"]
            [value "header" path "clearingConfirmed"]
        + creditLimitInformation
            [value "creditLimitInformation" path "clearingConfirmed->trade->tradeHeader"]

    EventInstruction:
        + eventDate
            [value "clearedDate" path "clearingConfirmed->trade->tradeHeader" maps 2]

    MessageInformation:
        - sentBy
        + sentBy
            [value "sentBy" meta "messageAddressScheme"]
        - sentTo
        + sentTo
            [value "sendTo" meta "messageAddressScheme"]

    EventTimestamp:
        + dateTime
            [value "creationTimestamp"]
            [value "expiryTimestamp"]
            [value "submittedForClearing"]
        + qualification
            [set to EventTimestampQualificationEnum -> eventCreationDateTime when "creationTimestamp" exists]
            [set to EventTimestampQualificationEnum -> eventExpirationDateTime when "expiryTimestamp" exists]
            [set to EventTimestampQualificationEnum -> clearingReceiptDateTime when "submittedForClearing" exists]

    WorkflowState:
        + workflowStatus
            [value "status" path "clearingConfirmed->trade->tradeHeader"]

    LimitApplicableExtended:
        + limitLevel
            [value "level" meta "creditLimitLevelScheme"]
        + limitAmount
            [value "limitAmount"]
        + limitImpactDueToTrade
            [value "limitImpactDueToTrade"]

    CreditLimitInformation:
        + limitApplicable
            [value "limitApplicable"]

    Trade:
        + tradeIdentifier
            [value "universalSwapIdentifier" path "tradeHeader"]

    AssignedIdentifier:
        + identifier
            [value "tradeId" meta "tradeIdScheme"]
            [value "usi" meta "usiScheme"]

    enums

    // CategoryEnum:
    // + Customer
    // [value "CUST"]
    // + Principal
    // [value "HOUS"]
    WorkflowStatusEnum:
        + Accepted
            [value "Accepted"]
        + Amended
            [value "AMENDED"]
        + Cleared
            [value "CLEARED"]
        + Rejected
            [value "Rejected"]
        + Terminated
            [value "TERMINATED"]

    PartyRoleEnum:
        + DataSubmitter
            [value "InputSource"]
}

synonym source CME_SubmissionIRS_1_0 extends CME_BASE
{
    WorkflowStep:
        + proposedEvent
            [value "TrdCaptRpt"]
            [value "FpML" path "TrdCaptRpt->Instrmt->SecXML"]
        + action
            [value "TransTyp" path "TrdCaptRpt"]
        + messageInformation
            [value "TrdCaptRpt"]

    EventTimestamp:
        + dateTime
            [value "TxnTm" path "TrdCaptRpt"]
            [value "Snt" path "TrdCaptRpt->Hdr"]
            [value "TS" path "TrdCaptRpt->TrdRegTS"]
        + qualification
            [set to EventTimestampQualificationEnum -> transactionCreationDateTime when path = "TrdCaptRpt->TxnTm"]
            [set to EventTimestampQualificationEnum -> eventSentDateTime when path = "TrdCaptRpt->Hdr->Snt"]
            [set to EventTimestampQualificationEnum -> executionDateTime when path = "TrdCaptRpt->TrdRegTS->TS"]

    WorkflowState:
        + workflowStatus
            [value "RptTyp" path "TrdCaptRpt"]
        + partyCustomisedWorkflow
            [value "RptSide" path "TrdCaptRpt"]

    MessageInformation:
        + sentBy
            [value "SSub" path "Hdr"]
        + sentTo
            [value "TID" path "Hdr"]

    PartyCustomisedWorkflow:
        + partyName
            [value "ID" path "Pty"]

    CustomisedWorkflow:
        + itemName
            [set to "ClientOrderId" when path = "ClOrdID"]
            [set to "TradeOriginationSystem" when path = "InptSrc"]
            [set to "OriginatingTradeId" when path = "OrigTrdID"]
            [set to "ExecutionTime" when path = "TrdRegTS->TS"]
            [set to "PartyType" when path = "Pty->R"]
            [set to "PartyIdentifier" when path = "Pty->Src"]
        + itemValue
            [value "ClOrdID"]
            [value "InptSrc"]
            [value "OrigTrdID"]
            [value "TS" path "TrdRegTS"]
            [set to "Customer Account" when "Pty->R" = "24"]
            [set to "Custom" when "Pty->Src" = "D"]

    AssignedIdentifier:
        + identifier
            [value "RptID" path "TrdCaptRpt"]

    TradeState:
        [meta "id" path "trade"]
        - trade
        + trade
            [value "trade" mapper "CmeParty"]
            [hint "party"]
            [hint "account"]

    ExecutionDetails:
        + executionType
            [value "VenuTyp"]
        + executionVenue
            [value "Hdr"]

    PartyReferencePayerReceiver:
        - payerPartyReference
        + payerPartyReference
            [value "payerPartyReference" mapper "TradeSideToParty"]
            [value "buyerPartyReference" maps 2 mapper "TradeSideToParty"]
        - receiverPartyReference
        + receiverPartyReference
            [value "receiverPartyReference" mapper "TradeSideToParty"]
            [value "sellerPartyReference" maps 2 mapper "TradeSideToParty"]

    LegalEntity:
        + name
            [value "SID"]

    Party:
        + name
            [value "SID" path "Hdr"]

    enums

    ExecutionTypeEnum:
        - Electronic
        + Electronic
            [value "E"]
        + OffFacility
            [value "O"]

    ActionEnum:
        + New
            [value "0"]
        + Correct
            [value "2"]
        + Cancel
            [value "1"]

    WorkflowStatusEnum:
        + Cancelled
            [value "2"]
        + Pending
            [value "101"]
        + Rejected
            [value "1"]
        + Submitted
            [value "0"]
}

synonym source CME_BASE extends FpML_5_Confirmation_To_WorkflowStep
{
    InterestShortFall:
        + rateSource
            [value "rateSource" meta "floatingRateIndexScheme"]

    enums

    LimitLevelEnum:
        + Account
            [value "ACCT"]
        + Customer
            [value "CUST"]
        + House
            [value "HOUS"]
}


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-config-synonym.rosetta
================================================================================

namespace cdm.mapping.config
version "${project.version}"

synonym source AcadiaSoft_AM_1_0

synonym source FIX_5_0_SP2

synonym source ISDA_Taxonomy_v1

synonym source ISDA_Taxonomy_v2

synonym source ISO20022


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-createiq-synonym.rosetta
================================================================================

namespace cdm.mapping.createiq
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.party.*
import cdm.legaldocumentation.common.*
import cdm.legaldocumentation.csa.*
import cdm.legaldocumentation.master.*
import cdm.product.collateral.*

synonym source CreateiQ

synonym source CreateiQ_1_0 extends CreateiQ
{
    AccessConditionsElections:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_illegality" = "applicable" , set to CounterpartyRoleEnum -> Party1 when "partyA_illegality" = "not_applicable"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_illegality" = "applicable" , set to CounterpartyRoleEnum -> Party2 when "partyB_illegality" = "not_applicable"]
        + illegality
            [set to True when "partyA_illegality" = "applicable" , set to False when "partyA_illegality" = "not_applicable"]
            [set to True when "partyB_illegality" = "applicable" , set to False when "partyB_illegality" = "not_applicable"]
        + forceMajeure
            [set to True when "partyA_force_majeure" = "applicable" , set to False when "partyA_force_majeure" = "not_applicable"]
            [set to True when "partyB_force_majeure" = "applicable" , set to False when "partyB_force_majeure" = "not_applicable"]
        + taxEvent
            [set to True when "partyA_tax_event" = "applicable" , set to False when "partyA_tax_event" = "not_applicable"]
            [set to True when "partyB_tax_event" = "applicable" , set to False when "partyB_tax_event" = "not_applicable"]
        + taxEventUponMerger
            [set to True when "partyA_tax_event_upon_merger" = "applicable" , set to False when "partyA_tax_event_upon_merger" = "not_applicable"]
            [set to True when "partyB_tax_event_upon_merger" = "applicable" , set to False when "partyB_tax_event_upon_merger" = "not_applicable"]
        + creditEventUponMerger
            [set to True when "partyA_credit_event_upon_merger" = "applicable" , set to False when "partyA_credit_event_upon_merger" = "not_applicable"]
            [set to True when "partyB_credit_event_upon_merger" = "applicable" , set to False when "partyB_credit_event_upon_merger" = "not_applicable"]

    AdditionalRepresentation:
        + customElection
            [value "specify" removeHtml]

    AdditionalRepresentationElection:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_additional_representations" = "applicable" , set to CounterpartyRoleEnum -> Party1 when "partyA_additional_representations" = "not_applicable"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_additional_representations" = "applicable" , set to CounterpartyRoleEnum -> Party2 when "partyB_additional_representations" = "not_applicable"]
        + isApplicable
            [set to True when "partyA_additional_representations" = "applicable" , set to False when "partyA_additional_representations" = "not_applicable"]
            [set to True when "partyB_additional_representations" = "applicable" , set to False when "partyB_additional_representations" = "not_applicable"]

    AdditionalRepresentations:
        + additionalRepresentation
            [value "additional_representations"]
        + regulatoryComplianceRepresentation
            [set to True when "regulatory_compliance_and_concentration_limits->additional_information" = "applicable" , set to False when "regulatory_compliance_and_concentration_limits->additional_information" = "not_applicable"]

    AdditionalRightsEvent:
        + isApplicable
            [set to True when "applicable" = "true" , set to False when "applicable" = "false"]
        + qualification
            [value "specify" removeHtml]

    AdditionalType:
        + standardValue
            [value "additional_type"]
        + customValue
            [value "additional_type_specify" removeHtml]

    AmendmentEffectiveDate:
        + date
            [value "date_of_agreement"]
            [value "date_of_annex"]
        + specificDate
            [value "annex_date" mapper "EffectivenessDate"]
            [value "effectiveness_date" mapper "EffectivenessDate"]
            [value "agreement_date" mapper "EffectivenessDate"]
        + customProvision
            [value "specify" set when "effectiveness_date" = "other" removeHtml]
            [value "specify" set when "agreement_date" = "other" removeHtml]
            [value "specify" set when "annex_date" = "other" removeHtml]

    AppropriatedCollateralValuation:
        + isSpecified
            [set to True when "specified" = "true" , set to False when "specified" = "false"]
            [set to True when "valuation_of_appropriated_securities_is" = "other_specify" , set to False when "valuation_of_appropriated_securities_is" = "not_specified"]
            [set to True when "valuation_of_appropriated_collateral_is" = "other_specify" , set to False when "valuation_of_appropriated_collateral_is" = "not_specified"]
        + election
            [value "specify" removeHtml]
            [value "other_specify_text" removeHtml]

    BespokeCalculationDate:
        + isApplicable
            [set to True when "specified" = "true" , set to False when "specified" = "false"]

    BespokeCalculationTime:
        + asCalculationAgent
            [set to True when "calculation_time_IM_is" = "calculation_agent_IM_computation_time" , set to False when "calculation_time_IM_is" = "specify"]
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "specify"]
        + bespokeCalculationTimeTerms
            [value "calculation_agent_IM_computation_time_specify" removeHtml]

    BespokeTransferTiming:
        + isApplicable
            [set to True when "specified" = "true" , set to False when "specified" = "false"]
        + bespokeTransferTimingTerms
            [value "settlement_day_specify" removeHtml]

    CalculationAgentTerms:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "calculation_agent" = "partyA"]
            [set to CounterpartyRoleEnum -> Party1 when "calculation_agent" = "party_A"]
            [set to CounterpartyRoleEnum -> Party2 when "calculation_agent" = "partyB"]
            [set to CounterpartyRoleEnum -> Party2 when "calculation_agent" = "party_B"]
            [set to CounterpartyRoleEnum -> Party1 when "calculation_agent_IM_party" = "demanding_party_and_secured_party"]
            [set to CounterpartyRoleEnum -> Party2 when "calculation_agent_IM_party" = "demanding_party_and_secured_party"]
        + bespokeCalculationAgentTerms
            [value "specify" set when "is_applicable" = "applicable" removeHtml]

    CalculationAndTiming:
        + calculationAgentTerms
            [value "calculation_agent_IM"]
        + bespokeCalculationDate
            [value "calculation_date"]
        + bespokeCalculationTime
            [value "calculation_time"]
            [value "credit_support_amount_calculation_time"]
        + calculationDateLocation
            [value "calculation_date_location" mapper "CalculationDateLocation"]
            [value "calculation_date" mapper "CalculationDateLocation"]
            [value "designated_city" mapper "CalculationDateLocation"]
        + notificationTime
            [value "notification_time"]
        + collateralValuationAgent
            [value "collateral_valuation_agent"]
        + cashSettlementDay
            [value "specify" path "cash_settlement_day" set when "cash_settlement_day->specified" = "true"]
        + securitiesSettlementDay
            [value "specify" path "securities_settlement_day" set when "securities_settlement_day->specified" = "true"]

    CollateralAccessBreach:
        + isApplicable
            [set to True when "collateral_access_breach" = "applicable" , set to False when "collateral_access_breach" = "not_applicable"]
        + cabEndDateElection
            [set to True when "cab_end_date" = "days" , set to False when "cab_end_date" = "other"]
        + cabEndDate
            [value "cab_end_date_days"]
        + cabEndDateTerms
            [value "cab_end_date_specify" removeHtml]

    CollateralRounding:
        + deliveryAmount
            [value "delivery_amount"]
        + returnAmount
            [value "return_amount"]
        + deliveryDirection
            [value "delivery_direction"]

    CollateralTransferAgreementElections:
        + oneWayProvisions
            [value "one_way_provisions"]
        + identifiedCrossCurrencySwap
            [set to True when "cross_currency_swap->yey_ney" = "true" , set to False when "cross_currency_swap->yey_ney" = "false"]
        + fxHaircutCurrency
            [value "fx_haircut_percentage"]
        + postingObligations
            [value "security_provider_posting_obligations" mapper "PostingObligations"]
        + substitutedRegime
            [value "substituted_regimes" mapper "CtaSubstitutedRegime"]
        + substitution
            [value "consent"]
        + demandsAndNotices
            [value "demands_and_notices" mapper "ContactElection"]
        + addressesForTransfer
            [value "addresses_for_transfers" mapper "ContactElection"]
        + otherCsa
            [value "other_csa->specify" set when "other_csa->specified" = "true"]
            [value "other_csa->other_csa_specify" set when "other_csa->specified" = "true"]
        + terminationCurrencyAmendment
            [value "amendment_to_termination_currency" , "security_provider_posting_obligations" mapper "TerminationCurrencyAmendment"]
        + minimumTransferAmountAmendment
            [value "amendment_to_minimum_transfer_amount" mapper "MinimumTransferAmountAmendment"]
        + interpretationTerms
            [value "paragraph_1_6a_specify" path "interpretation" set when "interpretation->paragraph_1_6a_is" = "specify" removeHtml]
            [value "paragraph_10ki_specify" path "interpretation" set when "interpretation->paragraph_10ki_is" = "specify" removeHtml]
        + processAgent
            [value "process_agent"]
        + additionalAmendments
            [value "specify" path "amendments" maps 2 set when "amendments->is_applicable" = "applicable" removeHtml]
        + additionalBespokeTerms
            [value "specify" path "additional_terms" set when "additional_terms->is_applicable" = "applicable" removeHtml]
            [value "specify" path "bespoke_provisions" set when "bespoke_provisions->is_applicable" = "applicable" removeHtml]
        + pledgeeRepresentativeRider
            [value "rider"]

    CollateralValuationAgentElection:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_collateral_valuation_agent" = "other"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_collateral_valuation_agent" = "other"]
        + additionalLanguage
            [value "partyA_specify" removeHtml]
            [value "partyB_specify" removeHtml]

    ConditionsPrecedent:
        + conditionsPrecedentElection
            [value "specified" path "conditions_precedent"]
            [value "conditions_precedent" path "conditions_precedent"]
        + customProvision
            [value "specify" path "conditions_precedent" removeHtml]
        + accessConditions
            [value "access_conditions" mapper "AdditionalTerminationEvent"]
            [value "access_conditions" path "conditions_precedent" mapper "AdditionalTerminationEvent"]

    ControlAgreementNecEventElection:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_control_agreement_nec_event" = "applicable" , set to CounterpartyRoleEnum -> Party1 when "partyA_control_agreement_nec_event" = "not_applicable"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_control_agreement_nec_event" = "applicable" , set to CounterpartyRoleEnum -> Party2 when "partyB_control_agreement_nec_event" = "not_applicable"]
        + necEvent
            [set to True when "partyA_control_agreement_nec_event" = "applicable" , set to False when "partyA_control_agreement_nec_event" = "not_applicable"]
            [set to True when "partyB_control_agreement_nec_event" = "applicable" , set to False when "partyB_control_agreement_nec_event" = "not_applicable"]

    CreditSupportAgreementElections:
        + oneWayProvisions
            [value "one_way_provisions"]
        + identifiedCrossCurrencySwap
            [set to True when "cross_currency_swap->yey_ney" = "true" , set to False when "cross_currency_swap->yey_ney" = "false"]
        + fxHaircutCurrency
            [value "fx_haircut_percentage"]
        + postingObligations
            [value "chargor_posting_obligations" mapper "PostingObligations"]
            [value "pledgor_posting_obligations" mapper "PostingObligations"]
            [value "obligor_posting_obligations" mapper "PostingObligations"]
        + substitutedRegime
            [value "substituted_regimes" mapper "CsaSubstitutedRegime"]
        + additionalObligations
            [value "additional_obligations_specify" path "additional_obligations" set when "additional_obligations->additional_obligations" = "specify" removeHtml]
        + substitution
            [value "consent"]
        + distributionAndInterestPayment
            [value "eligible_currencies" path "interest_rate" mapper "DistributionAndInterestPayment"]
        + demandsAndNotices
            [value "demands_and_notices" mapper "ContactElection"]
        + addressesForTransfer
            [value "addresses_for_transfers" mapper "ContactElection"]
        + terminationCurrencyAmendment
            [value "amendment_to_termination_currency" , "pledgor_posting_obligations" , "chargor_posting_obligations" , "obligor_posting_obligations" mapper "TerminationCurrencyAmendment"]
        + minimumTransferAmountAmendment
            [value "amendment_to_minimum_transfer_amount" mapper "MinimumTransferAmountAmendment"]
        + interpretationTerms
            [value "paragraph_10ki_specify" path "interpretation" set when "interpretation->paragraph_10ki_is" = "specify" removeHtml]
            [value "paragraph_11g_specify" path "interpretation" set when "interpretation->paragraph_11g_is" = "specify" removeHtml]
            [value "paragraph_11j_specify" path "interpretation" set when "interpretation->paragraph_11j_is" = "specify" removeHtml]
        + processAgent
            [value "process_agent"]
        + appropriatedCollateralValuation
            [value "valuation_of_appropriated_collateral"]
        + additionalAmendments
            [value "specify" path "amendments" maps 2 set when "amendments->is_applicable" = "applicable" removeHtml]
        + additionalBespokeTerms
            [value "specify" path "additional_terms" set when "additional_terms->is_applicable" = "applicable" removeHtml]
            [value "specify" path "bespoke_provisions" set when "bespoke_provisions->is_applicable" = "applicable" removeHtml]
        + trustSchemeAddendum
            [set to True when "trust_scheme_addendum->is_applicable" = "applicable" , set to False when "trust_scheme_addendum->is_applicable" = "not_applicable"]

    CustodianEvent:
        + isApplicable
            [set to True when "custodian_event->definition" = "applicable" , set to False when "custodian_event->definition" = "not_applicable"]
            [set to True when "euroclear_event->definition" = "applicable" , set to False when "euroclear_event->definition" = "not_applicable"]
            [set to True when "clearstream_event->definition" = "applicable" , set to False when "clearstream_event->definition" = "not_applicable"]
            [set to True when "collateral_manager_event->definition" = "applicable" , set to False when "collateral_manager_event->definition" = "not_applicable"]
        + endDate
            [value "ce_end_date" mapper "CustodianEventEndDate"]
            [value "ee_end_date" mapper "CustodianEventEndDate"]
            [value "cme_end_date" mapper "CustodianEventEndDate"]

    CustodianRiskElection:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_custodian_risk" = "other" , set to CounterpartyRoleEnum -> Party1 when "partyA_custodian_risk" = "not_specified"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_custodian_risk" = "other" , set to CounterpartyRoleEnum -> Party2 when "partyB_custodian_risk" = "not_specified"]
            [set to CounterpartyRoleEnum -> Party1 when "partyA_collateral_manager_risk" = "other" , set to CounterpartyRoleEnum -> Party1 when "partyA_collateral_manager_risk" = "not_specified"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_collateral_manager_risk" = "other" , set to CounterpartyRoleEnum -> Party2 when "partyB_collateral_manager_risk" = "not_specified"]
            [set to CounterpartyRoleEnum -> Party1 when "partyA_clearstream_risk" = "other" , set to CounterpartyRoleEnum -> Party1 when "partyA_clearstream_risk" = "not_specified"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_clearstream_risk" = "other" , set to CounterpartyRoleEnum -> Party2 when "partyB_clearstream_risk" = "not_specified"]
            [set to CounterpartyRoleEnum -> Party1 when "partyA_euroclear_risk" = "other" , set to CounterpartyRoleEnum -> Party1 when "partyA_euroclear_risk" = "not_specified"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_euroclear_risk" = "other" , set to CounterpartyRoleEnum -> Party2 when "partyB_euroclear_risk" = "not_specified"]
        + isSpecified
            [set to True when "partyA_custodian_risk" = "other" , set to False when "partyA_custodian_risk" = "not_specified"]
            [set to True when "partyB_custodian_risk" = "other" , set to False when "partyB_custodian_risk" = "not_specified"]
            [set to True when "partyA_collateral_manager_risk" = "other" , set to False when "partyA_collateral_manager_risk" = "not_specified"]
            [set to True when "partyB_collateral_manager_risk" = "other" , set to False when "partyB_collateral_manager_risk" = "not_specified"]
            [set to True when "partyA_clearstream_risk" = "other" , set to False when "partyA_clearstream_risk" = "not_specified"]
            [set to True when "partyB_clearstream_risk" = "other" , set to False when "partyB_clearstream_risk" = "not_specified"]
            [set to True when "partyA_euroclear_risk" = "other" , set to False when "partyA_euroclear_risk" = "not_specified"]
            [set to True when "partyB_euroclear_risk" = "other" , set to False when "partyB_euroclear_risk" = "not_specified"]
            [set to True when "paragraph_6b" = "specified" , set to False when "paragraph_6b" = "not_specified"]
            [set to True when "paragraph_6a" = "specified" , set to False when "paragraph_6a" = "not_specified"]
            [set to True when "paragraph_5_2" = "specify" , set to False when "paragraph_5_2" = "not_specified"]
        + qualification
            [value "partyA_specify" removeHtml]
            [value "partyB_specify" removeHtml]
            [value "paragraph_6b_specify" set when "paragraph_6b" = "specify" removeHtml]
            [value "paragraph_6a_specify" set when "paragraph_6a" = "specify" removeHtml]
            [value "paragraph_5_2_specify" set when "paragraph_5_2" = "specify" removeHtml]

    CustodyArrangements:
        + isCreditSupportDocument
            [set to True when "control_agreement_as_a_credit_support_document->definition" = "creditSupportDocument" , set to False when "control_agreement_as_a_credit_support_document->definition" = "not_specified"]
            [set to True when "collateral_management_agreement_as_a_credit_support_document->definition" = "creditSupportDocument" , set to False when "collateral_management_agreement_as_a_credit_support_document->definition" = "not_specified"]
            [set to True when "euroclear_agreements_as_credit_support_documents->definition" = "creditSupportDocument" , set to False when "euroclear_agreements_as_credit_support_documents->definition" = "not_specified"]
            [set to True when "clearstream_agreements_as_credit_support_documents->definition" = "creditSupportDocument" , set to False when "clearstream_agreements_as_credit_support_documents->definition" = "not_specified"]
        + hasControlAgreementLanguage
            [set to True when "relationship_with_the_control_agreement->include_language" = "include" , set to False when "relationship_with_the_control_agreement->include_language" = "exclude"]
            [set to True when "relationship_with_the_collateral_management_agreement->include_language" = "include" , set to False when "relationship_with_the_collateral_management_agreement->include_language" = "exclude"]
        + otherProvisions
            [value "specify" path "other_provisions" set when "other_provisions->specify_provisions" = "specify" removeHtml]
        + collateralAccessBreach
            [value "collateral_access_breach_additional_termination_event"]
            [value "collateral_access_breach"]
        + custodianRisk
            [value "custodian_risk"]
            [value "collateral_manager_risk"]
            [value "euroclear_risk"]
            [value "clearstream_risk"]
        + controlAgreement
            [value "control_agreement_as_a_credit_support_document" mapper "ControlAgreement"]
            [value "euroclear_agreements_as_credit_support_documents" mapper "ControlAgreement"]
            [value "clearstream_agreements_as_credit_support_documents" mapper "ControlAgreement"]
        + custodian
            [value "custodian_name" mapper "Custodian"]
            [value "custodian_and_segregated_account_details" mapper "Custodian"]
            [value "collateral_manager" mapper "Custodian"]
        + collateralManagementAgreement
            [value "collateral_management_agreement" mapper "CollateralManagementAgreement"]

    DeliveryAmount:
        + standardElection
            [value "delivery_amount"]
        + customElection
            [value "specify_delivery_amount"]

    DisputeResolution:
        + resolutionTime
            [value "resolution_time" set when "resolution_time->specified" = "true"]
        + otherTerms
            [value "specify" path "resolution_time" set when "resolution_time->specified" = "false" removeHtml]
        + recalculationOfValue
            [value "recalculation_of_value" mapper "RecalculationOfValue"]
            [value "recalculation_of_market_value" mapper "RecalculationOfValue"]

    CollateralInterestParameters:
        + currency
            [value "eligible_currency"]

    CollateralInterestCalculationParameters:
        + fixedRate
            [value "interest_rate" pattern "([0-9.]*)([%])" "$1"]

    EnforcementEvent:
        + earlyTerminationDate
            [set to True when "paid_in_full_language" = "include" , set to False when "paid_in_full_language" = "exclude"]
        + failureToPay
            [set to True when "failure_to_pay_early_termination_amount" = "applicable" , set to False when "failure_to_pay_early_termination_amount" = "not_applicable"]

    ExecutionLanguage:
        + standardLanguage
            [set to True when "execution_language" = "standard_language" , set to False when "execution_language" = "other_execution_language"]
        + numberOfOriginals
            [value "number_of_originals"]
        + otherLanguage
            [value "specify_execution_language"]

    ExecutionLocation:
        + executionLocation
            [value "location_of_execution"]
        + otherLanguage
            [value "specify_location_of_execution"]
        + dutyPayer
            [set to "PartyA" when "documentary_duty_payer" = "party_A" , set to "PartyB" when "documentary_duty_payer" = "party_B" , set to "Specify" when "documentary_duty_payer" = "other"]
        + dutyPayerLanguage
            [value "specify_documentary_duty_payer"]
        + dutyPaymentDate
            [value "select_documentary_duty_date"]
        + dutyPaymentLanguage
            [value "specify_documentary_duty_date_datepicker" set when "documentary_duty_date" = "other"]

    FrenchLawAddendum:
        + isApplicable
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "not_applicable"]

    FxHaircutCurrency:
        + isTerminationCurrency
            [set to True when "is_termination_currency" = "terminationCurrency" , set to False when "is_termination_currency" = "fxCurrency"]
        + fxDesignatedCurrency
            [value "fx_designated_currency" mapper "IsoCurrency"]

    GeneralSimmElections:
        + simmVersion
            [value "version_of_ISDA_SIMM"]
        + simmCalculationCurrency
            [value "simm_calculation_currency" mapper "SimmCalculationCurrency"]

    InterestAdjustment:
        + isApplicable
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "not_applicable"]

    InterestAdjustmentPeriodicity:
        + standardElection
            [value "timing"]
        + customElection
            [value "specify" set when "timing" = "other"]

    JapaneseSecuritiesProvisions:
        + isApplicable
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "not_applicable"]
        + relevantProvisionsElection
            [set to True when "relevant_provisions" = "recommended_japanese" , set to False when "relevant_provisions" = "specified"]
        + relevantProvisionsTerms
            [value "relevant_specify" removeHtml]
        + amendmentsToJapaneseProvisions
            [set to True when "amendments_to_japanese_provisions" = "amendments_specify" , set to False when "amendments_to_japanese_provisions" = "amendments_not_specified"]
        + amendmentsToJapaneseProvisionsTerms
            [value "amendments_specify" maps 2 removeHtml]
        + clearstreamAmendmentToJapaneseProvisions
            [set to True when "japanese_collateral_provisions_is_applicable" = "include" , set to False when "japanese_collateral_provisions_is_applicable" = "exclude"]

    JurisdictionRelatedTerms:
        + japaneseSecuritiesProvisions
            [value "japanese_securities_provisions"]
            [value "japanese_security_provisions"]
            [value "japanese_collateral_provisions"]
        + exclusiveJurisdiction
            [set to True when "jurisdiction->exclusive_jurisdiction" = "applicable" , set to False when "jurisdiction->exclusive_jurisdiction" = "not_applicable"]
        + juryWaiver
            [set to True when "jury_waiver->is_applicable" = "applicable" , set to False when "jury_waiver->is_applicable" = "not_applicable"]
        + frenchLawAddendum
            [value "french_law_addendum" mapper "FrenchLawAddendum"]
        + belgianLawSecurityAgreement
            [set to True when "belgian_law_security_agreement->is_applicable" = "applicable" , set to False when "belgian_law_security_agreement->is_applicable" = "not_applicable"]

    MarginApproach:
        + marginApproach
            [value "approach_selection"]

    MinimumTransferAmountAmendment:
        + isApplicable
            [set to True when "amendment_to_minimum_transfer_amount_is" = "applicable" , set to False when "amendment_to_minimum_transfer_amount_is" = "not_applicable"]

    NotificationTime:
        + disputeNotificationReference
            [set to True when "include_reference_to_41a_is_applicable" = "applicable" , set to False when "include_reference_to_41a_is_applicable" = "not_applicable"]
        + transferTimingProviso
            [set to True when "inclusion_of_proviso_for_transfer_timing_is_applicable" = "applicable" , set to False when "inclusion_of_proviso_for_transfer_timing_is_applicable" = "not_applicable"]

    NotificationTimeElection:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_notification_time" = "false" , set to CounterpartyRoleEnum -> Party1 when "partyA_notification_time" = "true"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_notification_time" = "false" , set to CounterpartyRoleEnum -> Party2 when "partyB_notification_time" = "true"]
        + customNotification
            [value "partyA_specify" set when "partyA_notification_time" = "false" removeHtml]
            [value "partyB_specify" set when "partyB_notification_time" = "false" removeHtml]

    OneWayProvisions:
        + isApplicable
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "not_applicable"]
        + postingParty
            [set to CounterpartyRoleEnum -> Party1 when "posting_party" = "partyA" , set to CounterpartyRoleEnum -> Party2 when "posting_party" = "partyB"]

    OtherAgreements:
        + otherCsa
            [value "other_csa"]
        + japaneseLawCsa
            [value "japanese_law_csa_vm"]

    OtherEligibleAndPostedSupport:
        + applicableValue
            [set to True when "support_value->is_applicable" = "applicable" , set to False when "support_value->is_applicable" = "not_applicable"]
        + applicableTransfer
            [set to True when "support_transfer->is_applicable" = "applicable" , set to False when "support_transfer->is_applicable" = "not_applicable"]

    PostingObligations:
        + securityProvider
            [value "pledgor"]
            [value "chargor"]
            [value "obligor"]
            [value "security_provider"]

    PostingObligationsElection:
        + eligibleCollateral
            [value "partyA_eligible_currencies" set when "partyA_type" = "specify"]
            [value "partyB_eligible_currencies" set when "partyB_type" = "specify"]

    ProcessAgentElection:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_process_agent" = "not_applicable" , set to CounterpartyRoleEnum -> Party1 when "partyA_process_agent" = "other"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_process_agent" = "not_applicable" , set to CounterpartyRoleEnum -> Party2 when "partyB_process_agent" = "other"]
        + isApplicable
            [set to True when "partyA_process_agent" = "other" , set to False when "partyA_process_agent" = "not_applicable"]
            [set to True when "partyB_process_agent" = "other" , set to False when "partyB_process_agent" = "not_applicable"]

    Regime:
        + applicableRegime
            [value "australia" , "brazil" , "canada" , "cftc" , "emir" , "hong_kong" , "hong_kong_sfc" , "japan" , "prudential" , "sec" , "singapore" , "south_africa" , "south_korea" , "switzerland" , "united_kingdom" , "additional_regimes" mapper "ApplicableRegime"]
        + fallbackToMandatoryMethodDays
            [value "fallback_to_mandatory_method_days" path "fallback_to_mandatory_method"]

    PledgeeRepresentativeRider:
        + isApplicable
            [set to True when "representative_cta_provisions" = "applicable" , set to False when "representative_cta_provisions" = "not_applicable"]
        + party
            [set to CounterpartyRoleEnum -> Party1 when "represented_party" = "party_a" , set to CounterpartyRoleEnum -> Party2 when "represented_party" = "party_b"]
        + representativeTerms
            [value "specify" removeHtml]
        + representativeEvent
            [value "representative_event"]
        + representativeEventTerms
            [value "specify_text" removeHtml]

    ReturnAmount:
        + includesDefaultLanguage
            [set to True when "return_amount" = "include" , set to False when "return_amount" = "exclude" , set to False when "return_amount" = "other"]
        + customElection
            [value "specify_return_amount"]

    RightsEvents:
        + securityTakerRightsEvent
            [value "secured_party_rights_event"]
            [value "security_taker_rights_event"]
            [value "early_termination_date"]
        + controlAgreementNecEvent
            [value "control_agreement_nec_event"]
        + securityProviderRightsEvent
            [value "obligor_rights_event" mapper "SecurityProviderRightsEvent"]
            [value "chargor_rights_event" mapper "SecurityProviderRightsEvent"]
            [value "pledgor_rights_event" mapper "SecurityProviderRightsEvent"]
            [value "security_provider_rights_event" mapper "SecurityProviderRightsEvent"]
        + deliveryInLieuRight
            [set to True when "delivery_in_lieu_right->right" = "applicable" , set to False when "delivery_in_lieu_right->right" = "not_applicable"]
        + additionalRightsEvent
            [value "chargor_additional_rights_event"]
            [value "obligor_additional_rights_event"]
            [value "pledgor_additional_rights_event"]

    SecuredPartyRightsEvent:
        + earlyTerminationDateOptionalLanguage
            [set to True when "early_termination_date_optional_language" = "include" , set to False when "early_termination_date_optional_language" = "exclude"]
            [set to True when "paid_in_full_language" = "include" , set to False when "paid_in_full_language" = "exclude"]
        + failureToPayEarlyTermination
            [set to True when "failure_to_pay_early_termination_is_applicable" = "applicable" , set to False when "failure_to_pay_early_termination_is_applicable" = "not_applicable"]

    SecuredPartyRightsEventElection:
        + party
            [set to CounterpartyRoleEnum -> Party1 when "partyA_secured_party_rights_event" = "applicable" , set to CounterpartyRoleEnum -> Party1 when "partyA_secured_party_rights_event" = "not_applicable"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_secured_party_rights_event" = "applicable" , set to CounterpartyRoleEnum -> Party2 when "partyB_secured_party_rights_event" = "not_applicable"]
            [set to CounterpartyRoleEnum -> Party1 when "partyA_security_taker_rights_event" = "applicable" , set to CounterpartyRoleEnum -> Party1 when "partyA_security_taker_rights_event" = "not_applicable"]
            [set to CounterpartyRoleEnum -> Party2 when "partyB_security_taker_rights_event" = "applicable" , set to CounterpartyRoleEnum -> Party2 when "partyB_security_taker_rights_event" = "not_applicable"]
        + rightsEvent
            [set to True when "partyA_secured_party_rights_event" = "applicable" , set to False when "partyA_secured_party_rights_event" = "not_applicable"]
            [set to True when "partyB_secured_party_rights_event" = "applicable" , set to False when "partyB_secured_party_rights_event" = "not_applicable"]
            [set to True when "partyA_security_taker_rights_event" = "applicable" , set to False when "partyA_security_taker_rights_event" = "not_applicable"]
            [set to True when "partyB_security_taker_rights_event" = "applicable" , set to False when "partyB_security_taker_rights_event" = "not_applicable"]

    SecurityAgreementElections:
        + pledgedAccount
            [value "pledged_account_number"]
        + enforcementEvent
            [value "enforcement_event"]
            [value "early_termination_date"]
        + deliveryInLieuRight
            [set to True when "delivery_in_lieu_right->right" = "applicable" , set to False when "delivery_in_lieu_right->right" = "not_applicable"]
        + fullDischarge
            [set to True when "security_provider_full_discharge_condition->is_applicable" = "applicable" , set to False when "security_provider_full_discharge_condition->is_applicable" = "not_applicable"]
        + appropriatedCollateralValuation
            [value "valuation_of_appropriated_collateral"]
            [value "valuation_of_appropriated_securities"]
        + processAgent
            [value "process_agent"]
        + additionalAmendments
            [value "specify" path "amendments" maps 2 set when "amendments->is_applicable" = "applicable" removeHtml]
        + additionalBespokeTerms
            [value "specify" path "additional_terms" set when "additional_terms->is_applicable" = "applicable" removeHtml]
            [value "specify" path "bespoke_provisions" set when "bespoke_provisions->is_applicable" = "applicable" removeHtml]
        + executionTerms
            [value "execution_language"]

    SecurityProviderRightsEvent:
        + includeCoolingOffLanguage
            [set to True when "cooling_off_language" = "include" , set to False when "cooling_off_language" = "not_specified" , set to False when "cooling_off_language" = "other"]
            [set to True when "cooling_off_period_condition_is_applicable" = "applicable" , set to False when "cooling_off_period_condition_is_applicable" = "not_applicable"]
        + fullDischarge
            [set to True when "chargor_full_discharge_condition_is_applicable" = "applicable" , set to False when "chargor_full_discharge_condition_is_applicable" = "not_applicable"]
            [set to True when "pledgor_full_discharge_condition_is_applicable" = "applicable" , set to False when "pledgor_full_discharge_condition_is_applicable" = "not_applicable"]
            [set to True when "obligor_full_discharge_condition_is_applicable" = "applicable" , set to False when "obligor_full_discharge_condition_is_applicable" = "not_applicable"]
            [set to True when "security_provider_full_discharge_condition_is_applicable" = "applicable" , set to False when "security_provider_full_discharge_condition_is_applicable" = "not_applicable"]
        + automaticSetOff
            [set to True when "automatic_setoff->right" = "applicable" , set to False when "automatic_setoff->right" = "not_applicable"]
        + customElection
            [value "specify" removeHtml]

    SensitivityMethodologies:
        + sensitivityToEquity
            [value "sensitivities_to_equity_indices_funds_etfs"]
        + sensitivityToCommodity
            [value "sensitivities_to_commodity_indices"]

    SensitivityMethodology:
        + specifiedMethodology
            [value "sensitivities_equity_indices_funds_etfs" , "sensitivities_commodity_indices"]
        + customMethodology
            [value "sensitivities_equity_indices_funds_etfs_specify" , "sensitivities_commodity_indices_specify" removeHtml]

    SimmVersion:
        + isSpecified
            [set to True when "is_specified" = "specified" , set to False when "is_specified" = "not_specified"]
        + partyVersion
            [set to CounterpartyRoleEnum -> Party1 when "party_A_or_party_B_version" = "partyA" , set to CounterpartyRoleEnum -> Party2 when "party_A_or_party_B_version" = "partyB"]
        + asSpecified
            [value "specify" set when "is_specified" = "other" removeHtml]

    Substitution:
        + needsConsent
            [set to True when "is_applicable" = "standard" , set to False when "is_applicable" = "other"]
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "not_applicable"]
        + specificConsentLanguage
            [value "specify" removeHtml]

    TerminationCurrencyAmendment:
        + isApplicable
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "not_applicable"]
            [set to True when "amendment_to_termination_currency_is" = "applicable" , set to False when "amendment_to_termination_currency_is" = "not_applicable"]

    BaseAndEligibleCurrency:
        + baseCurrency
            [value "currency" path "base_currency" mapper "IsoCurrency"]

    CreditSupportObligations:
        + marginApproach
            [value "selection_of_margin_approach"]
        + otherEligibleSupport
            [value "eligible_support_specify" path "other_eligible_support" set when "other_eligible_support->other_eligible_support" = "specify" removeHtml]
            [value "other_eligible_support" path "eligible_support" removeHtml]
        + threshold
            [value "threshold" mapper "Threshold"]
        + minimumTransferAmount
            [value "minimum_transfer_amount" mapper "MinimumTransferAmount"]
        + rounding
            [value "rounding"]
        + bespokeTransferTiming
            [value "transfer_timing"]

    OtherAgreement:
        + date
            [value "collateral_transfer_agreement_date" path "collateral_transfer_agreement"]

    Agreement:
        + creditSupportAgreementElections
            [value "partyA" path "answers" set when "document->documentType" = "Credit Support Annex"]
            [value "partyA" path "answers" set when "document->documentType" = "Credit Support Deed"]
        + collateralTransferAgreementElections
            [value "partyA" path "answers" set when "document->documentType" = "Collateral Transfer Agreement"]
        + securityAgreementElections
            [value "partyA" path "answers" set when "document->documentType" = "Security Agreement"]
        + masterAgreementSchedule
            [value "ignore"]
        + masterAgreementElections
            [value "ignore"]

    AgreementTerms:
        + clauseLibrary
            [set to True when "document->documentType" = "Clause Library"]
        + counterparty
            [value "partyA" mapper "AgreementTermsParty"]

    LegalAgreement:
        + relatedAgreements
            [value "date_of_euroclear_security_agreement" path "answers->partyA" , "date_of_collateral_transfer_agreement" path "answers->partyA" , "date_of_isda_master_agreement" path "answers->partyA" , "collateral_transfer_agreement" path "answers->partyA" , "isda_master_agreement_form" path "answers->partyA" mapper "RelatedAgreement"]
        + umbrellaAgreement
            [value "umbrella_agreement_and_principal_identification" , "umbrella_agreement_and_principal_identification" path "answers->partyA"]

    LegalAgreementBase:
        + agreementDate
            [value "executionDate" path "answers->partyA->execution_date"]
        + contractualParty
            [value "partyA" mapper "ContractualParty"]

    LegalAgreementIdentification:
        + governingLaw
            [value "governingLaw" path "document"]
        + agreementName
            [value "document"]
        + publisher
            [value "publisher" path "document"]
        + vintage
            [value "year" path "document"]

    AgreementName:
        + agreementType
            [value "documentType"]
        + creditSupportAgreementType
            [value "documentType"]
        + creditSupportAgreementMarginType
            [set to CollateralMarginTypeEnum -> InitialMargin when "abbreviation" = "2016 IM CSA (Jpn Law)"]
            [set to CollateralMarginTypeEnum -> InitialMargin when "abbreviation" = "2016 IM CSA (NY Law)"]
            [set to CollateralMarginTypeEnum -> InitialMargin when "abbreviation" = "2018 IM CSA (NY Law)"]
            [set to CollateralMarginTypeEnum -> InitialMargin when "abbreviation" = "2016 IM CSD (Eng Law)"]
            [set to CollateralMarginTypeEnum -> InitialMargin when "abbreviation" = "2018 IM CSD (Eng Law)"]
        + masterAgreementType
            [value "documentType"]

    UmbrellaAgreement:
        + isApplicable
            [set to True when "is_applicable" = "applicable" , set to False when "is_applicable" = "not_applicable"]
        + language
            [value "language" maps 2 removeHtml]
        + parties
            [value "principal_identification_schedule" mapper "UmbrellaAgreementEntity"]

    OtherAgreementTerms:
        + isSpecified
            [set to True when "specify_japanese_law_csa_vm" = "true" , set to False when "specify_japanese_law_csa_vm" = "false"]
            [set to True when "specify_other_csa" = "true" , set to False when "specify_other_csa" = "false"]
        + legalDocument
            [value "specify"]

    BusinessCenterTime:
        + hourMinuteTime
            [value "partyA_time"]
            [value "partyB_time"]
            [value "time"]
        + businessCenter
            [value "partyA_location"]
            [value "partyB_location"]
            [value "location"]

    CustomisableOffset:
        + customProvision
            [value "re_end_date__days_after_representative_event__other__specify" set when "re_end_date__days_after_representative_event" = "other__specify" removeHtml]

    Account:
        + accountNumber
            [value "pledged_account_number" removeHtml]
        + accountName
            [value "name"]

    PartyContactInformation:
        + additionalInformation
            [value "partyA_specify" removeHtml]
            [value "partyB_specify" removeHtml]

    PartyRole:
        + partyReference
            [value "partyA"]

    enums

    ISOCurrencyCodeEnum:
        + AED
            [value "United Arab Emirates Dirham"]
        + AFN
            [value "Afghan Afghani"]
        + ALL
            [value "Albanian Lek"]
        + AMD
            [value "Armenian Dram"]
        + AOA
            [value "Angolan Kwanza"]
        + ARS
            [value "Argentine Peso"]
        + AUD
            [value "Australian Dollar"]
        + AWG
            [value "Aruban Florin"]
        + AZN
            [value "Azerbaijani Manat"]
        + BAM
            [value "Bosnia and Herzegovina Convertible Mark"]
        + BBD
            [value "Barbados Dollar"]
        + BDT
            [value "Bangladeshi Taka"]
        + BGN
            [value "Bulgarian Lev"]
        + BHD
            [value "Bahraini Dinar"]
        + BIF
            [value "Burundian Franc"]
        + BMD
            [value "Bermudian Dollar"]
        + BND
            [value "Brunei Dollar"]
        + BOB
            [value "Boliviano"]
        + BOV
            [value "Bolivian Mvdol"]
        + BRL
            [value "Brazilian Real"]
        + BSD
            [value "Bahamian Dollar"]
        + BTN
            [value "Bhutanese Ngultrum"]
        + BWP
            [value "Botswana Pula"]
        + BYN
            [value "Belarusian Ruble"]
        + BZD
            [value "Belize Dollar"]
        + CAD
            [value "Canadian Dollar"]
        + CDF
            [value "Congolese Franc"]
        + CHF
            [value "Swiss Franc"]
        + CLF
            [value "Unidad de Fomento"]
        + CLP
            [value "Chilean Peso"]
        + CNY
            [value "Chinese Yuan/Renminbi"]
        + COP
            [value "Colombian Peso"]
        + COU
            [value "Unidad de Valor Real (UVR)"]
        + CRC
            [value "Costa Rican Clon"]
        + CUP
            [value "Cuban Peso"]
        + CVE
            [value "Cape Verde Escudo"]
        + CZK
            [value "Czech Koruna"]
        + DJF
            [value "Djiboutian Franc"]
        + DKK
            [value "Danish Krone"]
        + DOP
            [value "Dominican Peso"]
        + DZD
            [value "Algerian Dinar"]
        + EGP
            [value "Egyptian Pound"]
        + ERN
            [value "Eritrean Nakfa"]
        + ETB
            [value "Ethiopian Birr"]
        + EUR
            [value "Euro"]
        + FJD
            [value "Fiji Dollar"]
        + FKP
            [value "Falkland Islands Pound"]
        + GBP
            [value "Pound Sterling"]
        + GEL
            [value "Georgian Lari"]
        + GHS
            [value "Ghanaian Cedi"]
        + GIP
            [value "Gibraltar Pound"]
        + GMD
            [value "Gambian Dalasi"]
        + GNF
            [value "Guinean Franc"]
        + GTQ
            [value "Guatemalan Quetzal"]
        + GYD
            [value "Guyanese Dollar"]
        + HKD
            [value "Hong Kong Dollar"]
        + HNL
            [value "Honduran Lempira"]
        + HTG
            [value "Haitian Gourde"]
        + HUF
            [value "Hungarian Forint"]
        + IDR
            [value "Indonesian Rupiah"]
        + ILS
            [value "Israeli New Shekel"]
        + INR
            [value "Indian Rupee"]
        + IQD
            [value "Iraqi Dinar"]
        + IRR
            [value "Iranian Rial"]
        + ISK
            [value "Icelandic Krna"]
        + JMD
            [value "Jamaican Dollar"]
        + JOD
            [value "Jordanian Dinar"]
        + JPY
            [value "Japanese Yen"]
        + KES
            [value "Kenyan Shilling"]
        + KGS
            [value "Kyrgyzstani Som"]
        + KHR
            [value "Cambodian Riel"]
        + KMF
            [value "Comoro Franc"]
        + KPW
            [value "North Korean Won"]
        + KRW
            [value "South Korean Won"]
        + KWD
            [value "Kuwaiti Dinar"]
        + KYD
            [value "Cayman Islands Dollar"]
        + KZT
            [value "Kazakhstani Tenge"]
        + LAK
            [value "Lao Kip"]
        + LBP
            [value "Lebanese Pound"]
        + LKR
            [value "Sri Lankan Rupee"]
        + LRD
            [value "Liberian Dollar"]
        + LSL
            [value "Lesotho Loti"]
        + LYD
            [value "Libyan Dinar"]
        + MAD
            [value "Moroccan Dirham"]
        + MDL
            [value "Moldovan Leu"]
        + MGA
            [value "Malagasy Ariary"]
        + MKD
            [value "Macedonian Denar"]
        + MMK
            [value "Myanmar Kyat"]
        + MNT
            [value "Mongolian Tgrg"]
        + MOP
            [value "Macanese Pataca"]
        + MRU
            [value "Mauritanian Ouguiya"]
        + MUR
            [value "Mauritian Rupee"]
        + MVR
            [value "Maldivian Rufiyaa"]
        + MWK
            [value "Malawian Kwacha"]
        + MXN
            [value "Mexican Peso"]
        + MXV
            [value "Mexican Unidad de Inversion (UDI)"]
        + MYR
            [value "Malaysian Ringgit"]
        + MZN
            [value "Mozambican Metical"]
        + NAD
            [value "Namibian Dollar"]
        + NGN
            [value "Nigerian Naira"]
        + NIO
            [value "Nicaraguan Crdoba"]
        + NOK
            [value "Norwegian Krone"]
        + NPR
            [value "Nepalese Rupee"]
        + NZD
            [value "New Zealand Dollar"]
        + OMR
            [value "Omani Rial"]
        + PAB
            [value "Panamanian Balboa"]
        + PEN
            [value "Peruvian Sol"]
        + PGK
            [value "Papua New Guinean Kina"]
        + PHP
            [value "Philippine Peso"]
        + PKR
            [value "Pakistani Rupee"]
        + PLN
            [value "Polish Zoty"]
        + PYG
            [value "Paraguayan Guaran"]
        + QAR
            [value "Qatari Riyal"]
        + RON
            [value "Romanian Leu"]
        + RSD
            [value "Serbian Dinar"]
        + RUB
            [value "Russian Ruble"]
        + RWF
            [value "Rwandan Franc"]
        + SAR
            [value "Saudi Riyal"]
        + SBD
            [value "Solomon Islands Dollar"]
        + SCR
            [value "Seychelles Rupee"]
        + SDG
            [value "Sudanese Pound"]
        + SEK
            [value "Swedish Krona/Kronor"]
        + SGD
            [value "Singapore Dollar"]
        + SHP
            [value "Saint Helena Pound"]
        + SLE
            [value "Leone"]
        + SOS
            [value "Somali Shilling"]
        + SRD
            [value "Surinamese Dollar"]
        + SSP
            [value "South Sudanese Pound"]
        + STN
            [value "So Tom and Prncipe Dobra"]
        + SVC
            [value "Salvadoran Coln"]
        + SYP
            [value "Syrian Pound"]
        + SZL
            [value "Swazi Lilangeni"]
        + THB
            [value "Thai Baht"]
        + TJS
            [value "Tajikistani Somoni"]
        + TMT
            [value "Turkmenistan Manat"]
        + TND
            [value "Tunisian Dinar"]
        + TOP
            [value "Tongan Paanga"]
        + TRY
            [value "Turkish Lira"]
        + TTD
            [value "Trinidad and Tobago Dollar"]
        + TWD
            [value "New Taiwan Dollar"]
        + TZS
            [value "Tanzanian Shilling"]
        + UAH
            [value "Ukrainian Hryvnia"]
        + UGX
            [value "Ugandan Shilling"]
        + USD
            [value "United States Dollar"]
        + UYI
            [value "Uruguay Peso en Unidades Indexadas (URUIURUI)"]
        + UYU
            [value "Uruguayan Peso"]
        + UYW
            [value "Unidad Previsional"]
        + UZS
            [value "Uzbekistan Som"]
        + VES
            [value "Venezuelan Bolvar Soberano"]
        + VND
            [value "Vietnamese ng"]
        + VUV
            [value "Vanuatu Vatu"]
        + WST
            [value "Samoan Tala"]
        + XAF
            [value "CFA Franc BEAC"]
        + XCD
            [value "East Caribbean Dollar"]
        + XOF
            [value "CFA Franc BCEAO"]
        + XPF
            [value "CFP Franc (Franc Pacifique)"]
        + YER
            [value "Yemeni Rial"]
        + ZAR
            [value "South African Rand"]
        + ZMW
            [value "Zambian Kwacha"]
        + ZWG
            [value "Zimbabwean Gold"]

    RecalculationOfValueElectionEnum:
        + ConsulationProcedure
            [value "consultation_procedure"]
        + OtherRegulatoryCSAProcedure
            [value "other_regulatory_CSA_procedure"]
        + NotApplicable
            [value "not_applicable"]
        + Specified
            [value "specified"]

    SimmExceptionApplicableEnum:
        + FallBackToMandatoryMethod
            [value "fallback"]
        + MandatoryMethod
            [value "mandatory"]
        + OtherMethod
            [value "other"]

    ExceptionEnum:
        + Applicable
            [value "applicable"]
            [value "not_specified"]
            [value "false"]
        + NotApplicable
            [value "not_applicable"]
            [value "paragraph_3_1_will_not_apply"]
            [value "paragraph_4a_will_not_apply"]
        + Other
            [value "specify"]
            [value "other"]
            [value "true"]
            [value "other__specify"]

    SensitivitiesEnum:
        + Alternative
            [value "alternative"]
            [value "other"]
        + Standard
            [value "standard"]
            [value "not_specified"]

    RegulatoryRegimeEnum:
        + AustraliaMarginRules
            [value "australia"]
        + CanadaMarginRules
            [value "canada"]
        + CFTC_MarginRules
            [value "cftc"]
        + EMIR_MarginRules
            [value "emir"]
        + HongKongMarginRules
            [value "hong_kong"]
        + JapanMarginRules
            [value "japan"]
        + US_PrudentialMarginRules
            [value "prudential"]
        + SEC_MarginRules
            [value "sec"]
        + SingaporeMarginRules
            [value "singapore"]
        + SwitzerlandMarginRules
            [value "switzerland"]
        + BrazilMarginRules
            [value "brazil"]
        + UnitedKingdomMarginRules
            [value "united_kingdom"]
        + SouthAfricaMarginRules
            [value "south_africa"]
        + SouthKoreaMarginRules
            [value "south_korea"]
        + HongKongSFCMarginRules
            [value "hong_kong_sfc"]

    MarginApproachEnum:
        + Distinct
            [value "distinct"]
        + Allocated
            [value "allocated"]
        + GreaterOf
            [value "greaterof"]
            [value "greater_of"]

    InterestAdjustmentPeriodicityEnum:
        + LastLocalBusinessDayOfMonth
            [value "last_day"]
        + EachDay
            [value "each_day"]

    DeliveryAmountElectionEnum:
        + LastLocalBusinessDay
            [value "include_one"]
        + LastAndAnyLocalBusinessDay
            [value "include_both"]

    CollateralAssetDefinitionsEnum:
        + GB_GILT
            [value "UK Gilts"]

    AmendmentEffectiveDateEnum:
        + AnnexDate
            [value "annex"]
            [value "specify_date"]
        + DeedDate
            [value "deed"]
        + AgreementDate
            [value "agreement"]
        + AmendmentEffectiveDate
            [value "amendment_effective_date"]

    AdditionalTypeEnum:
        + NotApplicable
            [value "not_applicable"]
        + Other
            [value "other"]

    BusinessCenterEnum:
        + AEAD
            [value "Abu Dhabi, United Arab Emirates"]
        + AMYE
            [value "Yerevan, Armenia"]
        + AOLU
            [value "Luanda, Angola"]
        + ARBA
            [value "Buenos Aires, Argentina"]
        + ATVI
            [value "Vienna, Austria"]
        + AUCA
            [value "Canberra, Australia"]
        + AUSY
            [value "Sydney, Australia"]
        + BBBR
            [value "Bridgetown, Barbados"]
        + BDDH
            [value "Dhaka, Bangladesh"]
        + BEBR
            [value "Brussels, Belgium"]
        + BGSO
            [value "Sofia, Bulgaria"]
        + BHMA
            [value "Manama, Bahrain"]
        + BMHA
            [value "Hamilton, Bermuda"]
        + BNBS
            [value "Bandar Seri Begawan, Brunei Darussalam"]
        + BOLP
            [value "La Paz, Bolivia"]
        + BRBR
            [value "Braslia, Brazil"]
        + BSNA
            [value "Nassau, Bahamas"]
        + BWGA
            [value "Gaborone, Botswana"]
        + BYMI
            [value "Minsk, Belarus"]
        + CAOT
            [value "Ottawa-Gatineau, Canada"]
        + CATO
            [value "Toronto, Canada"]
        + CIAB
            [value "Abidjan, Cte d'Ivoire"]
        + CLSA
            [value "Santiago, Chile"]
        + CNBE
            [value "Beijing, China"]
        + CNSH
            [value "Shanghai, China"]
        + COBO
            [value "Bogot, Colombia"]
        + CRSJ
            [value "San Jos, Costa Rica"]
        + CYNI
            [value "Nicosia, Cyprus"]
        + CZPR
            [value "Prague, Czechia"]
        + DEFR
            [value "Frankfurt, Germany"]
        + DKCO
            [value "Copenhagen, Denmark"]
        + DOSD
            [value "Santo Domingo, Dominican Republic"]
        + DZAL
            [value "Algiers, Algeria"]
        + EETA
            [value "Tallinn, Estonia"]
        + EGCA
            [value "Cairo, Egypt"]
        + ESMA
            [value "Madrid, Spain"]
        + FIHE
            [value "Helsinki, Finland"]
        + FRPA
            [value "Paris, France"]
        + GBLO
            [value "London, United Kingdom"]
        + GETB
            [value "Tbilisi, Georgia"]
        + GRAT
            [value "Athens, Greece"]
        + HKHK
            [value "Hong Kong, China"]
        + HNTE
            [value "Tegucigalpa, Honduras"]
        + HRZA
            [value "Zagreb, Croatia"]
        + HUBU
            [value "Budapest, Hungary"]
        + IDJA
            [value "Jakarta, Indonesia"]
        + IEDU
            [value "Dublin, Ireland"]
        + ILJE
            [value "Jerusalem, Israel"]
        + INND
            [value "New Delhi, India"]
        + IRTE
            [value "Tehran, Iran (Islamic Republic of)"]
        + ISRE
            [value "Reykjavk, Iceland"]
        + JESH
            [value "St. Helier, Channel Islands"]
        + JMKI
            [value "Kingston, Jamaica"]
        + JOAM
            [value "Amman, Jordan"]
        + JPTO
            [value "Tokyo, Japan"]
        + KENA
            [value "Nairobi, Kenya"]
        + KRSE
            [value "Seoul, Republic of Korea"]
        + KWKC
            [value "Kuwait City, Kuwait"]
        + KYGE
            [value "George Town, Cayman Islands"]
        + LBBE
            [value "Beirut, Lebanon"]
        + LKCO
            [value "Colombo, Sri Lanka"]
        + LULU
            [value "Luxembourg, Luxembourg"]
        + LVRI
            [value "Riga, Latvia"]
        + MARA
            [value "Rabat, Morocco"]
        + MCMO
            [value "Monaco, Monaco"]
        + MOMA
            [value "Macao, China, Macao SAR"]
        + MTVA
            [value "Valletta, Malta"]
        + MUPL
            [value "Port Louis, Mauritius"]
        + MVMA
            [value "Male, Maldives"]
        + MWLI
            [value "Lilongwe, Malawi"]
        + MXMC
            [value "Mexico City, Mexico"]
        + MYKL
            [value "Kuala Lumpur, Malaysia"]
        + NAWI
            [value "Windhoek, Namibia"]
        + NGAB
            [value "Abuja, Nigeria"]
        + NLAM
            [value "Amsterdam, Netherlands"]
        + NOOS
            [value "Oslo, Norway"]
        + NPKA
            [value "Kathmandu, Nepal"]
        + NZWE
            [value "Wellington, New Zealand"]
        + OMMU
            [value "Masqat (Muscat), Oman"]
        + PAPC
            [value "Panama City, Panama"]
        + PELI
            [value "Lima, Peru"]
        + PHMA
            [value "Manila, Philippines"]
        + PLWA
            [value "Warsaw, Poland"]
        + PRSJ
            [value "San Juan, Puerto Rico"]
        + PTLI
            [value "Lisbon, Portugal"]
        + QADO
            [value "Doha, Qatar"]
        + RSBE
            [value "Belgrade, Serbia"]
        + RUMO
            [value "Moscow, Russian Federation"]
        + SARI
            [value "Riyadh, Saudi Arabia"]
        + SEST
            [value "Stockholm, Sweden"]
        + SGSI
            [value "Singapore, Singapore"]
        + SILJ
            [value "Ljubljana, Slovenia"]
        + SKBR
            [value "Bratislava, Slovakia"]
        + SNDA
            [value "Dakar, Senegal"]
        + SVSS
            [value "San Salvador, El Salvador"]
        + THBA
            [value "Bangkok, Thailand"]
        + TNTU
            [value "Tunis, Tunisia"]
        + TRAN
            [value "Ankara, Turkey"]
        + TTPS
            [value "Port of Spain, Trinidad and Tobago"]
        + TWTA
            [value " Taibei, China, Taiwan Province of China"]
        + TZDO
            [value "Dodoma, United Republic of Tanzania"]
        + UAKI
            [value "Kiev, Ukraine"]
        + UGKA
            [value "Kampala, Uganda"]
        + USDC
            [value "Washington, D.C., United States of America"]
        + USNY
            [value "New York, United States of America"]
        + UYMO
            [value "Montevideo, Uruguay"]
        + VECA
            [value "Caracas, Venezuela (Bolivarian Republic of)"]
        + VGRT
            [value "Road Town, British Virgin Islands"]
        + VNHA
            [value "H Noi, Viet Nam"]
        + VNHC
            [value "Ho Chi Minh (formerly Saigon), Vietnam"]
        + ZMLU
            [value "Lusaka, Zambia"]
        + ZWHA
            [value "Harare, Zimbabwe"]

    DayTypeEnum:
        + Business
            [value "days_after_days"]
            [value "day_release_days"]
            [value "day_release_date_i"]
            [value "day_release_date_ii"]
            [value "days_days_prior_to_release_date"]
            [value "days_timely_days"]
            [value "days_days_after_timely_statement"]
            [value "local_business_days_days_after_timely_statement"]
        + Calendar
            [value "calendar_days_after_days"]
            [value "calendar_day_release_days"]
            [value "calendar_day_release_date_i"]
            [value "calendar_day_release_date_ii"]
            [value "calendar_days_days_prior_to_release_date"]
            [value "calendar_days_timely_days"]

    GoverningLawEnum:
        + BE
            [value "Belgian"]
        + GBEN
            [value "English"]
        + JP
            [value "Japanese"]
        + LU
            [value "Luxembourg"]
        + RelatedMasterAgreement
            [value "As agreed in the ISDA Master Agreement"]
        + USNY
            [value "New York"]

    LegalAgreementTypeEnum:
        + MasterAgreement
            [value "Master Agreement"]
        + CreditSupportAgreement
            [value "Credit Support Deed"]
            [value "Credit Support Annex"]
            [value "Collateral Transfer Agreement"]
        + SecurityAgreement
            [value "Security Agreement"]

    MasterAgreementTypeEnum:
        + ISDAMaster
            [value "Master Agreement"]

    CreditSupportAgreementTypeEnum:
        + CreditSupportDeed
            [value "Credit Support Deed"]
        + CreditSupportAnnex
            [value "Credit Support Annex"]
        + CollateralTransferAgreement
            [value "Collateral Transfer Agreement"]

    LegalAgreementPublisherEnum:
        + ISDAClearstream
            [value "ISDA/Clearstream"]
        + ISDAEuroclear
            [value "ISDA/Euroclear"]
        + ISDA
            [value "ISDA"]

    ExecutionLocationEnum:
        + ExecutedOutsideBelgium
            [value "executed_outside_of_belgium"]
        + ExecutedInBelgium
            [value "executed_in_belgium"]
        + OtherLocation
            [value "other"]
}


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-dtcc-synonym.rosetta
================================================================================

namespace cdm.mapping.dtcc
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.mapping.fpml.confirmation.workflowstep.*
import cdm.product.asset.*
import cdm.product.common.settlement.*
import cdm.product.template.*

synonym source DTCC_11_0 extends DTCC_BASE
{
    EventInstruction:
        + intent
            [set to EventIntentEnum -> ContractFormation when "OTC_Matching->Trade->FpML->trade" exists]
        + instruction
            [value "Manifest" path "OTC_RM" , "ReportingHeader" path "OTC_Matching->ReportingData" , "FpML" path "OTC_Matching->Trade"]

    Instruction:
        + before
            [hint "TradeMsg"]
            [hint "ReportingJurisdiction"]
}

synonym source DTCC_9_0 extends DTCC_BASE
{
    WorkflowStep:
        + party
            [value "party" path "Body->OTC_Matching->Payment->FpML"]

    EventInstruction:
        + intent
            [value "ignore"]
        + instruction
            [value "FpML" path "OTC_Matching->Payment"]

    Instruction:
        - before
        + before
            [value "ignore"]

    PrimitiveInstruction:
        - transfer

    TransferInstruction:
        + transferState
            [value "payment"]

    TransferState:
        - transfer

    Asset:
        + Instrument
            [value "ignore"]
}

synonym source DTCC_BASE extends FpML_5_Confirmation_To_WorkflowStep
{
    AdjustableOrAdjustedOrRelativeDate:
        + adjustedDate
            [value "adjustedPaymentDate"]

    TradeState:
        + trade
            [value "TradeMsg"]
            [value "ReportingJurisdiction"]

    Trade:
        - tradeIdentifier
        + tradeIdentifier
            [value "Submitter"]
            [value "ContraTradeId"]
            [value "YourTradeId"]
            [value "tradeIdentifyingItems"]
            [value "USI"]
            [value "OriginatingUSI"]
            [value "UTI"]

    TransferableProduct:
        + Instrument
            [hint "ProductType"]

    AssignedIdentifier:
        + identifier
            [value "tradeId" path "partyTradeIdentifier" maps 2 set when "partyTradeIdentifier->tradeId->tradeIdScheme" = "EventProcessingId" and rosettaPath = WorkflowStep -> eventIdentifier -> assignedIdentifier -> identifier , set when "partyTradeIdentifier->tradeId->tradeIdScheme" = "TradeRefNbr" and rosettaPath = Trade -> tradeIdentifier -> assignedIdentifier -> identifier meta "tradeIdScheme"]
            [value "USITradeId" meta "tradeIdScheme"]
            [value "UTITradeId" meta "tradeIdScheme"]
            [value "identifier" meta "paymentIdScheme"]

    Identifier:
        + issuerReference
            [value "partyReference" path "partyTradeIdentifier" maps 2 meta "href"]
        + issuer
            [value "USIIssuer" meta "issuerIdScheme"]
            [value "UTIIssuer" meta "issuerIdScheme"]

    InterestShortFall:
        + rateSource
            [value "rateSource" meta "floatingRateIndexScheme"]

    CustomisedWorkflow:
        + itemName
            [set to "comment" when path = "PartyWorkflowFields->comment"]
            [set to "superId" when path = "PartyWorkflowFields->superId"]
            [set to "deskId" when path = "PartyWorkflowFields->deskId"]
            [set to "eTradeId" when path = "PartyWorkflowFields->eTradeId"]
            [set to "designatedParty" when path = "PartyWorkflowFields->designatedParty"]
            [set to "brokerName" when path = "PartyWorkflowFields->brokerName"]
            [set to "branchLocation" when path = "PartyWorkflowFields->branchLocation"]
            [set to "midMarketPriceType" when path = "PartyWorkflowFields->midMarketPrice->midMarketPriceType"]
            [set to "amount" when path = "PartyWorkflowFields->midMarketPrice->amount"]
        + itemValue
            [value "comment" path "PartyWorkflowFields"]
            [value "superId" path "PartyWorkflowFields"]
            [value "deskId" path "PartyWorkflowFields"]
            [value "eTradeId" path "PartyWorkflowFields"]
            [value "designatedParty" path "PartyWorkflowFields"]
            [value "brokerName" path "PartyWorkflowFields"]
            [value "branchLocation" path "PartyWorkflowFields"]
            [value "midMarketPriceType" path "PartyWorkflowFields->midMarketPrice"]
            [value "amount" path "PartyWorkflowFields->midMarketPrice"]

    WorkflowStep:
        + proposedEvent
            [value "Body" , "Header"]
        - messageInformation
        + messageInformation
            [value "FpML" path "Body->OTC_Matching->Trade"]
            [value "FpML" path "Body->OTC_Matching->Payment"]
            [value "RouteInfo" path "Header->OTC_RM->Delivery"]
            [value "Manifest" path "Header->OTC_RM"]
        + timestamp
            [value "header" path "Body->OTC_Matching->Trade->FpML"]
            [value "Route" path "Header->OTC_RM->Delivery->RouteHist"]
            [value "header" path "Body->OTC_Matching->Payment->FpML"]
        - eventIdentifier
        + eventIdentifier
            [value "Submitter" path "Header->OTC_RM->Manifest->TradeMsg"]
            [value "ContraTradeId" path "Header->OTC_RM->Manifest->TradeMsg"]
            [value "YourTradeId" path "Header->OTC_RM->Manifest->TradeMsg"]
            [value "tradeIdentifyingItems" path "Header->OTC_RM->Manifest->TradeMsg"]
        + action
            [value "Activity" path "Header->OTC_RM->Manifest->TradeMsg"]
        + workflowState
            [value "OTC_Matching" path "Body"]

    EventTimestamp:
        + dateTime
            [value "creationTimestamp"]
            [value "expiryTimestamp"]
            [value "ReceiveTime"]
        + qualification
            [set to EventTimestampQualificationEnum -> eventCreationDateTime when "creationTimestamp" exists]
            [set to EventTimestampQualificationEnum -> eventExpirationDateTime when "expiryTimestamp" exists]
            [set to EventTimestampQualificationEnum -> eventSubmittedDateTime when "ReceiveTime" exists]

    MessageInformation:
        + messageId
            [value "messageId" path "header" meta "messageIdScheme"]
        + sentBy
            [value "From"]
        + sentTo
            [value "To"]

    PartyCustomisedWorkflow:
        + partyReference
            [value "partyReference" maps 2 meta "href"]

    WorkflowState:
        + warehouseIdentity
            [value "WarehousePositionType" path "WarehouseState"]
        + workflowStatus
            [value "WarehouseStatus" path "WarehouseState"]
        + partyCustomisedWorkflow
            [value "WorkflowData"]

    enums

    ActionEnum:
        + New
            [value "New"]
        + Correct
            [value "Modify"]
        + Cancel
            [value "Disable"]

    TransferSettlementEnum:
        + PaymentVersusPayment
            [value "CentralSettlement"]
        + NotCentralSettlement
            [value "NotCentralSettlement"]

    WarehouseIdentityEnum:
        + DTCC_TIW_Gold
            [value "Gold"]

    WorkflowStatusEnum:
        + Alleged
            [value "Alleged"]
        + Certain
            [value "Certain"]
        + Submitted
            [value "Submit"]
        + Uncertain
            [value "Uncertain"]
        + Unconfirmed
            [value "Unconfirmed"]
}


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-fis-synonym.rosetta
================================================================================

namespace cdm.mapping.fis
version "${project.version}"

import cdm.event.common.*
import cdm.event.workflow.*

synonym source FIS_BASE

synonym source FIS extends FIS_BASE
{
    WorkflowStep:
        + businessEvent
            [value "FIS_TRADE" mapper "FISMapper"]
        + lineage
            [value "ignore"]

    BusinessEvent:
        + instruction
            [value "ignore"]
        + after
            [value "ignore"]
}


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-fpml-confirmation-tradestate-synonym.rosetta
================================================================================

namespace cdm.mapping.fpml.confirmation.tradestate
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.credit.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.asset.commodity.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.legaldocumentation.common.*
import cdm.legaldocumentation.master.*
import cdm.observable.asset.*
import cdm.observable.asset.calculatedrate.*
import cdm.observable.common.*
import cdm.observable.event.*
import cdm.product.asset.*
import cdm.product.collateral.*
import cdm.product.common.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.template.*

synonym source FpML

synonym source FpML_5_Confirmation_To_TradeState extends FpML
{
    TradeState:
		[meta "id" path "trade"]
        + trade
            [value "trade" mapper "Party"]
            [hint "party" , "account" , "quote" , "partyTradeIdentifier"]
        + resetHistory
            [value "ignore"]
        + transferHistory
            // premium
            [value "bondOption" path "trade"]
            [value "swaption" path "trade"]
            [value "fxOption" path "trade"]
            [value "fxDigitalOption" path "trade"]
            [value "creditDefaultSwapOption" path "trade"]
            [value "commodityOption" path "trade"]
            [value "commodityBasketOption" path "trade"]
            [value "capFloor" path "trade"]
            [value "commoditySwaption" path "trade"]
            // equityPremium
            [value "equityOption" path "trade"]
            [value "brokerEquityOption" path "trade"]
            [value "dividendSwapOptionTransactionSupplement" path "trade"]
            [value "equityOptionTransactionSupplement" path "trade"]
            [value "varianceOptionTransactionSupplement" path "trade"]
            [value "dividendSwapOptionTransactionSupplement" path "trade"]
            [value "fxVarianceSwap" path "trade"]
            [value "fxVolatilitySwap" path "trade"]
            // initialPayment / singlePayment
            [value "feeLeg" path "trade->creditDefaultSwap"]
            // additionalPayment
            [value "swap" path "trade"]
            // otherPartyPayment
            [value "trade"]
        + observationHistory
            [value "ignore"]

    Trade:
        + tradeIdentifier
            [value "partyTradeIdentifier"]
            [value "partyTradeIdentifier" path "tradeHeader"]
            [value "tradeHeader"]
        + tradeDate
            [value "tradeDate" maps 2 meta "id"]
            [value "tradeDate" path "tradeHeader" maps 2 meta "id"]
        + party
            [value "party"]
        + partyRole
            [value "determiningParty" , "barrierDeterminationAgent" , "hedgingParty" , "brokerPartyReference" mapper "PartyRole"]
            [value "partyReference" path "tradeHeader->partyTradeInformation" mapper "RelatedPartyRole"]
        + clearedDate
            [value "clearedDate" path "tradeHeader"]
        + collateral
            [value "collateral"]
        + account
            [value "account"]

    TradeIdentifier:
        + identifierType
            // [set to TradeIdentifierTypeEnum -> UniqueSwapIdentifier when "tradeId->tradeIdScheme" = "http://www.fpml.org/coding-scheme/external/unique-transaction-identifier" and "issuer->issuerIdScheme" = "http://www.fpml.org/coding-scheme/external/cftc/issuer-identifier"]
            [set to TradeIdentifierTypeEnum -> UniqueTransactionIdentifier when "tradeId->tradeIdScheme" = "http://www.fpml.org/coding-scheme/external/uti"]
            [set to TradeIdentifierTypeEnum -> UniqueTransactionIdentifier when "tradeId->tradeIdScheme" = "http://www.fpml.org/coding-scheme/external/unique-transaction-identifier"]
            [set to TradeIdentifierTypeEnum -> UniqueSwapIdentifier when "tradeId->tradeIdScheme" = "http://www.fpml.org/coding-scheme/external/usi"]
            [set to TradeIdentifierTypeEnum -> UniqueSwapIdentifier when "tradeId->tradeIdScheme" = "http://www.fpml.org/coding-scheme/external/unique-swap-identifier"]

    Identifier:
        [meta "id"]
        [meta "id" path "versionedTradeId->tradeId"]
        + issuerReference
            [value "issuer" meta "href"]
            [value "partyReference" meta "href"]
        + issuer
            [value "issuer" maps 2 meta "issuerIdScheme"]

    AssignedIdentifier:
        + identifier
            [value "tradeId" maps 2 meta "tradeIdScheme"]
            [value "tradeId" path "versionedTradeId" meta "tradeIdScheme"]
            [value "businessUnitId" meta "unitScheme"]
            [value "eventId" meta "eventIdScheme"]
            [value "messageId"]
            [value "collateralPortfolio"]
            [value "linkId" path "partyTradeIdentifier" mapper "LinkId"]
        + version
            [value "version" path "versionedTradeId"]
            [value "version"]

    IdentifiedList:
        + listId
            [value "packageIdentifier" , "packageIdentifier" path "packageHeader"]
        + componentId
            [value "partyTradeIdentifier" path "trade->tradeHeader" set when "trade->tradeHeader->originatingPackage" exists]

    TransferState:
		[meta "id" path "singlePayment"]
		[meta "id" path "additionalPayment"]
        + transfer
            [value "premium"]
            [value "equityPremium"]
            [value "initialPayment"]
            [value "singlePayment"]
            [value "additionalPayment"]
            [value "otherPartyPayment"]

    Transfer:
        + identifier
            [value "ignore"]
        + settlementOrigin
            [value "ignore"]
        + resetOrigin
            [value "ignore"]

    TransferExpression:
        + priceTransfer
            [set to FeeTypeEnum -> Upfront when path = "additionalPayment"]
            [set to FeeTypeEnum -> Upfront when path = "otherPartyPayment"]
            [set to FeeTypeEnum -> Upfront when path = "initialPayment"]
            [set to FeeTypeEnum -> Upfront when path = "singlePayment->fixedAmount"]
            [set to FeeTypeEnum -> Upfront when "paymentType" = "Additional Payment"]
            [set to FeeTypeEnum -> Premium when path = "premium"]
            [set to FeeTypeEnum -> Premium when path = "equityPremium"]
            [set to FeeTypeEnum -> BrokerageCommission when "paymentType" = "Brokerage"]
            [set to FeeTypeEnum -> Novation when path = "novation->payment"]

    ContractDetails:
        + documentation
            [value "documentation" mapper "Documentation"]
        + governingLaw
            [value "governingLaw" meta "governingLawScheme"]

    ExecutionDetails:
        + packageReference
            [value "originatingPackage" path "tradeHeader"]

    TradableProduct:
        + product // i.e. NonTransferableProduct
            // For Equity Swap:
            [value "returnSwap"]
            [value "equitySwapTransactionSupplement"]
            // For Swap Stream:
            [value "swap"]
            // For Swaption:
            [value "swaption"]
            [hint "swaption"]
            // For CapFloor:
            [value "capFloor"]
            [hint "capFloor"]
            // For FRA:
            [hint "fra"]
            [value "fra" mapper "FraPayoutSplitter"]
            // For Bond Options:
            [hint "bondOption"]
            // For CDS:
            [value "creditDefaultSwap" mapper "CdsFeeLegPayout"]
            [hint "creditDefaultSwap"]
            // For CDS Option
            [hint "creditDefaultSwapOption"]
            // For FX:
            [hint "fxSingleLeg"]
            [value "fxSingleLeg"]
            // For FX Option:
            [value "fxOption"]
            [hint "fxOption"]
            [value "fxDigitalOption"]
            [hint "fxDigitalOption"]
            // For fxSwap
            [value "fxSwap"]
            // For Repo:
            [hint "repo"]
            [hint "calculationAgent" , "calculationAgentBusinessCenter"]
            // For Equity Options:
            [hint "equityOption"]
            [value "equityOption"]
            [hint "brokerEquityOption"]
            [value "brokerEquityOption"]
            [value "equityOptionTransactionSupplement"]
            [hint "equityOptionTransactionSupplement"]
            // For Commodity Swap
            [value "commoditySwap"]
            [hint "commoditySwap"]
            // For Commodity Option
            [hint "commodityOption"]
            [value "commodityOption"]
            [hint "commoditySwaption"]
            // For Variance / Volatility / Correlation / Dividend
            [value "varianceSwap"]
            [value "varianceSwapTransactionSupplement"]
            [value "volatilitySwap"]
            [value "volatilitySwapTransactionSupplement"]
            [value "correlationSwap"]
            [value "dividendSwapTransactionSupplement"]
            [hint "varianceOptionTransactionSupplement"]
            [hint "dividendSwapOptionTransactionSupplement"]
            [value "fxVarianceSwap"]
            [hint "fxVarianceSwap"]
            [value "fxVolatilitySwap"]
            [hint "fxVolatilitySwap"]
            [hint "genericProduct"]
            [hint "tradeHeader"]
        + tradeLot
            // Rates
            [value "swap"]
            [value "swap" path "swaption"]
            [value "capFloor"]
            [hint "fra"]
            [hint "bondOption"]
            [value "bulletPayment"]
            // Credit
            [value "creditDefaultSwap"]
            [value "creditDefaultSwap" path "creditDefaultSwapOption"]
            // FX
            [hint "fxSingleLeg"]
            [value "fxSwap"]
            [hint "fxOption"]
            [hint "fxDigitalOption"]
            // Equity
            [value "returnSwap"]
            [value "equitySwapTransactionSupplement"]
            [hint "equityOption"]
            [hint "equityOptionTransactionSupplement"]
            [hint "brokerEquityOption"]
            // Performance
            [value "varianceSwap"]
            [value "correlationSwap"]
            [value "volatilitySwapTransactionSupplement"]
            [value "varianceOptionTransactionSupplement"]
            [value "dividendSwapTransactionSupplement"]
            [value "dividendSwapTransactionSupplement" path "dividendSwapOptionTransactionSupplement"]
            [value "varianceSwapTransactionSupplement"]
            [value "varianceSwapTransactionSupplement" path "varianceOptionTransactionSupplement"]
            [hint "fxVarianceSwap"]
            [hint "fxVolatilitySwap"]
            // Commodity
            [value "commoditySwap"]
            [value "commoditySwap" path "commoditySwaption"]
            [hint "commodityOption"]
            // Other
            [hint "repo"]
            [hint "genericProduct"]
            [hint "quote"]
            [hint "productSummary"]
        + adjustment
            [value "notionalAdjustments" path "returnSwap->returnLeg" , "notionalAdjustments" path "equitySwapTransactionSupplement->returnLeg"]

    ProductIdentifier:
        + identifier
            [value "productId" maps 2 mapper "ProductIdentifierSource"]
            [value "productId" path "commoditySwaption" maps 2 mapper "ProductIdentifierSource"]
            [value "productId" path "creditDefaultSwapOption" maps 2 mapper "ProductIdentifierSource"]
            [value "productId" path "bondOption" maps 2 mapper "ProductIdentifierSource"]
            [value "productId" path "genericProduct" maps 2 mapper "ProductIdentifierSource"]

    Taxonomy:
        + source
            [set to TaxonomySourceEnum -> ISDA when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/isda-layer-1-commodity-classification"]
            [set to TaxonomySourceEnum -> EMIR when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/esma-emir-refit-layer-1-commodity-classification"]

    ProductTaxonomy:
        + primaryAssetClass
            [value "primaryAssetClass" meta "assetClassScheme"]
            [value "primaryAssetClass" path "fra" meta "assetClassScheme"]
            [value "primaryAssetClass" path "creditDefaultSwapOption" meta "assetClassScheme"]
            [value "primaryAssetClass" path "bondOption" meta "assetClassScheme"]
            [value "primaryAssetClass" path "commoditySwaption" meta "assetClassScheme"]
            [value "primaryAssetClass" path "genericProduct" meta "assetClassScheme"]
        + secondaryAssetClass
            [value "secondaryAssetClass" meta "assetClassScheme"]
            [value "secondaryAssetClass" path "fra" meta "assetClassScheme"]
            [value "secondaryAssetClass" path "creditDefaultSwapOption" meta "assetClassScheme"]
            [value "secondaryAssetClass" path "bondOption" meta "assetClassScheme"]
            [value "secondaryAssetClass" path "commoditySwaption" meta "assetClassScheme"]
            [value "secondaryAssetClass" path "genericProduct" meta "assetClassScheme"]
        + source
            [value "productType" mapper "TaxonomySource"]
            [value "productType" path "fra" mapper "TaxonomySource"]
            [value "productType" path "creditDefaultSwapOption" mapper "TaxonomySource"]
            [value "productType" path "bondOption" mapper "TaxonomySource"]
            [value "productType" path "commoditySwaption" mapper "TaxonomySource"]
            [value "productType" path "genericProduct" mapper "TaxonomySource"]

    TaxonomyValue:
        + name
            [value "productType"]
            [value "productType" path "fra" maps 2]
            [value "productType" path "creditDefaultSwapOption"]
            [value "productType" path "bondOption"]
            [value "productType" path "commoditySwaption"]
            [value "productType" path "genericProduct"]

    TaxonomyClassification:
        + value
            [value "code"]
        + ordinal
            [set to 1 when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/esma-emir-refit-layer-1-commodity-classification"]
            [set to 2 when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/esma-emir-refit-layer-2-commodity-classification"]
            [set to 3 when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/esma-emir-refit-layer-3-commodity-classification"]
            [set to 1 when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/isda-layer-1-commodity-classification"]
            [set to 2 when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/isda-layer-2-commodity-classification"]
            [set to 3 when "code->commodityClassificationScheme" = "http://www.fpml.org/coding-scheme/isda-layer-3-commodity-classification"]

    EconomicTerms:
        + effectiveDate
            [value "effectiveDate" path "generalTerms"]
            [value "effectiveDate" path "commoditySwap"]
            [value "effectiveDate" path "fxOption"]
            [value "effectiveDate"]
            [value "effectiveDate" path "varianceLeg"]
            [value "effectiveDate" path "volatilityLeg"]
            [value "effectiveDate" path "correlationLeg"]
            [value "effectiveDate" path "dividendLeg"]
            [value "effectiveDate" path "fixedLeg"]
            [value "effectiveDate" path "returnLeg"]
            [value "effectiveDate" path "genericProduct"]
        + terminationDate
            [value "scheduledTerminationDate" path "generalTerms"]
            [value "terminationDate"]
            [value "terminationDate" path "varianceLeg"]
            [value "terminationDate" path "volatilityLeg"]
            [value "terminationDate" path "correlationLeg"]
            [value "terminationDate" path "dividendLeg"]
            [value "terminationDate" path "fixedLeg"]
            [value "terminationDate" path "returnLeg"]
            [value "terminationDate" path "genericProduct"]
        + dateAdjustments
            [value "dateAdjustments" path "generalTerms"]
            [value "extraordinaryEvents"]
        + calculationAgent
            [value "calculationAgent"]
            [hint "calculationAgentBusinessCenter"]
        + collateral
            [value "ignore"]
        + nonStandardisedTerms
            [set to True when "tradeHeader->partyTradeInformation->nonStandardTerms" = True]
            [set to False when "tradeHeader->partyTradeInformation->nonStandardTerms" = False]

    SettlementTerms:
        + settlementDate
            [value "cashSettlement"]
            [value "cashSettlementPaymentDate" path "cashSettlement"]
            [hint "valueDate"]
            [value "settlementDate"]
            [hint "settlementDate"]
            [value "americanExercise"]
            [value "europeanExercise"]
            [value "exercise"]
            [value "equityEuropeanExercise" path "equityExercise"]
            [value "equityAmericanExercise" path "equityExercise"]
            [hint "paymentDelay"]
            [hint "paymentDate"]
            [hint "adjustablePaymentDate"]
            [hint "adjustedPaymentDate"]
            [value "equityExercise"]
            [hint "nonDeliverableSettlement"]
        + settlementProvision
            [value "ignore"]
        + cashSettlementTerms
            [value "cashSettlement"]
            [value "cashSettlementTerms" set when rosettaPath = CreditDefaultPayout -> settlementTerms]
            [value "settlementProvision" /*set when rosettaPath = Payout->interestRatePayout->settlementTerms*/ ]
            [value "nonDeliverableSettlement"]
        + physicalSettlementTerms
            [value "physicalSettlement"]
            [value "physicalSettlementTerms" set when rosettaPath = CreditDefaultPayout -> settlementTerms]
            [value "clearingInstructions"]

    SettlementBase:
		[meta "id"]
        + settlementType
            [value "settlementCurrency" mapper "SettlementType"]
            [value "settlementCurrency" path "exercise" mapper "SettlementType"]
            [value "settlementType"]
            [value "settlementType" path "equityExercise"]
            [set to SettlementTypeEnum -> Cash when "cashSettlement" exists]
            [set to SettlementTypeEnum -> Cash when "settlementType" = "Cash"]
            [set to SettlementTypeEnum -> Cash when "amount->cashSettlement" = True]
            [set to SettlementTypeEnum -> Physical when "settlementType" = "Physical"]
            [set to SettlementTypeEnum -> Cash when "cashSettlementTerms" exists]
            [set to SettlementTypeEnum -> Physical when "physicalSettlementTerms" exists]
            [set to SettlementTypeEnum -> Physical when "physicalExercise" exists]
            [set to SettlementTypeEnum -> Cash when "nonDeliverableSettlement" exists]
            [set to SettlementTypeEnum -> Cash when "settlementProvision->nonDeliverableSettlement" exists]
        + settlementCurrency
            [value "settlementCurrency" maps 2 meta "currencyScheme"]
            [value "settlementCurrency" path "settlementProvision"]
            [value "cashSettlementCurrency" meta "currencyScheme"]
            [value "cashSettlementCurrency" path "cashSettlement->cashPriceMethod"]
            [value "cashSettlementCurrency" path "cashSettlement->crossCurrencyMethod"]
            [value "settlementCurrency" path "cashSettlementTerms" set when rosettaPath = CreditDefaultPayout -> settlementTerms -> settlementCurrency]
            [value "settlementCurrency" path "physicalSettlementTerms" set when rosettaPath = CreditDefaultPayout -> settlementTerms -> settlementCurrency]
            [value "settlementCurrency" path "nonDeliverableSettlement" meta "currencyScheme"]
            [value "settlementCurrency" path "cashSettlement"]
            [value "settlementCurrency" path "exercise"]
            [value "settlementCurrency" path "equityExercise"]
            [value "currency" path "amount"]
            [value "entitlementCurrency"]

    SettlementDate:
		[meta "id" path "settlementDate"]
		[meta "id" path "cashSettlementPaymentDate"]
        + adjustableOrRelativeDate
            [hint "relativeDate"]
            [value "settlementDate"]
            [value "settlementDate" path "nonDeliverableSettlement"]
            [value "relativePaymentDates"]
            [value "paymentDates"]
            [hint "adjustablePaymentDate"]
            [hint "adjustedPaymentDate"]
            [value "paymentDate" set when "paymentAmount" exists /*and rosettaPath = PriceQuantity->settlementTerms->settlementDate*/ ]
        + valueDate
            [value "valueDate"]
            [value "latestValueDate"]
        + adjustableDates
            [value "adjustableDates"]
        + businessDateRange
            [value "businessDateRange"]
        + paymentDelay
            [value "paymentDelay" set when "singlePayment" exists /*and rosettaPath = PriceQuantity->settlementTerms->settlementDate*/ ]

    CashSettlementTerms:
		[meta "id"]
        + cashSettlementMethod
            [set to CashSettlementMethodEnum -> CashPriceMethod when "cashPriceMethod" exists]
            [set to CashSettlementMethodEnum -> CashPriceAlternateMethod when "cashPriceAlternateMethod" exists]
            [set to CashSettlementMethodEnum -> ParYieldCurveUnadjustedMethod when "parYieldCurveUnadjustedMethod" exists]
            [set to CashSettlementMethodEnum -> ParYieldCurveAdjustedMethod when "parYieldCurveAdjustedMethod" exists]
            [set to CashSettlementMethodEnum -> ZeroCouponYieldAdjustedMethod when "zeroCouponYieldAdjustedMethod" exists]
            [set to CashSettlementMethodEnum -> CrossCurrencyMethod when "crossCurrencyMethod" exists]
            [set to CashSettlementMethodEnum -> CollateralizedCashPriceMethod when "collateralizedCashPriceMethod" exists]
            [set to CashSettlementMethodEnum -> MidMarketIndicativeQuotations when "midMarketValuation->indicativeQuotations" exists]
            [set to CashSettlementMethodEnum -> MidMarketIndicativeQuotationsAlternate when "midMarketValuation->indicativeQuotationsAlternate" exists]
            [set to CashSettlementMethodEnum -> MidMarketCalculationAgentDetermination when "midMarketValuation->calculationAgentDetermination" exists]
            [set to CashSettlementMethodEnum -> ReplacementValueFirmQuotations when "replacementValue->firmQuotations" exists]
            [set to CashSettlementMethodEnum -> ReplacementValueCalculationAgentDetermination when "replacementValue->calculationAgentDetermination" exists]
        + valuationDate
            [value "fixing"]
            [value "rateSourceFixing"]
            [value "valuationDate"]
            [value "nonDeliverableSettlement"]
            [value "cashSettlementValuationDate"]
        + valuationTime
            [value "fixingTime" path "fixing->fxSpotRateSource"]
            [value "valuationTime"]
            [value "cashSettlementValuationTime"]
        + cashSettlementAmount
            [value "cashSettlementAmount"]
        + recoveryFactor
            [value "recoveryFactor"]
        + fixedSettlement
            [value "fixedSettlement"]
        + accruedInterest
            [value "accruedInterest"]
        + valuationMethod
            [hint "fixing"]
            [hint "rateSourceFixing"]
            [value "valuationMethod"]
            [value "nonDeliverableSettlement"]
            [value "cashPriceMethod"]
            [value "cashPriceAlternateMethod"]
            [value "parYieldCurveAdjustedMethod"]
            [value "parYieldCurveUnadjustedMethod"]
            [value "zeroCouponYieldAdjustedMethod"]
            [value "crossCurrencyMethod"]
            [value "collateralizedCashPriceMethod"]
            [hint "minimumQuotationAmount" , "quotationAmount" , "quotationMethod"]
            [value "midMarketValuation"]
            [value "replacementValue"]

    PhysicalSettlementTerms:
        + physicalSettlementPeriod
            [value "physicalSettlementPeriod"]
        + deliverableObligations
            [value "deliverableObligations"]
        + escrow
            [value "escrow"]
        + sixtyBusinessDaySettlementCap
            [value "sixtyBusinessDaySettlementCap"]
        + clearedPhysicalSettlement
            [value "clearedPhysicalSettlement"]
        + predeterminedClearingOrganizationParty
            [value "predeterminedClearingOrganizationPartyReference" mapper "PredeterminedClearingOrganizationParty"]

    ValuationMethod:
        + valuationSource
            [value "settlementRateSource"]
            [value "fixing"]
            [value "rateSourceFixing"]
            [hint "settlementRateOption"]
            [value "indicativeQuotations"]
            // The following are un-tested:
            // [value "indicativeQuotationsAlternate"]
            // [value "calculationAgentDetermination"]
            [value "firmQuotations"]
        + quotationMethod
            [value "quotationMethod"]
            [value "quotationRateType"]
        + quotationAmount
            [value "quotationAmount"]
        + minimumQuotationAmount
            [value "minimumQuotationAmount"]
        + cashCollateralValuationMethod
            [value "indicativeQuotations"]
            // The following are un-tested:
            // [value "indicativeQuotationsAlternate"]
            // [value "calculationAgentDetermination"]
            [value "firmQuotations"]

    DeliverableObligations:
        + accruedInterest
            [value "accruedInterest"]
        + category
            [value "category"]
        + notSubordinated
            [value "notSubordinated"]
        + specifiedCurrency
            [value "specifiedCurrency"]
        + notSovereignLender
            [value "notSovereignLender"]
        + notDomesticCurrency
            [value "notDomesticCurrency"]
        + notDomesticLaw
            [value "notDomesticLaw"]
        + listed
            [value "listed"]
        + notContingent
            [value "notContingent"]
        + notDomesticIssuance
            [value "notDomesticIssuance"]
        + assignableLoan
            [value "assignableLoan"]
        + consentRequiredLoan
            [value "consentRequiredLoan"]
        + directLoanParticipation
            [value "directLoanParticipation"]
        + transferable
            [value "transferable"]
        + maximumMaturity
            [value "maximumMaturity"]
        + acceleratedOrMatured
            [value "acceleratedOrMatured"]
        + notBearer
            [value "notBearer"]
        + fullFaithAndCreditObLiability
            [value "fullFaithAndCreditObLiability"]
        + generalFundObligationLiability
            [value "generalFundObligationLiability"]
        + revenueObligationLiability
            [value "revenueObligationLiability"]
        + indirectLoanParticipation
            [value "indirectLoanParticipation"]
        + excluded
            [value "excluded"]
        + othReferenceEntityObligations
            [value "othReferenceEntityObligations"]

    FloatingAmountEvents:
        + failureToPayPrincipal
            [value "failureToPayPrincipal"]
        + interestShortfall
            [value "interestShortfall"]
        + writedown
            [value "writedown"]
        + impliedWritedown
            [value "impliedWritedown"]
        + floatingAmountProvisions
            [value "floatingAmountProvisions"]
        + additionalFixedPayments
            [value "additionalFixedPayments"]

    FloatingAmountProvisions:
        + wacCapInterestProvision
            [value "WACCapInterestProvision"]
        + stepUpProvision
            [value "stepUpProvision"]

    ValuationSource:
        + quotedCurrencyPair
            [value "quotedCurrencyPair" meta "quoteBasis"]
        + informationSource
            [value "informationSource"]
            [value "fxSpotRateSource"]
        + settlementRateOption
            [value "settlementRateSource"]
            [hint "settlementRateOption"]
        + referenceBanks
            [value "cashSettlementReferenceBanks"]
        + dealerOrCCP
            [hint "dealer"]
            [value "mutuallyAgreedClearinghouse"]

    QuotedCurrencyPair:
        + currency1
            [value "currency1" maps 2 meta "currencyScheme"]
            [value "currency" path "putCurrencyAmount" maps 2]
        + currency2
            [value "currency2" maps 2 meta "currencyScheme"]
            [value "currency" path "callCurrencyAmount" maps 2]
        + quoteBasis
            [value "quoteBasis" maps 2]
            [value "rateObservationQuoteBasis" path "asian" maps 2]
            [value "strikeQuoteBasis" maps 2]

    RateObservation:
	 	[value "RateObservation" meta "id"]
        + resetDate
            [value "resetDate"]
        + adjustedFixingDate
            [value "adjustedFixingDate"]
        + observedRate
            [value "observedRate"]
        + treatedRate
            [value "treatedRate"]
        + observationWeight
            [value "observationWeight"]
        + rateReference
            [value "rateReference" meta "href"]
        + forecastRate
            [value "forecastRate"]
        + treatedForecastRate
            [value "treatedForecastRate"]

    ResetFrequency:
        + weeklyRollConvention
            [value "weeklyRollConvention"]

    Resource:
        + resourceId
            [value "resourceId" meta "resourceIdScheme"]
        + resourceType
            [value "resourceType" meta "resourceTypeScheme"]
        + language
            [value "language" meta "languageScheme"]
        + sizeInBytes
            [value "sizeInBytes"]
        + length
            [value "length"]
        + mimeType
            [value "mimeType" meta "mimeTypeScheme"]
        + name
            [value "name"]
        + comments
            [value "comments"]
        + string
            [value "string"]
        + url
            [value "url"]

    ResourceLength:
        + lengthUnit
            [value "lengthUnit"]
        + lengthValue
            [value "lengthValue"]

    FallbackReferencePrice:
        + valuationPostponement
            [value "valuationPostponement"]
        + fallBackSettlementRateOption
            [value "fallBackSettlementRateOption" meta "settlementRateOptionScheme"]
        + fallbackSurveyValuationPostponement
            [set to True]
        + calculationAgentDetermination
            [value "calculationAgentDetermination"]

    FinalCalculationPeriodDateAdjustment:
        + relevantUnderlyingDateReference
            [value "relevantUnderlyingDateReference" meta "href"]
        + swapStreamReference
            [value "swapStreamReference" meta "href"]
        + businessDayConvention
            [value "businessDayConvention"]

    FloatingRateDefinition:
        + calculatedRate
            [value "calculatedRate"]
        + rateObservation
            [value "rateObservation"]
        + floatingRateMultiplier
            [value "floatingRateMultiplier"]
        + spread
            [value "spread"]
        + capRate
            [value "capRate"]
        + floorRate
            [value "floorRate"]

    FxFixingDate:
        + businessDayConvention
            [value "businessDayConvention"]
        + businessCenters
            [value "businessCenters"]
        + businessCentersReference
            [value "businessCentersReference" meta "href"]
        + dateRelativeToPaymentDates
            [value "dateRelativeToPaymentDates"]
        + dateRelativeToCalculationPeriodDates
            [value "dateRelativeToCalculationPeriodDates"]
        + fxFixingDate
            [value "fixingDate"]
            [hint "fixingDate"]

    FxLinkedNotionalAmount:
        + resetDate
            [value "resetDate"]
        + adjustedFxSpotFixingDate
            [value "adjustedFxSpotFixingDate"]
        + observedFxSpotRate
            [value "observedFxSpotRate"]
        + notionalAmount
            [value "notionalAmount"]

    FxLinkedNotionalSchedule:
        + varyingNotionalCurrency
            [value "varyingNotionalCurrency" meta "currencyScheme"]
        + varyingNotionalFixingDates
            [value "varyingNotionalFixingDates"]
        + fxSpotRateSource
            [value "fxSpotRateSource"]
        + fixingTime
            [value "fixingTime" path "fxSpotRateSource"]
        + varyingNotionalInterimExchangePaymentDates
            [value "varyingNotionalInterimExchangePaymentDates"]

    PaymentCalculationPeriod:
	 	[value "PaymentCalculationPeriod" meta "id"]
        + unadjustedPaymentDate
            [value "unadjustedPaymentDate"]
        + adjustedPaymentDate
            [value "adjustedPaymentDate"]
        + calculationPeriod
            [value "calculationPeriod"]
        + fixedPaymentAmount
            [value "fixedPaymentAmount"]
            [value "amount" path "paymentAmount"]
            [value "paymentAmount"]
        + discountFactor
            [value "discountFactor"]
        + forecastPaymentAmount
            [value "forecastPaymentAmount"]
        + presentValueAmount
            [value "presentValueAmount"]

    PriceSourceDisruption:
        + fallbackReferencePrice
            [value "fallbackReferencePrice"]

    ResetDates:
	 	[value "ResetDates" meta "id" path "resetDates"]
        + calculationPeriodDatesReference
            [value "calculationPeriodDatesReference" path "resetDates" meta "href"]
            [value "calculationPeriodDatesReference" path "interestLegCalculationPeriodDates->interestLegResetDates" meta "href"]
        + resetRelativeTo
            [value "resetRelativeTo" path "resetDates"]
            [value "resetRelativeTo" path "interestLegCalculationPeriodDates->interestLegResetDates"]
        + fixingDates
            [value "fixingDates" path "resetDates"]
            [value "relativeDate" path "interestLegCalculationPeriodDates->interestLegResetDates->fixingDates"]
            [value "fixingDateOffset"]
        + finalFixingDate
            [value "finalFixingDate" path "periodicPayment->floatingAmountCalculation"]
        + rateCutOffDaysOffset
            [value "resetCutOffDaysOffset" path "resetDates"]
        + resetFrequency
            [value "resetFrequency" path "resetDates" , "resetFrequency" path "interestLegCalculationPeriodDates->interestLegResetDates"]
        + resetDatesAdjustments
            [value "resetDatesAdjustments" path "resetDates"]

    InitialFixingDate:
        + relativeDateOffset
            [value "initialFixingDate" path "resetDates"]
        + initialFixingDate
            [value "initialFixingDate" path "periodicPayment->floatingAmountCalculation"]

    StubCalculationPeriodAmount:
        + calculationPeriodDatesReference
            [value "calculationPeriodDatesReference" meta "href"]
        + initialStub
            [value "initialStub"]
        + finalStub
            [value "finalStub"]

    ValuationPostponement:
        + maximumDaysOfPostponement
            [value "maximumDaysOfPostponement"]

    SettlementRateOption:
        + settlementRateOption
            [value "settlementRateOption" meta "settlementRateOptionScheme"]
        + priceSourceDisruption
            [value "priceSourceDisruption"]

    ReferenceBanks:
        + referenceBank
            [value "referenceBank"]

    Strike:
		[value "Strike" meta "id"]
        + strikeRate
            [value "strikeRate"]
        + buyer
            [value "buyer"]
        + seller
            [value "seller"]

    StrikeSchedule:
        + buyer
            [value "buyer"]
        + seller
            [value "seller"]

    StubFloatingRate:
	 	[value "StubFloatingRate" meta "id"]
        + floatingRateIndex
            [value "floatingRateIndex"]
        + indexTenor
            [value "indexTenor"]
        + floatingRateMultiplierSchedule
            [value "floatingRateMultiplierSchedule"]
        + spreadSchedule
            [value "spreadSchedule"]
        + rateTreatment
            [value "rateTreatment"]
        + capRateSchedule
            [value "capRateSchedule"]
        + floorRateSchedule
            [value "floorRateSchedule"]

    StubValue:
        + floatingRate
            [value "floatingRate"]
        + stubRate
            [value "stubRate"]
        + stubAmount
            [value "stubAmount"]

    AveragingFeature:
        + averagingInOut
            [value "averagingInOut"]
        + strikeFactor
            [value "strikeFactor"]
        + averagingPeriodIn
            [value "averagingPeriodIn"]
        + averagingPeriodOut
            [value "averagingPeriodOut"]

    ObservationTerms:
        + observationTime
            [value "pricingDates"]
            [value "fixingTime"]
            [value "fixingTime" path "fixingInformationSource"]
            [value "valuationTime"]
        + observationTimeType
            [value "pricingDates"]
        + calculationPeriodDates
            [hint "calculationPeriodsSchedule"]
        + numberOfObservationDates
            [value "numberOfReturns"]
        + informationSource
            [value "fixingInformationSource"]
            [hint "primaryRateSource"]
        + observationDates
            [hint "pricingDates"]
            [value "pricingDates" path "pricingDates"]
            [hint "amount"]
            [hint "observationSchedule"]
            [hint "rateObservation"]
            [hint "valuationDate"]
            [hint "fixingSchedule"]

    AveragingObservationList:
        + averagingObservation
            [value "averagingObservation"]

    AveragingPeriod:
        + schedule
            [value "schedule"]
        + averagingDateTimes
            [value "averagingDateTimes"]
        + averagingObservations
            [value "averagingObservations"]
        + marketDisruption
            [value "marketDisruption" meta "marketDisruptionScheme"]

    AveragingSchedule:
        + startDate
            [value "startDate"]
        + endDate
            [value "endDate"]
        + averagingPeriodFrequency
            [value "averagingPeriodFrequency"]

    CalendarSpread:
        + expirationDateTwo
            [value "expirationDateTwo"]

    Composite:
        + determinationMethod
            [value "determinationMethod"]
        + relativeDate
            [value "relativeDate"]
        + fxSpotRateSource
            [value "fxSpotRateSource"]
        + fixingTime
            [value "fixingTime" path "fxSpotRateSource"]

    CreditEvents:
	 	[value "CreditEvents" meta "id"]
        + bankruptcy
            [value "bankruptcy"]
        + failureToPay
            [value "failureToPay"]
        + failureToPayPrincipal
            [value "failureToPayPrincipal"]
        + failureToPayInterest
            [value "failureToPayInterest"]
        + obligationDefault
            [value "obligationDefault"]
        + obligationAcceleration
            [value "obligationAcceleration"]
        + repudiationMoratorium
            [value "repudiationMoratorium"]
        + restructuring
            [value "restructuring"]
        + governmentalIntervention
            [value "governmentalIntervention"]
        + distressedRatingsDowngrade
            [value "distressedRatingsDowngrade"]
        + maturityExtension
            [value "maturityExtension"]
        + writedown
            [value "writedown"]
        + impliedWritedown
            [value "impliedWritedown"]
        + defaultRequirement
            [value "defaultRequirement"]
        + creditEventNotice
            [value "creditEventNotice"]

    CreditEventNotice:
        + notifyingParty
            [value "buyerPartyReference" path "notifyingParty" , "sellerPartyReference" path "notifyingParty" mapper "NotifyingParty"]
        + businessCenter
            [value "businessCenter"]
        + publiclyAvailableInformation
            [value "publiclyAvailableInformation"]

    FailureToPay:
        + applicable
            [value "applicable"]
        + gracePeriodExtension
            [value "gracePeriodExtension"]
        + paymentRequirement
            [value "paymentRequirement"]

    FeaturePayment:
	 	[value "FeaturePayment" meta "id"]
        + levelPercentage
            [value "levelPercentage"]
        + amount
            [value "amount"]
        + time
            [value "time"]
        + currency
            [value "currency" meta "currencyScheme"]
        + paymentDate
            [value "featurePaymentDate"]

    GracePeriodExtension:
        + applicable
            [value "applicable"]
        + gracePeriod
            [value "gracePeriod"]

    CancelableProvision:
        + exerciseNotice
            [value "exerciseNotice"]
        + followUpConfirmation
            [value "followUpConfirmation"]
        + cancelableProvisionAdjustedDates
            [value "cancelableProvisionAdjustedDates"]
        + finalCalculationPeriodDateAdjustment
            [value "finalCalculationPeriodDateAdjustment"]
        + initialFee
            [value "initialFee"]
        + callingParty
            [value "callingParty"]

    CancelableProvisionAdjustedDates:
        + cancellationEvent
            [value "cancellationEvent"]

    CancellationEvent:
		[meta "id"]
        + adjustedExerciseDate
            [value "adjustedExerciseDate"]
        + adjustedEarlyTerminationDate
            [value "adjustedEarlyTerminationDate"]

    CashflowRepresentation:
        + cashflowsMatchParameters
            [value "cashflowsMatchParameters"]
        + paymentCalculationPeriod
            [value "paymentCalculationPeriod"]
            [value "adjustedPaymentDates"]

    DateRelativeToCalculationPeriodDates:
        + calculationPeriodDatesReference
            [value "calculationPeriodDatesReference" meta "href"]

    DateRelativeToPaymentDates:
        + paymentDatesReference
            [value "paymentDatesReference" meta "href"]

    DiscountingMethod:
        + discountingType
            [value "discountingType"]
            [value "fraDiscounting" set when "fraDiscounting" <> "NONE"]
        + discountRate
            [value "discountRate"]
        + discountRateDayCountFraction
            [value "discountRateDayCountFraction" meta "dayCountFractionScheme"]

    PrincipalPayments:
	 	[value "PrincipalExchanges" meta "id"]
        + initialPayment
            [value "initialExchange"]
        + finalPayment
            [value "finalExchange"]
        + intermediatePayment
            [value "intermediateExchange"]
        + principalPaymentSchedule
            [value "cashflows" mapper "PrincipalPaymentSchedule"]

    EarlyTerminationEvent:
		[meta "id"]
        + adjustedExerciseDate
            [value "adjustedExerciseDate"]
        + adjustedEarlyTerminationDate
            [value "adjustedEarlyTerminationDate"]
        + adjustedCashSettlementValuationDate
            [value "adjustedCashSettlementValuationDate"]
        + adjustedCashSettlementPaymentDate
            [value "adjustedCashSettlementPaymentDate"]
        + adjustedExerciseFeePaymentDate
            [value "adjustedExerciseFeePaymentDate"]

    EarlyTerminationProvision:
		[meta "id"]
        + mandatoryEarlyTermination
            [value "mandatoryEarlyTermination"]
        + mandatoryEarlyTerminationDateTenor
            [value "mandatoryEarlyTerminationDateTenor"]
        + optionalEarlyTermination
            [value "optionalEarlyTermination"]
            [hint "mutualEarlyTermination"]
        + optionalEarlyTerminationParameters
            [value "optionalEarlyTerminationParameters"]

    ExerciseEvent:
		[meta "id"]
        + adjustedExerciseDate
            [value "adjustedExerciseDate"]
        + adjustedRelevantSwapEffectiveDate
            [value "adjustedRelevantSwapEffectiveDate"]
        + adjustedCashSettlementValuationDate
            [value "adjustedCashSettlementValuationDate"]
        + adjustedCashSettlementPaymentDate
            [value "adjustedCashSettlementPaymentDate"]
        + adjustedExerciseFeePaymentDate
            [value "adjustedExerciseFeePaymentDate"]

    ExercisePeriod:
		[value "ExercisePeriod" meta "id"]
        + earliestExerciseDateTenor
            [value "earliestExerciseDateTenor"]
        + exerciseFrequency
            [value "exerciseFrequency"]

    ExtendibleProvision:
        + exerciseNotice
            [value "exerciseNotice"]
        + followUpConfirmation
            [value "followUpConfirmation"]
        + extendibleProvisionAdjustedDates
            [value "extendibleProvisionAdjustedDates"]
        + callingParty
            [value "callingParty"]

    ExtendibleProvisionAdjustedDates:
        + extensionEvent
            [value "extensionEvent"]

    ExtensionEvent:
	 	[value "ExtensionEvent" meta "id"]
        + adjustedExerciseDate
            [value "adjustedExerciseDate"]
        + adjustedExtendedTerminationDate
            [value "adjustedExtendedTerminationDate"]

    CalculationAgent:
        + calculationAgentParty
            [value "calculationAgentPartyReference" mapper "CalculationAgentParty"]
        + calculationAgentPartyEnum
            [value "calculationAgentParty"]
        + calculationAgentBusinessCenter
            [value "calculationAgentBusinessCenter" meta "businessCenterScheme"]

    Collateral:
        + independentAmount
            [value "independentAmount"]

    CollateralProvisions:
        + collateralType
            [value "ignore"]
        + eligibleCollateral
            [value "ignore"]
        + substitutionProvisions
            [value "ignore"]

    ContractualMatrix:
        + matrixType
            [value "matrixType" meta "matrixTypeScheme"]
        + matrixTerm
            [value "matrixTerm" meta "matrixTermScheme"]

    IndependentAmount:
        + paymentDetail
            [value "paymentDetail"]

    // For CDS protectionTerms see CreditDefaultPayout
    // For CDS feeLeg see InterestRatePayout
    // For Equities see PerformancePayout
    Payout:
        + InterestRatePayout
            // For Rates
            [value "swapStream" , "additionalTerms" /*set when rosettaPath "interestRatePayout->rateSpecification->fixedRate" exists*/ ]
            [value "capFloorStream"]
            [value "fra"]
            // For Credit:
            [value "feeLeg" , "protectionTerms" , "generalTerms"]
            // For Equity
            [value "interestLeg"]
            // For Repo:
            [value "repo"]
        + CreditDefaultPayout
            [value "creditDefaultSwap"]
        + OptionPayout
            [value "swaption"]
            [value "creditDefaultSwapOption"]
            [value "bondOption"]
            [value "fxOption"]
            [value "fxDigitalOption"]
            [value "equityOption"]
            [value "brokerEquityOption"]
            [value "equityOptionTransactionSupplement"]
            [value "commodityOption"]
            [value "commoditySwaption"]
            [value "varianceOptionTransactionSupplement"]
            [value "dividendSwapOptionTransactionSupplement"]
            [value "genericProduct" set when "genericProduct->optionType" exists]
        + SettlementPayout
            [value "fxSingleLeg"]
            [value "nearLeg"]
            [value "farLeg"]
            [value "coalPhysicalLeg" path "commoditySwap" mapper "CommodityClassificationMeta"]
            [value "electricityPhysicalLeg" path "commoditySwap" mapper "CommodityClassificationMeta"]
            [value "environmentalPhysicalLeg" path "commoditySwap" mapper "CommodityClassificationMeta"]
            [value "gasPhysicalLeg" path "commoditySwap" mapper "CommodityClassificationMeta"]
            [value "oilPhysicalLeg" path "commoditySwap" mapper "CommodityClassificationMeta"]
            [value "genericProduct" set when condition-func MapGenericProductToForwardPayout condition-path "genericProduct->productType"]
        + CommodityPayout
            [value "commoditySwap" , "floatingLeg" path "commoditySwap"]
        + FixedPricePayout
            [value "fixedLeg" path "commoditySwap"]
            [value "fixedPayment" path "fixedLeg" , "dividendPeriod" path "dividendLeg" mapper "DividendFixedLeg"]
        + AssetPayout
            [value "ignore"]
        + PerformancePayout
            [value "varianceLeg"]
            [value "volatilityLeg"]
            [value "correlationLeg"]
            [value "dividendLeg"]
            [value "fxVarianceSwap"]
            [value "fxVolatilitySwap"]
            [value "returnLeg"]

    PayoutBase:
        + payerReceiver
            [hint "payerPartyReference"]
            [hint "receiverPartyReference"]
            [hint "buyerPartyReference"]
            [hint "sellerPartyReference"]
        + priceQuantity
            // For Swap Stream and FRA: moved to InterestRatePayout
            [value "knownAmountSchedule" path "calculationPeriodAmount"]
            // For Options:
            [hint "numberOfOptions"]
            // For Bond Option:
            [hint "notionalAmount"]
            // For Credit Option:
            [hint "notionalReference"]
            // FX
            [hint "strike"]
            // For Commodity
            [value "commodity"]
            [hint "notionalQuantity"]
            [hint "totalNotionalQuantity"]
            [hint "amount"]
            [hint "paymentAmount"]
            [hint "notionalQuantitySchedule"]
            // For Repo:
            [value "nearLeg"]

    BuyerSeller:
        + buyer
            [value "buyerPartyReference" mapper "Buyer"]
            [value "payerPartyReference" mapper "CashPaymentBuyer"]
        + seller
            [value "sellerPartyReference" mapper "Seller"]
            [value "receiverPartyReference" mapper "CashPaymentSeller"]

    PayerReceiver:
        + payer
            [value "payerPartyReference" mapper "Payer"]
            [value "sellerPartyReference" maps 2 mapper "SellerAsPayerOrReceiver"]
            [value "payerPartyReference" path "floatingLeg" mapper "Payer"] // FX Var / Vol swaps
            [value "receiverPartyReference" path "fixedLeg" mapper "Payer"] // FX Var / Vol swaps
        + receiver
            [value "receiverPartyReference" mapper "Receiver"]
            [value "buyerPartyReference" maps 2 mapper "BuyerAsReceiverOrPayer"]
            [value "payerPartyReference" path "fixedLeg" mapper "Receiver"] // FX Var / Vol swaps
            [value "receiverPartyReference" path "floatingLeg" mapper "Receiver"] // FX Var / Vol swaps

    PartyReferencePayerReceiver:
        + payerPartyReference
            [value "payerPartyReference" meta "href"]
        + receiverPartyReference
            [value "receiverPartyReference" meta "href"]

    ResolvablePriceQuantity:
        [meta "id" path "notional"]
        [meta "id" path "notionalSchedule"]
        [meta "id" path "notionalSchedule->notionalStepSchedule"]
        [meta "id" path "notionalAmount"]
        [meta "id" path "calculationAmount"]
        + resolvedQuantity
            [value "ignore"]
        + quantityReference
            [value "relativeNotionalAmount" path "notional" meta "href"]
            [value "constantNotionalScheduleReference" meta "href"]
            // For CDS Option, CDX Index Option, Bond Option, Swaption:
            [value "notionalReference" meta "href"]
        + quantitySchedule
            // Swap Stream
            [value "notionalStepSchedule" path "notionalSchedule" meta "initialValue"]
            [meta "initialValue"]
            // FRA, Bond Forward, and FX Variance Swap
            [value "notional" meta "amount"]
            // Equity Swap - Only mapping the notional amount in the payout, not the no. shares
            [value "notionalAmount" meta "amount"]
            [value "relativeNotionalAmount" meta "href" mapper "RelativeNotionalAmount"]
            // Div Swaps
            [value "singleUnderlyer" meta "openUnits"]
            // Credit
            [value "calculationAmount" meta "amount" mapper "CdsFeeLegMeta"]
            // Repo
            [value "settlementAmount" meta "amount"]
            // FX
            [value "paymentAmount" path "exchangedCurrency1" meta "amount"]
            [value "paymentAmount" path "exchangedCurrency2" meta "amount"]
            [value "strikeQuoteBasis" path "strike" mapper "FxOptionQuantityMeta"]
            // Bond Option
            [meta "numberOfOptions"]
            // Commodity
            [meta "totalNotionalQuantity"]
            // Var / Vol / Corr Swap
            [value "varianceAmount" path "amount->variance" meta "amount"]
            [value "volatility" path "amount" meta "vegaNotionalAmount"]
            [value "notionalAmount" path "amount->correlation" meta "amount"]
            // Div Swap
            [value "paymentAmount" meta "amount"]
        + reset
            [value "notionalReset"]
        + futureValueNotional
            [value "futureValueNotional"]
        + priceSchedule
            [meta "rate"]
            [meta "initialValue"]

    FutureValueAmount:
        + quantity
            [meta "amount"]
        + currency
            [value "currency" maps 2 meta "currencyScheme"]
        + calculationPeriodNumberOfDays
            [value "calculationPeriodNumberOfDays"]
        + valueDate
            [value "valueDate"]

    InterestRatePayout:
        + dayCountFraction
            [value "dayCountFraction" path "calculationPeriodAmount->calculation" meta "dayCountFractionScheme"]
            [value "dayCountFraction" path "periodicPayment->fixedAmountCalculation" meta "dayCountFractionScheme"]
            [value "dayCountFraction" path "periodicPayment->floatingAmountCalculation" meta "dayCountFractionScheme"]
            [value "dayCountFraction" meta "dayCountFractionScheme"]
            [value "dayCountFraction" path "interestCalculation" meta "dayCountFractionScheme"]
        + paymentDates
            [value "paymentDates"]
            [value "periodicPayment"]
            [value "interestLegPaymentDates" path "interestLegCalculationPeriodDates"]
            [hint "indexTenor"]
        + paymentDate
            [value "paymentDate"]
        + paymentDelay
            [value "paymentDelay"]
        + discountingMethod
            [value "discounting" path "calculationPeriodAmount->calculation"]
            [hint "fraDiscounting"]
        + principalPayment
            [value "principalExchanges"]
            [hint "cashflows"]
            [value "calculationPeriodAmount"]
        + compoundingMethod
            [value "compoundingMethod" path "calculationPeriodAmount->calculation"]
        + cashflowRepresentation
            [value "cashflows"]
            [value "periodicPayment"]
        + stubPeriod
            [value "stubCalculationPeriodAmount"]
            [value "stubCalculationPeriod"]
        + bondReference
            [value "bondReference"]
        + rateSpecification
            [value "calculation" path "calculationPeriodAmount"]
            // For FRAs:
            [hint "fixedRate" , "floatingRateIndex" , "indexTenor"]
            // For CDS:
            [value "periodicPayment"]
            // For Equity:
            [value "interestCalculation"]
            // For Repo:
            [hint "fixedRateSchedule"]
            [hint "floatingRateCalculation"]
        - priceQuantity
        + priceQuantity
            // For Swap Stream:
            [value "calculation" path "calculationPeriodAmount"]
            [value "fxLinkedNotionalSchedule" path "calculationPeriodAmount->calculation"]
            [hint "calculationPeriodAmount"]
            // For FRAs:
            [hint "notional"]
            // For the interest leg of Equity Swap:
            [value "notional"]
            // For the fee leg of CDS
            [value "fixedAmountCalculation" path "periodicPayment"]
            [value "floatingAmountCalculation" path "periodicPayment"]
            [hint "calculationAmount"]

    CalculationPeriodBase:
        [meta "id"]
        + adjustedStartDate
            [value "adjustedStartDate"]
        + adjustedEndDate
            [value "adjustedEndDate"]

    CalculationPeriod:
        + unadjustedStartDate
            [value "unadjustedStartDate"]
        + unadjustedEndDate
            [value "unadjustedEndDate"]
        + calculationPeriodNumberOfDays
            [value "calculationPeriodNumberOfDays"]
        + notionalAmount
            [value "notionalAmount"]
        + fxLinkedNotionalAmount
            [value "fxLinkedNotionalAmount"]
        + floatingRateDefinition
            [value "floatingRateDefinition"]
        + fixedRate
            [value "fixedRate"]
        + dayCountYearFraction
            [value "dayCountYearFraction"]
        + forecastAmount
            [value "forecastAmount"]
        + forecastRate
            [value "forecastRate"]

    CalculationPeriodDates:
        [meta "id" path "calculationPeriodDates"]
        [meta "id" path "interestLegCalculationPeriodDates"]
        [meta "id" path "calculationPeriods"]
        + effectiveDate
            [value "effectiveDate" set when "effectiveDate->relativeDate" exists]
            [value "effectiveDate" path "calculationPeriodDates"]
            [value "relativeEffectiveDate" path "calculationPeriodDates"]
            [hint "adjustedEffectiveDate"]
            [value "effectiveDate" path "interestLegCalculationPeriodDates"]
            [value "settlementDate" path "nearLeg"]
            [value "calculationPeriods"]
        + terminationDate
            [value "terminationDate" path "calculationPeriodDates"]
            [value "relativeTerminationDate" path "calculationPeriodDates"]
            [hint "adjustedTerminationDate"]
            [value "terminationDate" path "interestLegCalculationPeriodDates" , "terminationDate"]
            [value "settlementDate" path "farLeg"]
        + calculationPeriodDatesAdjustments
            [value "calculationPeriodDatesAdjustments" path "calculationPeriodDates"]
        + firstPeriodStartDate
            [value "firstPeriodStartDate" path "calculationPeriodDates"]
            [value "periodicPayment"]
        + firstRegularPeriodStartDate
            [value "firstRegularPeriodStartDate" path "calculationPeriodDates"]
        + firstCompoundingPeriodEndDate
            [value "firstCompoundingPeriodEndDate" path "calculationPeriodDates"]
        + lastRegularPeriodEndDate
            [value "lastRegularPeriodEndDate" path "calculationPeriodDates"]
        + stubPeriodType
            [value "stubPeriodType" path "calculationPeriodDates"]
        + calculationPeriodFrequency
            [value "calculationPeriodFrequency" path "calculationPeriodDates"]
            // for Commodity Floating Leg (Payout)
            [value "calculationPeriodsSchedule"]
            [value "periodicPayment"]

    PaymentDates:
        [value "PaymentDates" meta "id"]
        [value "PaymentDates" meta "id" path "interestLegCalculationPeriodDates"]
        [value "relativePaymentDates" meta "id" path "calculationPeriodsScheduleReference"]
        + paymentFrequency
            [value "paymentFrequency"]
            [value "indexTenor"]
        + firstPaymentDate
            [value "firstPaymentDate"]
            [value "firstPaymentDate" path "periodicPayment"]
        + lastRegularPaymentDate
            [value "lastRegularPaymentDate"]
            [value "lastRegularPaymentDate" path "periodicPayment"]
        + payRelativeTo
            [value "payRelativeTo"]
        + paymentDaysOffset
            [value "paymentDaysOffset"]
        + paymentDatesAdjustments
            [value "paymentDatesAdjustments"]
            [value "paymentDaysOffset"]
            [hint "businessCenters"]

    PaymentDateSchedule:
        + interimPaymentDates
            [value "paymentDatesInterim"]
            [hint "adjustableDates"]
            [hint "relativeDates"]
            [hint "periodicDates"]
            [hint "periodicPayment"]
        + finalPaymentDate
            [value "paymentDateFinal"]

    PaymentDetail:
        [value "PaymentDetail" meta "id"]
        + paymentDate
            [value "paymentDate"]
        + paymentRule
            [value "paymentRule"]
        + paymentAmount
            [value "paymentAmount"]

    PercentageRule:
        + paymentPercent
            [value "paymentPercent"]
        + notionalAmountReference
            [value "notionalAmountReference" meta "href"]

    PeriodicDates:
        + startDate
            [value "calculationStartDate"]
            [hint "startDate"]
            [value "observationStartDate"]
        + endDate
            [value "calculationEndDate"]
            [hint "endDate"]
        + periodFrequency
            [value "calculationPeriodFrequency"]
            [value "paymentFrequency"]
            [hint "rollConvention"]
        + periodDatesAdjustments
            [value "calculationPeriodDatesAdjustments"]
            [hint "businessCenters"]
        + dayType
            [value "dayType"]

    StubPeriod:
        + calculationPeriodDatesReference
            [value "calculationPeriodDatesReference" meta "href"]
        + initialStub
            [value "initialStub"]
        + finalStub
            [value "finalStub"]

    CalculationPeriodFrequency:
        + rollConvention
            [value "rollConvention"]
        + balanceOfFirstPeriod
            [value "balanceOfFirstPeriod"]

    BondReference:
        + bond
            [hint "bond"]
        + conditionPrecedentBond
            [value "conditionPrecedentBond"]
        + discrepancyClause
            [value "discrepancyClause"]

    RateSpecification:
        + FixedRateSpecification
            [hint "fixedRateSchedule"]
            [hint "fixedRate"]
            [hint "fixedAmountCalculation"]
        + FloatingRateSpecification
            [value "floatingRateCalculation"]
            // For FRAs:
            [hint "floatingRateIndex" , "indexTenor"]
            // For Credit:
            [value "floatingAmountCalculation"]
            [value "floatingRate" path "floatingAmountCalculation"]
        + InflationRateSpecification
            [value "inflationRateCalculation"]

    FixedRateSpecification:
		[meta "id" path "fixedAmountCalculation->fixedRate"]
        + rateSchedule
            [value "fixedRateSchedule"]
            [value "fixedAmountCalculation"]
            [hint "fixedRate"]

    RateSchedule:
        + price
            [meta "initialValue"]
            [meta "fixedRate"]
            [value "spread" maps 2 meta "amount"]
            [value "floatingRateMultiplierSchedule"]

    FloatingRateSpecification:
        + finalRateRounding
            [value "finalRateRounding"]
        + negativeInterestRateTreatment
            [value "negativeInterestRateTreatment"]

    InflationRateSpecification:
        + inflationLag
            [value "inflationLag"]
        + indexSource
            [value "indexSource" meta "rateSourcePageScheme"]
        + mainPublication
            [value "mainPublication" meta "mainPublicationScheme"]
        + interpolationMethod
            [value "interpolationMethod" meta "interpolationMethodScheme"]
        + initialIndexLevel
            [value "initialIndexLevel"]
        + fallbackBondApplicable
            [value "fallbackBondApplicable"]
        + floatingRateMultiplierSchedule
            [hint "floatingRateMultiplierSchedule"]

    FloatingRateBase:
	 	[meta "id"]
        + rateOption
            [meta "floatingRateIndex"]
        + spreadSchedule
            [value "spreadSchedule"]
        + capRateSchedule
            [value "capRateSchedule"]
        + floorRateSchedule
            [value "floorRateSchedule"]

    SpreadSchedule:
        + spreadScheduleType
            [value "SpreadScheduleType" meta "spreadScheduleTypeScheme"]

    FloatingRate:
        + floatingRateMultiplierSchedule
            [value "floatingRateMultiplierSchedule"]
        + rateTreatment
            [value "rateTreatment"]
        + calculationParameters
            [value "calculationParameters"]
        + fallbackRate
            [value "fallbackRate"]

    InterestRateIndex:
        + FloatingRateIndex
            [value "floatingRateCalculation"]
            [hint "floatingRateIndex" , "indexTenor"]
        + InflationIndex
            [value "inflationRateCalculation"]

    FloatingRateIndex:
        + floatingRateIndex
            [value "floatingRateIndex" maps 2 meta "floatingRateIndexScheme"]
        + indexTenor
            [value "indexTenor" maps 2]
        + assetClass
            [value "floatingRateIndex" mapper "IndexAssetClass"]

    InflationIndex:
        + inflationRateIndex
            [value "floatingRateIndex" maps 2 meta "floatingRateIndexScheme"]
        + indexTenor
            [value "indexTenor" maps 2]
        + assetClass
            [set to AssetClassEnum -> InterestRate]

    CreditDefaultPayout:
        [meta "id"]
        - payerReceiver
        + payerReceiver
            [value "generalTerms"]
        - priceQuantity
        + priceQuantity
            [value "protectionTerms"]
        + generalTerms
            [value "generalTerms"]
            [hint "underlyer"]
        + protectionTerms
            [value "protectionTerms"]

    GeneralTerms:
        + referenceInformation
            [value "referenceInformation"]
        + indexReferenceInformation
            [value "indexReferenceInformation"]
        + basketReferenceInformation
            [value "basketReferenceInformation"]
            [hint "underlyer"]
        + additionalTerm
            [value "additionalTerm" meta "additionalTermScheme"]
        + substitution
            [value "substitution"]
        + modifiedEquityDelivery
            [value "modifiedEquityDelivery"]

    ProtectionTerms:
	 	[value "ProtectionTerms" meta "id"]
        + creditEvents
            [value "creditEvents"]
        + obligations
            [value "obligations"]
        + floatingAmountEvents
            [value "floatingAmountEvents"]

    ReferenceInformation:
        + referenceObligation
            [value "referenceObligation"]
        + noReferenceObligation
            [value "noReferenceObligation"]
        + unknownReferenceObligation
            [value "unknownReferenceObligation"]
        + allGuarantees
            [value "allGuarantees"]
        + referencePrice
            [hint "referencePrice"]
        + referencePolicy
            [value "referencePolicy"]
        + securedList
            [value "securedList"]

    ReferenceObligation:
        + security
            [hint "bond"]
            [hint "convertibleBond"]
            [hint "mortgage"]
        + loan
            [hint "loan"]
        + primaryObligor
            [value "primaryObligor"]
        + primaryObligorReference
            [value "primaryObligorReference" meta "href"]
        + guarantor
            [value "guarantor"]
        + guarantorReference
            [value "guarantorReference"]
        + standardReferenceObligation
            [value "standardReferenceObligation"]

    ReferencePair:
        + referenceObligation
            [value "referenceObligation"]
        + noReferenceObligation
            [value "noReferenceObligation"]
        + entityType
            [value "entityType" meta "entityTypeScheme"]

    ReferencePool:
        + referencePoolItem
            [value "referencePoolItem"]
            [value "underlyer"]

    ReferencePoolItem:
        + constituentWeight
            [value "constituentWeight"]
        + referencePair
            [value "referencePair"]
            [value "referenceEntity"]
        + protectionTermsReference
            [value "protectionTermsReference" meta "href"]
        + cashSettlementTermsReference
            [value "settlementTermsReference" maps 2 meta "href"]
        + physicalSettlementTermsReference
            [value "settlementTermsReference" maps 2 meta "href"]

    OptionPayout:
		[meta "id"]
        + settlementTerms
            [hint "physicalExercise"]
        + payerReceiver
            [hint "putCurrencyAmount"]
            [hint "callCurrencyAmount"]
        + feature
            [value "feature"]
            [value "features"]
            [hint "averagingMethod"]
        + observationTerms
            [value "asian" path "features"]
            [hint "pricingDates"]
            [hint "calculationPeriodsSchedule"]
            [value "equityValuation" path "equityExercise"]
        + schedule
            [value "schedule"]
        + delivery
            [value "ignore"]
        + strike
            [value "strike"]
            [hint "strikePricePerUnit"]
            [hint "strikePricePerUnitSchedule"]
            [hint "spotRate"]
        + underlier
            [value "singleUnderlyer" path "underlyer"]
            [value "basketConstituent" path "underlyer->basket"]
            [value "strike"]
            [hint "bond" , "convertibleBond" , "equity" , "index" , "mortgage"]
            [hint "swap"]
            [hint "varianceSwapTransactionSupplement"]
            [hint "dividendSwapTransactionSupplement"]
            [hint "commodity"]
            [hint "commoditySwap"]
            [hint "creditDefaultSwap"]
        + optionType
            [value "optionType"]
            [value "strikeQuoteBasis" path "strike"]
            [set to OptionTypeEnum -> Straddle when "swaptionStraddle" = True]

    OptionFeature:
        + fxFeature
            [value "fxFeature"]
        + averagingFeature
            [value "asian"]
            [value "fixingSchedule"]
            [hint "averagingMethod"]
        + barrier
            [value "barrier"]
        + knock
            [value "knock"]
        + passThrough
            [value "passThrough"]

    FxFeature:
        + referenceCurrency
            [value "referenceCurrency" meta "id" , "currencyScheme"]
        + composite
            [value "composite"]
        + quanto
            [value "quanto"]
        + crossCurrency
            [value "crossCurrency"]

    Quanto:
        + fxRate
            [value "fxRate"]
        + fxSpotRateSource
            [value "fxSpotRateSource"]
        + fixingTime
            [value "fixingTime" path "fxSpotRateSource"]

    FxRate:
        + quotedCurrencyPair
            [value "quotedCurrencyPair"]
        + rate
            [value "rate"]

    FxSpotRateSource:
        + primarySource
            [value "primaryRateSource"]
            [hint "rateSource"]
        + secondarySource
            [value "secondaryRateSource"]

    InformationSource:
        + sourceProvider
            [value "rateSource" maps 2 meta "informationProviderScheme"]
        + sourcePage
            [value "rateSourcePage" maps 2 meta "rateSourcePageScheme"]
        + sourcePageHeading
            [value "rateSourcePageHeading" maps 2]

    Barrier:
        + barrierCap
            [value "barrierCap"]
        + barrierFloor
            [value "barrierFloor"]

    Knock:
        + knockIn
            [value "knockIn"]
        + knockOut
            [value "knockOut"]

    PassThrough:
        + passThroughItem
            [value "passThroughItem"]

    PassThroughItem:
        + passThroughPercentage
            [value "passThroughPercentage"]

    TerminationProvision:
        + cancelableProvision
            [value "cancelableProvision"]
            [value "repo"]
        + earlyTerminationProvision
            [value "earlyTerminationProvision"]
            [hint "mutualEarlyTermination"]
        + extendibleProvision
            [value "extendibleProvision"]
        + evergreenProvision
            [value "ignore"]

    MandatoryEarlyTermination:
	 	[value "MandatoryEarlyTermination" meta "id"]
        + mandatoryEarlyTerminationDate
            [value "mandatoryEarlyTerminationDate"]
        + calculationAgent
            [value "calculationAgent"]
        + cashSettlement
            [hint "cashSettlement"]
        + mandatoryEarlyTerminationAdjustedDates
            [value "mandatoryEarlyTerminationAdjustedDates"]

    MandatoryEarlyTerminationAdjustedDates:
        + adjustedEarlyTerminationDate
            [value "adjustedEarlyTerminationDate"]
        + adjustedCashSettlementValuationDate
            [value "adjustedCashSettlementValuationDate"]
        + adjustedCashSettlementPaymentDate
            [value "adjustedCashSettlementPaymentDate"]

    OptionalEarlyTermination:
        + singlePartyOption
            [value "singlePartyOption"]
        + mutualEarlyTermination
            [value "mutualEarlyTermination"]
        + exerciseNotice
            [value "exerciseNotice"]
        + followUpConfirmation
            [value "followUpConfirmation"]
        + calculationAgent
            [value "calculationAgent"]
        + cashSettlement
            [hint "cashSettlement"]
        + optionalEarlyTerminationAdjustedDates
            [value "optionalEarlyTerminationAdjustedDates"]

    OptionalEarlyTerminationAdjustedDates:
        + earlyTerminationEvent
            [value "earlyTerminationEvent"]

    OptionStrike:
        + strikePrice
            [hint "price"]
            [value "price"]
            [hint "strikePrice"]
            [hint "rate"]
            [hint "spread"]
            [hint "strikePricePerUnit"]
            [value "strikePricePerUnitSchedule"]
            [hint "spotRate"]
        + strikeReference
            [value "strikeReference" meta "href"]
        + referenceSwapCurve
            [value "referenceSwapCurve"]
        + averagingStrikeFeature
            [value "FxAverageStrike"]

    ObservationDates:
        + observationSchedule
            [hint "rateObservation"]
            [hint "adjustedDate"]
        + periodicSchedule
            [value "observationSchedule"]
            [value "fixingSchedule"]
            [value "amount"]
        + parametricDates
            [value "observationSchedule"]
            [value "pricingDates"]

    ObservationSchedule:
        + observationDate
            [value "rateObservation"]

    ObservationDate:
        + adjustedDate
            [value "date"]
        + weight
            [value "averageRateWeightingFactor"]

    PubliclyAvailableInformation:
        + standardPublicSources
            [value "standardPublicSources"]
        + publicSource
            [value "publicSource"]
        + specifiedNumber
            [value "specifiedNumber"]

    Restructuring:
        + applicable
            [value "applicable"]
        + restructuringType
            [value "restructuringType" meta "restructuringScheme"]
        + multipleHolderObligation
            [value "multipleHolderObligation"]
        + multipleCreditEventNotices
            [value "multipleCreditEventNotices"]

    StrategyFeature:
        + strikeSpread
            [value "strikeSpread" path "strategyFeature"]
        + calendarSpread
            [value "calendarSpread" path "strategyFeature"]

    StrikeSpread:
        + upperStrike
            [value "upperStrike"]
        + upperStrikeNumberOfOptions
            [value "upperStrikeNumberOfOptions"]

    Trigger:
        + level
            [hint "level"]
            [hint "levelPercentage"]
            [value "levelPrice"]
        + creditEvents
            [value "creditEvents"]
        + creditEventsReference
            [value "creditEventsReference" meta "href"]
        + triggerType
            [value "triggerType"]
        + triggerTimeType
            [value "triggerTimeType"]

    TriggerEvent:
        + schedule
            [value "schedule"]
        + triggerDates
            [value "triggerDates"]
        + trigger
            [value "trigger"]
        + featurePayment
            [value "featurePayment"]

    WeightedAveragingObservation:
        + dateTime
            [value "dateTime"]
        + observationNumber
            [value "observationNumber"]
        + weight
            [value "weight"]

    Underlier:
        + Observable
            [value "bond" meta "instrumentId" mapper "UnderlierMeta"]
            [value "convertibleBond" meta "instrumentId" mapper "UnderlierMeta"]
            [value "equity" meta "instrumentId" mapper "UnderlierMeta"]
            [value "index" meta "instrumentId" mapper "UnderlierMeta"]
            [value "mortgage" meta "instrumentId" mapper "UnderlierMeta"]
            [value "commodity" meta "instrumentId" mapper "UnderlierMeta"]
            [value "strikeQuoteBasis" mapper "AssetCashMeta"]
            [value "quotedCurrencyPair" meta "quoteBasis"]

    Product:
        + NonTransferableProduct
            [value "swap"]
            [value "varianceSwapTransactionSupplement"]
            [value "dividendSwapTransactionSupplement"]
            [value "creditDefaultSwap" mapper "CdsFeeLegPayout"]
            [hint "creditDefaultSwap"]
            [value "commoditySwap"]
            [hint "commoditySwap"]
        + TransferableProduct
            [value "ignore"]

    ExerciseTerms:
        + commencementDate
            [value "commencementDate" path "americanExercise"]
            [value "commencementDate" path "americanExercise->exercisePeriod"]
            [value "commencementDate" path "exercise->americanExercise->exercisePeriod"]
            [value "commencementDate" path "equityExercise->equityAmericanExercise"]
        + earliestExerciseTime
            [value "earliestExerciseTime" path "americanExercise"]
            [value "earliestExerciseTime" path "bermudaExercise"]
            [value "earliestExerciseTime" path "europeanExercise"]
        + exerciseDates
            [value "bermudaExerciseDates" path "bermudaExercise"]
            [value "bermudaExerciseDates" path "equityBermudaExercise"]
            [value "bermudaExerciseDates" path "equityExercise->equityBermudaExercise"]
        + exerciseFee
            [value "exerciseFee" path "europeanExercise"]
        + exerciseFeeSchedule
            [value "exerciseFeeSchedule" path "americanExercise"]
            [value "exerciseFeeSchedule" path "bermudaExercise"]
        + exerciseProcedure
            [value "physicalExercise"]
            [value "exerciseProcedure"]
            [value "exercise"]
            [value "equityExercise"]
            [value "equityAmericanExercise" path "equityExercise"]
            [value "europeanExercise"]
            [value "americanExercise"]
            [hint "exercise"]
        + expirationDate
            [value "expirationDate" path "americanExercise"]
            [value "expirationDate" path "americanExercise->exercisePeriod"]
            [value "expirationDate" path "exercise->americanExercise->exercisePeriod"]
            [value "expirationDate" path "equityExercise->equityAmericanExercise"]
            [value "expirationDates" path "americanExercise"]
            [value "expirationDate" path "europeanExercise"]
            [value "expirationDate" path "exercise->europeanExercise"]
            [value "expirationDate" path "equityExercise->equityEuropeanExercise"]
            [value "expirationDate" path "physicalExercise->europeanExercise"]
            [value "expirationDates" path "europeanExercise"]
            [value "europeanExercise"]
            [value "americanExercise"]
        + expirationTime
            [value "expirationTime" path "europeanExercise" mapper "ExpirationTimeType"]
            [value "expirationTime" path "americanExercise" mapper "ExpirationTimeType"]
            [value "expirationTime" path "bermudaExercise" mapper "ExpirationTimeType"]
            [value "expirationTime" path "physicalExercise->europeanExercise" mapper "ExpirationTimeType"]
            [value "expirationTime" path "physicalExercise->americanExercise" mapper "ExpirationTimeType"]
            [value "expiryTime" path "europeanExercise" mapper "ExpirationTimeType"]
            [value "expiryTime" path "americanExercise" mapper "ExpirationTimeType"]
            [value "expiryTime" path "bermudaExercise" mapper "ExpirationTimeType"]
            [value "equityExpirationTime" path "equityEuropeanExercise"]
            [value "equityExpirationTime" path "equityAmericanExercise"]
            [value "equityExpirationTime" path "equityBermudaExercise"]
        + expirationTimeType
            [value "equityExpirationTimeType" path "equityExercise->equityEuropeanExercise"]
            [value "equityExpirationTimeType" path "equityExercise->equityAmericanExercise"]
            [value "equityExpirationTimeType" path "equityExercise->equityBermudaExercise"]
        + latestExerciseTime
            [value "latestExerciseTime" path "americanExercise"]
            [value "latestExerciseTime" path "equityExercise->equityAmericanExercise"]
            [value "latestExerciseTime" path "bermudaExercise"]
            [value "latestExerciseTime" path "equityExercise->equityBermudaExercise"]
        + multipleExercise
            [value "multipleExercise" path "americanExercise"]
            [value "equityMultipleExercise" path "equityExercise->equityAmericanExercise"]
            [value "multipleExercise" path "bermudaExercise"]
            [value "equityMultipleExercise" path "equityExercise->equityBermudaExercise"]
        + partialExercise
            [value "partialExercise" path "europeanExercise"]
            [value "partialExercise" path "creditDefaultSwapOption->europeanExercise"]
            [value "partialExercise" path "bondOption->europeanExercise"]
            [value "partialExercise" path "cancelableProvision->europeanExercise"]
            [value "partialExercise" path "extendibleProvision->europeanExercise"]
            [value "partialExercise" path "swaption->europeanExercise"]
        + relevantUnderlyingDate
            [value "relevantUnderlyingDate" path "americanExercise"]
            [value "relevantUnderlyingDate" path "bermudaExercise"]
            [value "relevantUnderlyingDate" path "europeanExercise"]
        + style
            [set to OptionExerciseStyleEnum -> European when "europeanExercise" exists]
            [set to OptionExerciseStyleEnum -> European when "physicalExercise->europeanExercise" exists]
            [set to OptionExerciseStyleEnum -> European when "exercise->europeanExercise" exists]
            [set to OptionExerciseStyleEnum -> European when "equityExercise->equityEuropeanExercise" exists]
            [set to OptionExerciseStyleEnum -> American when "americanExercise" exists]
            [set to OptionExerciseStyleEnum -> American when "physicalExercise->americanExercise" exists]
            [set to OptionExerciseStyleEnum -> American when "exercise->americanExercise" exists]
            [set to OptionExerciseStyleEnum -> American when "equityExercise->equityAmericanExercise" exists]
            [set to OptionExerciseStyleEnum -> Bermuda when "bermudaExercise" exists]
            [set to OptionExerciseStyleEnum -> Bermuda when "equityExercise->equityBermudaExercise" exists]

    ExerciseFee:
        + notionalReference
            [value "notionalReference" meta "href"]
        + feeAmount
            [value "feeAmount"]
        + feeRate
            [value "feeRate"]
        + feePaymentDate
            [value "feePaymentDate"]

    ExerciseFeeSchedule:
        + notionalReference
            [value "notionalReference" meta "href"]
        + feeAmountSchedule
            [value "feeAmountSchedule"]
        + feeRateSchedule
            [value "feeRateSchedule"]
        + feePaymentDate
            [value "feePaymentDate"]

    ExerciseNotice:
        + exerciseNoticeGiver
            [value "partyReference" mapper "ExerciseNoticeGiver"]
        + exerciseNoticeReceiver
            [value "exerciseNoticePartyReference" mapper "ExerciseNoticeReceiver"]
        + businessCenter
            [value "businessCenter" meta "businessCenterScheme"]

    ExerciseProcedure:
        + manualExercise
            [value "manualExercise"]
        + automaticExercise
            [hint "automaticExercise"]
        + followUpConfirmation
            [value "followUpConfirmation"]
            [value "writtenConfirmation"]
        + limitedRightToConfirm
            [value "limitedRightToConfirm"]
        + splitTicket
            [value "splitTicket"]

    ManualExercise:
        + exerciseNotice
            [value "exerciseNotice"]
        + fallbackExercise
            [value "fallbackExercise"]

    Money:
	 	[value "Money" meta "id"]

    MultipleExercise:
        + maximumNotionalAmount
            [value "maximumNotionalAmount"]
        + maximumNumberOfOptions
            [value "maximumNumberOfOptions"]

    OtherAgreement:
        + identifier
            [value "identifier" meta "agreementIdScheme"]
        + otherAgreementType
            [value "type" meta "agreementTypeScheme"]
        + version
            [value "version" meta "agreementVersionScheme"]
        + date
            [value "date"]

    PartialExercise:
        + notionaReference
            [value "notionalReference" meta "href"]
        + integralMultipleAmount
            [value "integralMultipleAmount"]
            [value "integralMultipleExercise"]
        + minimumNotionalAmount
            [value "minimumNotionalAmount"]
        + minimumNumberOfOptions
            [value "minimumNumberOfOptions"]

    CommodityPayout:
        [meta "id"]
        + pricingDates
            [value "pricingDates" path "calculation"]
        + paymentDates
            [value "paymentDates"]
            [value "relativePaymentDates"]
        + fxFeature
            [value "fxFeature"]
        + calculationPeriodDates
            [hint "calculationPeriodsSchedule"]
            [hint "calculationPeriods"]
        + delivery
            [value "ignore"]

    CommodityPriceReturnTerms:
        + spread
            [value "calculation"]
        + conversionFactor
            [value "conversionFactor" path "calculation"]

    PricingDates:
        + specifiedDates
            [value "calculationPeriodsScheduleReference"]
            [value "pricingDates"]

    ParametricDates:
        + dayOfWeek
            [value "dayOfWeek"]
        + dayDistribution
            [value "dayDistribution"]
        + businessCenters
            [hint "businessCalendar"]
        + dayType
            [value "dayType"]
        + lag
            [value "lag"]

    Lag:
        + lagDuration
            [value "lagDuration"]
        + firstObservationDateOffset
            [value "firstObservationDateOffset"]

    Commodity:
        + identifier
            [hint "commodity"]
        + priceQuoteType
            [value "specifiedPrice" path "commodity" maps 2]
        + deliveryDateReference
            [value "commodity"]
        + description
            [value "description" path "commodity"]

    DeliveryDateParameters:
        + deliveryNearby
            [hint "deliveryDates"]
            [value "deliveryNearby"]
        + deliveryDateRollConvention
            [value "deliveryDateRollConvention"]
        + deliveryDateExpirationConvention
            [value "ignore"]

    SettlementPayout:
        [meta "id"]
        + payerReceiver
            [value "exchangedCurrency1" maps 2 set when "exchangeRate->quotedCurrencyPair->quoteBasis" = "Currency2PerCurrency1"]
            [value "exchangedCurrency2" maps 2 set when "exchangeRate->quotedCurrencyPair->quoteBasis" = "Currency1PerCurrency2"]
        + priceQuantity
            [value "exchangedCurrency1" maps 2 set when "exchangeRate->quotedCurrencyPair->quoteBasis" = "Currency2PerCurrency1"]
            [value "exchangedCurrency2" maps 2 set when "exchangeRate->quotedCurrencyPair->quoteBasis" = "Currency1PerCurrency2"]
            [value "exchangeRate"]
            [hint "notional"]
        + underlier
            [value "quoteBasis" path "exchangeRate->quotedCurrencyPair" mapper "AssetCashMeta"]
            [value "underlyer"]
        + delivery
            [value "ignore"]

    FixedPricePayout:
		[meta "id"]
        + paymentDates
            [value "paymentDates"]
            [value "relativePaymentDates"]
            [hint "paymentDate"]
        + schedule
            [value "ignore"]

    FixedPrice:
        + price
            [value "fixedPrice" meta "price"]
            [hint "fixedStrike"]
            [value "fixedPriceStep" path "fixedPriceSchedule" meta "price"]

    PaymentDiscounting:
        + discountFactor
            [value "discountFactor"]
        + presentValueAmount
            [value "presentValueAmount"]

    PerformancePayout:
	    [meta "id"]
        + payerReceiver
            [hint "fixedLeg"]
            [hint "floatingLeg"]
        - priceQuantity
        + priceQuantity
            [value "vegaNotional" set when path = "fxVolatilitySwap"]
            // For Equity Swap
            [value "rateOfReturn"]
            [value "underlyer" set when path = "dividendLeg"]
            [value "notional"] // when monetary amount
            [hint "notional"] // for FX Variance Swap
        + paymentDates
            [value "paymentDates" path "rateOfReturn"]
        + underlier
            [value "singleUnderlyer" path "underlyer"]
            [value "basketConstituent" path "underlyer->basket"]
            [hint "quotedCurrencyPair"]
        + fxFeature
            [value "fxFeature"]
        + portfolioReturnTerms
            [value "ignore"]
        + initialValuationPrice
            [value "ignore"]
        + interimValuationPrice
            [value "ignore"]
        + finalValuationPrice
            [value "ignore"]

    ValuationDates:
        + initialValuationDate
            [value "initialPrice" path "rateOfReturn"]
        + interimValuationDate
            [value "valuationPriceInterim" path "rateOfReturn"]
        + finalValuationDate
            [value "valuationPriceFinal" path "rateOfReturn"]
            [value "valuation"]
            [hint "valuationDate"]
            [hint "valuationDateOffset"]

    PerformanceValuationDates:
	    [meta "id" path "valuationRules"]
        + determinationMethod
            [value "determinationMethod"]
        + valuationDate
            [value "valuationDate" path "valuationRules"]
            [value "valuationDate"]
            [hint "valuationDate"]
        + valuationDates
            [value "valuationDates" path "valuationRules"]
            [value "valuationDates"]
            [hint "valuationDateOffset"]
        + valuationTimeType
            [value "valuationTimeType" path "valuationRules"]
            [value "valuationTimeType"]
        + valuationTime
            [value "valuationTime"]

    ReturnTerms:
        + priceReturnTerms
            [value "return"]
        + dividendReturnTerms
            // Equity swaps
            [value "return" , "underlyer"]
            // Dividend swaps
            [hint "declaredCashDividendPercentage" , "declaredCashEquivalentDividendPercentage" , "dividendPeriod" , "specialDividends" , "materialDividend"]
        + varianceReturnTerms
            [value "variance" path "amount"]
            [hint "amount"]
            [hint "valuation"]
            [hint "annualizationFactor" , "meanAdjustment" , "vegaNotional" , "fixedLeg"]
        + volatilityReturnTerms
            [value "volatility" path "amount"]
            [hint "amount"]
            [hint "valuation"]
            [hint "annualizationFactor" , "meanAdjustment" , "fixedLeg"]
        + correlationReturnTerms
            [value "correlation" path "amount"]
            [hint "amount"]
            [hint "valuation"]

    PriceReturnTerms:
        + returnType
            [value "returnType"]

    DividendReturnTerms:
        + dividendPayoutRatio
            // Equity swaps
            [value "singleUnderlyer" , "basketConstituent" path "basket" , "dividendConditions" mapper "DividendPayoutBasketConstituent"]
            // Dividend swaps
            [hint "declaredCashDividendPercentage" , "declaredCashEquivalentDividendPercentage"]
        + dividendReinvestment
            [value "dividendReinvestment" path "dividendConditions"]
        + dividendEntitlement
            [value "dividendEntitlement" path "dividendConditions"]
        + dividendAmountType
            [value "dividendAmount" path "dividendConditions"]
        + firstOrSecondPeriod
            [value "dividendPeriod" path "dividendConditions"]
        + extraordinaryDividendsParty
            [value "extraOrdinaryDividends" path "dividendConditions" mapper "ExtraordinaryDividendsParty"]
        + excessDividendAmount
            [value "excessDividendAmount" path "dividendConditions"]
        + dividendCurrency
            [value "dividendConditions"]
        + nonCashDividendTreatment
            [value "nonCashDividendTreatment" path "dividendConditions"]
        + dividendComposition
            [value "dividendComposition" path "dividendConditions"]
        + specialDividends
            [value "specialDividends"]
        + materialDividend
            [value "materialDividend"]
        + dividendPeriod
            // Equity swaps
            [value "dividendConditions"]
            // Dividend swaps
            [value "dividendPeriod"]

    DividendPeriod:
        + startDate
            [hint "unadjustedStartDate"]
            [hint "dividendPeriodEffectiveDate"]
        + endDate
            [hint "unadjustedEndDate"]
            [hint "dividendPeriodEndDate"]
        + dateAdjustments
            [value "dateAdjustments"]
        + basketConstituent
            [value "underlierReference"]
        + dividendPaymentDate
            [value "dividendPaymentDate"]
            [hint "paymentDate"]
        + dividendValuationDate
            [value "valuationDate"]

    DividendCurrency:
        + currency
            [value "currency" meta "currencyScheme"]
        + determinationMethod
            [value "determinationMethod"]
        + currencyReference
            [value "currencyReference" meta "href"]

    DividendDateReference:
        + dateReference
            [value "dividendDateReference"]
        + paymentDateOffset
            [value "paymentDateOffset"]
            [value "relativeDate"]

    DividendPaymentDate:
        + dividendDateReference
            [hint "dividendDateReference"]
        + dividendDate
            [value "paymentDate"]
            [hint "unadjustedStartDate"]
            [hint "unadjustedEndDate"]
            [value "dividendPeriodEffectiveDate" meta "href"]
            [value "dividendPeriodEndDate" meta "href"]

    ReturnTermsBase:
        + expectedN
            [value "expectedN"]
        + initialLevel
            [value "initialLevel"]

    VolatilityReturnTerms:
        // Common for variance, volatility and correlation (ReturnTermsBase)
        + dividendApplicability
            [value "amount" set when path = "volatilityLeg"]
        + valuationTerms
            [value "valuation" set when path = "volatilityLeg"]
        // Volatility specific
        + volatilityStrikePrice
            [hint "volatilityStrikePrice"]
            [value "fixedLeg" set when path = "fxVolatilitySwap"]
        + volatilityCapFloor
            [value "volatilityCap"]
        + annualizationFactor
            [value "annualizationFactor" set when path = "fxVolatilitySwap"]
        + meanAdjustment
            [value "meanAdjustment" set when path = "fxVolatilitySwap"]

    VarianceReturnTerms:
        // Common for variance, volatility and correlation (ReturnTermsBase)
        + dividendApplicability
            [value "amount" set when path = "varianceLeg"]
        + valuationTerms
            [value "valuation" set when path = "varianceLeg"]
        // Variance specific
        + varianceStrikePrice
            [hint "varianceStrikePrice"]
            [value "fixedLeg" set when path = "fxVarianceSwap"]
        + volatilityStrikePrice
            [hint "volatilityStrikePrice"]
        + vegaNotionalAmount
            [hint "vegaNotionalAmount"]
            [value "vegaNotional" set when path = "fxVarianceSwap"]
        + exchangeTradedContractNearest
            [value "variance" path "amount" set when path = "varianceLeg"]
        + annualizationFactor
            [value "annualizationFactor" set when path = "fxVarianceSwap"]
        + meanAdjustment
            [value "meanAdjustment" set when path = "fxVarianceSwap"]

    CorrelationReturnTerms:
        // Common for variance, volatility and correlation (ReturnTermsBase)
        + dividendApplicability
            [value "amount" set when path = "correlationLeg"]
        + valuationTerms
            [value "valuation" set when path = "correlationLeg"]
        // Correlation specific
        + correlationStrikePrice
            [hint "correlationStrikePrice"]
        + boundedCorrelation
            [value "boundedCorrelation"]
        + numberOfDataSeries
            [value "numberOfDataSeries"]

    NumberRange:
        + upperBound
            [hint "maximumBoundaryPercent"]
        + lowerBound
            [hint "minimumBoundaryPercent"]

    NumberBound:
        + number
            [value "maximumBoundaryPercent"]
            [value "minimumBoundaryPercent"]

    VarianceCapFloor:
        + varianceCap
            [value "varianceCap"]
        + unadjustedVarianceCap
            [value "unadjustedVarianceCap"]
        + boundedVariance
            [value "boundedVariance"]

    VolatilityCapFloor:
        + applicable
            [value "applicable"]
        + totalVolatilityCap
            [value "totalVolatilityCap"]
        + volatilityCapFactor
            [value "volatilityCapFactor"]

    BoundedVariance:
        + daysInRangeAdjustment
            [value "daysInRangeAdjustment"]
        + realisedVarianceMethod
            [value "realisedVarianceMethod"]
        + upperBarrier
            [value "upperBarrier"]
        + lowerBarrier
            [value "lowerBarrier"]

    ValuationTerms:
        + futuresPriceValuation
            [value "futuresPriceValuation"]
        + optionsPriceValuation
            [value "optionsPriceValuation"]
        + numberOfValuationDates
            [value "numberOfValuationDates"]
        + dividendValuationDates
            [value "dividendValuationDates"]
        + fPVFinalPriceElectionFallback
            [value "fPVFinalPriceElectionFallback"]
        + multipleExchangeIndexAnnexFallback
            [value "multipleExchangeIndexAnnexFallback"]
        + componentSecurityIndexAnnexFallback
            [value "componentSecurityIndexAnnexFallback"]

    DividendApplicability:
        + optionsExchangeDividends
            [value "optionsExchangeDividends"]
        + additionalDividends
            [value "additionalDividends"]
        + allDividends
            [value "allDividends"]

    AdjustableRelativeOrPeriodicDates:
		[meta "id"]
        + adjustableDates
            [value "adjustableDates"]
        + relativeDates
            [value "relativeDates"]
            [value "relativeDateSequence"]
            [value "valuationDateOffset"]
        + periodicDates
            [value "periodicDates"]
            [value "periodicPayment"]
            [hint "amount"]
            [hint "valuationDateOffset"]

    AmountSchedule:
        + currency
            [value "currency" meta "currencyScheme"]

    AutomaticExercise:
        + thresholdRate
            [value "thresholdRate" path "automaticExercise"]
        + isApplicable
            [value "automaticExercise"]

    Observable:
        + Basket
            [hint "basketConstituent"]

    Asset:
        + Cash
            [value "quoteBasis" path "exchangeRate->quotedCurrencyPair" mapper "CashAssetIdentifier"]
            [value "strikeQuoteBasis" mapper "CashAssetIdentifier"]
            [hint "paymentAmount"]
        + Commodity
            [hint "commodity"]
            [hint "commodityClassification"]
        + DigitalAsset
            [value "ignore"]
        + Instrument
            [hint "equity"]
            [hint "bond"]
            [hint "convertibleBond"]
            [hint "loan"]
            [hint "exchangeTradedContractNearest"]

    AssetBase:
        + taxonomy
            [value "commodityClassification"]
        + isExchangeListed
            [set to True when "bond->exchangeId" exists]
            [set to True when "convertibleBond->exchangeId" exists]
            [set to True when "loan->exchangeId" exists]
            [set to True when "mortgage->exchangeId" exists]
            [set to True when "equity->exchangeId" exists]
            [set to True when "index->exchangeId" exists]
            [set to True when "commodity->exchangeId" exists]
            [set to True when "exchangeTradedContractNearest->exchangeId" exists]
        + exchange
            [value "bond"]
            [value "convertibleBond"]
            [value "loan"]
            [value "mortgage"]
            [value "equity"]
            [value "index"]
            [value "commodity"]
            [value "exchangeTradedContractNearest"]

    AssetIdentifier:
        + identifier
            [value "instrumentId" path "bond" maps 2 mapper "AssetIdentifierType"]
            [value "instrumentId" path "convertibleBond" maps 2 mapper "AssetIdentifierType"]
            [value "instrumentId" path "loan" maps 2 mapper "AssetIdentifierType"]
            [value "instrumentId" path "mortgage" maps 2 mapper "AssetIdentifierType"]
            [value "instrumentId" path "equity" maps 2 mapper "AssetIdentifierType"]
            [value "instrumentId" path "index" maps 2 mapper "AssetIdentifierType"]
            [value "instrumentId" path "commodity" maps 2 mapper "AssetIdentifierType"]
            [value "instrumentId" path "exchangeTradedContractNearest" maps 2 mapper "AssetIdentifierType"]
            [value "description" path "equity" maps 2 mapper "AssetIdentifierType"]
            [value "indexId" maps 2 mapper "AssetIdentifierType"]
            [value "indexName" maps 2 mapper "AssetIdentifierType"]
            [value "floatingRateIndex" maps 2 mapper "AssetIdentifierType"]
            // premium
            [value "currency" path "paymentAmount" maps 2 meta "currencyScheme"]
        + identifierType
            [set to AssetIdTypeEnum -> CurrencyCode when "paymentAmount->currency" exists]

    Instrument:
        + ListedDerivative
            [hint "exchangeTradedContractNearest"]
        + Loan
            [hint "loan"]
        + Security
            [hint "equity"]
            [hint "bond"]
            [hint "convertibleBond"]

    ListedDerivative:
        + instrumentType
            [set to InstrumentTypeEnum -> ListedDerivative when "exchangeTradedContractNearest" exists]

    Loan:
        + borrower
            [value "borrower" path "loan"]
        + lien
            [value "lien" path "loan" meta "lienScheme"]
        + facilityType
            [value "facilityType" path "loan" meta "facilityTypeScheme"]
        + creditAgreementDate
            [value "creditAgreementDate" path "loan"]
        + tranche
            [value "tranche" path "loan" meta "loanTrancheScheme"]
        + instrumentType
            [set to InstrumentTypeEnum -> Debt when "loan" exists]

    Security:
        + identifier
            [value "equity" meta "description"]
            [meta "instrumentId"]
            [hint "bond"]
            [hint "convertibleBond"]
            [hint "mortgage"]
            [hint "equity"]
        + instrumentType
            [set to InstrumentTypeEnum -> Debt when "bond" exists]
            [set to InstrumentTypeEnum -> Debt when "convertibleBond" exists]
            [set to InstrumentTypeEnum -> Debt when "mortgage" exists]
            [set to InstrumentTypeEnum -> Equity when "equity" exists]

    IndexBase:
        + name
            [value "description" path "index"]
            [value "indexName"]
        + provider
            [value "ignore"]

    Index:
        + CreditIndex
            [value "ignore"]
        + EquityIndex
            [hint "index"]
        + ForeignExchangeRateIndex
            [value "quotedCurrencyPair"]
            [value "fixingInformationSource"]
        + OtherIndex
            [value "ignore"]

    EquityIndex:
        + assetClass
            [value "index" mapper "IndexAssetClass"]

    ForeignExchangeRateIndex:
        + primaryFxSpotRateSource
            [value "primaryRateSource"]
        + assetClass
            [set to AssetClassEnum -> ForeignExchange]

    Basket:
        + basketConstituent
            [value "basketConstituent"]

    BasketConstituent:
        + quantity
            [value "constituentWeight"]
            [hint "constituentWeight"]

    TradeLot:
        + priceQuantity
            // Rates
            [value "swapStream"]
            [value "capFloorStream"]
            [value "fra" mapper "FraPriceQuantitySplitter"]
            [value "payment"]
            [value "bondOption"]
            // Credit
            [value "periodicPayment" path "feeLeg"]
            [value "protectionTerms"]
            // Equity
            [value "returnLeg"]
            [value "interestLeg"]
            [value "equityOption"]
            [value "brokerEquityOption"]
            [value "equityOptionTransactionSupplement"]
            // Performance
            [value "varianceLeg"]
            [value "fixedLeg"]
            [value "dividendLeg"]
            [value "correlationLeg"]
            [value "volatilityLeg"]
            [value "fxVarianceSwap"]
            [value "fxVolatilitySwap"]
            // FX
            [value "nearLeg"]
            [value "farLeg"]
            [value "fxSingleLeg"]
            [value "fxOption"]
            [value "fxDigitalOption"]
            // Commodity
            [value "commodityOption"]
            [value "floatingLeg"]
            [value "coalPhysicalLeg"]
            [value "electricityPhysicalLeg"]
            [value "environmentalPhysicalLeg"]
            [value "gasPhysicalLeg"]
            [value "oilPhysicalLeg"]
            // Other
            [value "repo"]
            [value "genericProduct" mapper "InterestRateForwardDebtPrice"]
            [value "productSummary"]
        + lotIdentifier
            [value "ignore"]

    PriceQuantity:
        + price
            // For Swap Stream
            [value "calculation" path "calculationPeriodAmount" mapper "FloatingRateCalculation"]
            [value "fixedRateSchedule" path "calculationPeriodAmount->calculation"]
            [value "spreadSchedule" path "calculationPeriodAmount->calculation->floatingRateCalculation"]
            [value "knownAmountSchedule" path "calculationPeriodAmount"]
            // For FRAs:
            [hint "fixedRate"]
            // For Credit:
            [value "fixedAmountCalculation"]
            [value "spreadSchedule" path "floatingAmountCalculation->floatingRate"]
            // For Equity Swaps:
            [value "rateOfReturn"]
            [value "floatingRateCalculation" path "interestCalculation"]
            [value "spreadSchedule" path "interestCalculation->floatingRateCalculation"]
            [value "floatingRateMultiplierSchedule" path "interestCalculation->floatingRateCalculation"]
            [value "underlyerPrice"]
            [hint "equityPremium"]
            // For FX:
            [value "exchangeRate"]
            // For Repo:
            [value "fixedRateSchedule"]
            [value "floatingRateCalculation"]
            [value "spreadSchedule" path "floatingRateCalculation"]
            [value "floatingRateMultiplierSchedule" path "floatingRateCalculation"]
            // For Commodity:
            [value "fixedPrice"] // Commodity Swap Fixed Leg
            [value "spread" path "calculation"] // Commodity Swap Floating Leg
            // For bullet payments
            [value "paymentAmount"]
        + quantity
            // For Swap Stream
            [value "notionalStepSchedule" path "calculationPeriodAmount->calculation->notionalSchedule"]
            [value "fxLinkedNotionalSchedule" path "calculationPeriodAmount->calculation"]
            [value "futureValueNotional" path "calculationPeriodAmount->calculation"]
            [value "notionalAmount"]
            // For FRAs:
            [value "notional"]
            // For CDS, Swaption, Index:
            [value "calculationAmount" path "fixedAmountCalculation"]
            [value "calculationAmount"]
            [value "calculationAmount" path "floatingAmountCalculation"]
            // For Equity Swaps:
            [value "singleUnderlyer" path "underlyer"]
            [value "basket" path "underlyer"]
            [value "notionalAmount" path "notional"]
            // Performance
            [value "fixedPayment"]
            [value "variance" path "amount"]
            [value "notionalAmount" path "amount->correlation"]
            [value "volatility" path "amount"]
            [hint "vegaNotional"]
            // For FX:
            [value "paymentAmount" path "exchangedCurrency1"]
            [value "paymentAmount" path "exchangedCurrency2"]
            [value "putCurrencyAmount"]
            [value "callCurrencyAmount"]
            // For Repo:
            [value "settlementAmount" path "nearLeg"]
            // For Commodity
            [value "notionalQuantity"]
            [value "totalNotionalQuantity" mapper "TotalNotionalQuantity"]
            [value "notionalQuantitySchedule"] // Commodity Option
            // For Options
            [value "numberOfOptions" mapper "NumberOfOptions"] // handles optionEntitlement
        + observable
            // For Swap Streams etc
            [value "calculation" path "calculationPeriodAmount"]
            // For FRA:
            [hint "floatingRateIndex" , "indexTenor"]
            // For Credit:
            [value "floatingAmountCalculation"]
            [value "floatingRate" path "floatingAmountCalculation"]
            // For Equity:
            [value "singleUnderlyer" path "underlyer"]
            [value "interestCalculation"]
            [hint "equity"]
            [hint "index"]
            // For FX:
            [hint "exchangeRate"]
            [value "strike"]
            // For FX variance:
            [hint "quotedCurrencyPair"]
            [hint "fixingInformationSource"]
            // For Repo / Bond Options:
            [hint "bond" , "convertibleBond"]
            // For Commodity Swap Floating Leg
            [hint "commodity"]
            [hint "commodityClassification"]
            // Other
            [value "basket" path "underlyer"]
            [value "underlyer"] // For bond forwards (generic products)
        + effectiveDate
            [value "ignore"] // Do not map, until a canonical representation of effective date is built in the CDM and existing effective date attributes can be re-directed here

    Measure:
        // Only used to map quantity multiplier
        // TBD: merge Measure, PriceSchedule and QuantitySchedule synonyms into a single "MeasureBase"
        + value
            [value "optionEntitlement"]
        + unit
            [hint "entitlementCurrency"]

    MeasureSchedule:
        + datedValue
            [value "ignore"]

    PriceSchedule:
        + value
            [value "initialRate" mapper "PriceUnitType"]
            [value "initialValue" mapper "PriceUnitType"]
            [value "rate" maps 2 mapper "PriceUnitType"]
            [value "amount" mapper "PriceUnitType"]
            [value "amount" path "initialPrice->netPrice" mapper "PriceUnitType"]
            [value "fixedRate" mapper "PriceUnitType"]
            [value "level" mapper "PriceUnitType"]
            [value "levelPercentage" mapper "PriceUnitType"]
            [value "strikePrice" mapper "PriceUnitType"]
            [value "spread" mapper "PriceUnitType"]
            [value "spread" path "floatingRateCalculation" mapper "PriceUnitType"]
            [value "referencePrice" mapper "PriceUnitType"]
            [value "price" maps 2] // For Commodity Swap Fixed Leg
            [value "amount" path "strikePricePerUnit" mapper "PriceUnitType"] // For Commodity Option
            [value "varianceStrikePrice" mapper "PriceUnitType"]
            [value "volatilityStrikePrice" mapper "PriceUnitType"]
            [value "correlationStrikePrice" mapper "PriceUnitType"]
            [value "fixedStrike" mapper "PriceUnitType"]
            [value "value" mapper "PriceUnitType"]
            [value "amount" path "equityPremium->pricePerOption" mapper "PriceUnitType"]
        + unit
            [value "fxLinkedNotionalSchedule" set when "floatingRateCalculation->spreadSchedule" exists]
            [value "quotedCurrencyPair"]
            [value "settlementAmount" path "nearLeg"]
            // For Commodity Swap Fixed Leg
            [hint "priceCurrency"]
            [value "priceCurrency" path "fixedPriceStep"]
            [value "fixedPriceStep"]
        + perUnitOf
            [value "fxLinkedNotionalSchedule" set when "floatingRateCalculation->spreadSchedule" exists]
            [value "quotedCurrencyPair"]
            [value "settlementAmount" path "nearLeg"]
            [value "amount"]
            // For Commodity Swap Fixed Leg
            [hint "priceUnit"]
            [value "priceUnit" path "fixedPriceStep"]
            [value "fixedPriceStep"]
        + datedValue
            [value "step"]
            [value "fixedPriceStep" mapper "PriceUnitType"]
            [value "strikePricePerUnitStep" mapper "CommoditySchedules"]
        + priceType
            [set to PriceTypeEnum -> InterestRate when path = "fixedRateSchedule"]
            [set to PriceTypeEnum -> InterestRate when "fixedRate" exists]
            [set to PriceTypeEnum -> InterestRate when "initialRate" exists]
            [set to PriceTypeEnum -> InterestRate when "spread" exists]
            [set to PriceTypeEnum -> InterestRate when path = "knownAmountSchedule"]
            [set to PriceTypeEnum -> InterestRate when "floatingRateCalculation->spread" exists]
            [set to PriceTypeEnum -> InterestRate when path = "spreadSchedule"]
            [set to PriceTypeEnum -> InterestRate when path = "floatingRateIndex"]
            [set to PriceTypeEnum -> AssetPrice when "referencePrice" exists]
            [set to PriceTypeEnum -> AssetPrice when "strikePrice" exists]
            [set to PriceTypeEnum -> AssetPrice when "level" exists]
            [set to PriceTypeEnum -> AssetPrice when "levelPercentage" exists]
            [set to PriceTypeEnum -> AssetPrice when "initialPrice->netPrice->amount" exists]
            [set to PriceTypeEnum -> AssetPrice when "equityPremium->pricePerOption" exists]
            [set to PriceTypeEnum -> Dividend when "fixedStrike" exists]
            [set to PriceTypeEnum -> Correlation when "correlationStrikePrice" exists]
            [set to PriceTypeEnum -> Variance when path = "variance" and "varianceStrikePrice" exists]
            [set to PriceTypeEnum -> Volatility when path = "variance" and "volatilityStrikePrice" exists]
            [set to PriceTypeEnum -> Volatility when path = "volatility" and "volatilityStrikePrice" exists]
            [set to PriceTypeEnum -> CashPrice when path = "bulletPayment->payment->paymentAmount"]
            [set to PriceTypeEnum -> ExchangeRate when path = "exchangeRate" and "rate" exists]
            [set to PriceTypeEnum -> ExchangeRate when path = "fxOption->strike"]
            // For Commodity Swaps
            [set to PriceTypeEnum -> CashPrice when path = "fixedLeg->fixedPrice"]
            [set to PriceTypeEnum -> CashPrice when path = "fixedLeg->fixedPriceSchedule"]
            [set to PriceTypeEnum -> AssetPrice when path = "calculation->spread"]
            // For Commodity Option
            [set to PriceTypeEnum -> AssetPrice when "strikePricePerUnit->amount" exists]
            [value "measureType"]
        + arithmeticOperator
            [set to ArithmeticOperationEnum -> Add when "spread" exists]
            [set to ArithmeticOperationEnum -> Add when "floatingRateCalculation->spread" exists]
            [set to ArithmeticOperationEnum -> Add when path = "spreadSchedule"]
            [set to ArithmeticOperationEnum -> Add when path = "floatingRateIndex"]
            [set to ArithmeticOperationEnum -> Add when path = "calculation->spread"]
            [set to ArithmeticOperationEnum -> Max when path = "floorRateSchedule"]
            [set to ArithmeticOperationEnum -> Min when path = "capRateSchedule"]
            [set to ArithmeticOperationEnum -> Multiply when path = "floatingRateMultiplierSchedule"]

    PriceComposite:
        + baseValue
            [value "spotRate"]
        + operand
            [value "forwardPoints"]
        + arithmeticOperator
            [set to ArithmeticOperationEnum -> Add when "forwardPoints" exists]
        + operandType
            [set to PriceOperandEnum -> ForwardPoint when "forwardPoints" exists]

    PremiumExpression:
        + premiumType
            [value "premiumType"]
        + pricePerOption
            [value "pricePerOption"]
        + percentageOfNotional
            [value "percentageOfNotional"]

    CashPrice:
        + cashPriceType
            [set to CashPriceTypeEnum -> Fee when path = "fixedLeg->fixedPrice"]
            [set to CashPriceTypeEnum -> Fee when path = "bulletPayment->payment->paymentAmount"]
        + feeType
            [value "paymentType"]

    QuantitySchedule:
        + value
            [value "initialValue" maps 2]
            [value "amount" maps 2]
            [value "openUnits" maps 2]
            [value "numberOfOptions" maps 2]
            [value "basketPercentage" maps 2]
            [value "quantity" maps 2]
            [value "amount" path "paymentAmount"]
            [value "amount" path "fixedAmount"]
            [value "amount" path "varianceAmount"]
            [value "vegaNotionalAmount" mapper "VegaNotionalAmount"]
            [value "amount" path "vegaNotional" mapper "VegaNotionalAmount"]
        + unit
            [value "singleUnderlyer"]
            [value "basket"]
            [value "basketPercentage"]
            [hint "openUnits"]
            [value "paymentAmount"]
            [value "fixedAmount"]
            [value "varianceAmount"]
            [value "notionalStep"]
            [hint "quantityUnit"]
        + multiplier
            [hint "optionEntitlement"]
            [hint "entitlementCurrency"]
        + frequency
            [value "Frequency"]
            // For Commodity Swap Fixed Leg
            [hint "quantityFrequency"]
            [value "notionalStep"]
        + datedValue
            [value "step"]
            [value "notionalStep"]
            [value "period"]
            [value "calculationPeriod" path "period"]

    NonNegativeStep:
        + stepDate
            [value "stepDate"]
        + stepValue
            [value "stepValue"]

    Rounding:
        + roundingDirection
            [value "roundingDirection"]
        + precision
            [value "precision"]

    Schedule:
        + value
            [value "initialValue" set when "step" exists]
        + datedValue
            [value "step"]

    DatedValue:
        [value "Step" meta "id"]
        + date
            [value "stepDate" maps 2]
            [value "startDate" maps 2]
        + value
            [value "stepValue" maps 2]
            [value "quantity" set when path = "notionalStep"]
            [value "amount" maps 2]
            [value "price" maps 2]

    TransactedPrice:
        + marketFixedRate
            [value "marketFixedRate" path "feeLeg"]
        + initialPoints
            [value "initialPoints" path "feeLeg"]
        + marketPrice
            [value "marketPrice" path "feeLeg"]
        + quotationStyle
            [value "quotationStyle" path "feeLeg"]

    NotDomesticCurrency:
        + applicable
            [value "applicable"]
        + currency
            [value "currency" meta "currencyScheme"]

    Obligations:
        + category
            [value "category"]
        + notSubordinated
            [value "notSubordinated"]
        + specifiedCurrency
            [value "specifiedCurrency"]
        + notSovereignLender
            [value "notSovereignLender"]
        + notDomesticCurrency
            [value "notDomesticCurrency"]
        + notDomesticLaw
            [value "notDomesticLaw"]
        + listed
            [value "listed"]
        + notDomesticIssuance
            [value "notDomesticIssuance"]
        + fullFaithAndCreditObLiability
            [value "fullFaithAndCreditObLiability"]
        + generalFundObligationLiability
            [value "generalFundObligationLiability"]
        + revenueObligationLiability
            [value "revenueObligationLiability"]
        + notContingent
            [value "notContingent"]
        + excluded
            [value "excluded"]
        + othReferenceEntityObligations
            [value "othReferenceEntityObligations"]
        + designatedPriority
            [value "designatedPriority" meta "lienScheme"]
        + cashSettlementOnly
            [value "cashSettlementOnly"]
        + deliveryOfCommitments
            [value "deliveryOfCommitments"]
        + continuity
            [value "continuity"]

    SpecifiedCurrency:
        + applicable
            [value "applicable"]
        + currency
            [value "currency" meta "currencyScheme"]

    AdjustableDate:
		[value "AdjustableDate" meta "id" path "adjustableDate"]
        + unadjustedDate
            [value "unadjustedDate" maps 2]
            [value "unadjustedDate" path "adjustableDate" maps 2]
            [value "unadjustedDate" path "adjustableDates"]
            [value "unadjustedDate" path "paymentDate"]
            [value "unadjustedDate" path "paymentDate->adjustableDate"]
            [value "firstPeriodStartDate"]
            [value "adjustablePaymentDate"]
            [value "startDate"]
            [value "endDate"]
            [value "fixingDate"]
            [value "unadjustedStartDate"]
            [value "unadjustedEndDate"]
        + dateAdjustments
            [value "dateAdjustments"]
            [value "dateAdjustments" path "paymentDate->adjustableDate"]
            [value "dateAdjustments" path "adjustableDate"]
            [value "dateAdjustments" path "paymentDate"]
        + dateAdjustmentsReference
            [value "dateAdjustmentsReference" meta "href"]
        + adjustedDate
            [value "adjustedDate" meta "id"]
            [value "adjustedDate" path "paymentDate" meta "id"]
            [value "adjustedDate" path "adjustableDate" meta "id"]
            [value "adjustedDate" path "paymentDate->adjustableDate" meta "id"]
            [value "adjustedTerminationDate"]
            [value "adjustedEffectiveDate"]
            [value "adjustedPaymentDate"]
            // for FX Option
            [value "expiryDate" maps 2]

    AdjustableDates:
		[value "AdjustableDates" meta "id"]
        + unadjustedDate
            [value "unadjustedDate"]
        + dateAdjustments
            [value "dateAdjustments"]
        + adjustedDate
            [value "adjustedDate" meta "id"]

    AdjustableOrAdjustedDate:
		[value "AdjustableOrAdjustedDate" meta "id"]
        + unadjustedDate
            [value "unadjustedDate"]
        + dateAdjustments
            [value "dateAdjustments"]
        + adjustedDate
            [value "adjustedDate" meta "id"]
            [value "date"]

    AdjustableOrAdjustedOrRelativeDate:
        + unadjustedDate
            [value "unadjustedDate"]
            [value "adjustablePaymentDate"]
            [value "unadjustedDate" path "paymentDate->adjustableDate"]
            [value "unadjustedDate" path "paymentDate"]
            [value "unadjustedDate" path "adjustableDate"]
        + dateAdjustments
            [value "dateAdjustments"]
            [value "dateAdjustments" path "paymentDate->adjustableDate"]
            [value "dateAdjustments" path "paymentDate"]
            [value "dateAdjustments" path "adjustableDate"]
        + adjustedDate
            [value "adjustedDate" meta "id"]
            [value "adjustedDate" path "paymentDate" meta "id"]
            [value "adjustedDate" path "paymentDate" meta "id" dateFormat "yyyy-MM-ddz"]
            [value "adjustedDate" path "adjustableDate" meta "id"]
            [value "adjustedPaymentDate" meta "id"]
            [value "adjustedPaymentDate" path "FpML"]
        + relativeDate
            [value "relativeDate"]
            [value "relativeDate" path "paymentDate"]
            [value "paymentDaysOffset"]
            [hint "businessCenters"]

    AdjustableOrRelativeDate:
		[meta "id"]
		[meta "id" path "adjustedEffectiveDate"]
		[meta "id" path "calculationPeriodsReference"]
        + relativeDate
            [value "relativeDate"]
            [value "relativeDate" path "paymentDate"]
            [value "relativeDate" path "periodicDates->calculationStartDate"]
            [value "relativeDate" path "periodicDates->calculationEndDate"]
            [hint "periodMultiplier"]
            [hint "period"]
            [hint "dayType"]
            [hint "businessDayConvention"]
            [hint "businessCenters"]
            [hint "dateRelativeTo"]
            [hint "relativeDateAdjustments"]
            [value "relativeDate" path "paymentDateFinal"]
            [value "paymentDaysOffset"]
            [hint "payRelativeTo"]
            // FX Options
            [value "expiryDate"]

    AdjustableOrRelativeDates:
		[meta "id"]
        + adjustableDates
            [value "adjustableDates"]
            [value "bermudaExerciseDates"]
        + relativeDates
            [value "relativeDates"]
            [value "relativeDateSequence"]

    AdjustedRelativeDateOffset:
        + relativeDateAdjustments
            [value "relativeDateAdjustments"]

    BusinessCenters:
        [meta "id" path "businessCenters"]
        [meta "id"]
        + businessCenter
            [value "businessCenter" meta "businessCenterScheme"]
            [value "businessCenter" path "businessCenters" meta "businessCenterScheme"]
        + commodityBusinessCalendar
            [value "businessCalendar" meta "commodityBusinessCalendarScheme"]
        + businessCentersReference
            [value "businessCentersReference" meta "href"]

    BusinessCenterTime:
        + hourMinuteTime
            [value "hourMinuteTime" maps 2]
        + businessCenter
            [value "businessCenter" maps 2 meta "businessCenterScheme"]

    BusinessDateRange:
        + businessDayConvention
            [value "businessDayConvention"]

    BusinessDayAdjustments:
		[value "BusinessDayAdjustments" meta "id"]
        + businessDayConvention
            [value "businessDayConvention" maps 2]

    DateRange:
        + startDate
            [value "unadjustedFirstDate"]
        + endDate
            [value "unadjustedLastDate"]

    DateList:
        + date
            [value "date"]

    DateTimeList:
        + dateTime
            [value "dateTime"]

    Frequency:
		[value "Frequency" meta "id"]
        + periodMultiplier
            [value "periodMultiplier"]
            [value "periodMultiplier" path "paymentFrequency" maps 2]
            [value "periodMultiplier" path "paymentDatesInterim->relativeDates"]
            [set to 1 when "quantityFrequency" = "PerHour"]
            [set to 1 when "quantityFrequency" = "PerCalendarDay"]
            [set to 1 when "quantityFrequency" = "PerMonth"]
            [set to 1 when "quantityFrequency" = "PerCalculationPeriod"]
            [set to 1 when "quantityFrequency" = "PerSettlementPeriod"]
            [set to 1 when "quantityFrequency" = "PerCalculationDay"]
        + period
            [value "period"]
            [value "period" path "paymentFrequency" maps 2]
            [value "period" path "paymentDatesInterim->relativeDates"]
            [value "quantityFrequency" set when rosettaPath = Quantity -> frequency]
            [set to PeriodExtendedEnum -> H when "quantityFrequency" = "PerHour"]
            [set to PeriodExtendedEnum -> C when "quantityFrequency" = "PerCalculationPeriod"]
            [set to PeriodExtendedEnum -> C when "quantityFrequency" = "PerSettlementPeriod"]
            [set to PeriodExtendedEnum -> D when "quantityFrequency" = "PerCalculationDay"]

    Offset:
        + dayType
            [value "dayType" maps 2]

    Period:
	 	[value "Period" meta "id"]
        + periodMultiplier
            [value "periodMultiplier" maps 2]
            [value "periodMultiplier" path "dateOffset"]
            [value "periodMultiplier" path "calculationPeriodDates->relativeEffectiveDate"]
            [value "deliveryNearbyMultiplier"]
            // For Commodity Swap
            [set to 1 when "deliveryDates" = "FirstNearby"]
            [set to 2 when path = "deliveryDates->SecondNearby"]
        + period
            [value "period" maps 2]
            [value "period" path "dateOffset"]
            [value "deliveryNearbyType"]
            // For Commodity Swap
            [set to PeriodEnum -> M when "deliveryDates" exists]

    RelativeDates:
        + periodSkip
            [value "periodSkip"]
        + scheduleBounds
            [value "scheduleBounds"]

    RelativeDateOffset:
        + businessDayConvention
            [value "businessDayConvention"]
            [value "businessDayConvention" path "dateOffset"]
        + businessCenters
            [value "businessCenters"]
        + businessCentersReference
            [value "businessCentersReference" meta "href"]
        + dateRelativeTo
            [value "dateRelativeTo" meta "href"]
            [value "payRelativeTo" meta "href"]
        + adjustedDate
            [value "adjustedDate"]

    ConstituentWeight:
        + openUnits
            [value "openUnits"]
        + basketPercentage
            [value "basketPercentage"]

    DividendPayoutRatio:
        + totalRatio
            [value "dividendPayoutRatio" path "dividendPayout"]
        + cashRatio
            [value "dividendPayoutRatioCash"]
            [value "declaredCashDividendPercentage"]
        + nonCashRatio
            [value "dividendPayoutRatioNonCash"]
            [value "declaredCashEquivalentDividendPercentage"]
        + basketConstituent
            [value "equity" meta "instrumentId"]

    ReferenceBank:
        + referenceBankId
            [value "referenceBankId" meta "referenceBankIdScheme"]
        + referenceBankName
            [value "referenceBankName"]

    RelatedParty:
        + partyReference
            [value "partyReference" maps 2 meta "href"]
        + accountReference
            [value "accountReference" meta "href"]
        + role
            [value "role" maps 2]

    Account:
	 	[value "Account" meta "id"]
        + partyReference
            [value "id" mapper "AccountPartyReference"]
        + accountNumber
            [value "accountId" meta "accountIdScheme"]
        + accountName
            [value "accountName" meta "accountNameScheme"]
        + accountType
            [value "accountType" meta "accountTypeScheme"]
        + accountBeneficiary
            [value "accountBeneficiary" meta "href"]
        + servicingParty
            [value "servicingParty" meta "href"]

    Address:
        + street
            [value "streetAddress"]
            [value "streetLine" path "streetAddress"]
        + city
            [value "city"]
        + state
            [value "state"]
        + country
            [value "country" meta "countryScheme"]
        + postalCode
            [value "postalCode"]

    BusinessUnit:
	 	[value "BusinessUnit" meta "id"]
        + name
            [value "name"]
        + contactInformation
            [value "contactInfo"]
            [hint "country"]

    TelephoneNumber:
        + number
            [value "number"]
        + telephoneNumberType
            [value "type"]

    ContactInformation:
        + telephone
            [value "telephone"]
        + address
            [value "address"]
            [hint "country"]
        + email
            [value "email"]

    LegalEntity:
		[meta "id" path "referenceEntity"]
        + entityId
            [value "entityId" meta "entityIdScheme"]
            [value "entityId" path "referenceEntity" meta "entityIdScheme"]
        + name
            [value "partyName" meta "entityNameScheme"]
            [value "entityName" meta "entityNameScheme"]
            [value "entityName" path "referenceEntity" meta "entityNameScheme"]
            [value "initialDesignation"]
            [value "dealer"]
            [value "exchangeId" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "bond" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "convertibleBond" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "loan" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "mortgage" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "equity" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "index" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "commodity" maps 2 meta "exchangeIdScheme"]
            [value "relatedExchangeId" path "exchangeTradedContractNearest" maps 2 meta "exchangeIdScheme"]
        + name
            [value "identifier"]

    NaturalPerson:
        [value "Person" meta "id"]
        + honorific
            [value "honorific"]
        + firstName
            [value "firstName"]
            [value "personId" maps 2 pattern "([a-zA-Z]*).([a-zA-Z]*)" "$1"]
        + middleName
            [value "middleName"]
        + initial
            [value "initial"]
        + surname
            [value "surname"]
            [value "personId" maps 2 pattern "([a-zA-Z]*).([a-zA-Z]*)" "$2"]
        + suffix
            [value "suffix"]
        + dateOfBirth
            [value "dateOfBirth"]

    PersonIdentifier:
        + identifier
            [value "personId" meta "personIdScheme"]
        + country
            [value "country" path "Person"]

    NaturalPersonRole:
        + personReference
            [value "personReference" meta "href"]
        + role
            [value "role" meta "personRoleScheme"]

    Party:
	 	[value "Party" meta "id" maps 2]
        + name
            [value "partyName" meta "entityNameScheme"]
            [value "entityName" meta "entityNameScheme"]
            [value "entityName" path "referenceEntity" meta "entityNameScheme"]
        + person
            [value "person"]
        + account
            [value "account"]
        + contactInformation
            [value "contactInfo"]
            [hint "country"]
        + businessUnit
            [value "businessUnit"]

    CounterpartyPositionBusinessEvent:
        + after
            [value "ignore"]

    PartyIdentifier:
        + identifier
            [value "partyId" meta "partyIdScheme"]
        + identifierType
            [value "partyIdScheme" path "partyId"]

    PartyContactInformation:
        + partyReference
            [value "partyReference" meta "href"]
        + contactInformation
            [value "contactInfo"]
        + businessUnit
            [value "businessUnit"]
        + person
            [value "person"]

    PartyRole:
        + partyReference
            [value "partyReference" path "relatedParty" meta "href"]
        + role
            [value "role" path "relatedParty"]
        + ownershipPartyReference
            [value "partyReference" set when "relatedParty->role" exists meta "href"]

    CreditLimitUtilisation:
        + executed
            [value "executed"]
        + pending
            [value "pending"]

    CreditLimitUtilisationPosition:
        + shortPosition
            [value "short"]
        + longPosition
            [value "long"]
        + global
            [value "global"]

    LimitApplicable:
        + limitType
            [value "limitType" meta "creditLimitTypeScheme"]
        + clipSize
            [value "clipSize"]
        + amountUtilized
            [value "amountUtilized"]
        + utilization
            [value "utilization"]
        + amountRemaining
            [value "amountRemaining"]
        + currency
            [value "currency" meta "currencyScheme"]
        + velocity
            [value "velocity"]

    // TransferorTransferee:
    // + transferorPartyReference
    // [value "payerPartyReference" meta "href"]
    // + transfereePartyReference
    // [value "receiverPartyReference" meta "href"]
    MakeWholeAmount:
        + interpolationMethod
            [value "interpolationMethod"]
        + earlyCallDate
            [value "earlyCallDate" meta "id"]

    ReferenceSwapCurve:
        + swapUnwindValue
            [value "swapUnwindValue"]
        + makeWholeAmount
            [value "makeWholeAmount"]

    SwapCurveValuation:
        + floatingRateIndex
            [value "floatingRateIndex"]
        + indexTenor
            [value "indexTenor"]
        + spread
            [value "spread"]
        + side
            [value "side"]

    AdditionalFixedPayments:
        + interestShortfallReimbursement
            [value "interestShortfallReimbursement"]
        + principalShortfallReimbursement
            [value "principalShortfallReimbursement"]
        + writedownReimbursement
            [value "writedownReimbursement"]

    BasketReferenceInformation:
        + basketName
            [value "basketName" meta "basketNameScheme"]
            [value "basketName" path "underlyer->basket" meta "basketNameScheme"]
        + basketId
            [value "basketId" meta "basketIdScheme"]
            [value "id" path "underlyer->basket" meta "basketIdScheme"]
            [value "basketId" path "underlyer->basket" meta "basketIdScheme"]
        + referencePool
            [value "referencePool"]
            [hint "underlyer"]
        + nthToDefault
            [value "nthToDefault"]
        + mthToDefault
            [value "mthToDefault"]
        + tranche
            [value "tranche"]

    CreditIndex:
	 	[value "CreditIndex" meta "id"]
        + indexSeries
            [value "indexSeries"]
        + indexAnnexVersion
            [value "indexAnnexVersion"]
        + indexAnnexDate
            [value "indexAnnexDate"]
        + indexAnnexSource
            [value "indexAnnexSource" meta "indexAnnexSourceScheme"]
        + excludedReferenceEntity
            [value "excludedReferenceEntity"]
        + tranche
            [value "tranche"]
        + settledEntityMatrix
            [value "settledEntityMatrix"]
        + indexFactor
            [value "indexFactor"]
        + seniority
            [value "seniority"]
        + assetClass
            [set to AssetClassEnum -> Credit]

    InterestShortFall:
        + interestShortfallCap
            [value "interestShortfallCap"]
        + compounding
            [value "compounding"]
        + rateSource
            [value "rateSource"]

    LoanParticipation:
        + qualifyingParticipationSeller
            [value "qualifyingParticipationSeller"]

    MultipleValuationDates:
        + businessDaysThereafter
            [value "businessDaysThereafter"]
        + numberValuationDates
            [value "numberValuationDates"]

    PCDeliverableObligationCharac:
        + applicable
            [value "applicable"]
        + partialCashSettlement
            [value "partialCashSettlement"]

    PhysicalSettlementPeriod:
        + businessDaysNotSpecified
            [value "businessDaysNotSpecified"]
        + businessDays
            [value "businessDays"]
        + maximumBusinessDays
            [value "maximumBusinessDays"]

    SettledEntityMatrix:
        + matrixSource
            [value "matrixSource" meta "settledEntityMatrixSourceScheme"]
        + publicationDate
            [value "publicationDate"]

    SingleValuationDate:
        + businessDays
            [value "businessDays"]

    Tranche:
        + attachmentPoint
            [value "attachmentPoint"]
        + exhaustionPoint
            [value "exhaustionPoint"]
        + incurredRecoveryApplicable
            [value "incurredRecoveryApplicable"]

    ValuationDate:
        + singleValuationDate
            [value "singleValuationDate"]
        + multipleValuationDates
            [value "multipleValuationDates"]
        + fxFixingDate
            [hint "fixingDate"]
            [value "fxFixingDate"]
            [hint "rateSourceFixing"]
        + fxFixingSchedule
            [value "fxFixingSchedule"]

    FxRateSourceFixing:
        + settlementRateSource
            [value "settlementRateSource"]
        + fixingDate
            [value "fixingDate"]

    FxSettlementRateSource:
        + settlementRateOption
            [value "settlementRateOption"]

    CreditNotation:
        + agency
            [value "agency" meta "creditRatingAgencyScheme"]
        + notation
            [value "notation" meta "creditRatingNotationScheme"]
        + scale
            [value "scale" meta "creditRatingScaleScheme"]
        + debt
            [value "debt"]

    CreditNotations:
        + creditNotation
            [value "creditNotation"]

    CreditRatingDebt:
        + debtType
            [value "debtType" meta "debtTypeScheme"]

    LegalAgreement:
        + agreementTerms
            [value "ignore"]
        + relatedAgreements
            [value "ignore"]

    LegalAgreementBase:
        + agreementDate
            [value "agreementDate" path "legalDocumentHeader"]
        + effectiveDate
            [value "effectiveDate" path "legalDocumentHeader"]
        + identifier
            [value "partyDocumentIdentifier" path "legalDocumentHeader"]
        + contractualParty
            [value "party"]

    LegalAgreementIdentification:
        + governingLaw
            [value "style"]
        + publisher
            [value "publisher"]
        + vintage
            [value "version"]

    MultipleCreditNotations:
        + condition
            [value "condition"]
        + creditNotation
            [value "debtType" meta "creditNotation"]

    MultipleDebtTypes:
        + condition
            [value "condition"]
        + debtType
            [value "debtType" meta "debtTypeScheme"]

    UnitType:
        + capacityUnit
            [value "quantityUnit" maps 2]
            // For Commodity Swap Fixed Leg
            [value "priceUnit" maps 2 set when rosettaPath = PriceSchedule -> perUnitOf]
        + weatherUnit
            [value "quantityUnit" maps 2]
        // For Commodity Swap Fixed Leg
        // [value "priceUnit" set when rosettaPath = PriceSchedule->perUnitOfAmount]
        + financialUnit
            [value "quantityUnit" maps 2]
            [value "openUnits" mapper "OpenUnits"]
            [set to FinancialUnitEnum -> Weight when path = "basketPercentage"]
            [set to FinancialUnitEnum -> ContractualProduct when path = "bulletPayment->payment->paymentAmount->amount"]
        + currency
            [value "currency" maps 2 meta "currencyScheme"]
            [value "varyingNotionalCurrency" maps 2 meta "currencyScheme"]
            [value "currency1" maps 2 set when "quoteBasis" = "Currency1PerCurrency2" and rosettaPath = Price -> unit -> currency]
            [value "currency2" maps 2 set when "quoteBasis" = "Currency1PerCurrency2" and rosettaPath = Price -> perUnitOf -> currency]
            [value "currency2" maps 2 set when "quoteBasis" = "Currency2PerCurrency1" and rosettaPath = Price -> unit -> currency]
            [value "currency1" maps 2 set when "quoteBasis" = "Currency2PerCurrency1" and rosettaPath = Price -> perUnitOf -> currency]
            // For Commodity Swap Fixed Leg
            [value "priceCurrency" maps 2 set when rosettaPath = Price -> unit -> currency]
            // For Bond Option
            [value "entitlementCurrency" maps 2 meta "currencyScheme"]

    AveragingCalculationMethod:
        + calculationMethod
            [value "averagingMethod" path "calculation"]
            [value "averagingMethod"]
        + isWeighted
            [set to False when "calculation->averagingMethod" = "Unweighted"]
            [set to False when "averagingMethod" = "Unweighted"]
            [set to False when "calculation->averagingMethod" = "Arithmetic"]
            [set to False when "averagingMethod" = "Arithmetic"]
            [set to False when "calculation->averagingMethod" = "Geometric"]
            [set to False when "averagingMethod" = "Geometric"]
            [set to False when "calculation->averagingMethod" = "Harmonic"]
            [set to False when "averagingMethod" = "Harmonic"]
            [set to True when "calculation->averagingMethod" = "Weighted"]
            [set to True when "averagingMethod" = "Weighted"]

    FloatingRateCalculationParameters:
        + calculationMethod
            [value "calculationMethod"]
        + applicableBusinessDays
            [value "applicableBusinessDays"]
        + observationShiftCalculation
            [value "observationShift"]
        + lookbackCalculation
            [value "lookback"]
        + lockoutCalculation
            [value "lockout"]

    FallbackRateParameters:
        + floatingRateIndex
            [value "floatingRateIndex"]
        + effectiveDate
            [value "effectiveDate"]
        + calculationParameters
            [value "calculationParameters"]
        + spreadAdjustment
            [value "spreadAdjustment"]

    OffsetCalculation:
        + offsetDays
            [value "offsetDays"]

    ObservationShiftCalculation:
        + offsetDays
            [value "offsetDays"]
        + calculationBase
            [value "observationPeriodDates"]
        + additionalBusinessDays
            [value "additionalBusinessDays"]

    ObservationParameters:
        + observationCapRate
            [value "observationCapRate"]
        + observationFloorRate
            [value "observationFloorRate"]

    AncillaryEntity:
        + ancillaryParty
            [value "partyReference"]
        + legalEntity
            [hint "identifier"]

    CashCollateralValuationMethod:
        + applicableCsa
            [value "applicableCsa"]
        + cashCollateralCurrency
            [value "cashCollateralCurrency"]
        + cashCollateralInterestRate
            [value "cashCollateralInterestRate"]
        + agreedDiscountRate
            [value "agreedDiscountRate" meta "benchmarkRateScheme"]
        + protectedParty
            [value "partyDetermination" path "protectedParty"]
        + prescribedDocumentationAdjustment
            [value "prescribedDocumentationAdjustment"]

    enums

    AveragingWeightingMethodEnum:
        + Unweighted
            [value "Unweighted"]
            [value "Arithmetic"]
            [value "Geometric"]
            [value "Harmonic"]
        + Weighted
            [value "Weighted"]

    ExpirationTimeTypeEnum:
        + Close
            [value "Close"]
        + Open
            [value "Open"]
        + OSP
            [value "OSP"]
        + SpecificTime
            [value "SpecificTime"]
        + XETRA
            [value "XETRA"]
        + DerivativesClose
            [value "DerivativesClose"]
        + AsSpecifiedInMasterConfirmation
            [value "AsSpecifiedInMasterConfirmation"]

    RealisedVarianceMethodEnum:
        + Previous
            [value "Previous"]
        + Last
            [value "Last"]
        + Both
            [value "Both"]

    FPVFinalPriceElectionFallbackEnum:
        + FPVClose
            [value "FPVClose"]
        + FPVHedgeExecution
            [value "FPVHedgeExecution"]

    ObligationCategoryEnum:
        + Payment
            [value "Payment"]
        + BorrowedMoney
            [value "BorrowedMoney"]
        + ReferenceObligationsOnly
            [value "ReferenceObligationsOnly"]
        + Bond
            [value "Bond"]
        + Loan
            [value "Loan"]
        + BondOrLoan
            [value "BondOrLoan"]

    FloatingRateIndexEnum:
        + AED_EIBOR
            [value "AED-EIBOR"]
        + AED_EBOR_Reuters
            [value "AED-EBOR-Reuters"]
        + AUD_AONIA
            [value "AUD-AONIA"]
        + AUD_AONIA_OIS_Compound_1
            [value "AUD-AONIA-OIS Compound"]
        + AUD_AONIA_OIS_COMPOUND
            [value "AUD-AONIA-OIS-COMPOUND"]
        + AUD_AONIA_OIS_COMPOUND_SwapMarker
            [value "AUD-AONIA-OIS-COMPOUND-SwapMarker"]
        + AUD_BBR_AUBBSW
            [value "AUD-BBR-AUBBSW"]
        + AUD_BBR_BBSW
            [value "AUD-BBR-BBSW"]
        + AUD_BBR_BBSW_Bloomberg
            [value "AUD-BBR-BBSW-Bloomberg"]
        + AUD_BBR_BBSY__BID_
            [value "AUD-BBR-BBSY (BID)"]
        + AUD_BBR_ISDC
            [value "AUD-BBR-ISDC"]
        + AUD_BBSW
            [value "AUD-BBSW"]
        + AUD_BBSW_Quarterly_Swap_Rate_ICAP
            [value "AUD-BBSW Quarterly Swap Rate ICAP"]
        + AUD_BBSW_Semi_Annual_Swap_Rate_ICAP
            [value "AUD-BBSW Semi Annual Swap Rate ICAP"]
        + AUD_BBSY_Bid
            [value "AUD-BBSY Bid"]
        + AUD_LIBOR_BBA
            [value "AUD-LIBOR-BBA"]
        + AUD_LIBOR_BBA_Bloomberg
            [value "AUD-LIBOR-BBA-Bloomberg"]
        + AUD_LIBOR_Reference_Banks
            [value "AUD-LIBOR-Reference Banks"]
        + AUD_Quarterly_Swap_Rate_ICAP
            [value "AUD-Quarterly Swap Rate-ICAP"]
        + AUD_Quarterly_Swap_Rate_ICAP_Reference_Banks
            [value "AUD-Quarterly Swap Rate-ICAP-Reference Banks"]
        + AUD_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "AUD-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + AUD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks
            [value "AUD-Semi-Annual Swap Rate-BGCANTOR-Reference Banks"]
        + AUD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks
            [value "AUD-Semi-Annual Swap Rate-ICAP-Reference Banks"]
        + AUD_Semi_annual_Swap_Rate_ICAP
            [value "AUD-Semi-annual Swap Rate-ICAP"]
        + AUD_Swap_Rate_Reuters
            [value "AUD-Swap Rate-Reuters"]
        + BRL_CDI
            [value "BRL-CDI"]
        + CAD_BA_CDOR
            [value "CAD-BA-CDOR"]
        + CAD_BA_CDOR_Bloomberg
            [value "CAD-BA-CDOR-Bloomberg"]
        + CAD_BA_ISDD
            [value "CAD-BA-ISDD"]
        + CAD_BA_Reference_Banks
            [value "CAD-BA-Reference Banks"]
        + CAD_BA_Reuters
            [value "CAD-BA-Reuters"]
        + CAD_BA_Telerate
            [value "CAD-BA-Telerate"]
        + CAD_CDOR
            [value "CAD-CDOR"]
        + CAD_CORRA
            [value "CAD-CORRA"]
        + CAD_CORRA_CanDeal_TMX_Term
            [value "CAD-CORRA CanDeal TMX Term"]
        + CAD_CORRA_Compounded_Index
            [value "CAD-CORRA Compounded Index"]
        + CAD_CORRA_OIS_Compound_1
            [value "CAD-CORRA-OIS Compound"]
        + CAD_CORRA_OIS_COMPOUND
            [value "CAD-CORRA-OIS-COMPOUND"]
        + CAD_ISDA_Swap_Rate
            [value "CAD-ISDA-Swap Rate"]
        + CAD_LIBOR_BBA
            [value "CAD-LIBOR-BBA"]
        + CAD_LIBOR_BBA_Bloomberg
            [value "CAD-LIBOR-BBA-Bloomberg"]
        + CAD_LIBOR_BBA_SwapMarker
            [value "CAD-LIBOR-BBA-SwapMarker"]
        + CAD_LIBOR_Reference_Banks
            [value "CAD-LIBOR-Reference Banks"]
        + CAD_REPO_CORRA
            [value "CAD-REPO-CORRA"]
        + CAD_TBILL_ISDD
            [value "CAD-TBILL-ISDD"]
        + CAD_TBILL_Reference_Banks
            [value "CAD-TBILL-Reference Banks"]
        + CAD_TBILL_Reuters
            [value "CAD-TBILL-Reuters"]
        + CAD_TBILL_Telerate
            [value "CAD-TBILL-Telerate"]
        + CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP
            [value "CHF-3M LIBOR SWAP-CME vs LCH-ICAP"]
        + CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg
            [value "CHF-3M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg"]
        + CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP
            [value "CHF-3M LIBOR SWAP-EUREX vs LCH-ICAP"]
        + CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg
            [value "CHF-3M LIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg"]
        + CHF_6M_LIBORSWAP_CME_vs_LCH_ICAP_Bloomberg
            [value "CHF-6M LIBORSWAP-CME vs LCH-ICAP-Bloomberg"]
        + CHF_6M_LIBOR_SWAP_CME_vs_LCH_ICAP
            [value "CHF-6M LIBOR SWAP-CME vs LCH-ICAP"]
        + CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP
            [value "CHF-6M LIBOR SWAP-EUREX vs LCH-ICAP"]
        + CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg
            [value "CHF-6M LIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg"]
        + CHF_Annual_Swap_Rate
            [value "CHF-Annual Swap Rate"]
        + CHF_Annual_Swap_Rate_11_00_ICAP
            [value "CHF-Annual Swap Rate-11:00-ICAP"]
        + CHF_Annual_Swap_Rate_Reference_Banks
            [value "CHF-Annual Swap Rate-Reference Banks"]
        + CHF_Basis_Swap_3m_vs_6m_LIBOR_11_00_ICAP
            [value "CHF-Basis Swap-3m vs 6m-LIBOR-11:00-ICAP"]
        + CHF_ISDAFIX_Swap_Rate
            [value "CHF-ISDAFIX-Swap Rate"]
        + CHF_LIBOR
            [value "CHF-LIBOR"]
        + CHF_LIBOR_BBA
            [value "CHF-LIBOR-BBA"]
        + CHF_LIBOR_BBA_Bloomberg
            [value "CHF-LIBOR-BBA-Bloomberg"]
        + CHF_LIBOR_ISDA
            [value "CHF-LIBOR-ISDA"]
        + CHF_LIBOR_Reference_Banks
            [value "CHF-LIBOR-Reference Banks"]
        + CHF_OIS_11_00_ICAP
            [value "CHF-OIS-11:00-ICAP"]
        + CHF_SARON
            [value "CHF-SARON"]
        + CHF_SARON_Average_12M
            [value "CHF-SARON Average 12M"]
        + CHF_SARON_Average_1M
            [value "CHF-SARON Average 1M"]
        + CHF_SARON_Average_1W
            [value "CHF-SARON Average 1W"]
        + CHF_SARON_Average_2M
            [value "CHF-SARON Average 2M"]
        + CHF_SARON_Average_3M
            [value "CHF-SARON Average 3M"]
        + CHF_SARON_Average_6M
            [value "CHF-SARON Average 6M"]
        + CHF_SARON_Average_9M
            [value "CHF-SARON Average 9M"]
        + CHF_SARON_Compounded_Index
            [value "CHF-SARON Compounded Index"]
        + CHF_SARON_OIS_Compound_1
            [value "CHF-SARON-OIS Compound"]
        + CHF_SARON_OIS_COMPOUND
            [value "CHF-SARON-OIS-COMPOUND"]
        + CHF_TOIS_OIS_COMPOUND
            [value "CHF-TOIS-OIS-COMPOUND"]
        + CHF_USD_Basis_Swaps_11_00_ICAP
            [value "CHF USD-Basis Swaps-11:00-ICAP"]
        + CLP_ICP
            [value "CLP-ICP"]
        + CLP_TNA
            [value "CLP-TNA"]
        + CL_CLICP_Bloomberg
            [value "CL-CLICP-Bloomberg"]
        + CNH_HIBOR
            [value "CNH-HIBOR"]
        + CNH_HIBOR_Reference_Banks
            [value "CNH-HIBOR-Reference Banks"]
        + CNH_HIBOR_TMA
            [value "CNH-HIBOR-TMA"]
        + CNY_7_Repo_Compounding_Date
            [value "CNY 7-Repo Compounding Date"]
        + CNY_CNREPOFIX_CFXS_Reuters
            [value "CNY-CNREPOFIX=CFXS-Reuters"]
        + CNY_Deposit_Rate
            [value "CNY-Deposit Rate"]
        + CNY_Fixing_Repo_Rate
            [value "CNY-Fixing Repo Rate"]
        + CNY_LPR
            [value "CNY-LPR"]
        + CNY_PBOCB_Reuters
            [value "CNY-PBOCB-Reuters"]
        + CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION
            [value "CNY-Quarterly 7 day Repo Non Deliverable Swap Rate-TRADITION"]
        + CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION_Reference_Banks
            [value "CNY-Quarterly 7 day Repo Non Deliverable Swap Rate-TRADITION-Reference Banks"]
        + CNY_Quarterly_7D_Repo_NDS_Rate_Tradition
            [value "CNY-Quarterly 7D Repo NDS Rate Tradition"]
        + CNY_SHIBOR
            [value "CNY-SHIBOR"]
        + CNY_SHIBOR_OIS_Compound
            [value "CNY-SHIBOR-OIS Compound"]
        + CNY_Shibor_OIS_Compounding
            [value "CNY-Shibor-OIS-Compounding"]
        + CNY_SHIBOR_Reuters
            [value "CNY-SHIBOR-Reuters"]
        + CNY_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "CNY-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + CNY_Semi_Annual_Swap_Rate_Reference_Banks
            [value "CNY-Semi-Annual Swap Rate-Reference Banks"]
        + CNY_Shibor_OIS_Compounding
            [value "CNY-Shibor-OIS-Compounding"]
        + COP_IBR_OIS_COMPOUND
            [value "COP-IBR-OIS-COMPOUND"]
        + COP_IBR_OIS_Compound_1
            [value "COP-IBR-OIS Compound"]
        + CZK_Annual_Swap_Rate_11_00_BGCANTOR
            [value "CZK-Annual Swap Rate-11:00-BGCANTOR"]
        + CZK_Annual_Swap_Rate_Reference_Banks
            [value "CZK-Annual Swap Rate-Reference Banks"]
        + CZK_CZEONIA
            [value "CZK-CZEONIA"]
        + CZK_CZEONIA_OIS_Compound
            [value "CZK-CZEONIA-OIS Compound"]
        + CZK_PRIBOR
            [value "CZK-PRIBOR"]
        + CZK_PRIBOR_PRBO
            [value "CZK-PRIBOR-PRBO"]
        + CZK_PRIBOR_Reference_Banks
            [value "CZK-PRIBOR-Reference Banks"]
        + DKK_CIBOR
            [value "DKK-CIBOR"]
        + DKK_CIBOR2
            [value "DKK-CIBOR2"]
        + DKK_CIBOR2_Bloomberg
            [value "DKK-CIBOR2-Bloomberg"]
        + DKK_CIBOR2_DKNA13
            [value "DKK-CIBOR2-DKNA13"]
        + DKK_CIBOR_DKNA13
            [value "DKK-CIBOR-DKNA13"]
        + DKK_CIBOR_DKNA13_Bloomberg
            [value "DKK-CIBOR-DKNA13-Bloomberg"]
        + DKK_CIBOR_Reference_Banks
            [value "DKK-CIBOR-Reference Banks"]
        + DKK_CITA
            [value "DKK-CITA"]
        + DKK_CITA_DKNA14_COMPOUND
            [value "DKK-CITA-DKNA14-COMPOUND"]
        + DKK_DESTR
            [value "DKK-DESTR"]
        + DKK_DESTR_Compounded_Index
            [value "DKK-DESTR Compounded Index"]
        + DKK_DESTR_OIS_Compound
            [value "DKK-DESTR-OIS Compound"]
        + DKK_DKKOIS_OIS_COMPOUND
            [value "DKK-DKKOIS-OIS-COMPOUND"]
        + DKK_Tom_Next_OIS_Compound
            [value "DKK-Tom Next-OIS Compound"]
        + EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP
            [value "EUR-3M EURIBOR SWAP-CME vs LCH-ICAP"]
        + EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg
            [value "EUR-3M EURIBOR SWAP-CME vs LCH-ICAP-Bloomberg"]
        + EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP
            [value "EUR-3M EURIBOR SWAP-EUREX vs LCH-ICAP"]
        + EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg
            [value "EUR-3M EURIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg"]
        + EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP
            [value "EUR-6M EURIBOR SWAP-CME vs LCH-ICAP"]
        + EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg
            [value "EUR-6M EURIBOR SWAP-CME vs LCH-ICAP-Bloomberg"]
        + EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP
            [value "EUR-6M EURIBOR SWAP-EUREX vs LCH-ICAP"]
        + EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg
            [value "EUR-6M EURIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg"]
        + EUR_Annual_Swap_Rate_10_00
            [value "EUR-Annual Swap Rate-10:00"]
        + EUR_Annual_Swap_Rate_10_00_BGCANTOR
            [value "EUR-Annual Swap Rate-10:00-BGCANTOR"]
        + EUR_Annual_Swap_Rate_10_00_Bloomberg
            [value "EUR-Annual Swap Rate-10:00-Bloomberg"]
        + EUR_Annual_Swap_Rate_10_00_ICAP
            [value "EUR-Annual Swap Rate-10:00-ICAP"]
        + EUR_Annual_Swap_Rate_10_00_SwapMarker
            [value "EUR-Annual Swap Rate-10:00-SwapMarker"]
        + EUR_Annual_Swap_Rate_10_00_TRADITION
            [value "EUR-Annual Swap Rate-10:00-TRADITION"]
        + EUR_Annual_Swap_Rate_11_00
            [value "EUR-Annual Swap Rate-11:00"]
        + EUR_Annual_Swap_Rate_11_00_Bloomberg
            [value "EUR-Annual Swap Rate-11:00-Bloomberg"]
        + EUR_Annual_Swap_Rate_11_00_ICAP
            [value "EUR-Annual Swap Rate-11:00-ICAP"]
        + EUR_Annual_Swap_Rate_11_00_SwapMarker
            [value "EUR-Annual Swap Rate-11:00-SwapMarker"]
        + EUR_Annual_Swap_Rate_3_Month
            [value "EUR-Annual Swap Rate-3 Month"]
        + EUR_Annual_Swap_Rate_3_Month_SwapMarker
            [value "EUR-Annual Swap Rate-3 Month-SwapMarker"]
        + EUR_Annual_Swap_Rate_4_15_TRADITION
            [value "EUR-Annual Swap Rate-4:15-TRADITION"]
        + EUR_Annual_Swap_Rate_Reference_Banks
            [value "EUR-Annual Swap Rate-Reference Banks"]
        + EUR_Basis_Swap_EONIA_vs_3m_EUR_IBOR_Swap_Rates_A_360_10_00_ICAP
            [value "EUR Basis Swap-EONIA vs 3m EUR+IBOR Swap Rates-A/360-10:00-ICAP"]
        + EUR_CNO_TEC10
            [value "EUR-CNO TEC10"]
        + EUR_EONIA
            [value "EUR-EONIA"]
        + EUR_EONIA_AVERAGE_1
            [value "EUR-EONIA-AVERAGE"]
        + EUR_EONIA_Average
            [value "EUR-EONIA-Average"]
        + EUR_EONIA_OIS_10_00_BGCANTOR
            [value "EUR-EONIA-OIS-10:00-BGCANTOR"]
        + EUR_EONIA_OIS_10_00_ICAP
            [value "EUR-EONIA-OIS-10:00-ICAP"]
        + EUR_EONIA_OIS_10_00_TRADITION
            [value "EUR-EONIA-OIS-10:00-TRADITION"]
        + EUR_EONIA_OIS_11_00_ICAP
            [value "EUR-EONIA-OIS-11:00-ICAP"]
        + EUR_EONIA_OIS_4_15_TRADITION
            [value "EUR-EONIA-OIS-4:15-TRADITION"]
        + EUR_EONIA_OIS_Compound_1
            [value "EUR-EONIA-OIS Compound"]
        + EUR_EONIA_OIS_COMPOUND
            [value "EUR-EONIA-OIS-COMPOUND"]
        + EUR_EONIA_OIS_COMPOUND_Bloomberg
            [value "EUR-EONIA-OIS-COMPOUND-Bloomberg"]
        + EUR_EONIA_Swap_Index
            [value "EUR-EONIA-Swap-Index"]
        + EUR_EURIBOR
            [value "EUR-EURIBOR"]
        + EUR_EURIBOR_Act_365
            [value "EUR-EURIBOR-Act/365"]
        + EUR_EURIBOR_Act_365_Bloomberg
            [value "EUR-EURIBOR-Act/365-Bloomberg"]
        + EUR_EURIBOR_Annual_Bond_Swap_vs_1m_11_00_ICAP
            [value "EUR EURIBOR-Annual Bond Swap vs 1m-11:00-ICAP"]
        + EUR_EURIBOR_Basis_Swap_1m_vs_3m_Euribor_11_00_ICAP
            [value "EUR EURIBOR-Basis Swap-1m vs 3m-Euribor-11:00-ICAP"]
        + EUR_EURIBOR_Basis_Swap_3m_vs_6m_11_00_ICAP
            [value "EUR EURIBOR-Basis Swap-3m vs 6m-11:00-ICAP"]
        + EUR_EURIBOR_ICE_Swap_Rate_11_00
            [value "EUR-EURIBOR ICE Swap Rate-11:00"]
        + EUR_EURIBOR_ICE_Swap_Rate_12_00
            [value "EUR-EURIBOR ICE Swap Rate-12:00"]
        + EUR_EURIBOR_Reference_Banks
            [value "EUR-EURIBOR-Reference Banks"]
        + EUR_EURIBOR_Reuters
            [value "EUR-EURIBOR-Reuters"]
        + EUR_EURIBOR_Telerate
            [value "EUR-EURIBOR-Telerate"]
        + EUR_EURONIA_OIS_COMPOUND
            [value "EUR-EURONIA-OIS-COMPOUND"]
        + EUR_EURONIA_OIS_Compound_1
            [value "EUR-EURONIA-OIS Compound"]
        + EUR_EuroSTR
            [value "EUR-EuroSTR"]
        + EUR_EuroSTR_Average_12M
            [value "EUR-EuroSTR Average 12M"]
        + EUR_EuroSTR_Average_1M
            [value "EUR-EuroSTR Average 1M"]
        + EUR_EuroSTR_Average_1W
            [value "EUR-EuroSTR Average 1W"]
        + EUR_EuroSTR_Average_3M
            [value "EUR-EuroSTR Average 3M"]
        + EUR_EuroSTR_Average_6M
            [value "EUR-EuroSTR Average 6M"]
        + EUR_EuroSTR_COMPOUND
            [value "EUR-EuroSTR-COMPOUND"]
        + EUR_EuroSTR_Compounded_Index
            [value "EUR-EuroSTR Compounded Index"]
        + EUR_EuroSTR_FTSE_Term
            [value "EUR-EuroSTR FTSE Term"]
        + EUR_EuroSTR_ICE_Compounded_Index
            [value "EUR-EuroSTR ICE Compounded Index"]
        + EUR_EuroSTR_ICE_Compounded_Index_0_Floor
            [value "EUR-EuroSTR ICE Compounded Index 0 Floor"]
        + EUR_EuroSTR_ICE_Compounded_Index_0_Floor_2D_Lag
            [value "EUR-EuroSTR ICE Compounded Index 0 Floor 2D Lag"]
        + EUR_EuroSTR_ICE_Compounded_Index_0_Floor_5D_Lag
            [value "EUR-EuroSTR ICE Compounded Index 0 Floor 5D Lag"]
        + EUR_EuroSTR_ICE_Compounded_Index_2D_Lag
            [value "EUR-EuroSTR ICE Compounded Index 2D Lag"]
        + EUR_EuroSTR_ICE_Compounded_Index_5D_Lag
            [value "EUR-EuroSTR ICE Compounded Index 5D Lag"]
        + EUR_EuroSTR_OIS_Compound
            [value "EUR-EuroSTR-OIS Compound"]
        + EUR_EuroSTR_Term
            [value "EUR-EuroSTR Term"]
        + EUR_ISDA_EURIBOR_Swap_Rate_11_00
            [value "EUR-ISDA-EURIBOR Swap Rate-11:00"]
        + EUR_ISDA_EURIBOR_Swap_Rate_12_00
            [value "EUR-ISDA-EURIBOR Swap Rate-12:00"]
        + EUR_ISDA_LIBOR_Swap_Rate_10_00
            [value "EUR-ISDA-LIBOR Swap Rate-10:00"]
        + EUR_ISDA_LIBOR_Swap_Rate_11_00
            [value "EUR-ISDA-LIBOR Swap Rate-11:00"]
        + EUR_LIBOR
            [value "EUR-LIBOR"]
        + EUR_LIBOR_BBA
            [value "EUR-LIBOR-BBA"]
        + EUR_LIBOR_BBA_Bloomberg
            [value "EUR-LIBOR-BBA-Bloomberg"]
        + EUR_LIBOR_Reference_Banks
            [value "EUR-LIBOR-Reference Banks"]
        + EUR_TAM_CDC
            [value "EUR-TAM-CDC"]
        + EUR_TEC10_CNO
            [value "EUR-TEC10-CNO"]
        + EUR_TEC10_CNO_SwapMarker
            [value "EUR-TEC10-CNO-SwapMarker"]
        + EUR_TEC10_Reference_Banks
            [value "EUR-TEC10-Reference Banks"]
        + EUR_TEC5_CNO
            [value "EUR-TEC5-CNO"]
        + EUR_TEC5_CNO_SwapMarker
            [value "EUR-TEC5-CNO-SwapMarker"]
        + EUR_TEC5_Reference_Banks
            [value "EUR-TEC5-Reference Banks"]
        + EUR_TMM_CDC_COMPOUND
            [value "EUR-TMM-CDC-COMPOUND"]
        + EUR_USD_Basis_Swaps_11_00_ICAP
            [value "EUR USD-Basis Swaps-11:00-ICAP"]
        + GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP
            [value "GBP-6M LIBOR SWAP-CME vs LCH-ICAP"]
        + GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg
            [value "GBP-6M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg"]
        + GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP
            [value "GBP-6M LIBOR SWAP-EUREX vs LCH-ICAP"]
        + GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg
            [value "GBP-6M LIBOR SWAP-EUREX vs LCH-ICAP-Bloomberg"]
        + GBP_ISDA_Swap_Rate
            [value "GBP-ISDA-Swap Rate"]
        + GBP_LIBOR
            [value "GBP-LIBOR"]
        + GBP_LIBOR_BBA
            [value "GBP-LIBOR-BBA"]
        + GBP_LIBOR_BBA_Bloomberg
            [value "GBP-LIBOR-BBA-Bloomberg"]
        + GBP_LIBOR_ICE_Swap_Rate
            [value "GBP-LIBOR ICE Swap Rate"]
        + GBP_LIBOR_ISDA
            [value "GBP-LIBOR-ISDA"]
        + GBP_LIBOR_Reference_Banks
            [value "GBP-LIBOR-Reference Banks"]
        + GBP_RONIA
            [value "GBP-RONIA"]
        + GBP_RONIA_OIS_Compound
            [value "GBP-RONIA-OIS Compound"]
        + GBP_SONIA
            [value "GBP-SONIA"]
        + GBP_SONIA_COMPOUND
            [value "GBP-SONIA-COMPOUND"]
        + GBP_SONIA_Compounded_Index
            [value "GBP-SONIA Compounded Index"]
        + GBP_SONIA_FTSE_Term
            [value "GBP-SONIA FTSE Term"]
        + GBP_SONIA_ICE_Compounded_Index
            [value "GBP-SONIA ICE Compounded Index"]
        + GBP_SONIA_ICE_Compounded_Index_0_Floor
            [value "GBP-SONIA ICE Compounded Index 0 Floor"]
        + GBP_SONIA_ICE_Compounded_Index_0_Floor_2D_Lag
            [value "GBP-SONIA ICE Compounded Index 0 Floor 2D Lag"]
        + GBP_SONIA_ICE_Compounded_Index_0_Floor_5D_Lag
            [value "GBP-SONIA ICE Compounded Index 0 Floor 5D Lag"]
        + GBP_SONIA_ICE_Compounded_Index_2D_Lag
            [value "GBP-SONIA ICE Compounded Index 2D Lag"]
        + GBP_SONIA_ICE_Compounded_Index_5D_Lag
            [value "GBP-SONIA ICE Compounded Index 5D Lag"]
        + GBP_SONIA_ICE_Swap_Rate
            [value "GBP-SONIA ICE Swap Rate"]
        + GBP_SONIA_ICE_Term
            [value "GBP-SONIA ICE Term"]
        + GBP_SONIA_OIS_11_00_ICAP
            [value "GBP-SONIA-OIS-11:00-ICAP"]
        + GBP_SONIA_OIS_11_00_TRADITION
            [value "GBP-SONIA-OIS-11:00-TRADITION"]
        + GBP_SONIA_OIS_4_15_TRADITION
            [value "GBP-SONIA-OIS-4:15-TRADITION"]
        + GBP_SONIA_OIS_Compound
            [value "GBP-SONIA-OIS Compound"]
        + GBP_SONIA_Swap_Rate
            [value "GBP-SONIA Swap Rate"]
        + GBP_Semi_Annual_Swap_Rate
            [value "GBP-Semi-Annual Swap Rate"]
        + GBP_Semi_Annual_Swap_Rate_11_00_ICAP
            [value "GBP-Semi-Annual Swap Rate-11:00-ICAP"]
        + GBP_Semi_Annual_Swap_Rate_11_00_TRADITION
            [value "GBP-Semi Annual Swap Rate-11:00-TRADITION"]
        + GBP_Semi_Annual_Swap_Rate_4_15_TRADITION
            [value "GBP-Semi Annual Swap Rate-4:15-TRADITION"]
        + GBP_Semi_Annual_Swap_Rate_Reference_Banks
            [value "GBP-Semi-Annual Swap Rate-Reference Banks"]
        + GBP_Semi_Annual_Swap_Rate_SwapMarker26
            [value "GBP-Semi-Annual Swap Rate-SwapMarker26"]
        + GBP_UK_Base_Rate
            [value "GBP-UK Base Rate"]
        + GBP_USD_Basis_Swaps_11_00_ICAP
            [value "GBP USD-Basis Swaps-11:00-ICAP"]
        + GBP_WMBA_RONIA_COMPOUND
            [value "GBP-WMBA-RONIA-COMPOUND"]
        + GBP_WMBA_SONIA_COMPOUND
            [value "GBP-WMBA-SONIA-COMPOUND"]
        + GRD_ATHIBOR_ATHIBOR
            [value "GRD-ATHIBOR-ATHIBOR"]
        + GRD_ATHIBOR_Reference_Banks
            [value "GRD-ATHIBOR-Reference Banks"]
        + GRD_ATHIBOR_Telerate
            [value "GRD-ATHIBOR-Telerate"]
        + GRD_ATHIMID_Reference_Banks
            [value "GRD-ATHIMID-Reference Banks"]
        + GRD_ATHIMID_Reuters
            [value "GRD-ATHIMID-Reuters"]
        + HKD_HIBOR
            [value "HKD-HIBOR"]
        + HKD_HIBOR_HIBOR_
            [value "HKD-HIBOR-HIBOR="]
        + HKD_HIBOR_HIBOR_Bloomberg
            [value "HKD-HIBOR-HIBOR-Bloomberg"]
        + HKD_HIBOR_HKAB
            [value "HKD-HIBOR-HKAB"]
        + HKD_HIBOR_HKAB_Bloomberg
            [value "HKD-HIBOR-HKAB-Bloomberg"]
        + HKD_HIBOR_ISDC
            [value "HKD-HIBOR-ISDC"]
        + HKD_HIBOR_Reference_Banks
            [value "HKD-HIBOR-Reference Banks"]
        + HKD_HONIA
            [value "HKD-HONIA"]
        + HKD_HONIA_OIS_Compound
            [value "HKD-HONIA-OIS Compound"]
        + HKD_HONIX_OIS_COMPOUND
            [value "HKD-HONIX-OIS-COMPOUND"]
        + HKD_ISDA_Swap_Rate_11_00
            [value "HKD-ISDA-Swap Rate-11:00"]
        + HKD_ISDA_Swap_Rate_4_00
            [value "HKD-ISDA-Swap Rate-4:00"]
        + HKD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR
            [value "HKD-Quarterly-Annual Swap Rate-11:00-BGCANTOR"]
        + HKD_Quarterly_Annual_Swap_Rate_11_00_TRADITION
            [value "HKD-Quarterly-Annual Swap Rate-11:00-TRADITION"]
        + HKD_Quarterly_Annual_Swap_Rate_4_00_BGCANTOR
            [value "HKD-Quarterly-Annual Swap Rate-4:00-BGCANTOR"]
        + HKD_Quarterly_Annual_Swap_Rate_Reference_Banks
            [value "HKD-Quarterly-Annual Swap Rate-Reference Banks"]
        + HKD_Quarterly_Quarterly_Swap_Rate_11_00_ICAP
            [value "HKD-Quarterly-Quarterly Swap Rate-11:00-ICAP"]
        + HKD_Quarterly_Quarterly_Swap_Rate_4_00_ICAP
            [value "HKD-Quarterly-Quarterly Swap Rate-4:00-ICAP"]
        + HKD_Quarterly_Quarterly_Swap_Rate_Reference_Banks
            [value "HKD-Quarterly-Quarterly Swap Rate-Reference Banks"]
        + HUF_BUBOR
            [value "HUF-BUBOR"]
        + HUF_BUBOR_Reference_Banks
            [value "HUF-BUBOR-Reference Banks"]
        + HUF_BUBOR_Reuters
            [value "HUF-BUBOR-Reuters"]
        + HUF_HUFONIA
            [value "HUF-HUFONIA"]
        + HUF_HUFONIA_OIS_Compound
            [value "HUF-HUFONIA-OIS Compound"]
        + IDR_IDMA_Bloomberg
            [value "IDR-IDMA-Bloomberg"]
        + IDR_IDRFIX
            [value "IDR-IDRFIX"]
        + IDR_JIBOR
            [value "IDR-JIBOR"]
        + IDR_JIBOR_Reuters
            [value "IDR-JIBOR-Reuters"]
        + IDR_SBI_Reuters
            [value "IDR-SBI-Reuters"]
        + IDR_SOR_Reference_Banks
            [value "IDR-SOR-Reference Banks"]
        + IDR_SOR_Reuters
            [value "IDR-SOR-Reuters"]
        + IDR_SOR_Telerate
            [value "IDR-SOR-Telerate"]
        + IDR_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "IDR-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + IDR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon
            [value "IDR-Semi Annual Swap Rate-Non-deliverable-16:00-Tullett Prebon"]
        + IDR_Semi_Annual_Swap_Rate_Reference_Banks
            [value "IDR-Semi-Annual Swap Rate-Reference Banks"]
        + ILS_SHIR
            [value "ILS-SHIR"]
        + ILS_SHIR_OIS_Compound
            [value "ILS-SHIR-OIS Compound"]
        + ILS_TELBOR
            [value "ILS-TELBOR"]
        + ILS_TELBOR01_Reuters
            [value "ILS-TELBOR01-Reuters"]
        + ILS_TELBOR_Reference_Banks
            [value "ILS-TELBOR-Reference Banks"]
        + INR_BMK
            [value "INR-BMK"]
        + INR_CMT
            [value "INR-CMT"]
        + INR_FBIL_MIBOR_OIS_COMPOUND
            [value "INR-FBIL-MIBOR-OIS-COMPOUND"]
        + INR_INBMK_REUTERS
            [value "INR-INBMK-REUTERS"]
        + INR_MIBOR_OIS
            [value "INR-MIBOR OIS"]
        + INR_MIBOR_OIS_Compound_1
            [value "INR-MIBOR-OIS Compound"]
        + INR_MIBOR_OIS_COMPOUND
            [value "INR-MIBOR-OIS-COMPOUND"]
        + INR_MIFOR
            [value "INR-MIFOR"]
        + INR_MIOIS
            [value "INR-MIOIS"]
        + INR_MITOR_OIS_COMPOUND
            [value "INR-MITOR-OIS-COMPOUND"]
        + INR_Modified_MIFOR
            [value "INR-Modified MIFOR"]
        + INR_Reference_Banks
            [value "INR-Reference Banks"]
        + INR_Semi_Annual_Swap_Rate_11_30_BGCANTOR
            [value "INR-Semi-Annual Swap Rate-11:30-BGCANTOR"]
        + INR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon
            [value "INR-Semi Annual Swap Rate-Non-deliverable-16:00-Tullett Prebon"]
        + INR_Semi_Annual_Swap_Rate_Reference_Banks
            [value "INR-Semi-Annual Swap Rate-Reference Banks"]
        + ISK_REIBOR
            [value "ISK-REIBOR"]
        + ISK_REIBOR_Reference_Banks
            [value "ISK-REIBOR-Reference Banks"]
        + ISK_REIBOR_Reuters
            [value "ISK-REIBOR-Reuters"]
        + JPY_Annual_Swap_Rate_11_00_TRADITION
            [value "JPY-Annual Swap Rate-11:00-TRADITION"]
        + JPY_Annual_Swap_Rate_3_00_TRADITION
            [value "JPY-Annual Swap Rate-3:00-TRADITION"]
        + JPY_BBSF_Bloomberg_10_00
            [value "JPY-BBSF-Bloomberg-10:00"]
        + JPY_BBSF_Bloomberg_15_00
            [value "JPY-BBSF-Bloomberg-15:00"]
        + JPY_Euroyen_TIBOR
            [value "JPY-Euroyen TIBOR"]
        + JPY_ISDA_Swap_Rate_10_00
            [value "JPY-ISDA-Swap Rate-10:00"]
        + JPY_ISDA_Swap_Rate_15_00
            [value "JPY-ISDA-Swap Rate-15:00"]
        + JPY_LIBOR
            [value "JPY-LIBOR"]
        + JPY_LIBOR_BBA
            [value "JPY-LIBOR-BBA"]
        + JPY_LIBOR_BBA_Bloomberg
            [value "JPY-LIBOR-BBA-Bloomberg"]
        + JPY_LIBOR_FRASETT
            [value "JPY-LIBOR-FRASETT"]
        + JPY_LIBOR_ISDA
            [value "JPY-LIBOR-ISDA"]
        + JPY_LIBOR_Reference_Banks
            [value "JPY-LIBOR-Reference Banks"]
        + JPY_LIBOR_TSR_10_00
            [value "JPY-LIBOR TSR-10:00"]
        + JPY_LIBOR_TSR_15_00
            [value "JPY-LIBOR TSR-15:00"]
        + JPY_LTPR_MHBK
            [value "JPY-LTPR MHBK"]
        + JPY_LTPR_MHCB
            [value "JPY-LTPR-MHCB"]
        + JPY_LTPR_TBC
            [value "JPY-LTPR-TBC"]
        + JPY_MUTANCALL_TONAR
            [value "JPY-MUTANCALL-TONAR"]
        + JPY_OIS_11_00_ICAP
            [value "JPY-OIS-11:00-ICAP"]
        + JPY_OIS_11_00_TRADITION
            [value "JPY-OIS-11:00-TRADITION"]
        + JPY_OIS_3_00_TRADITION
            [value "JPY-OIS-3:00-TRADITION"]
        + JPY_Quoting_Banks_LIBOR
            [value "JPY-Quoting Banks-LIBOR"]
        + JPY_STPR_Quoting_Banks
            [value "JPY-STPR-Quoting Banks"]
        + JPY_TIBOR
            [value "JPY-TIBOR"]
        + JPY_TIBOR_17096
            [value "JPY-TIBOR-17096"]
        + JPY_TIBOR_17097
            [value "JPY-TIBOR-17097"]
        + JPY_TIBOR_DTIBOR01
            [value "JPY-TIBOR-DTIBOR01"]
        + JPY_TIBOR_TIBM
            [value "JPY-TIBOR-TIBM"]
        + JPY_TIBOR_TIBM_Reference_Banks
            [value "JPY-TIBOR-TIBM-Reference Banks"]
        + JPY_TIBOR_TIBM__10_Banks_
            [value "JPY-TIBOR-TIBM (10 Banks)"]
        + JPY_TIBOR_TIBM__5_Banks_
            [value "JPY-TIBOR-TIBM (5 Banks)"]
        + JPY_TIBOR_TIBM__All_Banks_
            [value "JPY-TIBOR-TIBM (All Banks)"]
        + JPY_TIBOR_TIBM__All_Banks__Bloomberg
            [value "JPY-TIBOR-TIBM (All Banks)-Bloomberg"]
        + JPY_TIBOR_ZTIBOR
            [value "JPY-TIBOR-ZTIBOR"]
        + JPY_TONA
            [value "JPY-TONA"]
        + JPY_TONA_Average_180D
            [value "JPY-TONA Average 180D"]
        + JPY_TONA_Average_30D
            [value "JPY-TONA Average 30D"]
        + JPY_TONA_Average_90D
            [value "JPY-TONA Average 90D"]
        + JPY_TONA_Compounded_Index
            [value "JPY-TONA Compounded Index"]
        + JPY_TONA_ICE_Compounded_Index
            [value "JPY-TONA ICE Compounded Index"]
        + JPY_TONA_ICE_Compounded_Index_0_Floor
            [value "JPY-TONA ICE Compounded Index 0 Floor"]
        + JPY_TONA_ICE_Compounded_Index_0_Floor_2D_Lag
            [value "JPY-TONA ICE Compounded Index 0 Floor 2D Lag"]
        + JPY_TONA_ICE_Compounded_Index_0_Floor_5D_Lag
            [value "JPY-TONA ICE Compounded Index 0 Floor 5D Lag"]
        + JPY_TONA_ICE_Compounded_Index_2D_Lag
            [value "JPY-TONA ICE Compounded Index 2D Lag"]
        + JPY_TONA_ICE_Compounded_Index_5D_Lag
            [value "JPY-TONA ICE Compounded Index 5D Lag"]
        + JPY_TONA_OIS_Compound_1
            [value "JPY-TONA-OIS Compound"]
        + JPY_TONA_OIS_COMPOUND
            [value "JPY-TONA-OIS-COMPOUND"]
        + JPY_TONA_TSR_10_00
            [value "JPY-TONA TSR-10:00"]
        + JPY_TONA_TSR_15_00
            [value "JPY-TONA TSR-15:00"]
        + JPY_TORF_QUICK
            [value "JPY-TORF QUICK"]
        + JPY_TSR_Reference_Banks
            [value "JPY-TSR-Reference Banks"]
        + JPY_TSR_Reuters_10_00
            [value "JPY-TSR-Reuters-10:00"]
        + JPY_TSR_Reuters_15_00
            [value "JPY-TSR-Reuters-15:00"]
        + JPY_TSR_Telerate_10_00
            [value "JPY-TSR-Telerate-10:00"]
        + JPY_TSR_Telerate_15_00
            [value "JPY-TSR-Telerate-15:00"]
        + JPY_USD_Basis_Swaps_11_00_ICAP
            [value "JPY USD-Basis Swaps-11:00-ICAP"]
        + KRW_Bond_3222
            [value "KRW-Bond-3222"]
        + KRW_CD_3220
            [value "KRW-CD-3220"]
        + KRW_CD_91D
            [value "KRW-CD 91D"]
        + KRW_CD_KSDA_Bloomberg
            [value "KRW-CD-KSDA-Bloomberg"]
        + KRW_KOFR
            [value "KRW-KOFR"]
        + KRW_KOFR_OIS_Compound
            [value "KRW-KOFR-OIS Compound"]
        + KRW_Quarterly_Annual_Swap_Rate_3_30_ICAP
            [value "KRW-Quarterly Annual Swap Rate-3:30-ICAP"]
        + MXN_TIIE
            [value "MXN-TIIE"]
        + MXN_TIIE_Banxico
            [value "MXN-TIIE-Banxico"]
        + MXN_TIIE_Banxico_Bloomberg
            [value "MXN-TIIE-Banxico-Bloomberg"]
        + MXN_TIIE_Banxico_Reference_Banks
            [value "MXN-TIIE-Banxico-Reference Banks"]
        + MXN_TIIE_ON
            [value "MXN-TIIE ON"]
        + MXN_TIIE_ON_OIS_Compound
            [value "MXN-TIIE ON-OIS Compound"]
        + MXN_TIIE_Reference_Banks
            [value "MXN-TIIE-Reference Banks"]
        + MYR_KLIBOR
            [value "MYR-KLIBOR"]
        + MYR_KLIBOR_BNM
            [value "MYR-KLIBOR-BNM"]
        + MYR_KLIBOR_Reference_Banks
            [value "MYR-KLIBOR-Reference Banks"]
        + MYR_MYOR
            [value "MYR-MYOR"]
        + MYR_MYOR_OIS_Compound
            [value "MYR-MYOR-OIS Compound"]
        + MYR_Quarterly_Swap_Rate_11_00_TRADITION
            [value "MYR-Quarterly Swap Rate-11:00-TRADITION"]
        + MYR_Quarterly_Swap_Rate_TRADITION_Reference_Banks
            [value "MYR-Quarterly Swap Rate-TRADITION-Reference Banks"]
        + NOK_NIBOR
            [value "NOK-NIBOR"]
        + NOK_NIBOR_NIBR
            [value "NOK-NIBOR-NIBR"]
        + NOK_NIBOR_NIBR_Bloomberg
            [value "NOK-NIBOR-NIBR-Bloomberg"]
        + NOK_NIBOR_NIBR_Reference_Banks
            [value "NOK-NIBOR-NIBR-Reference Banks"]
        + NOK_NIBOR_OIBOR
            [value "NOK-NIBOR-OIBOR"]
        + NOK_NIBOR_Reference_Banks
            [value "NOK-NIBOR-Reference Banks"]
        + NOK_NOWA
            [value "NOK-NOWA"]
        + NOK_NOWA_OIS_Compound
            [value "NOK-NOWA-OIS Compound"]
        + NZD_BBR_BID
            [value "NZD-BBR-BID"]
        + NZD_BBR_FRA
            [value "NZD-BBR-FRA"]
        + NZD_BBR_ISDC
            [value "NZD-BBR-ISDC"]
        + NZD_BBR_Reference_Banks
            [value "NZD-BBR-Reference Banks"]
        + NZD_BBR_Telerate
            [value "NZD-BBR-Telerate"]
        + NZD_BKBM_Bid
            [value "NZD-BKBM Bid"]
        + NZD_BKBM_FRA
            [value "NZD-BKBM FRA"]
        + NZD_BKBM_FRA_Swap_Rate_ICAP
            [value "NZD-BKBM FRA Swap Rate ICAP"]
        + NZD_NZIONA
            [value "NZD-NZIONA"]
        + NZD_NZIONA_OIS_Compound_1
            [value "NZD-NZIONA-OIS Compound"]
        + NZD_NZIONA_OIS_COMPOUND
            [value "NZD-NZIONA-OIS-COMPOUND"]
        + NZD_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "NZD-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + NZD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks
            [value "NZD-Semi-Annual Swap Rate-BGCANTOR-Reference Banks"]
        + NZD_Swap_Rate_ICAP
            [value "NZD-Swap Rate-ICAP"]
        + NZD_Swap_Rate_ICAP_Reference_Banks
            [value "NZD-Swap Rate-ICAP-Reference Banks"]
        + PHP_PHIREF
            [value "PHP-PHIREF"]
        + PHP_PHIREF_BAP
            [value "PHP-PHIREF-BAP"]
        + PHP_PHIREF_Bloomberg
            [value "PHP-PHIREF-Bloomberg"]
        + PHP_PHIREF_Reference_Banks
            [value "PHP-PHIREF-Reference Banks"]
        + PHP_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "PHP-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + PHP_Semi_Annual_Swap_Rate_Reference_Banks
            [value "PHP-Semi-Annual Swap Rate-Reference Banks"]
        + PLN_POLONIA
            [value "PLN-POLONIA"]
        + PLN_POLONIA_OIS_Compound_1
            [value "PLN-POLONIA-OIS Compound"]
        + PLN_POLONIA_OIS_COMPOUND
            [value "PLN-POLONIA-OIS-COMPOUND"]
        + PLN_WIBID
            [value "PLN-WIBID"]
        + PLN_WIBOR
            [value "PLN-WIBOR"]
        + PLN_WIBOR_Reference_Banks
            [value "PLN-WIBOR-Reference Banks"]
        + PLN_WIBOR_WIBO
            [value "PLN-WIBOR-WIBO"]
        + PLN_WIRON
            [value "PLN-WIRON"]
        + PLN_WIRON_OIS_Compound
            [value "PLN-WIRON-OIS Compound"]
        + PLZ_WIBOR_Reference_Banks
            [value "PLZ-WIBOR-Reference Banks"]
        + PLZ_WIBOR_WIBO
            [value "PLZ-WIBOR-WIBO"]
        + REPOFUNDS_RATE_FRANCE_OIS_COMPOUND
            [value "REPOFUNDS RATE-FRANCE-OIS-COMPOUND"]
        + REPOFUNDS_RATE_GERMANY_OIS_COMPOUND
            [value "REPOFUNDS RATE-GERMANY-OIS-COMPOUND"]
        + REPOFUNDS_RATE_ITALY_OIS_COMPOUND
            [value "REPOFUNDS RATE-ITALY-OIS-COMPOUND"]
        + RON_Annual_Swap_Rate_11_00_BGCANTOR
            [value "RON-Annual Swap Rate-11:00-BGCANTOR"]
        + RON_Annual_Swap_Rate_Reference_Banks
            [value "RON-Annual Swap Rate-Reference Banks"]
        + RON_RBOR_Reuters
            [value "RON-RBOR-Reuters"]
        + RON_ROBID
            [value "RON-ROBID"]
        + RON_ROBOR
            [value "RON-ROBOR"]
        + RUB_Annual_Swap_Rate_11_00_BGCANTOR
            [value "RUB-Annual Swap Rate-11:00-BGCANTOR"]
        + RUB_Annual_Swap_Rate_12_45_TRADITION
            [value "RUB-Annual Swap Rate-12:45-TRADITION"]
        + RUB_Annual_Swap_Rate_4_15_TRADITION
            [value "RUB-Annual Swap Rate-4:15-TRADITION"]
        + RUB_Annual_Swap_Rate_Reference_Banks
            [value "RUB-Annual Swap Rate-Reference Banks"]
        + RUB_Annual_Swap_Rate_TRADITION_Reference_Banks
            [value "RUB-Annual Swap Rate-TRADITION-Reference Banks"]
        + RUB_Key_Rate_CBRF
            [value "RUB-Key Rate CBRF"]
        + RUB_MosPrime
            [value "RUB-MosPrime"]
        + RUB_MOSPRIME_NFEA
            [value "RUB-MOSPRIME-NFEA"]
        + RUB_MOSPRIME_Reference_Banks
            [value "RUB-MOSPRIME-Reference Banks"]
        + RUB_RUONIA
            [value "RUB-RUONIA"]
        + RUB_RUONIA_OIS_Compound_1
            [value "RUB-RUONIA-OIS Compound"]
        + RUB_RUONIA_OIS_COMPOUND
            [value "RUB-RUONIA-OIS-COMPOUND"]
        + SAR_SAIBOR
            [value "SAR-SAIBOR"]
        + SAR_SRIOR_Reference_Banks
            [value "SAR-SRIOR-Reference Banks"]
        + SAR_SRIOR_SUAA
            [value "SAR-SRIOR-SUAA"]
        + SEK_Annual_Swap_Rate
            [value "SEK-Annual Swap Rate"]
        + SEK_Annual_Swap_Rate_SESWFI
            [value "SEK-Annual Swap Rate-SESWFI"]
        + SEK_SIOR_OIS_COMPOUND
            [value "SEK-SIOR-OIS-COMPOUND"]
        + SEK_STIBOR
            [value "SEK-STIBOR"]
        + SEK_STIBOR_Bloomberg
            [value "SEK-STIBOR-Bloomberg"]
        + SEK_STIBOR_OIS_Compound
            [value "SEK-STIBOR-OIS Compound"]
        + SEK_STIBOR_Reference_Banks
            [value "SEK-STIBOR-Reference Banks"]
        + SEK_STIBOR_SIDE
            [value "SEK-STIBOR-SIDE"]
        + SEK_SWESTR
            [value "SEK-SWESTR"]
        + SEK_SWESTR_Average_1M
            [value "SEK-SWESTR Average 1M"]
        + SEK_SWESTR_Average_1W
            [value "SEK-SWESTR Average 1W"]
        + SEK_SWESTR_Average_2M
            [value "SEK-SWESTR Average 2M"]
        + SEK_SWESTR_Average_3M
            [value "SEK-SWESTR Average 3M"]
        + SEK_SWESTR_Average_6M
            [value "SEK-SWESTR Average 6M"]
        + SEK_SWESTR_Compounded_Index
            [value "SEK-SWESTR Compounded Index"]
        + SEK_SWESTR_OIS_Compound
            [value "SEK-SWESTR-OIS Compound"]
        + SGD_Semi_Annual_Currency_Basis_Swap_Rate_11_00_Tullett_Prebon
            [value "SGD-Semi-Annual Currency Basis Swap Rate-11:00-Tullett Prebon"]
        + SGD_Semi_Annual_Currency_Basis_Swap_Rate_16_00_Tullett_Prebon
            [value "SGD-Semi-Annual Currency Basis Swap Rate-16:00-Tullett Prebon"]
        + SGD_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "SGD-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + SGD_Semi_Annual_Swap_Rate_11_00_TRADITION
            [value "SGD-Semi-Annual Swap Rate-11.00-TRADITION"]
        + SGD_Semi_Annual_Swap_Rate_11_00_Tullett_Prebon
            [value "SGD-Semi-Annual Swap Rate-11:00-Tullett Prebon"]
        + SGD_Semi_Annual_Swap_Rate_16_00_Tullett_Prebon
            [value "SGD-Semi-Annual Swap Rate-16:00-Tullett Prebon"]
        + SGD_Semi_Annual_Swap_Rate_ICAP
            [value "SGD-Semi-Annual Swap Rate-ICAP"]
        + SGD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks
            [value "SGD-Semi-Annual Swap Rate-ICAP-Reference Banks"]
        + SGD_Semi_Annual_Swap_Rate_Reference_Banks
            [value "SGD-Semi-Annual Swap Rate-Reference Banks"]
        + SGD_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks
            [value "SGD-Semi-Annual Swap Rate-TRADITION-Reference Banks"]
        + SGD_SIBOR
            [value "SGD-SIBOR"]
        + SGD_SIBOR_Reference_Banks
            [value "SGD-SIBOR-Reference Banks"]
        + SGD_SIBOR_Reuters
            [value "SGD-SIBOR-Reuters"]
        + SGD_SIBOR_Telerate
            [value "SGD-SIBOR-Telerate"]
        + SGD_SONAR_OIS_COMPOUND
            [value "SGD-SONAR-OIS-COMPOUND"]
        + SGD_SONAR_OIS_VWAP_COMPOUND
            [value "SGD-SONAR-OIS-VWAP-COMPOUND"]
        + SGD_SOR
            [value "SGD-SOR"]
        + SGD_SOR_Reference_Banks
            [value "SGD-SOR-Reference Banks"]
        + SGD_SOR_Reuters
            [value "SGD-SOR-Reuters"]
        + SGD_SOR_Telerate
            [value "SGD-SOR-Telerate"]
        + SGD_SOR_VWAP
            [value "SGD-SOR-VWAP"]
        + SGD_SOR_VWAP_Reference_Banks
            [value "SGD-SOR-VWAP-Reference Banks"]
        + SGD_SORA
            [value "SGD-SORA"]
        + SGD_SORA_COMPOUND
            [value "SGD-SORA-COMPOUND"]
        + SGD_SORA_OIS_Compound
            [value "SGD-SORA-OIS Compound"]
        + SKK_BRIBOR_BRBO
            [value "SKK-BRIBOR-BRBO"]
        + SKK_BRIBOR_Bloomberg
            [value "SKK-BRIBOR-Bloomberg"]
        + SKK_BRIBOR_NBSK07
            [value "SKK-BRIBOR-NBSK07"]
        + SKK_BRIBOR_Reference_Banks
            [value "SKK-BRIBOR-Reference Banks"]
        + THB_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "THB-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + THB_Semi_Annual_Swap_Rate_Reference_Banks
            [value "THB-Semi-Annual Swap Rate-Reference Banks"]
        + THB_SOR_Reference_Banks
            [value "THB-SOR-Reference Banks"]
        + THB_SOR_Reuters
            [value "THB-SOR-Reuters"]
        + THB_SOR_Telerate
            [value "THB-SOR-Telerate"]
        + THB_THBFIX
            [value "THB-THBFIX"]
        + THB_THBFIX_Reference_Banks
            [value "THB-THBFIX-Reference Banks"]
        + THB_THBFIX_Reuters
            [value "THB-THBFIX-Reuters"]
        + THB_THOR
            [value "THB-THOR"]
        + THB_THOR_COMPOUND
            [value "THB-THOR-COMPOUND"]
        + THB_THOR_OIS_Compound
            [value "THB-THOR-OIS Compound"]
        + TRY_Annual_Swap_Rate_11_00_TRADITION
            [value "TRY Annual Swap Rate-11:00-TRADITION"]
        + TRY_Annual_Swap_Rate_11_15_BGCANTOR
            [value "TRY-Annual Swap Rate-11:15-BGCANTOR"]
        + TRY_Annual_Swap_Rate_Reference_Banks
            [value "TRY-Annual Swap Rate-Reference Banks"]
        + TRY_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks
            [value "TRY-Semi-Annual Swap Rate-TRADITION-Reference Banks"]
        + TRY_TLREF
            [value "TRY-TLREF"]
        + TRY_TLREF_OIS_Compound_1
            [value "TRY-TLREF-OIS Compound"]
        + TRY_TLREF_OIS_COMPOUND
            [value "TRY-TLREF-OIS-COMPOUND"]
        + TRY_TRLIBOR
            [value "TRY-TRLIBOR"]
        + TRY_TRYIBOR_Reference_Banks
            [value "TRY-TRYIBOR-Reference Banks"]
        + TRY_TRYIBOR_Reuters
            [value "TRY-TRYIBOR-Reuters"]
        + TWD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR
            [value "TWD-Quarterly-Annual Swap Rate-11:00-BGCANTOR"]
        + TWD_Quarterly_Annual_Swap_Rate_Reference_Banks
            [value "TWD-Quarterly-Annual Swap Rate-Reference Banks"]
        + TWD_Reference_Dealers
            [value "TWD-Reference Dealers"]
        + TWD_Reuters_6165
            [value "TWD-Reuters-6165"]
        + TWD_TAIBIR01
            [value "TWD-TAIBIR01"]
        + TWD_TAIBIR02
            [value "TWD-TAIBIR02"]
        + TWD_TAIBOR
            [value "TWD-TAIBOR"]
        + TWD_TAIBOR_Bloomberg
            [value "TWD-TAIBOR-Bloomberg"]
        + TWD_TAIBOR_Reuters
            [value "TWD-TAIBOR-Reuters"]
        + TWD_TWCPBA
            [value "TWD-TWCPBA"]
        + TWD_Telerate_6165
            [value "TWD-Telerate-6165"]
        + UK_Base_Rate
            [value "UK Base Rate"]
        + USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP
            [value "USD-3M LIBOR SWAP-CME vs LCH-ICAP"]
        + USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg
            [value "USD-3M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg"]
        + USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP
            [value "USD-6M LIBOR SWAP-CME vs LCH-ICAP"]
        + USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg
            [value "USD-6M LIBOR SWAP-CME vs LCH-ICAP-Bloomberg"]
        + USD_AMERIBOR
            [value "USD-AMERIBOR"]
        + USD_AMERIBOR_Average_30D
            [value "USD-AMERIBOR Average 30D"]
        + USD_AMERIBOR_Average_90D
            [value "USD-AMERIBOR Average 90D"]
        + USD_AMERIBOR_Term
            [value "USD-AMERIBOR Term"]
        + USD_AMERIBOR_Term_Structure
            [value "USD-AMERIBOR Term Structure"]
        + USD_Annual_Swap_Rate_11_00_BGCANTOR
            [value "USD-Annual Swap Rate-11:00-BGCANTOR"]
        + USD_Annual_Swap_Rate_11_00_TRADITION
            [value "USD-Annual Swap Rate-11:00-TRADITION"]
        + USD_Annual_Swap_Rate_4_00_TRADITION
            [value "USD-Annual Swap Rate-4:00-TRADITION"]
        + USD_AXI_Term
            [value "USD-AXI Term"]
        + USD_BA_H_15
            [value "USD-BA-H.15"]
        + USD_BA_Reference_Dealers
            [value "USD-BA-Reference Dealers"]
        + USD_BMA_Municipal_Swap_Index
            [value "USD-BMA Municipal Swap Index"]
        + USD_BSBY
            [value "USD-BSBY"]
        + USD_CD_H_15
            [value "USD-CD-H.15"]
        + USD_CD_Reference_Dealers
            [value "USD-CD-Reference Dealers"]
        + USD_CMS_Reference_Banks
            [value "USD-CMS-Reference Banks"]
        + USD_CMS_Reference_Banks_ICAP_SwapPX
            [value "USD-CMS-Reference Banks-ICAP SwapPX"]
        + USD_CMS_Reuters
            [value "USD-CMS-Reuters"]
        + USD_CMS_Telerate
            [value "USD-CMS-Telerate"]
        + USD_CMT
            [value "USD-CMT"]
        + USD_CMT_Average_1W
            [value "USD-CMT Average 1W"]
        + USD_CMT_T7051
            [value "USD-CMT-T7051"]
        + USD_CMT_T7052
            [value "USD-CMT-T7052"]
        + USD_COFI
            [value "USD-COFI"]
        + USD_COF11_FHLBSF
            [value "USD-COF11-FHLBSF"]
        + USD_COF11_Reuters
            [value "USD-COF11-Reuters"]
        + USD_COF11_Telerate
            [value "USD-COF11-Telerate"]
        + USD_CP_H_15
            [value "USD-CP-H.15"]
        + USD_CP_Money_Market_Yield
            [value "USD-CP-Money Market Yield"]
        + USD_CP_Reference_Dealers
            [value "USD-CP-Reference Dealers"]
        + USD_CRITR
            [value "USD-CRITR"]
        + USD_FFCB_DISCO
            [value "USD-FFCB-DISCO"]
        + USD_Federal_Funds
            [value "USD-Federal Funds"]
        + USD_Federal_Funds_H_15
            [value "USD-Federal Funds-H.15"]
        + USD_Federal_Funds_H_15_Bloomberg
            [value "USD-Federal Funds-H.15-Bloomberg"]
        + USD_Federal_Funds_H_15_OIS_COMPOUND
            [value "USD-Federal Funds-H.15-OIS-COMPOUND"]
        + USD_Federal_Funds_OIS_Compound
            [value "USD-Federal Funds-OIS Compound"]
        + USD_Federal_Funds_Reference_Dealers
            [value "USD-Federal Funds-Reference Dealers"]
        + USD_FXI_Term
            [value "USD-FXI Term"]
        + USD_ISDAFIX3_Swap_Rate
            [value "USD-ISDAFIX3-Swap Rate"]
        + USD_ISDAFIX3_Swap_Rate_3_00
            [value "USD-ISDAFIX3-Swap Rate-3:00"]
        + USD_ISDA_Swap_Rate
            [value "USD-ISDA-Swap Rate"]
        + USD_ISDA_Swap_Rate_3_00
            [value "USD-ISDA-Swap Rate-3:00"]
        + USD_LIBOR
            [value "USD-LIBOR"]
        + USD_LIBOR_BBA
            [value "USD-LIBOR-BBA"]
        + USD_LIBOR_BBA_Bloomberg
            [value "USD-LIBOR-BBA-Bloomberg"]
        + USD_LIBOR_ICE_Swap_Rate_11_00
            [value "USD-LIBOR ICE Swap Rate-11:00"]
        + USD_LIBOR_ICE_Swap_Rate_15_00
            [value "USD-LIBOR ICE Swap Rate-15:00"]
        + USD_LIBOR_ISDA
            [value "USD-LIBOR-ISDA"]
        + USD_LIBOR_LIBO
            [value "USD-LIBOR-LIBO"]
        + USD_LIBOR_Reference_Banks
            [value "USD-LIBOR-Reference Banks"]
        + USD_Municipal_Swap_Index
            [value "USD-Municipal Swap Index"]
        + USD_Municipal_Swap_Libor_Ratio_11_00_ICAP
            [value "USD-Municipal Swap Libor Ratio-11:00-ICAP"]
        + USD_Municipal_Swap_Rate_11_00_ICAP
            [value "USD-Municipal Swap Rate-11:00-ICAP"]
        + USD_OIS_11_00_BGCANTOR
            [value "USD-OIS-11:00-BGCANTOR"]
        + USD_OIS_11_00_LON_ICAP
            [value "USD-OIS-11:00-LON-ICAP"]
        + USD_OIS_11_00_NY_ICAP
            [value "USD-OIS-11:00-NY-ICAP"]
        + USD_OIS_11_00_TRADITION
            [value "USD-OIS-11:00-TRADITION"]
        + USD_OIS_3_00_BGCANTOR
            [value "USD-OIS-3:00-BGCANTOR"]
        + USD_OIS_3_00_NY_ICAP
            [value "USD-OIS-3:00-NY-ICAP"]
        + USD_OIS_4_00_TRADITION
            [value "USD-OIS-4:00-TRADITION"]
        + USD_Overnight_Bank_Funding_Rate
            [value "USD-Overnight Bank Funding Rate"]
        + USD_Prime
            [value "USD-Prime"]
        + USD_Prime_H_15
            [value "USD-Prime-H.15"]
        + USD_Prime_Reference_Banks
            [value "USD-Prime-Reference Banks"]
        + USD_SandP_Index_High_Grade
            [value "USD-SandP Index High Grade"]
        + USD_SIBOR_Reference_Banks
            [value "USD-SIBOR-Reference Banks"]
        + USD_SIBOR_SIBO
            [value "USD-SIBOR-SIBO"]
        + USD_SIFMA_Municipal_Swap_Index
            [value "USD-SIFMA Municipal Swap Index"]
        + USD_SOFR
            [value "USD-SOFR"]
        + USD_SOFR_COMPOUND
            [value "USD-SOFR-COMPOUND"]
        + USD_SOFR_Average_180D
            [value "USD-SOFR Average 180D"]
        + USD_SOFR_Average_30D
            [value "USD-SOFR Average 30D"]
        + USD_SOFR_Average_90D
            [value "USD-SOFR Average 90D"]
        + USD_SOFR_CME_Term
            [value "USD-SOFR CME Term"]
        + USD_SOFR_Compounded_Index
            [value "USD-SOFR Compounded Index"]
        + USD_SOFR_ICE_Compounded_Index
            [value "USD-SOFR ICE Compounded Index"]
        + USD_SOFR_ICE_Compounded_Index_0_Floor
            [value "USD-SOFR ICE Compounded Index 0 Floor"]
        + USD_SOFR_ICE_Compounded_Index_0_Floor_2D_Lag
            [value "USD-SOFR ICE Compounded Index 0 Floor 2D Lag"]
        + USD_SOFR_ICE_Compounded_Index_0_Floor_5D_Lag
            [value "USD-SOFR ICE Compounded Index 0 Floor 5D Lag"]
        + USD_SOFR_ICE_Compounded_Index_2D_Lag
            [value "USD-SOFR ICE Compounded Index 2D Lag"]
        + USD_SOFR_ICE_Compounded_Index_5D_Lag
            [value "USD-SOFR ICE Compounded Index 5D Lag"]
        + USD_SOFR_ICE_Swap_Rate
            [value "USD-SOFR ICE Swap Rate"]
        + USD_SOFR_ICE_Term
            [value "USD-SOFR ICE Term"]
        + USD_SOFR_OIS_Compound
            [value "USD-SOFR-OIS Compound"]
        + USD_S_P_Index_High_Grade
            [value "USD-S&P Index-High Grade"]
        + USD_Swap_Rate_BCMP1
            [value "USD Swap Rate-BCMP1"]
        + USD_TBILL_Auction_High_Rate
            [value "USD-TBILL Auction High Rate"]
        + USD_TBILL_H_15
            [value "USD-TBILL-H.15"]
        + USD_TBILL_H_15_Bloomberg
            [value "USD-TBILL-H.15-Bloomberg"]
        + USD_TBILL_Secondary_Market
            [value "USD-TBILL-Secondary Market"]
        + USD_TBILL_Secondary_Market_Bond_Equivalent_Yield
            [value "USD-TBILL Secondary Market-Bond Equivalent Yield"]
        + USD_TIBOR_ISDC
            [value "USD-TIBOR-ISDC"]
        + USD_TIBOR_Reference_Banks
            [value "USD-TIBOR-Reference Banks"]
        + USD_Treasury_19901_3_00_ICAP
            [value "USD-Treasury-19901-3:00-ICAP"]
        + USD_Treasury_Rate_BCMP1
            [value "USD Treasury Rate-BCMP1"]
        + USD_Treasury_Rate_ICAP_BrokerTec
            [value "USD-Treasury Rate-ICAP BrokerTec"]
        + USD_Treasury_Rate_SwapMarker100
            [value "USD-Treasury Rate-SwapMarker100"]
        + USD_Treasury_Rate_SwapMarker99
            [value "USD-Treasury Rate-SwapMarker99"]
        + USD_Treasury_Rate_T19901
            [value "USD-Treasury Rate-T19901"]
        + USD_Treasury_Rate_T500
            [value "USD-Treasury Rate-T500"]
        + VND_Semi_Annual_Swap_Rate_11_00_BGCANTOR
            [value "VND-Semi-Annual Swap Rate-11:00-BGCANTOR"]
        + VND_Semi_Annual_Swap_Rate_Reference_Banks
            [value "VND-Semi-Annual Swap Rate-Reference Banks"]
        + ZAR_DEPOSIT_Reference_Banks
            [value "ZAR-DEPOSIT-Reference Banks"]
        + ZAR_DEPOSIT_SAFEX
            [value "ZAR-DEPOSIT-SAFEX"]
        + ZAR_JIBAR
            [value "ZAR-JIBAR"]
        + ZAR_JIBAR_Reference_Banks
            [value "ZAR-JIBAR-Reference Banks"]
        + ZAR_JIBAR_SAFEX
            [value "ZAR-JIBAR-SAFEX"]
        + ZAR_Prime_Average_1
            [value "ZAR-Prime Average"]
        + ZAR_PRIME_AVERAGE
            [value "ZAR-PRIME-AVERAGE"]
        + ZAR_PRIME_AVERAGE_Reference_Banks
            [value "ZAR-PRIME-AVERAGE-Reference Banks"]
        + ZAR_Quarterly_Swap_Rate_1_00_TRADITION
            [value "ZAR-Quarterly Swap Rate-1:00-TRADITION"]
        + ZAR_Quarterly_Swap_Rate_5_30_TRADITION
            [value "ZAR-Quarterly Swap Rate-5:30-TRADITION"]
        + ZAR_Quarterly_Swap_Rate_TRADITION_Reference_Banks
            [value "ZAR-Quarterly Swap Rate-TRADITION-Reference Banks"]
        + ZAR_ZARONIA
            [value "ZAR-ZARONIA"]
        + ZAR_ZARONIA_OIS_Compound
            [value "ZAR-ZARONIA-OIS Compound"]

    InflationRateIndexEnum:
        + AUD_CPI
            [value "AUD-CPI"]
        + AUS_CPI
            [value "AUS-CPI"]
        + AUS_HICP
            [value "AUS-HICP"]
        + BLG_CPI_GI
            [value "BLG-CPI-GI"]
        + BLG_CPI_HI
            [value "BLG-CPI-HI"]
        + BLG_HICP
            [value "BLG-HICP"]
        + BRL_IGPM
            [value "BRL-IGPM"]
        + BRL_IPCA
            [value "BRL-IPCA"]
        + CAD_CPI
            [value "CAD-CPI"]
        + CLP_CPI
            [value "CLP-CPI"]
        + CNY_CPI
            [value "CNY-CPI"]
        + CZK_CPI
            [value "CZK-CPI"]
        + DEK_CPI
            [value "DEK-CPI"]
        + DEK_HICP
            [value "DEK-HICP"]
        + DEM_CPI
            [value "DEM-CPI"]
        + DEM_CPI_NRW
            [value "DEM-CPI-NRW"]
        + DEM_HICP
            [value "DEM-HICP"]
        + ESP_CPI
            [value "ESP-CPI"]
        + ESP_HICP
            [value "ESP-HICP"]
        + ESP_R_CPI
            [value "ESP-R-CPI"]
        + ESP_R_HICP
            [value "ESP-R-HICP"]
        + EUR_AI_CPI
            [value "EUR-AI-CPI"]
        + EUR_AI_R_CPI
            [value "EUR-AI-R-CPI"]
        + EUR_EXT_CPI
            [value "EUR-EXT-CPI"]
        + EUR_EXT_R_CPI
            [value "EUR-EXT-R-CPI"]
        + FIN_CPI
            [value "FIN-CPI"]
        + FIN_HICP
            [value "FIN-HICP"]
        + FRC_EXT_CPI
            [value "FRC-EXT-CPI"]
        + FRC_HICP
            [value "FRC-HICP"]
        + GRD_CPI
            [value "GRD-CPI"]
        + GRD_HICP
            [value "GRD-HICP"]
        + HKD_CPI
            [value "HKD-CPI"]
        + HUF_CPI
            [value "HUF-CPI"]
        + IDR_CPI
            [value "IDR-CPI"]
        + ILS_CPI
            [value "ILS-CPI"]
        + IRL_CPI
            [value "IRL-CPI"]
        + IRL_HICP
            [value "IRL-HICP"]
        + ISK_CPI
            [value "ISK-CPI"]
        + ISK_HICP
            [value "ISK-HICP"]
        + ITL_BC_EXT_CPI
            [value "ITL-BC-EXT-CPI"]
        + ITL_BC_INT_CPI
            [value "ITL-BC-INT-CPI"]
        + ITL_HICP
            [value "ITL-HICP"]
        + ITL_WC_EXT_CPI
            [value "ITL-WC-EXT-CPI"]
        + ITL_WC_INT_CPI
            [value "ITL-WC-INT-CPI"]
        + JPY_CPI_EXF
            [value "JPY-CPI-EXF"]
        + KRW_CPI
            [value "KRW-CPI"]
        + LUX_CPI
            [value "LUX-CPI"]
        + LUX_HICP
            [value "LUX-HICP"]
        + MXN_CPI
            [value "MXN-CPI"]
        + MXN_UDI
            [value "MXN-UDI"]
        + MYR_CPI
            [value "MYR-CPI"]
        + NLG_CPI
            [value "NLG-CPI"]
        + NLG_HICP
            [value "NLG-HICP"]
        + NOK_CPI
            [value "NOK-CPI"]
        + NZD_CPI
            [value "NZD-CPI"]
        + PER_CPI
            [value "PER-CPI"]
        + PLN_CPI
            [value "PLN-CPI"]
        + POR_CPI
            [value "POR-CPI"]
        + POR_HICP
            [value "POR-HICP"]
        + RUB_CPI
            [value "RUB-CPI"]
        + SEK_CPI
            [value "SEK-CPI"]
        + SGD_CPI
            [value "SGD-CPI"]
        + SWF_CPI
            [value "SWF-CPI"]
        + TRY_CPI
            [value "TRY-CPI"]
        + TWD_CPI
            [value "TWD-CPI"]
        + UK_HICP
            [value "UK-HICP"]
        + UK_RPI
            [value "UK-RPI"]
        + UK_RPIX
            [value "UK-RPIX"]
        + USA_CPI_U
            [value "USA-CPI-U"]
        + ZAR_CPI
            [value "ZAR-CPI"]
        + ZAR_CPIX
            [value "ZAR-CPIX"]

    BusinessCenterEnum:
        + AEAB
            [value "AEAB"]
        + AEAD
            [value "AEAD"]
        + AEDU
            [value "AEDU"]
        + AMYE
            [value "AMYE"]
        + AOLU
            [value "AOLU"]
        + ARBA
            [value "ARBA"]
        + ATVI
            [value "ATVI"]
        + AUAD
            [value "AUAD"]
        + AUBR
            [value "AUBR"]
        + AUCA
            [value "AUCA"]
        + AUDA
            [value "AUDA"]
        + AUME
            [value "AUME"]
        + AUPE
            [value "AUPE"]
        + AUSY
            [value "AUSY"]
        + BBBR
            [value "BBBR"]
        + BDDH
            [value "BDDH"]
        + BEBR
            [value "BEBR"]
        + BGSO
            [value "BGSO"]
        + BHMA
            [value "BHMA"]
        + BMHA
            [value "BMHA"]
        + BNBS
            [value "BNBS"]
        + BOLP
            [value "BOLP"]
        + BRBD
            [value "BRBD"]
        + BRBR
            [value "BRBR"]
        + BRRJ
            [value "BRRJ"]
        + BRSP
            [value "BRSP"]
        + BSNA
            [value "BSNA"]
        + BWGA
            [value "BWGA"]
        + BYMI
            [value "BYMI"]
        + CACL
            [value "CACL"]
        + CAMO
            [value "CAMO"]
        + CAOT
            [value "CAOT"]
        + CATO
            [value "CATO"]
        + CAVA
            [value "CAVA"]
        + CAWI
            [value "CAWI"]
        + CHBA
            [value "CHBA"]
        + CHGE
            [value "CHGE"]
        + CHZU
            [value "CHZU"]
        + CIAB
            [value "CIAB"]
        + CLSA
            [value "CLSA"]
        + CMYA
            [value "CMYA"]
        + CNBE
            [value "CNBE"]
        + CNSH
            [value "CNSH"]
        + COBO
            [value "COBO"]
        + CRSJ
            [value "CRSJ"]
        + CWWI
            [value "CWWI"]
        + CYNI
            [value "CYNI"]
        + CZPR
            [value "CZPR"]
        + DECO
            [value "DECO"]
        + DEDU
            [value "DEDU"]
        + DEFR
            [value "DEFR"]
        + DEHH
            [value "DEHH"]
        + DELE
            [value "DELE"]
        + DEMA
            [value "DEMA"]
        + DEMU
            [value "DEMU"]
        + DEST
            [value "DEST"]
        + DKCO
            [value "DKCO"]
        + DOSD
            [value "DOSD"]
        + DZAL
            [value "DZAL"]
        + ECGU
            [value "ECGU"]
        + EETA
            [value "EETA"]
        + EGCA
            [value "EGCA"]
        + ESAS
            [value "ESAS"]
        + ESBA
            [value "ESBA"]
        + ESMA
            [value "ESMA"]
        + ESSS
            [value "ESSS"]
        + ETAA
            [value "ETAA"]
        + EUR_ICESWAP
            [value "EUR-ICESWAP"]
        + EUTA
            [value "EUTA"]
        + FIHE
            [value "FIHE"]
        + FRPA
            [value "FRPA"]
        + GBED
            [value "GBED"]
        + GBLO
            [value "GBLO"]
        + GBP_ICESWAP
            [value "GBP-ICESWAP"]
        + GETB
            [value "GETB"]
        + GGSP
            [value "GGSP"]
        + GHAC
            [value "GHAC"]
        + GIGI
            [value "GIGI"]
        + GMBA
            [value "GMBA"]
        + GNCO
            [value "GNCO"]
        + GRAT
            [value "GRAT"]
        + GTGC
            [value "GTGC"]
        + HKHK
            [value "HKHK"]
        + HNTE
            [value "HNTE"]
        + HRZA
            [value "HRZA"]
        + HUBU
            [value "HUBU"]
        + IDJA
            [value "IDJA"]
        + IEDU
            [value "IEDU"]
        + ILJE
            [value "ILJE"]
        + ILS_TELBOR
            [value "ILS-TELBOR"]
        + ILTA
            [value "ILTA"]
        + INAH
            [value "INAH"]
        + INBA
            [value "INBA"]
        + INCH
            [value "INCH"]
        + INHY
            [value "INHY"]
        + INKO
            [value "INKO"]
        + INMU
            [value "INMU"]
        + INND
            [value "INND"]
        + IQBA
            [value "IQBA"]
        + IRTE
            [value "IRTE"]
        + ISRE
            [value "ISRE"]
        + ITMI
            [value "ITMI"]
        + ITRO
            [value "ITRO"]
        + ITTU
            [value "ITTU"]
        + JESH
            [value "JESH"]
        + JMKI
            [value "JMKI"]
        + JOAM
            [value "JOAM"]
        + JPTO
            [value "JPTO"]
        + KENA
            [value "KENA"]
        + KRSE
            [value "KRSE"]
        + KWKC
            [value "KWKC"]
        + KYGE
            [value "KYGE"]
        + KZAL
            [value "KZAL"]
        + LAVI
            [value "LAVI"]
        + LBBE
            [value "LBBE"]
        + LKCO
            [value "LKCO"]
        + LULU
            [value "LULU"]
        + LVRI
            [value "LVRI"]
        + MACA
            [value "MACA"]
        + MARA
            [value "MARA"]
        + MCMO
            [value "MCMO"]
        + MNUB
            [value "MNUB"]
        + MOMA
            [value "MOMA"]
        + MTVA
            [value "MTVA"]
        + MUPL
            [value "MUPL"]
        + MVMA
            [value "MVMA"]
        + MWLI
            [value "MWLI"]
        + MXMC
            [value "MXMC"]
        + MYKL
            [value "MYKL"]
        + MYLA
            [value "MYLA"]
        + MZMA
            [value "MZMA"]
        + NAWI
            [value "NAWI"]
        + NGAB
            [value "NGAB"]
        + NGLA
            [value "NGLA"]
        + NLAM
            [value "NLAM"]
        + NLRO
            [value "NLRO"]
        + NOOS
            [value "NOOS"]
        + NPKA
            [value "NPKA"]
        + NYFD
            [value "NYFD"]
        + NYSE
            [value "NYSE"]
        + NZAU
            [value "NZAU"]
        + NZWE
            [value "NZWE"]
        + OMMU
            [value "OMMU"]
        + PAPC
            [value "PAPC"]
        + PELI
            [value "PELI"]
        + PHMA
            [value "PHMA"]
        + PHMK
            [value "PHMK"]
        + PKKA
            [value "PKKA"]
        + PLWA
            [value "PLWA"]
        + PRSJ
            [value "PRSJ"]
        + PTLI
            [value "PTLI"]
        + QADO
            [value "QADO"]
        + ROBU
            [value "ROBU"]
        + RSBE
            [value "RSBE"]
        + RUMO
            [value "RUMO"]
        + SAAB
            [value "SAAB"]
        + SAJE
            [value "SAJE"]
        + SARI
            [value "SARI"]
        + SEST
            [value "SEST"]
        + SGSI
            [value "SGSI"]
        + SILJ
            [value "SILJ"]
        + SKBR
            [value "SKBR"]
        + SLFR
            [value "SLFR"]
        + SNDA
            [value "SNDA"]
        + SVSS
            [value "SVSS"]
        + THBA
            [value "THBA"]
        + TNTU
            [value "TNTU"]
        + TRAN
            [value "TRAN"]
        + TRIS
            [value "TRIS"]
        + TTPS
            [value "TTPS"]
        + TWTA
            [value "TWTA"]
        + TZDA
            [value "TZDA"]
        + TZDO
            [value "TZDO"]
        + UAKI
            [value "UAKI"]
        + UGKA
            [value "UGKA"]
        + USBO
            [value "USBO"]
        + USCH
            [value "USCH"]
        + USCR
            [value "USCR"]
        + USD_ICESWAP
            [value "USD-ICESWAP"]
        + USD_MUNI
            [value "USD-MUNI"]
        + USDC
            [value "USDC"]
        + USDN
            [value "USDN"]
        + USDT
            [value "USDT"]
        + USGS
            [value "USGS"]
        + USHL
            [value "USHL"]
        + USHO
            [value "USHO"]
        + USLA
            [value "USLA"]
        + USMB
            [value "USMB"]
        + USMN
            [value "USMN"]
        + USNY
            [value "USNY"]
        + USPO
            [value "USPO"]
        + USSA
            [value "USSA"]
        + USSE
            [value "USSE"]
        + USSF
            [value "USSF"]
        + USWT
            [value "USWT"]
        + UYMO
            [value "UYMO"]
        + UZTA
            [value "UZTA"]
        + VECA
            [value "VECA"]
        + VGRT
            [value "VGRT"]
        + VNHA
            [value "VNHA"]
        + VNHC
            [value "VNHC"]
        + YEAD
            [value "YEAD"]
        + ZAJO
            [value "ZAJO"]
        + ZMLU
            [value "ZMLU"]
        + ZWHA
            [value "ZWHA"]

    CommodityBusinessCalendarEnum:
        // Commodity Business Centers from FpML
        + ADSM
            [value "ADSM"]
        + AGRUS_FMB
            [value "AGRUS-FMB"]
        + APPI
            [value "APPI"]
        + ARGUS_CRUDE
            [value "ARGUS-CRUDE"]
        + ARGUS_EUROPEAN_GAS
            [value "ARGUS-EUROPEAN-GAS"]
        + ARGUS_EUROPEAN_PRODUCTS
            [value "ARGUS-EUROPEAN-PRODUCTS"]
        + ARGUS_INTERNATIONAL_LPG
            [value "ARGUS-INTERNATIONAL-LPG"]
        + ARGUS_MCCLOSKEYS_COAL_REPORT
            [value "ARGUS-MCCLOSKEYS-COAL-REPORT"]
        + ARGUS_US_PRODUCTS
            [value "ARGUS-US-PRODUCTS"]
        + ASX
            [value "ASX"]
        + AWB
            [value "AWB"]
        + AWEX
            [value "AWEX"]
        + BALTIC_EXCHANGE
            [value "BALTIC-EXCHANGE"]
        + BANK_NEGARA_MALAYSIA_POLICY_COMMITTEE
            [value "BANK-NEGARA-MALAYSIA-POLICY-COMMITTEE"]
        + BELPEX
            [value "BELPEX"]
        + BLUENEXT
            [value "BLUENEXT"]
        + BM_F
            [value "BM&F"]
        + BURSA_MALAYSIA_SETTLEMENT
            [value "BURSA-MALAYSIA-SETTLEMENT"]
        + BURSA_MALAYSIA_TRADING
            [value "BURSA-MALAYSIA-TRADING"]
        + CANADIAN_GAS_PRICE_REPORTER
            [value "CANADIAN-GAS-PRICE-REPORTER"]
        + CBOT_SOFT
            [value "CBOT-SOFT"]
        + CMAI_AROMATICS_MARKET_REPORT
            [value "CMAI-AROMATICS-MARKET-REPORT"]
        + CMAI_GLOBAL_PLASTICS_AND_POLYMERS_MARKET_REPORT
            [value "CMAI-GLOBAL-PLASTICS-AND-POLYMERS-MARKET-REPORT"]
        + CMAI_METHANOL_MARKET_REPORT
            [value "CMAI-METHANOL-MARKET-REPORT"]
        + CMAI_MONOMERS_MARKET_REPORT
            [value "CMAI-MONOMERS-MARKET-REPORT"]
        + CME_DAIRY
            [value "CME-DAIRY"]
        + CME_NON_DAIRY_SOFT
            [value "CME-NON-DAIRY-SOFT"]
        + COMEX
            [value "COMEX"]
        + CRU
            [value "CRU"]
        + CRU_LONG
            [value "CRU-LONG"]
        + DEPARTMENT_OF_ENERGY
            [value "DEPARTMENT-OF-ENERGY"]
        + DEWITT_BENZENE_DERIVATIVES
            [value "DEWITT-BENZENE-DERIVATIVES"]
        + DME
            [value "DME"]
        + DOW_JONES
            [value "DOW-JONES"]
        + DOW_JONES_ENERGY_SERVICE
            [value "DOW-JONES-ENERGY-SERVICE"]
        + DowJonesPower
            [value "DowJonesPower"]
        + EEX_COAL
            [value "EEX-COAL"]
        + EEX_EMISSIONS
            [value "EEX-EMISSIONS"]
        + EEX_GAS
            [value "EEX-GAS"]
        + EEX_POWER
            [value "EEX-POWER"]
        + EURONEX_MATIF
            [value "EURONEX-MATIF"]
        + FERTECON
            [value "FERTECON"]
        + FERTILIZER_WEEK
            [value "FERTILIZER-WEEK"]
        + GAS_DAILY
            [value "GAS-DAILY"]
        + GAS_DAILY_PRICE_GUIDE
            [value "GAS-DAILY-PRICE-GUIDE"]
        + GLOBALCOAL
            [value "GLOBALCOAL"]
        + HEREN_REPORT
            [value "HEREN-REPORT"]
        + ICE_10X_DAILY
            [value "ICE/10X-DAILY"]
        + ICE_10X_MONTHLY
            [value "ICE/10X-MONTHLY"]
        + ICE_CANADA
            [value "ICE-CANADA"]
        + ICE_ECX
            [value "ICE-ECX"]
        + ICE_GAS
            [value "ICE-GAS"]
        + ICE_OIL
            [value "ICE-OIL"]
        + ICE_US_AGRICULTURAL
            [value "ICE-US-AGRICULTURAL"]
        + ICIS_PRICING_BENZENE__EUROPE_
            [value "ICIS-PRICING-BENZENE-(EUROPE)"]
        + ICIS_PRICING_ETHYLENE__EUROPE_
            [value "ICIS-PRICING-ETHYLENE-(EUROPE)"]
        + ICIS_PRICING_POLYPROPYLENE__EUROPE_
            [value "ICIS-PRICING-POLYPROPYLENE-(EUROPE)"]
        + INSIDE_FERC
            [value "INSIDE-FERC"]
        + JAPAN_MOF_TSRR
            [value "JAPAN-MOF-TSRR"]
        + KCBOT
            [value "KCBOT"]
        + KUALA_LUMPUR_BANK
            [value "KUALA-LUMPUR-BANK"]
        + LABUAN_BANK
            [value "LABUAN-BANK"]
        + LIFFE_LONDON_SOFT
            [value "LIFFE-LONDON-SOFT"]
        + LME
            [value "LME"]
        + LONDON_BULLION_MARKET
            [value "LONDON-BULLION-MARKET"]
        + LONDON_BULLION_MARKET_GOLD_A_M_ONLY
            [value "LONDON-BULLION-MARKET-GOLD-A.M-ONLY"]
        + LONDON_PLATINUM_PALLADIUM_MARKET
            [value "LONDON-PLATINUM-PALLADIUM-MARKET"]
        + MGEX
            [value "MGEX"]
        + NASDAQ_OMX
            [value "NASDAQ-OMX"]
        + NATURAL_GAS_WEEK
            [value "NATURAL-GAS-WEEK"]
        + NERC
            [value "NERC"]
        + NGI
            [value "NGI"]
        + NGX
            [value "NGX"]
        + NUCLEAR_MARKET_REVIEW
            [value "NUCLEAR-MARKET-REVIEW"]
        + NYMEX_ELECTRICITY
            [value "NYMEX-ELECTRICITY"]
        + NYMEX_GAS
            [value "NYMEX-GAS"]
        + NYMEX_NATURAL_GAS
            [value "NYMEX-NATURAL-GAS"]
        + NYMEX_OIL
            [value "NYMEX-OIL"]
        + OFFICIAL_BOARD_MARKETS
            [value "OFFICIAL-BOARD-MARKETS"]
        + OPIS_LP_GAS
            [value "OPIS-LP-GAS"]
        + OPIS_PROPANE
            [value "OPIS-PROPANE"]
        + PAPER_PACKAGING_MONITOR
            [value "PAPER-PACKAGING-MONITOR"]
        + PAPER_TRADER
            [value "PAPER-TRADER"]
        + PERTAMINA
            [value "PERTAMINA"]
        + PETROCHEMWIRE
            [value "PETROCHEMWIRE"]
        + PIX_PULP_BENCHMARK_INDICES
            [value "PIX-PULP-BENCHMARK-INDICES"]
        + PLATTS_APAG_MARKETSCAN
            [value "PLATTS-APAG-MARKETSCAN"]
        + PLATTS_BUNKERWIRE
            [value "PLATTS-BUNKERWIRE"]
        + PLATTS_CLEAN_TANKERWIRE
            [value "PLATTS-CLEAN-TANKERWIRE"]
        + PLATTS_CRUDE_OIL_MARKETWIRE
            [value "PLATTS-CRUDE-OIL-MARKETWIRE"]
        + PLATTS_DIRTY_TANKERWIRE
            [value "PLATTS-DIRTY-TANKERWIRE"]
        + PLATTS_EUROPEAN_GAS
            [value "PLATTS-EUROPEAN-GAS"]
        + PLATTS_EUROPEAN_MARKETSCAN
            [value "PLATTS-EUROPEAN-MARKETSCAN"]
        + PLATTS_METALS_ALERT
            [value "PLATTS-METALS-ALERT"]
        + PLATTS_OILGRAM
            [value "PLATTS-OILGRAM"]
        + PLATTS_TSI_IRON_ORE
            [value "PLATTS-TSI-IRON-ORE"]
        + PLATTS_TSI_SCRAP
            [value "PLATTS-TSI-SCRAP"]
        + PLATTS_TSI_STEEL
            [value "PLATTS-TSI-STEEL"]
        + PLATTS_US_MARKETSCAN
            [value "PLATTS-US-MARKETSCAN"]
        + PULP_AND_PAPER_INTERNATIONAL
            [value "PULP-AND-PAPER-INTERNATIONAL"]
        + PULP_AND_PAPER_WEEK
            [value "PULP-AND-PAPER-WEEK"]
        + RIM_PRODUCTS_INTELLIGENCE_DAILY
            [value "RIM-PRODUCTS-INTELLIGENCE-DAILY"]
        + SAFEX_SOFT
            [value "SAFEX-SOFT"]
        + SFE_SOFT
            [value "SFE-SOFT"]
        + SGX
            [value "SGX"]
        + SICOM
            [value "SICOM"]
        + SP_GSCI
            [value "SP-GSCI"]
        + STATISTICHES_BUNDESAMT
            [value "STATISTICHES-BUNDESAMT"]
        + TGE
            [value "TGE"]
        + TOCOM_OIL
            [value "TOCOM-OIL"]
        + TOCOM_PRECIOUS
            [value "TOCOM-PRECIOUS"]
        + TOCOM_SOFT
            [value "TOCOM-SOFT"]
        + UX_WEEKLY
            [value "UX-WEEKLY"]
        + WORLD_PULP_MONTHLY
            [value "WORLD-PULP-MONTHLY"]

    BusinessDayConventionEnum:
        + FOLLOWING
            [value "FOLLOWING"]
        + FRN
            [value "FRN"]
        + MODFOLLOWING
            [value "MODFOLLOWING"]
        + PRECEDING
            [value "PRECEDING"]
        + MODPRECEDING
            [value "MODPRECEDING"]
        + NEAREST
            [value "NEAREST"]
        + NONE
            [value "NONE"]
        + NotApplicable
            [value "NotApplicable"]

    DayOfWeekEnum:
        + MON
            [value "MON"]
        + TUE
            [value "TUE"]
        + WED
            [value "WED"]
        + THU
            [value "THU"]
        + FRI
            [value "FRI"]
        + SAT
            [value "SAT"]
        + SUN
            [value "SUN"]

    DayTypeEnum:
        + Business
            [value "Business"]
            [value "CommodityBusiness"]
        + Calendar
            [value "Calendar"]
        + CurrencyBusiness
            [value "CurrencyBusiness"]
        + ExchangeBusiness
            [value "ExchangeBusiness"]
        + ScheduledTradingDay
            [value "ScheduledTradingDay"]

    PeriodEnum:
        + D
            [value "D"]
            [value "PerCalendarDay"]
        + W
            [value "W"]
            [value "NearbyWeek"]
        + M
            [value "M"]
            [value "NearbyMonth"]
        + Y
            [value "Y"]

    PeriodExtendedEnum:
        + D
            [value "D"]
            [value "PerCalendarDay"]
        + W
            [value "W"]
        + M
            [value "M"]
            [value "PerMonth"]
        + Y
            [value "Y"]
        + T
            [value "T"]
            [value "Term"]
        + C
            [value "PerCalculationPeriod"]

    PeriodTimeEnum:
        + Hour
            [value "Hour"]
        + Minute
            [value "Minute"]
        + Second
            [value "Second"]

    CreditRatingAgencyEnum:
        + AMBest
            [value "AMBest"]
        + CBRS
            [value "CBRS"]
        + DBRS
            [value "DBRS"]
        + Fitch
            [value "Fitch"]
        + Japanagency
            [value "Japanagency"]
        + Moodys
            [value "Moodys"]
        + RatingAndInvestmentInformation
            [value "RatingAndInvestmentInformation"]
        + StandardAndPoors
            [value "StandardAndPoors"]

    CreditSupportAgreementTypeEnum:
        + CreditSupportDeed
            [value "CreditSupportDeed"]
            [value "ISDA1995CreditSupportDeedEnglishLaw"]
        + CreditSupportAnnex
            [value "CreditSupportAnnex"]
            [value "ISDA1994CreditSupportAnnexNewYorkLaw"]
            [value "ISDA1995CreditSupportAnnexEnglishLaw"]
            [value "ISDA1995CreditSupportAnnexJapaneseLaw"]
        + CollateralTransferAgreement
            [value "CollateralTransferAgreement"]

    LegalAgreementPublisherEnum:
        + AFB
            [value "AFB"]
        + ISDA
            [value "ISDA"]

    DeliveryMethodEnum:
        + DeliveryVersusPayment
            [value "DeliveryVersusPayment"]
        + FreeOfPayment
            [value "FreeOfPayment"]
        + PreDelivery
            [value "PreDelivery"]
        + PrePayment
            [value "PrePayment"]

    AveragingInOutEnum:
        + In
            [value "In"]
        + Out
            [value "Out"]
        + Both
            [value "Both"]

    PartyDeterminationEnum:
        + ExercisingParty
            [value "ExercisingParty"]
        + NonExercisingParty
            [value "NonExercisingParty"]
        + AsSpecifiedInMasterAgreement
            [value "AsSpecifiedInMasterAgreement"]
        + AsSpecifiedInStandardTermsSupplement
            [value "AsSpecifiedInStandardTermsSupplement"]
        + Both
            [value "Both"]

    // CategoryEnum:
    // + Agent
    // [value "Agent"]
    // + Counterparty
    // [value "Counterparty"]
    // + Customer
    // [value "Customer"]
    // + Principal
    // [value "Principal"]
    CompoundingMethodEnum:
        + Flat
            [value "Flat"]
        + None
            [value "None"]
        + Straight
            [value "Straight"]
        + SpreadExclusive
            [value "SpreadExclusive"]

    ContractualDefinitionsEnum:
        + ISDA1991InterestRate
            [value "ISDA1991"]
        + ISDA1993CommodityDerivatives
            [value "ISDA1993Commodity"]
        + ISDA1996EquityDerivatives
            [value "ISDA1996Equity"]
        + ISDA1997Bullion
            [value "ISDA1997Bullion"]
        + ISDA1997GovernmentBondOption
            [value "ISDA1997GovernmentBond"]
        + ISDA1998FxAndCurrencyOption
            [value "ISDA1998FX"]
        + ISDA1999CreditDerivatives
            [value "ISDA1999Credit"]
        + ISDA2000
            [value "ISDA2000"]
        + ISDA2002EquityDerivatives
            [value "ISDA2002Equity"]
        + ISDA2003CreditDerivatives
            [value "ISDA2003Credit"]
        + ISDA2004Novation
            [value "ISDA2004Novation"]
        + ISDA2005Commodity
            [value "ISDA2005Commodity"]
        + ISDA2006
            [value "ISDA2006"]
        + ISDA2006InflationDerivatives
            [value "ISDA2006Inflation"]
        + ISDA2008InflationDerivatives
            [value "ISDA2008Inflation"]
        + ISDA2011EquityDerivatives
            [value "ISDA2011Equity"]
        + ISDA2014CreditDerivatives
            [value "ISDA2014Credit"]

    ContractualSupplementTypeEnum:
        + ABX
            [value "ABX"]
        + ABXTranche
            [value "ABXTranche"]
        + CDSonLeveragedLoans
            [value "CDSonLeveragedLoans"]
        + CDSonMBS
            [value "CDSonMBS"]
        + CDX
            [value "CDX"]
        + CDXEmergingMarkets
            [value "CDXEmergingMarkets"]
        + CDXEmergingMarketsDiversified
            [value "CDXEmergingMarketsDiversified"]
        + CDXSwaption
            [value "CDXSwaption"]
        + CDXTranche
            [value "CDXTranche"]
        + CMBX
            [value "CMBX"]
        + EuropeanCMBS
            [value "EuropeanCMBS"]
        + EuropeanRMBS
            [value "EuropeanRMBS"]
        + IOS
            [value "IOS"]
        + ISDA1999CreditConvertibleExchangeableAccretingObligations
            [value "ISDA1999CreditConvertibleExchangeableAccretingObligations"]
        + ISDA1999CreditRestructuring
            [value "ISDA1999CreditRestructuring"]
        + ISDA1999CreditSuccessorAndCreditEvents
            [value "ISDA1999CreditSuccessorAndCreditEvents"]
        + ISDA2003AdditionalProvisionsLPN
            [value "ISDA2003AdditionalProvisionsLPN"]
        + ISDA2003ContingentCreditSpreadTransaction
            [value "ISDA2003ContingentCreditSpreadTransaction"]
        + ISDA2003Credit2005MatrixSupplement
            [value "ISDA2003Credit2005MatrixSupplement"]
        + ISDA2003CreditArgentineRepublic
            [value "ISDA2003CreditArgentineRepublic"]
        + ISDA2003CreditAuctionSupplement
            [value "ISDA2003CreditAuctionSupplement"]
        + ISDA2003CreditMay2003
            [value "ISDA2003CreditMay2003"]
        + ISDA2003CreditMonolineInsurers
            [value "ISDA2003CreditMonolineInsurers"]
        + ISDA2003CreditMonolineInsurers2005
            [value "ISDA2003CreditMonolineInsurers2005"]
        + ISDA2003CreditRepublicOfHungary
            [value "ISDA2003CreditRepublicOfHungary"]
        + ISDA2003CreditRepublicOfHungary2005
            [value "ISDA2003CreditRepublicOfHungary2005"]
        + ISDA2003CreditRussianFederation
            [value "ISDA2003CreditRussianFederation"]
        + ISDA2003CreditUSMunicipals
            [value "ISDA2003CreditUSMunicipals"]
        + ISDA2003STMicroelectronicsNV
            [value "ISDA2003STMicroelectronicsNV"]
        + ISDA2007FullLookthroughDepositoryReceiptSupplement
            [value "ISDA2007FullLookthroughDepositoryReceiptSupplement"]
        + ISDA2007PartialLookthroughDepositoryReceiptSupplement
            [value "ISDA2007PartialLookthroughDepositoryReceiptSupplement"]
        + ISDACreditMonolineInsurers
            [value "ISDACreditMonolineInsurers"]
        + ISDADeliveryRestrictions
            [value "ISDADeliveryRestrictions"]
        + ISDAFixedRecovery
            [value "ISDAFixedRecovery"]
        + ISDALPNReferenceEntities
            [value "ISDALPNReferenceEntities"]
        + ISDAMarch2004EquityCanadianSupplement
            [value "ISDAMarch2004EquityCanadianSupplement"]
        + ISDARecoveryLock
            [value "ISDARecoveryLock"]
        + ISDASecuredDeliverableObligationCharacteristic
            [value "ISDASecuredDeliverableObligationCharacteristic"]
        + LCDX
            [value "LCDX"]
        + LCDXTranche
            [value "LCDXTranche"]
        + MBX
            [value "MBX"]
        + MCDX
            [value "MCDX"]
        + PO
            [value "PO"]
        + PrimeX
            [value "PrimeX"]
        + StandardCDXTranche
            [value "StandardCDXTranche"]
        + StandardLCDS
            [value "StandardLCDS"]
        + StandardLCDSBullet
            [value "StandardLCDSBullet"]
        + StandardLCDXBullet
            [value "StandardLCDXBullet"]
        + StandardLCDXBulletTranche
            [value "StandardLCDXBulletTranche"]
        + StandardiTraxxEuropeTranche
            [value "StandardiTraxxEuropeTranche"]
        + SyndicatedSecuredLoanCDS
            [value "SyndicatedSecuredLoanCDS"]
        + TRX
            [value "TRX"]
        + TRX_II
            [value "TRX.II"]
        + iTraxxAsiaExJapan
            [value "iTraxxAsiaExJapan"]
        + iTraxxAsiaExJapanSwaption
            [value "iTraxxAsiaExJapanSwaption"]
        + iTraxxAsiaExJapanTranche
            [value "iTraxxAsiaExJapanTranche"]
        + iTraxxAustralia
            [value "iTraxxAustralia"]
        + iTraxxAustraliaSwaption
            [value "iTraxxAustraliaSwaption"]
        + iTraxxAustraliaTranche
            [value "iTraxxAustraliaTranche"]
        + iTraxxCJ
            [value "iTraxxCJ"]
        + iTraxxCJTranche
            [value "iTraxxCJTranche"]
        + iTraxxEurope
            [value "iTraxxEurope"]
        + iTraxxEuropeDealer
            [value "iTraxxEuropeDealer"]
        + iTraxxEuropeNonDealer
            [value "iTraxxEuropeNonDealer"]
        + iTraxxEuropeSwaption
            [value "iTraxxEuropeSwaption"]
        + iTraxxEuropeTranche
            [value "iTraxxEuropeTranche"]
        + iTraxxJapan
            [value "iTraxxJapan"]
        + iTraxxJapanSwaption
            [value "iTraxxJapanSwaption"]
        + iTraxxJapanTranche
            [value "iTraxxJapanTranche"]
        + iTraxxLevX
            [value "iTraxxLevX"]
        + iTraxxSDI75Dealer
            [value "iTraxxSDI75Dealer"]
        + iTraxxSDI75NonDealer
            [value "iTraxxSDI75NonDealer"]
        + iTraxxSovX
            [value "iTraxxSovX"]

    DayCountFractionEnum:
        + ACT_360
            [value "ACT/360"]
        + ACT_365L
            [value "ACT/365L"]
        + ACT_365_FIXED
            [value "ACT/365.FIXED"]
        + ACT_ACT_AFB
            [value "ACT/ACT.AFB"]
        + ACT_ACT_ICMA
            [value "ACT/ACT.ICMA"]
        + ACT_ACT_ISMA
            [value "ACT/ACT.ISMA"]
        + ACT_ACT_ISDA
            [value "ACT/ACT.ISDA"]
        + CAL_252
            [value "CAL/252"]
            [value "BUS/252"]
        + _1_1
            [value "1/1"]
        + _30E_360
            [value "30E/360"]
        + _30E_360_ISDA
            [value "30E/360.ISDA"]
        + _30_360
            [value "30/360"]
        + RBA_BOND_BASIS
            [value "RBA"]

    DeterminationMethodEnum:
        + AgreedInitialPrice
            [value "AgreedInitialPrice"]
        + AsSpecifiedInMasterConfirmation
            [value "AsSpecifiedInMasterConfirmation"]
        + CalculationAgent
            [value "CalculationAgent"]
        + ClosingPrice
            [value "ClosingPrice"]
        + DividendCurrency
            [value "DividendCurrency"]
        + ExpiringContractLevel
            [value "ExpiringContractLevel"]
        + HedgeExecution
            [value "HedgeExecution"]
        + IssuerPaymentCurrency
            [value "IssuerPaymentCurrency"]
        + NAV
            [value "NAV"]
        + OpenPrice
            [value "OpenPrice"]
        + OSPPrice
            [value "OSPPrice"]
        + SettlementCurrency
            [value "SettlementCurrency"]
        + StrikeDateDetermination
            [value "StrikeDateDetermination"]
        + TWAPPrice
            [value "TWAPPrice"]
        + ValuationTime
            [value "ValuationTime"]
        + VWAPPrice
            [value "VWAPPrice"]

    DiscountingTypeEnum:
        + Standard
            [value "Standard"]
        + FRA
            [value "FRA"]
            [value "ISDA"]
        + FRAYield
            [value "FRAYield"]
        + AFMA
            [value "AFMA"]

    DividendAmountTypeEnum:
        + RecordAmount
            [value "RecordAmount"]
        + ExAmount
            [value "ExAmount"]
        + PaidAmount
            [value "PaidAmount"]
        + AsSpecifiedInMasterConfirmation
            [value "AsSpecifiedInMasterConfirmation"]

    DividendCompositionEnum:
        + EquityAmountReceiverElection
            [value "EquityAmountReceiverElection"]
        + CalculationAgentElection
            [value "CalculationAgentElection"]

    DividendDateReferenceEnum:
        + AdHocDate
            [value "AdHocDate"]
        + CashSettlementPaymentDate
            [value "CashSettlementPaymentDate"]
        + CashSettlePaymentDateExDiv
            [value "CashSettlePaymentDateExDiv"]
        + CashSettlePaymentDateIssuerPayment
            [value "CashSettlePaymentDateIssuerPayment"]
        + CumulativeEquityExDiv
            [value "CumulativeEquityExDiv"]
        + CumulativeEquityPaid
            [value "CumulativeEquityPaid"]
        + CumulativeInterestExDiv
            [value "CumulativeLiborExDiv"]
        + CumulativeInterestPaid
            [value "CumulativeLiborPaid"]
        + DividendPaymentDate
            [value "DividendPaymentDate"]
        + DividendValuationDate
            [value "DividendValuationDate"]
        + EquityPaymentDate
            [value "EquityPaymentDate"]
        + ExDate
            [value "ExDate"]
        + FloatingAmountPaymentDate
            [value "FloatingAmountPaymentDate"]
        + FollowingPaymentDate
            [value "FollowingPaymentDate"]
        + RecordDate
            [value "RecordDate"]
        + SharePayment
            [value "SharePayment"]
        + TerminationDate
            [value "TerminationDate"]

    DividendEntitlementEnum:
        + ExDate
            [value "ExDate"]

    DividendPeriodEnum:
        + FirstPeriod
            [value "FirstPeriod"]
        + SecondPeriod
            [value "SecondPeriod"]

    ExecutionTypeEnum:
        - Electronic
        + Electronic
            [value "Electronic"]
        + OffFacility
            [value "Voice"]

    GoverningLawEnum:
        + AsSpecifiedInMasterAgreement
            [value "AsSpecifiedInMasterAgreement"]
        + CAAB
            [value "CAAB"]
        + CABC
            [value "CABC"]
        + CAMN
            [value "CAMN"]
        + CAON
            [value "CAON"]
        + CAQC
            [value "CAQC"]
        + DE
            [value "DE"]
        + FR
            [value "FR"]
        + GBEN
            [value "GBEN"]
        + GBGY
            [value "GBGY"]
        + GBIM
            [value "GBIM"]
        + GBJY
            [value "GBJY"]
        + GBSC
            [value "GBSC"]
        + JP
            [value "JP"]
        + USCA
            [value "USCA"]
        + USDE
            [value "USDE"]
        + USIL
            [value "USIL"]
        + USNY
            [value "USNY"]

    IndexAnnexSourceEnum:
        + MasterConfirmation
            [value "MasterConfirmation"]
        + Publisher
            [value "Publisher"]

    IndexEventConsequenceEnum:
        + CalculationAgentAdjustment
            [value "CalculationAgentAdjustment"]
        + NegotiatedCloseOut
            [value "NegotiatedCloseOut"]
        + CancellationAndPayment
            [value "CancellationAndPayment"]
        + RelatedExchange
            [value "RelatedExchange"]

    InformationProviderEnum:
        + AssocBanksSingapore
            [value "AssocBanksSingapore"]
        + BankOfCanada
            [value "BankOfCanada"]
        + BankOfEngland
            [value "BankOfEngland"]
        + BankOfJapan
            [value "BankOfJapan"]
        + Bloomberg
            [value "Bloomberg"]
        + EuroCentralBank
            [value "EuroCentralBank"]
        + FHLBSF
            [value "FHLBSF"]
        + FederalReserve
            [value "FederalReserve"]
        + ISDA
            [value "ISDA"]
        + ReserveBankAustralia
            [value "ReserveBankAustralia"]
        + ReserveBankNewZealand
            [value "ReserveBankNewZealand"]
        + Reuters
            [value "Reuters"]
        + SAFEX
            [value "SAFEX"]
        + Telerate
            [value "Telerate"]

    InterestShortfallCapEnum:
        + Fixed
            [value "Fixed"]
        + Variable
            [value "Variable"]

    InterpolationMethodEnum:
        + LinearZeroYield
            [value "LinearZeroYield"]
        + None
            [value "None"]

    LengthUnitEnum:
        + Pages
            [value "Pages"]
        + TimeUnit
            [value "TimeUnit"]

    MarketDisruptionEnum:
        + ModifiedPostponement
            [value "ModifiedPostponement"]
        + Omission
            [value "Omission"]
        + Postponement
            [value "Postponement"]

    MasterAgreementTypeEnum:
        + AFB
            [value "AFB"]
        + Bespoke
            [value "Bespoke"]
        + CMA
            [value "CMA"]
        + CMOF
            [value "CMOF"]
        + EEIPower
            [value "EEIPower"]
        + EFETElectricity
            [value "EFETElectricity"]
        + EFETGas
            [value "EFETGas"]
        + EMA
            [value "EMA"]
        + FBF
            [value "FBF"]
        + GMRA
            [value "GMRA"]
        + GMSLA
            [value "GMSLA"]
        + GTMA
            [value "GTMA"]
        + GasEDI
            [value "GasEDI"]
        + German
            [value "German"]
        + ICOM
            [value "ICOM"]
        + IETA_ERPA
            [value "IETA-ERPA"]
        + IETA_ETMA
            [value "IETA-ETMA"]
        + IETA_IETMA
            [value "IETA-IETMA"]
        + IFEMA
            [value "IFEMA"]
        + IFEOMA
            [value "IFEOMA"]
        + ISDAMaster
            [value "ISDA"]
        + ISDAFIA_CDEA
            [value "ISDAFIA-CDEA"]
        + ISDAIIFM_TMA
            [value "ISDAIIFM-TMA"]
        + JSCC
            [value "JSCC"]
        + LBMA
            [value "LBMA"]
        + LEAP
            [value "LEAP"]
        + MCPSA
            [value "MCPSA"]
        + NAESBGas
            [value "NAESBGas"]
        + NBP
            [value "NBP"]
        + RussianDerivatives
            [value "RussianDerivatives"]
        + RussianRepo
            [value "RussianRepo"]
        + SCoTA
            [value "SCoTA"]
        + Swiss
            [value "Swiss"]
        + TTF
            [value "TTF"]
        + ZBT
            [value "ZBT"]

    MasterConfirmationAnnexTypeEnum:
        + ISDA2004IndexVarianceSwapAmericasInterdealer
            [value "ISDA2004IndexVarianceSwapAmericasInterdealer"]
        + ISDA2004ShareVarianceSwapAmericasInterdealer
            [value "ISDA2004ShareVarianceSwapAmericasInterdealer"]
        + ISDA2007DispersionVarianceSwapEuropean
            [value "ISDA2007DispersionVarianceSwapEuropean"]
        + ISDA2007EquityFinanceSwapEuropean
            [value "ISDA2007EquityFinanceSwapEuropean"]
        + ISDA2007IndexVarianceSwapAmericasInterdealer
            [value "ISDA2007IndexVarianceSwapAmericasInterdealer"]
        + ISDA2007ShareVarianceSwapAmericasInterdealer
            [value "ISDA2007ShareVarianceSwapAmericasInterdealer"]
        + ISDA2007VarianceOptionEuropean
            [value "ISDA2007VarianceOptionEuropean"]
        + ISDA2008EquityFinanceSwapAsiaExcludingJapan
            [value "ISDA2008EquityFinanceSwapAsiaExcludingJapan"]
        + ISDA2008EquityFinanceSwapAsiaExcludingJapanRev1
            [value "ISDA2008EquityFinanceSwapAsiaExcludingJapanRev1"]
        + ISDA2008EquityOptionAsiaExcludingJapan
            [value "ISDA2008EquityOptionAsiaExcludingJapan"]
        + ISDA2008EquityOptionAsiaExcludingJapanRev1
            [value "ISDA2008EquityOptionAsiaExcludingJapanRev1"]
        + ISDA2008EquityOptionJapan
            [value "ISDA2008EquityOptionJapan"]
        + ISDA2009ClosedMarketsOptionsAsiaExcludingJapan
            [value "ISDA2009ClosedMarketsOptionsAsiaExcludingJapan"]
        + ISDA2009EquityEuropeanIS
            [value "ISDA2009EquityEuropeanIS"]
        + ISDA2009EquityEuropeanInterdealerSS
            [value "ISDA2009EquityEuropeanInterdealerSS"]
        + ISDA2009IndexShareOptionAmericas
            [value "ISDA2009IndexShareOptionAmericas"]
        + ISDA2009IndexSwapEuropeanInterdealer
            [value "ISDA2009IndexSwapEuropeanInterdealer"]
        + ISDA2009IndexSwapPanAsiaInterdealer
            [value "ISDA2009IndexSwapPanAsiaInterdealer"]
        + ISDA2009ShareSwapPanAsia
            [value "ISDA2009ShareSwapPanAsia"]
        + ISDA2010FairValueShareSwapEuropeanInterdealer
            [value "ISDA2010FairValueShareSwapEuropeanInterdealer"]
        + ISDA2010IndexShareOptionEMEAInterdealer
            [value "ISDA2010IndexShareOptionEMEAInterdealer"]

    MasterConfirmationTypeEnum:
        + DJ_CDX_EM
            [value "DJ.CDX.EM"]
        + DJ_CDX_EM_DIV
            [value "DJ.CDX.EM.DIV"]
        + DJ_CDX_NA
            [value "DJ.CDX.NA"]
        + DJ_iTraxx_Europe
            [value "DJ.iTraxx.Europe"]
        + EquityAmericas
            [value "EquityAmericas"]
        + EquityAsia
            [value "EquityAsia"]
        + EquityEuropean
            [value "EquityEuropean"]
        + ISDA1999Credit
            [value "ISDA1999Credit"]
        + ISDA2003CreditAsia
            [value "ISDA2003CreditAsia"]
        + ISDA2003CreditAustraliaNewZealand
            [value "ISDA2003CreditAustraliaNewZealand"]
        + ISDA2003CreditEuropean
            [value "ISDA2003CreditEuropean"]
        + ISDA2003CreditJapan
            [value "ISDA2003CreditJapan"]
        + ISDA2003CreditNorthAmerican
            [value "ISDA2003CreditNorthAmerican"]
        + ISDA2003CreditSingapore
            [value "ISDA2003CreditSingapore"]
        + ISDA2003CreditSovereignAsia
            [value "ISDA2003CreditSovereignAsia"]
        + ISDA2003CreditSovereignCentralAndEasternEurope
            [value "ISDA2003CreditSovereignCentralAndEasternEurope"]
        + ISDA2003CreditSovereignJapan
            [value "ISDA2003CreditSovereignJapan"]
        + ISDA2003CreditSovereignLatinAmerica
            [value "ISDA2003CreditSovereignLatinAmerica"]
        + ISDA2003CreditSovereignMiddleEast
            [value "ISDA2003CreditSovereignMiddleEast"]
        + ISDA2003CreditSovereignWesternEurope
            [value "ISDA2003CreditSovereignWesternEurope"]
        + ISDA2003StandardCreditAsia
            [value "ISDA2003StandardCreditAsia"]
        + ISDA2003StandardCreditAustraliaNewZealand
            [value "ISDA2003StandardCreditAustraliaNewZealand"]
        + ISDA2003StandardCreditEuropean
            [value "ISDA2003StandardCreditEuropean"]
        + ISDA2003StandardCreditJapan
            [value "ISDA2003StandardCreditJapan"]
        + ISDA2003StandardCreditNorthAmerican
            [value "ISDA2003StandardCreditNorthAmerican"]
        + ISDA2003StandardCreditSingapore
            [value "ISDA2003StandardCreditSingapore"]
        + ISDA2004CreditSovereignAsia
            [value "ISDA2004CreditSovereignAsia"]
        + ISDA2004CreditSovereignEmergingEuropeanAndMiddleEastern
            [value "ISDA2004CreditSovereignEmergingEuropeanAndMiddleEastern"]
        + ISDA2004CreditSovereignJapan
            [value "ISDA2004CreditSovereignJapan"]
        + ISDA2004CreditSovereignLatinAmerican
            [value "ISDA2004CreditSovereignLatinAmerican"]
        + ISDA2004CreditSovereignWesternEuropean
            [value "ISDA2004CreditSovereignWesternEuropean"]
        + ISDA2004EquityAmericasInterdealer
            [value "ISDA2004EquityAmericasInterdealer"]
        + ISDA2004EquityAmericasInterdealerRev1
            [value "ISDA2004EquityAmericasInterdealerRev1"]
        + ISDA2004StandardCreditSovereignAsia
            [value "ISDA2004StandardCreditSovereignAsia"]
        + ISDA2004StandardCreditSovereignEmergingEuropeanAndMiddleEastern
            [value "ISDA2004StandardCreditSovereignEmergingEuropeanAndMiddleEastern"]
        + ISDA2004StandardCreditSovereignJapan
            [value "ISDA2004StandardCreditSovereignJapan"]
        + ISDA2004StandardCreditSovereignLatinAmerican
            [value "ISDA2004StandardCreditSovereignLatinAmerican"]
        + ISDA2004StandardCreditSovereignWesternEuropean
            [value "ISDA2004StandardCreditSovereignWesternEuropean"]
        + ISDA2005EquityAsiaExcludingJapanInterdealer
            [value "ISDA2005EquityAsiaExcludingJapanInterdealer"]
        + ISDA2005EquityAsiaExcludingJapanInterdealerRev2
            [value "ISDA2005EquityAsiaExcludingJapanInterdealerRev2"]
        + ISDA2005EquityJapaneseInterdealer
            [value "ISDA2005EquityJapaneseInterdealer"]
        + ISDA2006VarianceSwapJapanese
            [value "ISDA2006VarianceSwapJapanese"]
        + ISDA2006VarianceSwapJapaneseInterdealer
            [value "ISDA2006VarianceSwapJapaneseInterdealer"]
        + ISDA2007EquityEuropean
            [value "ISDA2007EquityEuropean"]
        + ISDA2007VarianceSwapAmericas
            [value "ISDA2007VarianceSwapAmericas"]
        + ISDA2007VarianceSwapAsiaExcludingJapan
            [value "ISDA2007VarianceSwapAsiaExcludingJapan"]
        + ISDA2007VarianceSwapAsiaExcludingJapanRev1
            [value "ISDA2007VarianceSwapAsiaExcludingJapanRev1"]
        + ISDA2007VarianceSwapAsiaExcludingJapanRev2
            [value "ISDA2007VarianceSwapAsiaExcludingJapanRev2"]
        + ISDA2007VarianceSwapEuropean
            [value "ISDA2007VarianceSwapEuropean"]
        + ISDA2007VarianceSwapEuropeanRev1
            [value "ISDA2007VarianceSwapEuropeanRev1"]
        + ISDA2008DividendSwapJapan
            [value "ISDA2008DividendSwapJapan"]
        + ISDA2008DividendSwapJapaneseRev1
            [value "ISDA2008DividendSwapJapaneseRev1"]
        + ISDA2008EquityAmericas
            [value "ISDA2008EquityAmericas"]
        + ISDA2008EquityAsiaExcludingJapan
            [value "ISDA2008EquityAsiaExcludingJapan"]
        + ISDA2008EquityAsiaExcludingJapanRev1
            [value "ISDA2008EquityAsiaExcludingJapanRev1"]
        + ISDA2008EquityJapan
            [value "ISDA2008EquityJapan"]
        + ISDA2009EquityAmericas
            [value "ISDA2009EquityAmericas"]
        + ISDA2009EquityEuropeanInterdealer
            [value "ISDA2009EquityEuropeanInterdealer"]
        + ISDA2009EquityPanAsia
            [value "ISDA2009EquityPanAsia"]
        + ISDA2010EquityEMEAInterdealer
            [value "ISDA2010EquityEMEAInterdealer"]
        + ISDA2013VolatilitySwapAmericas
            [value "ISDA2013VolatilitySwapAmericas"]
        + ISDA2013VolatilitySwapAsiaExcludingJapan
            [value "ISDA2013VolatilitySwapAsiaExcludingJapan"]
        + ISDA2013VolatilitySwapEuropean
            [value "ISDA2013VolatilitySwapEuropean"]
        + ISDA2013VolatilitySwapJapanese
            [value "ISDA2013VolatilitySwapJapanese"]
        + _2003CreditIndex
            [value "2003CreditIndex"]
        + _2004EquityEuropeanInterdealer
            [value "2004EquityEuropeanInterdealer"]
        + _2005VarianceSwapEuropeanInterdealer
            [value "2005VarianceSwapEuropeanInterdealer"]
        + _2006DividendSwapEuropean
            [value "2006DividendSwapEuropean"]
        + _2006DividendSwapEuropeanInterdealer
            [value "2006DividendSwapEuropeanInterdealer"]
        + _2014CreditAsia
            [value "2014CreditAsia"]
        + _2014CreditAsiaFinancial
            [value "2014CreditAsiaFinancial"]
        + _2014CreditAustraliaNewZealand
            [value "2014CreditAustraliaNewZealand"]
        + _2014CreditAustraliaNewZealandFinancial
            [value "2014CreditAustraliaNewZealandFinancial"]
        + _2014CreditEuropean
            [value "2014CreditEuropean"]
        + _2014CreditEuropeanCoCoFinancial
            [value "2014CreditEuropeanCoCoFinancial"]
        + _2014CreditEuropeanFinancial
            [value "2014CreditEuropeanFinancial"]
        + _2014CreditJapan
            [value "2014CreditJapan"]
        + _2014CreditJapanFinancial
            [value "2014CreditJapanFinancial"]
        + _2014CreditNorthAmerican
            [value "2014CreditNorthAmerican"]
        + _2014CreditNorthAmericanFinancial
            [value "2014CreditNorthAmericanFinancial"]
        + _2014CreditSingapore
            [value "2014CreditSingapore"]
        + _2014CreditSingaporeFinancial
            [value "2014CreditSingaporeFinancial"]
        + _2014CreditSovereignAsia
            [value "2014CreditSovereignAsia"]
        + _2014CreditSovereignEmergingEuropeanAndMiddleEastern
            [value "2014CreditSovereignEmergingEuropeanAndMiddleEastern"]
        + _2014CreditSovereignJapan
            [value "2014CreditSovereignJapan"]
        + _2014CreditSovereignLatinAmerican
            [value "2014CreditSovereignLatinAmerican"]
        + _2014CreditSovereignWesternEuropean
            [value "2014CreditSovereignWesternEuropean"]
        + _2014StandardCreditAsia
            [value "2014StandardCreditAsia"]
        + _2014StandardCreditAsiaFinancial
            [value "2014StandardCreditAsiaFinancial"]
        + _2014StandardCreditAustraliaNewZealand
            [value "2014StandardCreditAustraliaNewZealand"]
        + _2014StandardCreditAustraliaNewZealandFinancial
            [value "2014StandardCreditAustraliaNewZealandFinancial"]
        + _2014StandardCreditEuropean
            [value "2014StandardCreditEuropean"]
        + _2014StandardCreditEuropeanCoCoFinancial
            [value "2014StandardCreditEuropeanCoCoFinancial"]
        + _2014StandardCreditEuropeanFinancial
            [value "2014StandardCreditEuropeanFinancial"]
        + _2014StandardCreditJapan
            [value "2014StandardCreditJapan"]
        + _2014StandardCreditJapanFinancial
            [value "2014StandardCreditJapanFinancial"]
        + _2014StandardCreditNorthAmerican
            [value "2014StandardCreditNorthAmerican"]
        + _2014StandardCreditNorthAmericanFinancial
            [value "2014StandardCreditNorthAmericanFinancial"]
        + _2014StandardCreditSingapore
            [value "2014StandardCreditSingapore"]
        + _2014StandardCreditSingaporeFinancial
            [value "2014StandardCreditSingaporeFinancial"]
        + _2014StandardCreditSovereignAsia
            [value "2014StandardCreditSovereignAsia"]
        + _2014StandardCreditSovereignEmergingEuropeanAndMiddleEastern
            [value "2014StandardCreditSovereignEmergingEuropeanAndMiddleEastern"]
        + _2014StandardCreditSovereignJapan
            [value "2014StandardCreditSovereignJapan"]
        + _2014StandardCreditSovereignLatinAmerican
            [value "2014StandardCreditSovereignLatinAmerican"]
        + _2014StandardCreditSovereignWesternEuropean
            [value "2014StandardCreditSovereignWesternEuropean"]

    MatrixTermEnum:
        + AsiaCorporate
            [value "AsiaCorporate"]
        + AsiaFinancialCorporate
            [value "AsiaFinancialCorporate"]
        + AsiaSovereign
            [value "AsiaSovereign"]
        + AustraliaCorporate
            [value "AustraliaCorporate"]
        + AustraliaFinancialCorporate
            [value "AustraliaFinancialCorporate"]
        + AustraliaSovereign
            [value "AustraliaSovereign"]
        + EmergingEuropeanAndMiddleEasternSovereign
            [value "EmergingEuropeanAndMiddleEasternSovereign"]
        + EmergingEuropeanCorporate
            [value "EmergingEuropeanCorporate"]
        + EmergingEuropeanCorporateLPN
            [value "EmergingEuropeanCorporateLPN"]
        + EmergingEuropeanFinancialCorporate
            [value "EmergingEuropeanFinancialCorporate"]
        + EmergingEuropeanFinancialCorporateLPN
            [value "EmergingEuropeanFinancialCorporateLPN"]
        + EuropeanCoCoFinancialCorporate
            [value "EuropeanCoCoFinancialCorporate"]
        + EuropeanCorporate
            [value "EuropeanCorporate"]
        + EuropeanFinancialCorporate
            [value "EuropeanFinancialCorporate"]
        + EuropeanSeniorNonPreferredFinancialCorporate
            [value "EuropeanSeniorNonPreferredFinancialCorporate"]
        + IVS1OpenMarkets
            [value "IVS1OpenMarkets"]
        + JapanCorporate
            [value "JapanCorporate"]
        + JapanFinancialCorporate
            [value "JapanFinancialCorporate"]
        + JapanSovereign
            [value "JapanSovereign"]
        + LatinAmericaCorporate
            [value "LatinAmericaCorporate"]
        + LatinAmericaCorporateBond
            [value "LatinAmericaCorporateBond"]
        + LatinAmericaCorporateBondOrLoan
            [value "LatinAmericaCorporateBondOrLoan"]
        + LatinAmericaFinancialCorporateBond
            [value "LatinAmericaFinancialCorporateBond"]
        + LatinAmericaFinancialCorporateBondOrLoan
            [value "LatinAmericaFinancialCorporateBondOrLoan"]
        + LatinAmericaSovereign
            [value "LatinAmericaSovereign"]
        + NewZealandCorporate
            [value "NewZealandCorporate"]
        + NewZealandFinancialCorporate
            [value "NewZealandFinancialCorporate"]
        + NewZealandSovereign
            [value "NewZealandSovereign"]
        + NorthAmericanCorporate
            [value "NorthAmericanCorporate"]
        + NorthAmericanFinancialCorporate
            [value "NorthAmericanFinancialCorporate"]
        + SingaporeCorporate
            [value "SingaporeCorporate"]
        + SingaporeFinancialCorporate
            [value "SingaporeFinancialCorporate"]
        + SingaporeSovereign
            [value "SingaporeSovereign"]
        + StandardAsiaCorporate
            [value "StandardAsiaCorporate"]
        + StandardAsiaFinancialCorporate
            [value "StandardAsiaFinancialCorporate"]
        + StandardAsiaSovereign
            [value "StandardAsiaSovereign"]
        + StandardAustraliaCorporate
            [value "StandardAustraliaCorporate"]
        + StandardAustraliaFinancialCorporate
            [value "StandardAustraliaFinancialCorporate"]
        + StandardAustraliaSovereign
            [value "StandardAustraliaSovereign"]
        + StandardEmergingEuropeanAndMiddleEasternSovereign
            [value "StandardEmergingEuropeanAndMiddleEasternSovereign"]
        + StandardEmergingEuropeanCorporate
            [value "StandardEmergingEuropeanCorporate"]
        + StandardEmergingEuropeanCorporateLPN
            [value "StandardEmergingEuropeanCorporateLPN"]
        + StandardEmergingEuropeanFinancialCorporate
            [value "StandardEmergingEuropeanFinancialCorporate"]
        + StandardEmergingEuropeanFinancialCorporateLPN
            [value "StandardEmergingEuropeanFinancialCorporateLPN"]
        + StandardEuropeanCoCoFinancialCorporate
            [value "StandardEuropeanCoCoFinancialCorporate"]
        + StandardEuropeanCorporate
            [value "StandardEuropeanCorporate"]
        + StandardEuropeanFinancialCorporate
            [value "StandardEuropeanFinancialCorporate"]
        + StandardEuropeanSeniorNonPreferredFinancialCorporate
            [value "StandardEuropeanSeniorNonPreferredFinancialCorporate"]
        + StandardJapanCorporate
            [value "StandardJapanCorporate"]
        + StandardJapanFinancialCorporate
            [value "StandardJapanFinancialCorporate"]
        + StandardJapanSovereign
            [value "StandardJapanSovereign"]
        + StandardLatinAmericaCorporateBond
            [value "StandardLatinAmericaCorporateBond"]
        + StandardLatinAmericaCorporateBondOrLoan
            [value "StandardLatinAmericaCorporateBondOrLoan"]
        + StandardLatinAmericaFinancialCorporateBond
            [value "StandardLatinAmericaFinancialCorporateBond"]
        + StandardLatinAmericaFinancialCorporateBondOrLoan
            [value "StandardLatinAmericaFinancialCorporateBondOrLoan"]
        + StandardLatinAmericaSovereign
            [value "StandardLatinAmericaSovereign"]
        + StandardNewZealandCorporate
            [value "StandardNewZealandCorporate"]
        + StandardNewZealandFinancialCorporate
            [value "StandardNewZealandFinancialCorporate"]
        + StandardNewZealandSovereign
            [value "StandardNewZealandSovereign"]
        + StandardNorthAmericanCorporate
            [value "StandardNorthAmericanCorporate"]
        + StandardNorthAmericanFinancialCorporate
            [value "StandardNorthAmericanFinancialCorporate"]
        + StandardSingaporeCorporate
            [value "StandardSingaporeCorporate"]
        + StandardSingaporeFinancialCorporate
            [value "StandardSingaporeFinancialCorporate"]
        + StandardSingaporeSovereign
            [value "StandardSingaporeSovereign"]
        + StandardSubordinatedEuropeanInsuranceCorporate
            [value "StandardSubordinatedEuropeanInsuranceCorporate"]
        + StandardSukukFinancialCorporate
            [value "StandardSukukFinancialCorporate"]
        + StandardUSMunicipalFullFaithAndCredit
            [value "StandardUSMunicipalFullFaithAndCredit"]
        + StandardUSMunicipalGeneralFund
            [value "StandardUSMunicipalGeneralFund"]
        + StandardUSMunicipalRevenue
            [value "StandardUSMunicipalRevenue"]
        + StandardWesternEuropeanSovereign
            [value "StandardWesternEuropeanSovereign"]
        + SubordinatedEuropeanInsuranceCorporate
            [value "SubordinatedEuropeanInsuranceCorporate"]
        + SukukCorporate
            [value "SukukCorporate"]
        + SukukFinancialCorporate
            [value "SukukFinancialCorporate"]
        + SukukSovereign
            [value "SukukSovereign"]
        + USMunicipalFullFaithAndCredit
            [value "USMunicipalFullFaithAndCredit"]
        + USMunicipalGeneralFund
            [value "USMunicipalGeneralFund"]
        + USMunicipalRevenue
            [value "USMunicipalRevenue"]
        + WesternEuropeanSovereign
            [value "WesternEuropeanSovereign"]

    MatrixTypeEnum:
        + CreditDerivativesPhysicalSettlementMatrix
            [value "CreditDerivativesPhysicalSettlementMatrix"]
        + EquityDerivativesMatrix
            [value "EquityDerivativesMatrix"]
        + SettlementMatrix
            [value "SettlementMatrix"]

    NationalizationOrInsolvencyOrDelistingEventEnum:
        + NegotiatedCloseout
            [value "NegotiatedCloseout"]
        + CancellationAndPayment
            [value "CancellationAndPayment"]

    NegativeInterestRateTreatmentEnum:
        + NegativeInterestRateMethod
            [value "NegativeInterestRateMethod"]
        + ZeroInterestRateMethod
            [value "ZeroInterestRateMethod"]
        + ZeroInterestRateExcludingSpreadMethod
            [value "ZeroInterestRateMethodExcludingSpread"]

    NonCashDividendTreatmentEnum:
        + PotentialAdjustmentEvent
            [value "PotentialAdjustmentEvent"]
        + CashEquivalent
            [value "CashEquivalent"]

    NotionalAdjustmentEnum:
        + Execution
            [value "Execution"]
        + PortfolioRebalancing
            [value "PortfolioRebalancing"]
        + Standard
            [value "Standard"]

    PutCallEnum:
        + Put
            [value "Put"]
            [value "CallCurrencyPerPutCurrency"]
        + Call
            [value "Call"]
            [value "PutCurrencyPerCallCurrency"]

    OptionTypeEnum:
        + Payer
            [value "Payer"]
        + Receiver
            [value "Receiver"]
        + Straddle
            [value "Straddle"]

    PayRelativeToEnum:
        + CalculationPeriodStartDate
            [value "CalculationPeriodStartDate"]
        + CalculationPeriodEndDate
            [value "CalculationPeriodEndDate"]
        + LastPricingDate
            [value "LastPricingDate"]
        + ResetDate
            [value "ResetDate"]
        + ValuationDate
            [value "ValuationDate"]

    PremiumTypeEnum:
        + PrePaid
            [value "PrePaid"]
        + PostPaid
            [value "PostPaid"]
        + Variable
            [value "Variable"]
        + Fixed
            [value "Fixed"]

    PriceExpressionEnum:
        + AbsoluteTerms
            [value "AbsoluteTerms"]
        + PercentageOfNotional
            [value "PercentageOfNotional"]

    QuotationRateTypeEnum:
        + Bid
            [value "Bid"]
        + Ask
            [value "Ask"]
        + Mid
            [value "Mid"]
        + ExercisingPartyPays
            [value "ExercisingPartyPays"]

    QuotationSideEnum:
        + Afternoon
            [value "Afternoon"]
        + Ask
            [value "Ask"]
        + Bid
            [value "Bid"]
        + Closing
            [value "Closing"]
        + High
            [value "High"]
        + Index
            [value "Index"]
        + MeanOfBidAndAsk
            [value "MeanOfBidAndAsk"]
        + LocationalMarginal
            [value "LocationalMarginal"]
        + Low
            [value "Low"]
        + MarginalHourly
            [value "MarginalHourly"]
        + MarketClearing
            [value "MarketClearing"]
        + MeanOfHighAndLow
            [value "MeanOfHighAndLow"]
        + Morning
            [value "Morning"]
        + Official
            [value "Official"]
        + Opening
            [value "Opening"]
        + OSP
            [value "OSP"]
        + Settlement
            [value "Settlement"]
        + Spot
            [value "Spot"]
        + Mid
            [value "Mid"]
            [value "Midpoint"]
        + Settlement
            [value "Settlement"]
        + NationalSingle
            [value "NationalSingle"]
        + WeightedAverage
            [value "WeightedAverage"]
        + UnWeightedAverage
            [value "UnWeightedAverage"]

    QuotationStyleEnum:
        + PointsUpFront
            [value "PointsUpFront"]
        + TradedSpread
            [value "TradedSpread"]
        + Price
            [value "Price"]

    QuoteBasisEnum:
        + Currency1PerCurrency2
            [value "Currency1PerCurrency2"]
            [value "PutCurrencyPerCallCurrency"]
        + Currency2PerCurrency1
            [value "Currency2PerCurrency1"]
            [value "CallCurrencyPerPutCurrency"]

    RateTreatmentEnum:
        + BondEquivalentYield
            [value "BondEquivalentYield"]
        + MoneyMarketYield
            [value "MoneyMarketYield"]

    ResetRelativeToEnum:
        + CalculationPeriodStartDate
            [value "CalculationPeriodStartDate"]
        + CalculationPeriodEndDate
            [value "CalculationPeriodEndDate"]

    ResourceTypeEnum:
        + Confirmation
            [value "Confirmation"]
        + SupplementalMaterialEconomicTerms
            [value "SupplementalMaterialEconomicTerms"]
        + TermSheet
            [value "TermSheet"]

    RestructuringEnum:
        + ModModR
            [value "ModModR"]
        + ModR
            [value "ModR"]
        + R
            [value "R"]

    ReturnTypeEnum:
        + Price
            [value "Price"]
        + Total
            [value "Total"]

    RollConventionEnum:
        + EOM
            [value "EOM"]
        + FRN
            [value "FRN"]
        + IMM
            [value "IMM"]
        + IMMCAD
            [value "IMMCAD"]
        + IMMAUD
            [value "IMMAUD"]
        + IMMNZD
            [value "IMMNZD"]
        + SFE
            [value "SFE"]
        + NONE
            [value "NONE"]
        + TBILL
            [value "TBILL"]
        + _1
            [value "1"]
        + _2
            [value "2"]
        + _3
            [value "3"]
        + _4
            [value "4"]
        + _5
            [value "5"]
        + _6
            [value "6"]
        + _7
            [value "7"]
        + _8
            [value "8"]
        + _9
            [value "9"]
        + _10
            [value "10"]
        + _11
            [value "11"]
        + _12
            [value "12"]
        + _13
            [value "13"]
        + _14
            [value "14"]
        + _15
            [value "15"]
        + _16
            [value "16"]
        + _17
            [value "17"]
        + _18
            [value "18"]
        + _19
            [value "19"]
        + _20
            [value "20"]
        + _21
            [value "21"]
        + _22
            [value "22"]
        + _23
            [value "23"]
        + _24
            [value "24"]
        + _25
            [value "25"]
        + _26
            [value "26"]
        + _27
            [value "27"]
        + _28
            [value "28"]
        + _29
            [value "29"]
        + _30
            [value "30"]
        + MON
            [value "MON"]
        + TUE
            [value "TUE"]
        + WED
            [value "WED"]
        + THU
            [value "THU"]
        + FRI
            [value "FRI"]
        + SAT
            [value "SAT"]
        + SUN
            [value "SUN"]

    SettledEntityMatrixSourceEnum:
        + ConfirmationAnnex
            [value "ConfirmationAnnex"]
        + NotApplicable
            [value "NotApplicable"]
        + Publisher
            [value "Publisher"]

    SettlementRateOptionEnum:
        + ARS_BNAR_ARS01
            [value "ARS.BNAR/ARS01"]
            [value "ARS01"]
        + ARS_EMTA_INDICATIVE_SURVEY_RATE_ARS04
            [value "ARS.EMTA.INDICATIVE.SURVEY.RATE/ARS04"]
            [value "ARS04"]
        + ARS_EMTA_INDUSTRY_SURVEY_RATE_ARS03
            [value "ARS.EMTA.INDUSTRY.SURVEY.RATE/ARS03"]
            [value "ARS03"]
        + ARS_MAE_ARS05
            [value "ARS.MAE/ARS05"]
            [value "ARS05"]
        + ARS_OFFICIAL_RATE_ARS02
            [value "ARS.OFFICIAL.RATE/ARS02"]
            [value "ARS02"]
        + BRL_BRBY_BRL01
            [value "BRL.BRBY/BRL01"]
            [value "BRL01"]
        + BRL_EMTA_INDICATIVE_SURVEY_RATE_BRL13
            [value "BRL.EMTA.INDICATIVE.SURVEY.RATE/BRL13"]
            [value "BRL13"]
        + BRL_EMTA_INDUSTRY_SURVEY_RATE_BRL12
            [value "BRL.EMTA.INDUSTRY.SURVEY.RATE/BRL12"]
            [value "BRL12"]
        + BRL_OFFICIAL_RATE_BRL02
            [value "BRL.OFFICIAL.RATE/BRL02"]
            [value "BRL02"]
        + BRL_PCOT_COMMERCIAL_BRL03
            [value "BRL.PCOT-COMMERCIAL/BRL03"]
            [value "BRL03"]
        + BRL_PCOT_FLOATING_BRL04
            [value "BRL.PCOT-FLOATING/BRL04"]
            [value "BRL04"]
        + BRL_PTAX_BRL09
            [value "BRL.PTAX/BRL09"]
            [value "BRL09"]
        + BRL_PTAX_COMMERCIAL_BRFR_BRL06
            [value "BRL.PTAX-COMMERCIAL.BRFR/BRL06"]
            [value "BRL06"]
        + BRL_PTAX_COMMERCIAL_BRL05
            [value "BRL.PTAX-COMMERCIAL/BRL05"]
            [value "BRL05"]
        + BRL_PTAX_FLOATING_BRFR_BRL08
            [value "BRL.PTAX-FLOATING.BRFR/BRL08"]
            [value "BRL08"]
        + BRL_PTAX_FLOATING_BRL07
            [value "BRL.PTAX-FLOATING/BRL07"]
            [value "BRL07"]
        + CLP_BCCH_CLP01
            [value "CLP.BCCH/CLP01"]
            [value "CLP01"]
        + CLP_CHILD_INFORMAL_CLP02
            [value "CLP.CHILD-INFORMAL/CLP02"]
            [value "CLP02"]
        + CLP_CHILD_INTERBANK_CLP03
            [value "CLP.CHILD-INTERBANK/CLP03"]
            [value "CLP03"]
        + CLP_CHILD_OBSERVADO_CLP04
            [value "CLP.CHILD-OBSERVADO/CLP04"]
            [value "CLP04"]
        + CLP_CHILG_INFORMAL_CLP05
            [value "CLP.CHILG-INFORMAL/CLP05"]
            [value "CLP05"]
        + CLP_CHILG_INTERBANK_CLP06
            [value "CLP.CHILG-INTERBANK/CLP06"]
            [value "CLP06"]
        + CLP_CHILG_OBSERVADO_CLP07
            [value "CLP.CHILG-OBSERVADO/CLP07"]
            [value "CLP07"]
        + CLP_DOLAR_OBS_CLP10
            [value "CLP.DOLAR.OBS/CLP10"]
            [value "CLP10"]
        + CLP_EMTA_INDICATIVE_SURVEY_RATE_CLP11
            [value "CLP.EMTA.INDICATIVE.SURVEY.RATE/CLP11"]
            [value "CLP11"]
        + CLP_OFFICIAL_RATE_CLP08
            [value "CLP.OFFICIAL.RATE/CLP08"]
            [value "CLP08"]
        + CLP_TELERATE_38942_CLP09
            [value "CLP.TELERATE.38942/CLP09"]
            [value "CLP09"]
        + CNY_SAEC_CNY01
            [value "CNY.SAEC/CNY01"]
            [value "CNY01"]
        + CNY_SFEMC_INDICATIVE_SURVEY_RATE_CNY02
            [value "CNY.SFEMC.INDICATIVE.SURVEY.RATE/CNY02"]
            [value "CNY02"]
        + COP_CO_COL03_COP01
            [value "COP.CO/COL03/COP01"]
            [value "COP01"]
        + COP_EMTA_INDICATIVE_SURVEY_RATE_COP03
            [value "COP.EMTA.INDICATIVE.SURVEY.RATE/COP03"]
            [value "COP03"]
        + COP_TRM_COP02
            [value "COP.TRM/COP02"]
            [value "COP02"]
        + CURRENCY_IMPLIED_RATE__ADR__CURA1
            [value "CURRENCY-IMPLIED.RATE.(ADR)/CURA1"]
            [value "CURA1"]
        + CURRENCY_IMPLIED_RATE__LOCAL_ASSET__CURA2
            [value "CURRENCY-IMPLIED.RATE.(LOCAL.ASSET)/CURA2"]
            [value "CURA2"]
        + CURRENCY_MUTUAL_AGREEMENT_CURA3
            [value "CURRENCY-MUTUAL.AGREEMENT/CURA3"]
            [value "CURA3"]
        + CURRENCY_REFERENCE_DEALERS_CURA4
            [value "CURRENCY-REFERENCE.DEALERS/CURA4"]
            [value "CURA4"]
        + CURRENCY_WHOLESALE_MARKET_CURA5
            [value "CURRENCY-WHOLESALE.MARKET/CURA5"]
            [value "CURA5"]
        + ECS_DNRP_ECS01
            [value "ECS.DNRP/ECS01"]
            [value "ECS01"]
        + IDR_ABS_IDR01
            [value "IDR.ABS/IDR01"]
            [value "IDR01"]
        + IDR_JISDOR_IDR04
            [value "IDR.JISDOR/IDR04"]
            [value "IDR04"]
        + IDR_SFEMC_INDICATIVE_SURVEY_RATE_IDR02
            [value "IDR.SFEMC.INDICATIVE.SURVEY.RATE/IDR02"]
            [value "IDR02"]
        + IDR_VWAP_IDR03
            [value "IDR.VWAP/IDR03"]
            [value "IDR03"]
        + ILS_BOIJ_ILS01
            [value "ILS.BOIJ/ILS01"]
            [value "ILS01"]
        + ILS_FXIL_ILS02
            [value "ILS.FXIL/ILS02"]
            [value "ILS02"]
        + INR_FBIL_INR01
            [value "INR.FBIL/INR01"]
        + INR_RBIB_INR01
            [value "INR.RBIB/INR01"]
        + INR_SFEMC_INDICATIVE_SURVEY_RATE_INR02
            [value "INR.SFEMC.INDICATIVE.SURVEY.RATE/INR02"]
            [value "INR02"]
        + KRW_KEBEY_KRW01
            [value "KRW.KEBEY/KRW01"]
            [value "KRW01"]
        + KRW_KFTC18_KRW02
            [value "KRW.KFTC18/KRW02"]
            [value "KRW02"]
        + KRW_SFEMC_INDICATIVE_SURVEY_RATE_KRW04
            [value "KRW.SFEMC.INDICATIVE.SURVEY.RATE/KRW04"]
            [value "KRW04"]
        + KRW_TELERATE_45644_KRW03
            [value "KRW.TELERATE.45644/KRW03"]
            [value "KRW03"]
        + KZT_EMTA_INDICATIVE_SURVEY_RATE_KZT02
            [value "KZT.EMTA.INDICATIVE.SURVEY.RATE/KZT02"]
            [value "KZT02"]
        + KZT_KASE_KZT01
            [value "KZT.KASE/KZT01"]
            [value "KZT01"]
        + LBP_BDLX_LBP01
            [value "LBP.BDLX/LBP01"]
            [value "LBP01"]
        + MAD_OFFICIAL_RATE_MAD01
            [value "MAD.OFFICIAL.RATE/MAD01"]
            [value "MAD01"]
        + MXP_BNMX_MXP01
            [value "MXP.BNMX/MXP01"]
            [value "MXP01"]
        + MXP_FIXING_RATE_MXP02
            [value "MXP.FIXING.RATE/MXP02"]
            [value "MXP02"]
        + MXP_MEX01_MXP03
            [value "MXP.MEX01/MXP03"]
            [value "MXP03"]
        + MXP_PUBLISHED_MXP04
            [value "MXP.PUBLISHED/MXP04"]
            [value "MXP04"]
        + MYR_ABS_MYR01
            [value "MYR.ABS/MYR01"]
            [value "MYR01"]
        + MYR_KL_REF_MYR04
            [value "MYR.KL.REF/MYR04"]
            [value "MYR04"]
        + MYR_PPKM_MYR03
            [value "MYR.PPKM/MYR03"]
            [value "MYR03"]
        + MYR_SFEMC_INDICATIVE_SURVEY_RATE_MYR02
            [value "MYR.SFEMC.INDICATIVE.SURVEY.RATE/MYR02"]
            [value "MYR02"]
        + PEN_EMTA_INDICATIVE_SURVEY_RATE_PEN04
            [value "PEN.EMTA.INDICATIVE.SURVEY.RATE/PEN04"]
            [value "PEN04"]
        + PEN_INTERBANK_AVE_PEN05
            [value "PEN.INTERBANK.AVE/PEN05"]
            [value "PEN05"]
        + PEN_PDSB_PEN01
            [value "PEN.PDSB/PEN01"]
            [value "PEN01"]
        + PEN_WT_AVE_PEN03
            [value "PEN.WT.AVE/PEN03"]
            [value "PEN03"]
        + PHP_BAPPESO_PHP06
            [value "PHP.BAPPESO/PHP06"]
        + PHP_PDSPESO_PHP06
            [value "PHP.PDSPESO/PHP06"]
        + PHP_PHPESO_PHP01
            [value "PHP.PHPESO/PHP01"]
            [value "PHP01"]
        + PHP_SFEMC_INDICATIVE_SURVEY_RATE_PHP05
            [value "PHP.SFEMC.INDICATIVE.SURVEY.RATE/PHP05"]
            [value "PHP05"]
        + PHP_TELERATE_15439_PHP03
            [value "PHP.TELERATE.15439/PHP03"]
            [value "PHP03"]
        + PHP_TELERATE_2920_PHP02
            [value "PHP.TELERATE.2920/PHP02"]
            [value "PHP02"]
        + PKR_SBPK_PKR01
            [value "PKR.SBPK/PKR01"]
            [value "PKR01"]
        + PKR_SFEMC_INDICATIVE_SURVEY_RATE_PKR02
            [value "PKR.SFEMC.INDICATIVE.SURVEY.RATE/PKR02"]
            [value "PKR02"]
        + PLZ_NBPQ_PLZ01
            [value "PLZ.NBPQ/PLZ01"]
            [value "PLZ01"]
        + PLZ_NBPR_PLZ02
            [value "PLZ.NBPR/PLZ02"]
            [value "PLZ02"]
        + RUB_CME_EMTA_RUB03
            [value "RUB.CME-EMTA/RUB03"]
            [value "RUB03"]
        + RUB_EMTA_INDICATIVE_SURVEY_RATE_RUB04
            [value "RUB.EMTA.INDICATIVE.SURVEY.RATE/RUB04"]
            [value "RUB04"]
        + RUB_MICEXFRX_RUB01
            [value "RUB.MICEXFRX/RUB01"]
            [value "RUB01"]
        + RUB_MMVB_RUB02
            [value "RUB.MMVB/RUB02"]
            [value "RUB02"]
        + SGD_VWAP_SGD3
            [value "SGD.VWAP/SGD3"]
            [value "SGD3"]
        + SKK_NBSB_SKK01
            [value "SKK.NBSB/SKK01"]
            [value "SKK01"]
        + THB_ABS_THB01
            [value "THB.ABS/THB01"]
        + THB_VWAP_THB01
            [value "THB.VWAP/THB01"]
        + TWD_SFEMC_INDICATIVE_SURVEY_RATE_TWD04
            [value "TWD.SFEMC.INDICATIVE.SURVEY.RATE/TWD04"]
            [value "TWD04"]
        + TWD_TAIFX1_TWD03
            [value "TWD.TAIFX1/TWD03"]
            [value "TWD03"]
        + TWD_TELERATE_6161_TWD01
            [value "TWD.TELERATE.6161/TWD01"]
            [value "TWD01"]
        + TWD_TFEMA_TWD02
            [value "TWD.TFEMA/TWD02"]
            [value "TWD02"]
        + UAH_EMTA_INDICATIVE_SURVEY_RATE_UAH03
            [value "UAH.EMTA.INDICATIVE.SURVEY.RATE/UAH03"]
            [value "UAH03"]
        + UAH_EMTA_INDUSTRY_SURVEY_RATE_UAH02
            [value "UAH.EMTA.INDUSTRY.SURVEY.RATE/UAH02"]
            [value "UAH02"]
        + UAH_GFI_UAH01
            [value "UAH.GFI/UAH01"]
            [value "UAH01"]
        + VEF_FIX_VEF01
            [value "VEF.FIX/VEF01"]
            [value "VEF01"]
        + VND_ABS_VND01
            [value "VND.ABS/VND01"]
            [value "VND01"]
        + VND_FX_VND02
            [value "VND.FX/VND02"]
            [value "VND02"]
        + VND_SFEMC_INDICATIVE_SURVEY_RATE_VND03
            [value "VND.SFEMC.INDICATIVE.SURVEY.RATE/VND03"]
            [value "VND03"]

    ShareExtraordinaryEventEnum:
        + AlternativeObligation
            [value "AlternativeObligation"]
        + CancellationAndPayment
            [value "CancellationAndPayment"]
        + OptionsExchange
            [value "OptionsExchange"]
        + CalculationAgent
            [value "CalculationAgent"]
        + ModifiedCalculationAgent
            [value "ModifiedCalculationAgent"]
        + PartialCancellationAndPayment
            [value "PartialCancellationAndPayment"]
        + Component
            [value "Component"]

    SpreadScheduleTypeEnum:
        + Long
            [value "Long"]
        + Short
            [value "Short"]

    StubPeriodTypeEnum:
        + ShortInitial
            [value "ShortInitial"]
        + ShortFinal
            [value "ShortFinal"]
        + LongInitial
            [value "LongInitial"]
        + LongFinal
            [value "LongFinal"]

    TriggerTypeEnum:
        + EqualOrLess
            [value "EqualOrLess"]
        + EqualOrGreater
            [value "EqualOrGreater"]
        + Equal
            [value "Equal"]
        + Less
            [value "Less"]
        + Greater
            [value "Greater"]

    TimeTypeEnum:
        + Close
            [value "Close"]
        + Open
            [value "Open"]
        + OSP
            [value "OSP"]
        + SpecificTime
            [value "SpecificTime"]
        + XETRA
            [value "XETRA"]
        + DerivativesClose
            [value "DerivativesClose"]
        + AsSpecifiedInMasterConfirmation
            [value "AsSpecifiedInMasterConfirmation"]

    TriggerTimeTypeEnum:
        + Closing
            [value "Closing"]
        + Anytime
            [value "Anytime"]

    ValuationMethodEnum:
        + Market
            [value "Market"]
        + Highest
            [value "Highest"]
        + AverageMarket
            [value "AverageMarket"]
        + AverageHighest
            [value "AverageHighest"]
        + BlendedMarket
            [value "BlendedMarket"]
        + BlendedHighest
            [value "BlendedHighest"]
        + AverageBlendedMarket
            [value "AverageBlendedMarket"]
        + AverageBlendedHighest
            [value "AverageBlendedHighest"]

    WeeklyRollConventionEnum:
        + TBILL
            [value "TBILL"]

    AveragingCalculationMethodEnum:
        + Arithmetic
            [value "Unweighted"]
            [value "Weighted"]
            [value "Arithmetic"]
        + Geometric
            [value "Geometric"]
        + Harmonic
            [value "Harmonic"]

    RoundingDirectionEnum:
        + Up
            [value "Up"]
        + Down
            [value "Down"]
        + Nearest
            [value "Nearest"]

    QuantifierEnum:
        + All
            [value "All"]
        + Any
            [value "Any"]

    ScheduledTransferEnum:
        + Coupon
            [value "Coupon"]
        + CreditEvent
            [value "CreditEvent"]
        + DividendReturn
            [value "DividendReturn"]
        + Exercise
            [value "ExerciseFee"]
        + InterestReturn
            [value "InterestReturn"]
        + Performance
            [value "PriceReturn"]
        + PrincipalPayment
            [value "PrincipleExchange"]

    FeeTypeEnum:
        + Renegotiation
            [value "AmendmentFee"]
        + Assignment
            [value "AssignmentFee"]
        + Increase
            [value "IncreaseFee"]
        + PartialTermination
            [value "PartialTerminationFee"]
        + Termination
            [value "TerminationFee"]
        + Upfront
            [value "UPFRONT_FEE"]
            [value "Upfront fee"]

    CommodityReferencePriceEnum:
        + ALUMINIUM_ALLOY_LME_15_MONTH
            [value "ALUMINIUM ALLOY-LME 15 MONTH"]
        + COAL_CENTRAL_APPALACHIAN_NYMEX
            [value "COAL-CENTRAL APPALACHIAN-NYMEX"]
        + COCOA_ICE
            [value "COCOA-ICE"]
        + COFFEE_ARABICA_ICE
            [value "COFFEE ARABICA-ICE"]
        + COFFEE_ROBUSTA_ICE
            [value "COFFEE ROBUSTA-ICE"]
        + COPPER_COMEX
            [value "COPPER-COMEX"]
        + CORN_CBOT
            [value "CORN-CBOT"]
        + COTTON_NO__2_ICE
            [value "COTTON NO. 2-ICE"]
        + ETHANOL_CBOT
            [value "ETHANOL-CBOT"]
        + FEEDER_CATTLE_CME
            [value "FEEDER CATTLE-CME"]
        + FROZEN_CONCENTRATED_ORANGE_JUICE_NO__1_ICE
            [value "FROZEN CONCENTRATED ORANGE JUICE NO. 1-ICE"]
        + GASOLINE_RBOB_NEW_YORK_ICE
            [value "GASOLINE-RBOB-NEW YORK-ICE"]
        + GASOLINE_RBOB_NEW_YORK_NYMEX
            [value "GASOLINE-RBOB-NEW YORK-NYMEX"]
        + GOLD_COMEX
            [value "GOLD-COMEX"]
        + HEATING_OIL_NEW_YORK_NYMEX
            [value "HEATING OIL-NEW YORK-NYMEX"]
        + LEAN_HOGS_CME
            [value "LEAN HOGS-CME"]
        + LIVE_CATTLE_CME
            [value "LIVE CATTLE-CME"]
        + LUMBER_CME
            [value "LUMBER-CME"]
        + MILK_CLASS_III_CME
            [value "MILK-CLASS III-CME"]
        + MILK_NONFAT_DRY_CME
            [value "MILK-NONFAT-DRY-CME"]
        + NATURAL_GAS_NYMEX
            [value "NATURAL GAS-NYMEX"]
        + NATURAL_GAS_PEPL__TEXOK_MAINLINE__INSIDE_FERC
            [value "NATURAL GAS-PEPL (TEXOK MAINLINE)-INSIDE FERC"]
        + NATURAL_GAS_W__TEXAS__WAHA__INSIDE_FERC
            [value "NATURAL GAS-W. TEXAS (WAHA)-INSIDE FERC"]
        + OATS_CBOT
            [value "OATS-CBOT"]
        + OIL_WTI_NYMEX
            [value "OIL-WTI-NYMEX"]
        + PALLADIUM_NYMEX
            [value "PALLADIUM-NYMEX"]
        + PLATINUM_NYMEX
            [value "PLATINUM-NYMEX"]
        + RICE_CBOT
            [value "RICE-CBOT"]
        + SILVER_COMEX
            [value "SILVER-COMEX"]
        + SOYBEANS_CBOT
            [value "SOYBEANS-CBOT"]
        + SOYBEAN_MEAL_CBOT
            [value "SOYBEAN MEAL-CBOT"]
        + SOYBEAN_OIL_CBOT
            [value "SOYBEAN OIL-CBOT"]
        + SUGAR___11__WORLD__ICE
            [value "SUGAR # 11 (WORLD)-ICE"]
        + SUGAR___16__US__ICE
            [value "SUGAR # 16 (US)-ICE"]
        + WHEAT_CBOT
            [value "WHEAT-CBOT"]
        + WHEAT_HRW_KCBOT
            [value "WHEAT HRW-KCBOT"]
        + WHEAT_RED_SPRING_MGE
            [value "WHEAT RED SPRING-MGE"]

    CreditLimitTypeEnum:
        + CS01
            [value "CS01"]
        + DV01
            [value "DV01"]
        + IM
            [value "IM"]
        + Notional
            [value "Notional"]
        + NPV
            [value "NPV"]
        + PV01
            [value "PV01"]

    SettlementTypeEnum:
        + Cash
            [value "Cash"]
        + Physical
            [value "Physical"]
        + Election
            [value "Election"]
        + CashOrPhysical
            [value "CashOrPhysical"]

    EntityTypeEnum:
        + Asian
            [value "Asian"]
        + AustralianAndNewZealand
            [value "AustralianAndNewZealand"]
        + EuropeanEmergingMarkets
            [value "EuropeanEmergingMarket"]
        + Japanese
            [value "Japanese"]
        + NorthAmericanHighYield
            [value "NorthAmericanHighYield"]
        + NorthAmericanInsurance
            [value "NorthAmericanInsurance"]
        + NorthAmericanInvestmentGrade
            [value "NorthAmericanInvestmentGrade"]
        + Singaporean
            [value "Singaporean"]
        + WesternEuropean
            [value "WesternEuropean"]
        + WesternEuropeanInsurance
            [value "WesternEuropeanInsurance"]

    PayerReceiverEnum:
        + Payer
            [value "Payer"]
        + Receiver
            [value "Receiver"]

    AccountTypeEnum:
        + AggregateClient
            [value "AggregateClient"]
        + Client
            [value "Client"]
        + House
            [value "House"]

    NaturalPersonRoleEnum:
        + Broker
            [value "Broker"]
        + Buyer
            [value "Buyer"]
        + DecisionMaker
            [value "DecisionMaker"]
        + ExecutionWithinFirm
            [value "ExecutionWithinFirm"]
        + InvestmentDecisionMaker
            [value "InvestmentDecisionMaker"]
        + Seller
            [value "Seller"]
        + Trader
            [value "Trader"]

    PartyRoleEnum:
        + Accountant
            [value "Accountant"]
        + AllocationAgent
            [value "AllocationAgent"]
        + ArrangingBroker
            [value "ArrangingBroker"]
        + Beneficiary
            [value "Beneficiary"]
        + BookingParty
            [value "BookingParty"]
        + Buyer
            [value "Buyer"]
        + BuyerDecisionMaker
            [value "BuyerDecisionMaker"]
        + ClearingClient
            [value "ClearingClient"]
        + ClearingExceptionParty
            [value "ClearingExceptionParty"]
        + ClearingFirm
            [value "ClearingFirm"]
        + ClearingOrganization
            [value "ClearingOrganization"]
        + Client
            [value "Client"]
        + ClientDecisionMaker
            [value "ClientDecisionMaker"]
        + ConfirmationPlatform
            [value "ConfirmationPlatform"]
            [value "ConfirmationService"]
        + ContractualParty
            [value "ContractualParty"]
        + CounterPartyAffiliate
            [value "CounterPartyAffiliate"]
        + CounterPartyUltimateParent
            [value "CounterPartyUltimateParent"]
        + Counterparty
            [value "Counterparty"]
        + CreditSupportProvider
            [value "CreditSupportProvider"]
        + Custodian
            [value "Custodian"]
        + DataSubmitter
            [value "DataSubmitter"]
        + DisputingParty
            [value "DisputingParty"]
        + DocumentRepository
            [value "DocumentRepository"]
        + ExecutingBroker
            [value "ExecutingBroker"]
        + ExecutingEntity
            [value "ExecutingEntity"]
        + ExecutionAgent
            [value "ExecutionAgent"]
        + ExecutionFacility
            [value "ExecutionFacility"]
        + Guarantor
            [value "Guarantor"]
        + OrderTransmitter
            [value "OrderTransmitter"]
        + PrimeBroker
            [value "PrimeBroker"]
        + PriorTradeRepository
            [value "PriorTradeRepository"]
        + PTRRServiceProvider
            [value "PTRRCompressionProvider"]
            [value "PTRRRebalancingProvider"]
        + PublicationVenue
            [value "PublicationVenue"]
        + ReportingParty
            [value "ReportingParty"]
        + ReportingPartyAffiliate
            [value "ReportingPartyAffiliate"]
        + ReportingPartyUltimateParent
            [value "ReportingPartyUltimateParent"]
        + Seller
            [value "Seller"]
        + SellerDecisionMaker
            [value "SellerDecisionMaker"]
        + SettlementAgent
            [value "SettlementAgent"]
        + TradeRepository
            [value "TradeRepository"]
        + TradeSource
            [value "TradeSource"]
        + TradingManager
            [value "TradingManager"]
        + TradingPartner
            [value "TradingPartner"]

    TelephoneTypeEnum:
        + Work
            [value "Work"]
        + Mobile
            [value "Mobile"]
        + Fax
            [value "Fax"]
        + Personal
            [value "Personal"]

    AssetClassEnum:
        + Commodity
            [value "Commodity"]
        + Credit
            [value "Credit"]
        + Equity
            [value "Equity"]
        + ForeignExchange
            [value "ForeignExchange"]
        + InterestRate
            [value "InterestRate"]

    // MortgageSectorEnum:
    // + ABS
    // [value "ABS"]
    // + CDO
    // [value "CDO"]
    // + CMBS
    // [value "CMBS"]
    // + RMBS
    // [value "RMBS"]
    CallingPartyEnum:
        + InitialBuyer
            [value "InitialBuyer"]
        + InitialSeller
            [value "InitialSeller"]
        + Either
            [value "Either"]
        + AsDefinedInMasterAgreement
            [value "AsDefinedInMasterAgreement"]

    MarginTypeEnum:
        + Cash
            [value "Cash"]
        + Instrument
            [value "Instrument"]

    RepoDurationEnum:
        + Overnight
            [value "Overnight"]
        + Term
            [value "Term"]

    CapacityUnitEnum:
        // to be reviewed when FpML updates the priceQuoteUnits coding scheme
        + BBL
            [value "BBL"]
        + USCWT
            [value "CWT"]
        + DAG
            [value "dag"]
        + DAY
            [value "Day"]
        + DMTU
            [value "dmtu"]
        + FEU
            [value "FEU"]
        + USGAL
            [value "GAL"]
        + GBBSH
            [value "GBBSH"]
        + GBBTU
            [value "GBBTU"]
        + GBMBTU
            [value "GBMBTU"]
        + GBMMBTU
            [value "GBMMBTU"]
        + GBTHM
            [value "GBTHM"]
        + GJ
            [value "GJ"]
        + GW
            [value "GW"]
        + GWH
            [value "Gwh"]
        + HL
            [value "hl"]
        + HOGB
            [value "HOGB"]
        + ISOBTU
            [value "ISOBTU"]
        + ISOMBTU
            [value "ISOMBTU"]
        + ISOMMBTU
            [value "ISOMMBTU"]
        + ISOTHM
            [value "ISOTHM"]
        + KG
            [value "KG"]
        + KL
            [value "kl"]
        + KW
            [value "KW"]
        + KWD
            [value "KWD"]
        + KWH
            [value "KWh"]
        + KWM
            [value "KWM"]
        + KWMIN
            [value "KWMIN"]
        + KWY
            [value "KWY"]
        + L
            [value "L"]
        + LB
            [value "LB"]
        + MB
            [value "MB"]
        + MBF
            [value "MBF"]
        + MJ
            [value "MJ"]
        + MMBF
            [value "MMBF"]
        + MSF
            [value "msf"]
        + MT
            [value "MT"]
        + MW
            [value "MW"]
        + MWD
            [value "MWD"]
        + MWH
            [value "MWh"]
        + MWM
            [value "MWM"]
        + MWMIN
            [value "MWMIN"]
        + MWY
            [value "MWY"]
        + OZT
            [value "ozt"]
        + SGB
            [value "SGB"]
        + USBSH
            [value "USBSH"]
        + USBTU
            [value "USBTU"]
        + USMBTU
            [value "USMBTU"]
        + USMMBTU
            [value "USMMBTU"]
        + UST
            [value "st"]
        + USTHM
            [value "USTHM"]
        + GBT
            [value "t"]
        + TEU
            [value "TEU"]

    WeatherUnitEnum:
        + CDD
            [value "CDD"]
        + CPD
            [value "CPD"]
        + HDD
            [value "HDD"]

    FinancialUnitEnum:
        + IndexUnit
            [value "IndexUnits"]
        + LogNormalVolatility
            [value "LogNormalVolatility"]
        + Share
            [value "Shares"]
        + ValuePerDay
            [value "ValuePerDay"]
        + ValuePerPercent
            [value "ValuePerPercent"]

    DayDistributionEnum:
        + All
            [value "All"]
        + First
            [value "First"]
        + Last
            [value "Last"]
        + Penultimate
            [value "Penultimate"]

    PartyIdentifierTypeEnum:
        + LEI
            [value "http://www.fpml.org/coding-scheme/external/iso17442"]
        + BIC
            [value "http://www.fpml.org/coding-scheme/external/iso9362"]
        + MIC
            [value "http://www.fpml.org/coding-scheme/external/iso10383"]

    CsaTypeEnum:
        + NoCSA
            [value "NoCSA"]
        + ExistingCSA
            [value "ExistingCSA"]
        + ReferenceVMCSA
            [value "ReferenceVMCSA"]

    CalculationMethodEnum:
        + Averaging
            [value "Averaging"]
        + Compounding
            [value "Compounding"]
        + CompoundedIndex
            [value "CompoundedIndex"]

    ObservationPeriodDatesEnum:
        + Standard
            [value "Standard"]
        + SetInAdvance
            [value "SetInAdvance"]
        + FixingDate
            [value "FixingDate"]

    CreditSeniorityEnum:
        + Other
            [value "Other"]
        + SeniorLossAbsorbingCapacity
            [value "SeniorLossAbsorbingCapacity"]
        + SeniorSec
            [value "SeniorSec"]
        + SeniorUnSec
            [value "SeniorUnSec"]
        + SubLowerTier2
            [value "SubLowerTier2"]
        + SubTier1
            [value "SubTier1"]
        + SubTier3
            [value "SubTier3"]
        + SubUpperTier2
            [value "SubUpperTier2"]

    ProductGradeEnum:
        + _0_1_Percent
            [value "0.1-Percent"]
        + _0_5_Percent
            [value "0.5-Percent"]
        + _1_0_Percent
            [value "1.0-Percent"]
        + _10_PPM
            [value "10-PPM"]
        +_10_PPM_95_R
            [value "10-PPM-95-R"] 
        +_10_PPM_Premium_Unleaded
            [value "10-PPM-Premium-Unleaded"] 
        +_10_PPM_Regular_Unleaded
            [value "10-PPM-Regular-Unleaded"] 
        +_180_CST
            [value "180-CST"]
        +_3_5_Percent
            [value "3.5-Percent"]
        +_380_CST
            [value "380-CST"]
        +_50_PPM
            [value "50-PPM"] 
        +_54
            [value "54"]
        +_55
            [value "55"]
        +_87_M
            [value "87-M"] 
        +_87_Unleaded
            [value "87-Unleaded"] 
        +_87_Unleaded_ULS_30
            [value "87-Unleaded-ULS-30"] 
        +_92_Unleaded
            [value "92-Unleaded"] 
        +_93_Unleaded
            [value "93-Unleaded"] 
        +_95_Unleaded
            [value "95-Unleaded"] 
        +_97_Unleaded
            [value "92-Unleaded"] 
        +_98_Unleaded
            [value "92-Unleaded"] 
        +Arabian_Light
            [value "Arabian-Light"]
        +Brass_Blend
            [value "Brass-Blend"]
        +Brent
            [value "Brent"]
        +CARBOB
            [value "CARBOB"] 
        +CBOB
            [value "CBOB"] 
        +Cold_Lake
            [value "Cold-Lake"]
        +Dubai
            [value "Dubai"]
        +Edmonton_High_Sulphur_Sour
            [value "Edmonton-High-Sulphur-Sour"]
        +EUROBOB
            [value "EUROBOB"] 
        +German_10PPM
            [value "German-10PPM"]
        +Gulf_Coast_Sweet
            [value "Gulf-Coast-Sweet"]
        +Hardisty_Light
            [value "Hardisty-Light"]
        +Iranian_Light
            [value "Iranian-Light"]
        +Jet
            [value "Jet"]
        +Kirkuk_Light
            [value "Kirkuk-Light"]
        +Kuwait
            [value "Kuwait"]
        +Light_Louisiana_Sweet
            [value "Light-Louisiana-Sweet"]
        +Low_Sulphur
            [value "Low-Sulphur"]
        +Low_Sulphur_Jet
            [value "Low-Sulphur-Jet"]
        +Mars
            [value "Mars"]
        +Mixed_Sour_Blend
            [value "Mixed-Sour-Blend"]
        +Mixed_Sweet_Blend
            [value "Mixed-Sweet-Blend"]
        +Murban
            [value "Murban"]
        +Natural_Gasoline
            [value "Natural-Gasoline"] 
        +No__2
            [value "No.-2"]
        +No__6_0_3_Percent
            [value "No.-6-0.3-Percent"]
        +No__6_0_3_Percent_HP
            [value "No.-6-0.3-Percent-HP"]
        +No__6_0_3_Percent_LP
            [value "No.-6-0.3-Percent-LP"]
        +No__6_0_7_Percent
            [value "No.-6-0.7-Percent"]
        +No__6_1_0_Percent
            [value "No.-6-1.0-Percent"]
        +No__6_2_2_Percent
            [value "No.-6-2.2-Percent"]
        +No__6_3_Percent
            [value "No.-6-3-Percent"]
        +Normal_Butane
            [value "Normal-Butane"]
        +North_Dakota_Light
            [value "North-Dakota-Light"]
        +Oman
            [value "Oman"]
        +Polymer_Grade
            [value "Polymer-Grade"]
        +RBOB
            [value "RBOB"]
        +Saharan
            [value "Saharan"]
        +Sour
            [value "Sour"]
        +Southern_Green_Canyon
            [value "Southern-Green-Canyon"]
        +Tapis
            [value "Tapis"]
        +Thunder_Horse
            [value "Thunder-Horse"]
        +Ultra_Low_Sulphur
            [value "Ultra-Low-Sulphurs"]
        +Urals
            [value "Urals"]
        +Urals_Sour
            [value "Urals-Sour"]
        +US_Regular_Unleaded
            [value "US-Regular-Unleaded"]
        +Western_Canadian_Select
            [value "Western-Canadian-Select"]
        +WTI
            [value "WTI"]
        +WTS
            [value "WTS"]
        +Zuetina
            [value "Zuetina"]
}

func MapGenericProductToForwardPayout: <"Func that is invoked from a synonym 'set when' condition.">
    inputs:
        synonymPath string (1..1) <"The xml path from which the func is called.">
        modelPath string (1..1) <"The cdm path that is being mapped.">
        productType string (0..*)
    output:
        result boolean (1..1)

    set result: productType contains "InterestRate:Forward:Debt"


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-fpml-confirmation-workflowstep-synonym.rosetta
================================================================================

namespace cdm.mapping.fpml.confirmation.workflowstep
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.identifier.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.mapping.fpml.confirmation.tradestate.*
import cdm.observable.asset.*

synonym source FpML_5_Confirmation_To_WorkflowStep extends FpML_5_Confirmation_To_TradeState
{
    WorkflowStep:
        + businessEvent
            [value "ignore"]
        + approval
            [value "ignore"]
        + rejected
            [value "ignore"]
        + previousWorkflowStep
            [value "ignore"]
        + nextEvent
            [value "partyTradeInformation" path "trade->tradeHeader"]
        + messageInformation
            [value "header"]
        + eventIdentifier
            [value "header"]
            [value "eventIdentifier" path "tradingEvent"]
            [value "tradeHeader" path "trade"]
        + action
            [set to ActionEnum -> New when "isCorrection" = False]
            [set to ActionEnum -> Correct when "isCorrection" = True]
            [set to ActionEnum -> Cancel when "withdrawal->reason" = "RaisedInError"]
        + party
            [value "ignore"]
        + account
            [value "ignore"]
        + lineage
            [value "ignore"]
        + creditLimitInformation
            [value "ignore"]

    WorkflowState:
        + workflowStatus
            [set to WorkflowStatusEnum -> Cleared when "originatingEvent" = "Clearing"]

    EventInstruction:
        + intent
            [value "terminatingEvent"]
            // originatingEvent is mapped here as several "set to" mappings as a workaround for the fact that "set to" mappings take precedence over
            // "value" mappings. Since "originatingEvent" always appears with one or more of the other mapped elements (typically "trade"), a "value" mapping
            // would never be processed.
            [set to EventIntentEnum -> Allocation when "intentToAllocate" = True]
            [set to EventIntentEnum -> Allocation when "originatingEvent" = "Allocation"]
            [set to EventIntentEnum -> Allocation when "terminatingEvent" = "Allocation"]
            [set to EventIntentEnum -> Allocation when /*"originatingEvent" = "Trade" and */ "trade->tradeHeader->partyTradeInformation->allocationStatus" = "PostAllocation"] // not working
            [set to EventIntentEnum -> Clearing when "intentToClear" = True]
            [set to EventIntentEnum -> Compression when "originatingEvent" = "Netting"]
            [set to EventIntentEnum -> Compression when "originatingEvent" = "PortfolioCompression"]
            [set to EventIntentEnum -> Compression when "terminatingEvent" = "Netting"]
            [set to EventIntentEnum -> Compression when "terminatingEvent" = "PortfolioCompression"]
            [set to EventIntentEnum -> ContractTermsAmendment when "amendment" exists]
            [set to EventIntentEnum -> CreditEvent when "originatingEvent" = "CreditEvent"]
            [set to EventIntentEnum -> Novation when "novation" exists]
            [set to EventIntentEnum -> Novation when "originatingEvent" = "Novation"]
            [set to EventIntentEnum -> OptionExercise when "optionExercise" exists]
            [set to EventIntentEnum -> OptionExercise when "originatingEvent" = "Exercise"]
            [set to EventIntentEnum -> PortfolioRebalancing when "originatingEvent" = "PortfolioRebalancing"]
            [set to EventIntentEnum -> ContractFormation when "originatingEvent" = "ForwardAgainstFixing"]
            [set to EventIntentEnum -> ContractFormation when "originatingEvent" = "Trade"]
            [set to EventIntentEnum -> ContractFormation when "trade" exists]
        + instruction
            [merge "termination"]
            [merge "amendment"]
            [merge "novation"]
            [merge "trade"]
            [merge "party"]
            [merge "account"]
            [merge "quote"]
            [merge "optionExercise"]
            [merge "withdrawal"]
        + eventDate
            [value "executionDateTime" path "amendment" maps 2 dateFormat "yyyy-MM-dd'T'HH:mm:ssz"]
            [value "executionDateTime" path "termination" maps 2 dateFormat "yyyy-MM-dd'T'HH:mm:ssz"]
            [value "executionDateTime" path "trade->tradeHeader->partyTradeInformation" maps 2 dateFormat "yyyy-MM-dd'T'HH:mm:ssz"]
            [value "tradeDate" path "rebooking->trade->tradeHeader" maps 2]
            [value "agreementDate" path "amendment" maps 2 dateFormat "yyyy-MM-ddz"]
            [value "agreementDate" path "amendment" maps 2]
            [value "agreementDate" path "termination" maps 2 dateFormat "yyyy-MM-ddz"]
            [value "agreementDate" path "termination" maps 2]
            [value "novationDate" path "novation" maps 2]
            [value "novationTradeDate" path "novation" maps 2]
            [value "exerciseDate" path "optionExercise"]
        + effectiveDate
            [value "effectiveDate" path "tradingEvent" maps 2]
            [value "effectiveDate" path "termination" maps 2 dateFormat "yyyy-MM-ddz"]
            [value "effectiveDate" path "termination" maps 2]
            [value "effectiveDate" path "amendment" maps 2]
            [value "effectiveDate" path "novation" maps 2]
            [value "novationDate" path "novation" maps 2]
            [value "effectiveDate" path "withdrawal" maps 2]
        + packageInformation
            [value "ignore"] // not modelled in FpML

    Instruction:
        + before
            [value "termination"]
            [value "novation"]
            [value "amendment"]
            [hint "trade" , "party" , "account" , "quote"]
            [value "optionExercise"]
            [value "withdrawal"]

    PrimitiveInstruction:
        + contractFormation
            [value "trade"]
        + execution
            [value "ignore"]
        + exercise
            [value "ignore"]
        + observation
            [value "ignore"]
        + partyChange
            [value "ignore"]
        + quantityChange
            [value "termination"]
        + reset
            [value "ignore"]
        + split
            [hint "novation"]
        + termsChange
            [value "ignore"]
        + transfer
            [value "termination"]
            [value "amendment"]
            [value "optionExercise"]
        + indexTransition
            [value "ignore"]
        + stockSplit
            [value "ignore"]

    ContractFormationInstruction:
        + legalAgreement
            [value "documentation" mapper "ContractFormationInstructionLegalAgreement"]

    QuantityChangeInstruction:
        + direction
            [set to QuantityChangeDirectionEnum -> Replace]
        + lotIdentifier
            [value "ignore"]

    SplitInstruction:
        + breakdown
            [value "novation" mapper "NovationInstruction"]

    TransferState:
        + transfer
            [value "payment"]

    TransferExpression:
        + priceTransfer
            [value "paymentType"]
            [set to FeeTypeEnum -> Termination when path = "termination->payment"]
            [set to FeeTypeEnum -> Renegotiation when path = "amendment->payment"]

    PriceQuantity:
        + quantity
            [value "outstandingNotionalAmount"]
            [value "outstandingNotionalAmount" path "sizeChange"]

    Price:
        + value
            [value "value" mapper "PriceUnitType"]
        + priceType
            [value "measureType"]
        + arithmeticOperator
            [value "measureType"]

    EventTimestamp:
        + dateTime
            [value "creationTimestamp" path "header"]
            [value "executionDateTime" path "trade->tradeHeader->partyTradeInformation"]
            [value "executionDateTime" path "termination"]
            [value "submittedForClearing" path "trade->tradeHeader->partyTradeInformation->timestamps"]
            [value "cleared" path "trade->tradeHeader->partyTradeInformation->timestamps"]
            [value "confirmed" path "trade->tradeHeader->partyTradeInformation->timestamps"]
        + qualification
            [set to EventTimestampQualificationEnum -> eventCreationDateTime when path = "header->creationTimestamp"]
            [set to EventTimestampQualificationEnum -> clearingReceiptDateTime when path = "trade->tradeHeader->partyTradeInformation->timestamps->submittedForClearing"]
            [set to EventTimestampQualificationEnum -> clearingDateTime when path = "trade->tradeHeader->partyTradeInformation->timestamps->cleared"]
            [set to EventTimestampQualificationEnum -> executionDateTime when path = "trade->tradeHeader->partyTradeInformation->executionDateTime"]
            [set to EventTimestampQualificationEnum -> executionDateTime when path = "termination"]
            [set to EventTimestampQualificationEnum -> confirmationDateTime when path = "trade->tradeHeader->partyTradeInformation->timestamps->confirmed"]

    MessageInformation:
        + messageId
            [value "messageId" maps 2 meta "messageIdScheme"]
        + sentBy
            [value "systemId" path "sentBy"]
            [value "sentBy"]
        + sentTo
            [value "systemId" path "sendTo"]
            [value "sendTo"]
        + copyTo
            [value "copyTo"]

    TradeState:
        [meta "id" path "trade"]
        [meta "id" path "originalTrade"]
        [meta "id" path "oldTrade"]
        [meta "id" path "feeTrade"]
        [meta "id" path "newTrade"]
        - trade
        + trade
            [value "trade" mapper "Party"]
            [value "originalTrade" mapper "Party"]
            [value "oldTrade" mapper "Party"]
            [value "feeTrade" mapper "Party"]
            [value "newTrade" mapper "Party"]
            [hint "party" , "account" , "quote"]
        + transferHistory
            // premium
            [value "bondOption" path "feeTrade" , "bondOption" path "originalTrade" , "bondOption" path "newTrade" , "bondOption" path "oldTrade"]
            [value "swaption" path "feeTrade" , "swaption" path "originalTrade" , "swaption" path "newTrade" , "swaption" path "oldTrade"]
            [value "fxOption" path "feeTrade" , "fxOption" path "originalTrade" , "fxOption" path "newTrade" , "fxOption" path "oldTrade"]
            [value "fxDigitalOption" path "feeTrade" , "fxDigitalOption" path "originalTrade" , "fxDigitalOption" path "newTrade" , "fxDigitalOption" path "oldTrade"]
            [value "creditDefaultSwapOption" path "feeTrade" , "creditDefaultSwapOption" path "originalTrade" , "creditDefaultSwapOption" path "newTrade" , "creditDefaultSwapOption" path "oldTrade"]
            [value "commodityOption" path "feeTrade" , "commodityOption" path "originalTrade" , "commodityOption" path "newTrade" , "commodityOption" path "oldTrade"]
            [value "commodityBasketOption" path "feeTrade" , "commodityBasketOption" path "originalTrade" , "commodityBasketOption" path "newTrade" , "commodityBasketOption" path "oldTrade"]
            [value "capFloor" path "feeTrade" , "capFloor" path "originalTrade" , "capFloor" path "newTrade" , "capFloor" path "trade" , "capFloor" path "oldTrade"]
            // equityPremium
            [value "equityOption" path "feeTrade" , "equityOption" path "originalTrade" , "equityOption" path "newTrade" , "equityOption" path "oldTrade"]
            [value "brokerEquityOption" path "feeTrade" , "brokerEquityOption" path "originalTrade" , "brokerEquityOption" path "newTrade" , "brokerEquityOption" path "oldTrade"]
            [value "dividendSwapOptionTransactionSupplement" path "feeTrade" , "dividendSwapOptionTransactionSupplement" path "originalTrade" , "dividendSwapOptionTransactionSupplement" path "newTrade" , "dividendSwapOptionTransactionSupplement" path "oldTrade"]
            [value "equityOptionTransactionSupplement" path "feeTrade" , "equityOptionTransactionSupplement" path "originalTrade" , "equityOptionTransactionSupplement" path "newTrade" , "equityOptionTransactionSupplement" path "oldTrade"]
            [value "varianceOptionTransactionSupplement" path "feeTrade" , "varianceOptionTransactionSupplement" path "originalTrade" , "varianceOptionTransactionSupplement" path "newTrade" , "varianceOptionTransactionSupplement" path "oldTrade"]
            // initialPayment / singlePayment
            [value "feeLeg" path "feeTrade->creditDefaultSwap" , "feeLeg" path "originalTrade->creditDefaultSwap" , "feeLeg" path "newTrade->creditDefaultSwap" , "feeLeg" path "oldTrade->creditDefaultSwap"]
            // additionalPayment
            [value "swap" path "feeTrade" , "swap" path "originalTrade" , "swap" path "newTrade" , "swap" path "oldTrade"]
            // otherPartyPayment
            [value "feeTrade" , "originalTrade" , "newTrade" , "oldTrade"]

    ContractDetails:
        - documentation
        + documentation
            [value "documentation" mapper "InstructionDocumentation"]

    ExecutionDetails:
        + packageReference
            [hint "quote"]

    IdentifiedList:
        + price
            [value "quote" set when "quote->measureType" = "PackagePrice"]
            [value "quote" set when "quote->measureType" = "PackageSpread"]

    enums

    ArithmeticOperationEnum:
        + Add
            [value "PackageSpread"]

    EventIntentEnum:
        + Novation
            [value "Novation"]
        + Compression
            [value "PortfolioCompression"]
            [value "Netting"]
        + OptionExercise
            [value "Exercise"]
        + Allocation
            [value "Allocation"]
        + CreditEvent
            [value "CreditEvent"]
        + PortfolioRebalancing
            [value "PortfolioRebalancing"]

    FeeTypeEnum:
        + BrokerageCommission
            [value "BrokerageCommission"]
        + Novation
            [value "Novation Fee"]
        + Termination
            [value "TerminationFee"]
        + Upfront
            [value "PrincipalExchange"]

    PriceTypeEnum:
        + CashPrice
            [value "PackagePrice"]
        + InterestRate
            [value "PackageSpread"]
}


================================================================================
FILE: rosetta-source/src/main/rosetta/mapping-ore-synonym.rosetta
================================================================================

namespace cdm.mapping.ore
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.observable.asset.*
import cdm.product.asset.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.template.*
import cdm.product.collateral.*
import cdm.legaldocumentation.csa.*

synonym source ORE

synonym source ORE_1_0_39 extends ORE
{
    TradeState:
        + resetHistory
            [value "ignore"]

    Trade:
        + tradeIdentifier
        + party
            [value "Envelope" path "Trade"]
        + product
            [value "SwapData" path "Trade"]
        + tradeLot
            [value "Trade"]
        + counterparty
            [value "Trade" mapper "ORECounterparty"]
        + party
            [value "Envelope" path "Trade"]

    TradeLot:
        + priceQuantity
            [value "LegData" path "SwapData"]

    Counterparty:
        + partyReference
            [value "Envelope"]
        + role
            [set to CounterpartyRoleEnum -> Party2 when rosettaPath = TradeState -> trade -> counterparty]

    PriceSchedule:
        + value
            [value "Rate"]
            [value "Spread"]
        + priceType
            [set to PriceTypeEnum -> InterestRate when path = "Rates"]
            [set to PriceTypeEnum -> InterestRate when path = "Spreads"]
        + arithmeticOperator
            [set to ArithmeticOperationEnum -> Add when path = "Spreads"]

    PriceQuantity:
        + price
            [value "Rates" path "FixedLegData" mapper "OrePrice"]
            [value "Spreads" path "FloatingLegData" mapper "OrePrice"]
        + observable
            [value "FloatingLegData"]
        + quantity
            [value "Notionals" mapper "OreQuantity"]

    PartyIdentifier:
        + identifier
            [value "CounterParty" maps 2]
            [value "party_id" path "AdditionalFields"]

    QuantitySchedule:
        + value
            [value "Notional"]
        + multiplier
            [value "ignore"]
        + datedValue
            [value "step"]

    Payout:
        + InterestRatePayout
            [value "LegData"]
            [value "LegData"]
        + CreditDefaultPayout
            [value "ignore"]
        + OptionPayout
            [value "ignore"]
        + CommodityPayout
            [value "ignore"]
        + SettlementPayout
            [value "ignore"]
        + FixedPricePayout
            [value "ignore"]
        + PerformancePayout
            [value "ignore"]
        + AssetPayout
            [value "ignore"]

    InterestRatePayout:
        + priceQuantity
            [value "Notionals"]
        + calculationPeriodDates
            [value "Rules" path "ScheduleData"]
        + paymentDates
            [value "Rules" path "ScheduleData"]
        + principalPayment
            [value "ignore"]
        + cashflowRepresentation
            [value "ignore"]
        + stubPeriod
            [value "ignore"]

    Frequency:
        + periodMultiplier
            [value "Tenor" maps 2 pattern "([0-9]*).*" "$1"]
        + period
            [value "Tenor" maps 2 pattern "[0-9]*(.*)" "$1"]

    CalculationPeriodDates:
        + effectiveDate
            [hint "StartDate"]

    AdjustableOrRelativeDate:
        + adjustableDate

    AdjustableDate:
        + unadjustedDate
            [value "StartDate"]

    FloatingRateIndex:
        + floatingRateIndex
            [value "Index" maps 2]

    RateSpecification:
        + FixedRateSpecification
            [value "FixedLegData"]
        + FloatingRateSpecification
            [value "FloatingLegData"]
        + InflationRateSpecification
            [value "ignore"]

    FixedRateSpecification:
        + rateSchedule
            [value "Rates"]

    FloatingRate:
        + spreadSchedule
            [value "Spreads"]

    RateSchedule:
        + price
            [meta "Rate"]
            [meta "Spread"]

    ResolvablePriceQuantity:
        + quantitySchedule
            [meta "Notional"]
        + resolvedQuantity
            [value "ignore"]
        + priceSchedule
            [value "ignore"]

    UnitType:
        + currency
            [value "Currency"]

    PrincipalPaymentSchedule:
        + initialPrincipalPayment
            [value "ignore"]
        + intermediatePrincipalPayment
            [value "ignore"]
        + finalPrincipalPayment
            [value "ignore"]

    SettlementTerms:
        + settlementProvision
            [value "ignore"]

    Basket:
        + basketConstituent
            [value "ignore"]

    CollateralProvisions:
        + eligibleCollateral
            [value "ignore"]

    PostingObligationsElection:
        + eligibleCollateral
           [value "ignore"]

    enums

    FloatingRateIndexEnum:
        + EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP
            [value "EUR-EURIBOR-6M"]

    PeriodEnum:
        + D
            [value "D"]
        + W
            [value "W"]
        + M
            [value "M"]
        + Y
            [value "Y"]
}


================================================================================
FILE: rosetta-source/src/main/rosetta/margin-schedule-enum.rosetta
================================================================================

namespace cdm.margin.schedule
version "${project.version}"

enum StandardizedScheduleAssetClassEnum:
    InterestRates
    Credit
    ForeignExchange
    Equity
    Commodity

enum StandardizedScheduleProductClassEnum:
    Swap
    CrossCurrencySwap
    Swaption
    SwaptionStraddle
    SwapWithCallableBermudanRightToEnterExitSwaps
    IRExoticSwapWithAnExoticCouponAgainstAFloatingLeg
    Option
    ForwardRateAgreement
    SingleNameCreditDefaultSwap
    IndexCDS
    IndexTranche
    CreditNthToDefault
    CreditTotalReturnSwapOnABond
    DeliverableSwap
    NonDeliverableCrossCurrencySwap
    DeliverableForward
    NonDeliverableForward
    DeliverableOption
    NonDeliverableOption
    VarianceSwap
    VolatilitySwap
    CorrelationSwap
    Forward
    DividendSwap
    DeliverableOptionF
    ContractForDifference
    SwapsAndPortfolioSwaps
    FixedFloatSwap
    BasisSwap


================================================================================
FILE: rosetta-source/src/main/rosetta/margin-schedule-func.rosetta
================================================================================

namespace cdm.margin.schedule
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.event.common.*
import cdm.observable.asset.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*
import cdm.product.template.*

func BuildStandardizedSchedule: <"Takes a trade and uses qualification to extract the relevant information to populate the grid that will be used to calculate the gross initial margin.">
    inputs:
        trade Trade (1..1)
    output:
        standardizedSchedule StandardizedSchedule (1..1)
    alias assetClass: StandardizedScheduleAssetClass(trade)
    alias productClass: StandardizedScheduleProductClass(trade)
    set standardizedSchedule -> assetClass: assetClass
    set standardizedSchedule -> productClass: productClass
    set standardizedSchedule -> notional:
        StandardizedScheduleNotional(trade, assetClass, productClass)
    set standardizedSchedule -> notionalCurrency:
        StandardizedScheduleNotionalCurrency(trade, assetClass, productClass)
    set standardizedSchedule -> durationInYears:
        StandardizedScheduleDuration(trade, assetClass, productClass)

func GetGrossInitialMarginFromStandardizedSchedule: <"Takes the grid information from an specific trade and calculates the gross initial margin.">
    inputs:
        standardizedSchedule StandardizedSchedule (1..1)
    output:
        grossInitialMargin Money (0..1)
    alias initialMarginRequirement:
        GetStandardizedScheduleMarginRate(
                standardizedSchedule -> assetClass,
                standardizedSchedule -> durationInYears
            )
    set grossInitialMargin -> value:
        standardizedSchedule -> notional * initialMarginRequirement * 0.01
    set grossInitialMargin -> unit -> currency: standardizedSchedule -> notionalCurrency

    post-condition PositiveGrossInitialMargin: <"Ensure gross initial margin is greater than 0">
        grossInitialMargin -> value > 0

func StandardizedScheduleAssetClass: <"Identifies the asset class of a trade from qualifying functions, according to the standardized schedule classification.">
    inputs:
        trade Trade (1..1)
    output:
        assetClass StandardizedScheduleAssetClassEnum (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set assetClass:
        if Qualify_AssetClass_InterestRate(economicTerms)
        then StandardizedScheduleAssetClassEnum -> InterestRates
        else if Qualify_AssetClass_Credit(economicTerms)
        then StandardizedScheduleAssetClassEnum -> Credit
        else if Qualify_AssetClass_ForeignExchange(economicTerms)
        then StandardizedScheduleAssetClassEnum -> ForeignExchange
        else if Qualify_AssetClass_Equity(economicTerms)
        then StandardizedScheduleAssetClassEnum -> Equity
        else if Qualify_AssetClass_Commodity(economicTerms)
        then StandardizedScheduleAssetClassEnum -> Commodity

func StandardizedScheduleProductClass: <"Identifies the product class of a trade from qualifying functions, according to the standardized schedule classification.">
    inputs:
        trade Trade (1..1)
    output:
        productClass StandardizedScheduleProductClassEnum (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set productClass:
        if Qualify_InterestRate_SwapWithCallableBermudanRightToEnterExitSwaps(economicTerms)
        then StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
        else if Qualify_BaseProduct_IRSwap(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swap
        else if Qualify_BaseProduct_CrossCurrency(economicTerms)
        then StandardizedScheduleProductClassEnum -> CrossCurrencySwap
        else if Qualify_InterestRate_Swaption_Straddle(economicTerms)
        then StandardizedScheduleProductClassEnum -> SwaptionStraddle
        else if Qualify_InterestRate_Option_Swaption(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swaption
        // IR Exotic swap with an exotic coupon against a floating leg not supported
        else if Qualify_InterestRate_CapFloor(economicTerms)
        then StandardizedScheduleProductClassEnum -> Option
        else if Qualify_InterestRate_Fra(economicTerms)
        then StandardizedScheduleProductClassEnum -> ForwardRateAgreement
        else if Qualify_CreditDefaultSwap_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
        else if Qualify_CreditDefaultSwap_Index(economicTerms)
        then StandardizedScheduleProductClassEnum -> IndexCDS
        else if Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
        then StandardizedScheduleProductClassEnum -> IndexTranche
        else if Qualify_CreditDefaultSwaption(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swaption
        else if Qualify_Credit_NthToDefault(economicTerms)
        then StandardizedScheduleProductClassEnum -> CreditNthToDefault
        // Credit Total return swap on a bond not supported
        else if Qualify_ForeignExchange_Swap(economicTerms)
        then StandardizedScheduleProductClassEnum -> DeliverableSwap
        else if Qualify_ForeignExchange_NDS(economicTerms)
        then StandardizedScheduleProductClassEnum -> NonDeliverableCrossCurrencySwap
        else if Qualify_ForeignExchange_Spot_Forward(economicTerms)
        then StandardizedScheduleProductClassEnum -> DeliverableForward
        else if Qualify_ForeignExchange_NDF(economicTerms)
        then StandardizedScheduleProductClassEnum -> NonDeliverableForward
        else if Qualify_ForeignExchange_VanillaOption(economicTerms)
        then StandardizedScheduleProductClassEnum -> DeliverableOption
        else if Qualify_ForeignExchange_NDO(economicTerms)
        then StandardizedScheduleProductClassEnum -> NonDeliverableOption
        else if Qualify_ForeignExchange_ParameterReturnVariance(economicTerms)
        then StandardizedScheduleProductClassEnum -> VarianceSwap
        else if Qualify_ForeignExchange_ParameterReturnVolatility(economicTerms)
        then StandardizedScheduleProductClassEnum -> VolatilitySwap
        else if Qualify_ForeignExchange_ParameterReturnCorrelation(economicTerms)
        then StandardizedScheduleProductClassEnum -> CorrelationSwap
        else if Qualify_EquityOption_PriceReturnBasicPerformance_Basket(economicTerms)
                or Qualify_EquityOption_PriceReturnBasicPerformance_Index(economicTerms)
                or Qualify_EquityOption_PriceReturnBasicPerformance_SingleName(
                        economicTerms
                    )
                or Qualify_EquityOption_ParameterReturnVolatility_Basket(economicTerms)
                or Qualify_EquityOption_ParameterReturnVolatility_Index(economicTerms)
                or Qualify_EquityOption_ParameterReturnVolatility_SingleName(economicTerms)
                or Qualify_EquityOption_ParameterReturnVariance_Basket(economicTerms)
                or Qualify_EquityOption_ParameterReturnVariance_Index(economicTerms)
                or Qualify_EquityOption_ParameterReturnVariance_SingleName(economicTerms)
                or Qualify_EquityOption_ParameterReturnCorrelation_Basket(economicTerms)
                    // or Qualify_EquityOption_ParameterReturnCorrelation_Index(economicTerms)
                    // or Qualify_EquityOption_ParameterReturnCorrelation_SingleName(economicTerms)
                or Qualify_EquityOption_ParameterReturnDividend_Basket(economicTerms)
                or Qualify_EquityOption_ParameterReturnDividend_Index(economicTerms)
                or Qualify_EquityOption_ParameterReturnDividend_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> Option
        else if Qualify_BaseProduct_EquityForward(economicTerms)
        then StandardizedScheduleProductClassEnum -> Forward
        else if Qualify_EquitySwap_ParameterReturnDividend_Basket(economicTerms)
                or Qualify_EquitySwap_ParameterReturnDividend_Index(economicTerms)
                or Qualify_EquitySwap_ParameterReturnDividend_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> DividendSwap
        else if Qualify_EquitySwap_ParameterReturnVariance_Basket(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVariance_Index(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVariance_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> VarianceSwap
        else if Qualify_EquitySwap_ParameterReturnVolatility_Basket(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVolatility_Index(economicTerms)
                or Qualify_EquitySwap_ParameterReturnVolatility_SingleName(economicTerms)
        then StandardizedScheduleProductClassEnum -> VolatilitySwap
        // EQ Contract fo Difference (CFD) not supported
        else if Qualify_BaseProduct_EquitySwap(economicTerms)
        then StandardizedScheduleProductClassEnum -> SwapsAndPortfolioSwaps
        else if Qualify_Commodity_Forward(economicTerms)
        then StandardizedScheduleProductClassEnum -> Forward
        else if Qualify_Commodity_Option(economicTerms)
        then StandardizedScheduleProductClassEnum -> Option
        else if Qualify_Commodity_Swap_FixedFloat(economicTerms)
        then StandardizedScheduleProductClassEnum -> FixedFloatSwap
        else if Qualify_Commodity_Swap_Basis(economicTerms)
        then StandardizedScheduleProductClassEnum -> BasisSwap
        else if Qualify_Commodity_Swaption(economicTerms)
        then StandardizedScheduleProductClassEnum -> Swaption

// CO Contract for Difference (CFD) not supported
func StandardizedScheduleNotional: <"Extracts the notional amount of a trade, according to the product class-depending extraction method defined in the ISDA industry survey.">
    inputs:
        trade Trade (1..1)
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        productClass StandardizedScheduleProductClassEnum (1..1)
    output:
        notional number (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set notional:
        if assetClass = StandardizedScheduleAssetClassEnum -> InterestRates
        then (if productClass = StandardizedScheduleProductClassEnum -> Swap
                    or productClass = StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
            then (economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> CrossCurrencySwap
            then (economicTerms -> payout -> InterestRatePayout
                filter (True /*how do we identify the receiver party?*/ )
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
                    or productClass = StandardizedScheduleProductClassEnum -> SwaptionStraddle
            then (UnderlierForOptionOrForwardProduct(product) -> Product ->> economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            // IR Exotic swap with an exotic coupon against a floating leg not supported
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> InterestRatePayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> ForwardRateAgreement
            then (economicTerms -> payout -> InterestRatePayout
                filter rateSpecification -> FixedRateSpecification exists
                then only-element
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ))
        else if assetClass = StandardizedScheduleAssetClassEnum -> Credit
        then (if productClass = StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
                    or productClass = StandardizedScheduleProductClassEnum -> IndexCDS
                    or productClass = StandardizedScheduleProductClassEnum -> IndexTranche
                    or productClass = StandardizedScheduleProductClassEnum -> CreditNthToDefault
            then (economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (UnderlierForOptionOrForwardProduct(product) -> Product ->> economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalFromResolvablePQ) // Credit Total return swap on a bond not supported
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> ForeignExchange
        then (if productClass = StandardizedScheduleProductClassEnum -> DeliverableSwap
            then (StandardizedScheduleFXSwapNotional(
                        FXFarLeg(product),
                        trade -> tradeLot only-element
                    ) -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableCrossCurrencySwap
            then 0.0 // Recieve side notional and currency. What does that mean?
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> value)
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (
                        StandardizedScheduleFXVarianceNotionalAmount(economicTerms -> payout -> PerformancePayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then 0.0 // Vega notional amount not mapped in the product
            else if productClass = StandardizedScheduleProductClassEnum -> CorrelationSwap
            then 0.0 // No sample trades
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Equity
        then (if productClass = StandardizedScheduleProductClassEnum -> Option
            then (
                        StandardizedScheduleOptionNotionalAmount(economicTerms -> payout -> OptionPayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (
                        StandardizedScheduleEquityForwardNotionalAmount(economicTerms -> payout -> SettlementPayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> DividendSwap
            then 0.0 // All dividend swaps are defined with a monetary payment, no strike price or number of shares
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (
                        StandardizedScheduleVarianceSwapNotionalAmount(economicTerms -> payout -> PerformancePayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then 0.0 // Is volatility amount = vega notional amount?
                // EQ Contract fo Difference (CFD) not supported
            else if productClass = StandardizedScheduleProductClassEnum -> SwapsAndPortfolioSwaps
            then 0.0 // No initial value or current value available in the test samples
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Commodity
        then (if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (
                        StandardizedScheduleCommodityForwardNotionalAmount(economicTerms
                    ) // Floating price forwards not supported
                    )
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (
                        StandardizedScheduleOptionNotionalAmount(economicTerms -> payout -> OptionPayout only-element
                    ))
            else if productClass = StandardizedScheduleProductClassEnum -> FixedFloatSwap
            then (StandardizedScheduleCommoditySwapFixedFloatNotionalAmount(economicTerms))
            else if productClass = StandardizedScheduleProductClassEnum -> BasisSwap
            then 0.0 // No spot price available
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (
                        StandardizedScheduleCommoditySwapFixedFloatNotionalAmount(UnderlierForOptionOrForwardProduct(
                                product
                            ) -> Product ->> economicTerms
                    )) // CO Contract for Difference (CFD) not supported
            )

    post-condition PositiveNotional: <"Ensure notional is greater than 0">
        notional > 0

func StandardizedScheduleNotionalCurrency: <"Extracts the notional currency of a trade, according to the product class-depending extraction method defined in the ISDA industry survey.">
    inputs:
        trade Trade (1..1)
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        productClass StandardizedScheduleProductClassEnum (1..1)
    output:
        notionalCurrency string (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set notionalCurrency:
        if assetClass = StandardizedScheduleAssetClassEnum -> InterestRates
        then (if productClass = StandardizedScheduleProductClassEnum -> Swap
                    or productClass = StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
            then (economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> CrossCurrencySwap
            then (economicTerms -> payout -> InterestRatePayout
                filter (True /*how do we identify the receiver party?*/ )
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
                    or productClass = StandardizedScheduleProductClassEnum -> SwaptionStraddle
            then (UnderlierForOptionOrForwardProduct(product) -> Product ->> economicTerms -> payout -> InterestRatePayout
                filter (priceQuantity -> quantitySchedule exists)
                then first
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            // IR Exotic swap with an exotic coupon against a floating leg not supported
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> InterestRatePayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> ForwardRateAgreement
            then (economicTerms -> payout -> InterestRatePayout
                filter rateSpecification -> FixedRateSpecification exists
                then only-element
                then priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ))
        else if assetClass = StandardizedScheduleAssetClassEnum -> Credit
        then (if productClass = StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
                    or productClass = StandardizedScheduleProductClassEnum -> IndexCDS
                    or productClass = StandardizedScheduleProductClassEnum -> IndexTranche
                    or productClass = StandardizedScheduleProductClassEnum -> CreditNthToDefault
            then (economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ)
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (UnderlierForOptionOrForwardProduct(product) -> Product ->> economicTerms -> payout -> CreditDefaultPayout only-element -> priceQuantity
                then StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ) // Credit Total return swap on a bond not supported
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> ForeignExchange
        then (if productClass = StandardizedScheduleProductClassEnum -> DeliverableSwap
            then (StandardizedScheduleFXSwapNotional(
                        FXFarLeg(product),
                        trade -> tradeLot only-element
                    ) -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableCrossCurrencySwap
            then "AAA" // Recieve side notional and currency. What does that mean?
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableForward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> DeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> NonDeliverableOption
            then (economicTerms -> payout -> OptionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (economicTerms -> payout -> PerformancePayout only-element -> returnTerms -> varianceReturnTerms -> varianceStrikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then "AAA" // Vega notional amount not mapped in the product
            else if productClass = StandardizedScheduleProductClassEnum -> CorrelationSwap
            then "AAA" // No sample trades
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Equity
        then (if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> OptionPayout only-element -> strike -> strikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> DividendSwap
            then "AAA" // All dividend swaps are defined with a monetary payment, no strike price or number of shares
                // EQ Deliverable Option F not supported
            else if productClass = StandardizedScheduleProductClassEnum -> VarianceSwap
            then (economicTerms -> payout -> PerformancePayout only-element -> returnTerms -> varianceReturnTerms -> volatilityStrikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> VolatilitySwap
            then "AAA" // Is volatility amount = vega notional amount?
                // EQ Contract fo Difference (CFD) not supported
            else if productClass = StandardizedScheduleProductClassEnum -> SwapsAndPortfolioSwaps
            then "AAA" // No initial value or current value available in the test samples
            )
        else if assetClass = StandardizedScheduleAssetClassEnum -> Commodity
        then (if productClass = StandardizedScheduleProductClassEnum -> Forward
            then (economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> unit -> currency // Floating price forwards not supported
                )
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then (economicTerms -> payout -> OptionPayout only-element -> strike -> strikePrice -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> FixedFloatSwap
            then (economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> unit -> currency)
            else if productClass = StandardizedScheduleProductClassEnum -> BasisSwap
            then "AAA" // No spot price available
            else if productClass = StandardizedScheduleProductClassEnum -> Swaption
            then (UnderlierForOptionOrForwardProduct(product) -> Product ->> economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> unit -> currency) // CO Contract for Difference (CFD) not supported
            )

    post-condition ValidCurrency: <"Ensure Currency is an ISO 3-Letter Currency Code ">
        notionalCurrency to-enum ISOCurrencyCodeEnum exists

func AuxiliarEffectiveDate: <"Extracts the effective date of specific products such as interest rate swaps and swaptions.">
    inputs:
        trade Trade (1..1)
    output:
        effectiveDate date (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set effectiveDate:
        // interestRatePayout
        if economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate exists
        then (economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate
            extract AdjustableDateResolution
            then min)
        // interestRateSwaptions
        else if economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate exists
        then (economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate
            extract AdjustableDateResolution
            then min)

func AuxiliarTerminationDate: <"Extracts the termination date of specific products such as interest rate swaps and swaptions.">
    inputs:
        trade Trade (1..1)
    output:
        terminationDate date (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    set terminationDate:
        // interestRatePayout
        if economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate exists
        then (economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate
            extract AdjustableDateResolution
            then max)
        // interestRateSwaptions
        else if economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate exists
        then (economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate
            extract AdjustableDateResolution
            then max)

func StandardizedScheduleDuration: <"Extracts the duration of a trade, according to the product class-depending extraction method defined in the ISDA industry survey.">
    inputs:
        trade Trade (1..1)
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        productClass StandardizedScheduleProductClassEnum (1..1)
    output:
        durationInYears number (0..1)
    alias product: trade -> product
    alias economicTerms: product -> economicTerms
    alias underlier: UnderlierForOptionOrForwardProduct(product)
    alias transactionEffectiveDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(economicTerms -> effectiveDate)
            )
    alias transactionTerminationDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(
                        economicTerms -> terminationDate
                    )
            )
    alias transactionTenorInYears:
        if transactionEffectiveDate exists and transactionTerminationDate exists
        then DateDifferenceYears(transactionEffectiveDate, transactionTerminationDate)
    alias underlyingTransactionEffectiveDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(
                        underlier -> Product ->> economicTerms -> effectiveDate
                    )
            )
    alias underlyingTransactionTerminationDate:
        AdjustableOrAdjustedOrRelativeDateResolution(
                ConvertToAdjustableOrAdjustedOrRelativeDate(
                        underlier -> Product ->> economicTerms -> terminationDate
                    )
            )
    alias underlyingTransactionTenorInYears:
        if underlyingTransactionEffectiveDate exists
                and underlyingTransactionTerminationDate exists
        then DateDifferenceYears(
                    underlyingTransactionEffectiveDate,
                    underlyingTransactionTerminationDate
                )
    alias optionExpiry:
        economicTerms -> payout -> OptionPayout only-element -> exerciseTerms
            then extract
                if style = OptionExerciseStyleEnum -> American
                then AdjustableOrAdjustedOrRelativeDateResolution(
                            ConvertToAdjustableOrAdjustedOrRelativeDate(
                                    expirationDate only-element
                                )
                        )
                else if style = OptionExerciseStyleEnum -> European
                then (expirationDate
                    max [
                        AdjustableOrAdjustedOrRelativeDateResolution(
                                ConvertToAdjustableOrAdjustedOrRelativeDate(item)
                            )
                    ]
                    extract
                        AdjustableOrAdjustedOrRelativeDateResolution(
                                ConvertToAdjustableOrAdjustedOrRelativeDate(item)
                            ))
                else if style = OptionExerciseStyleEnum -> Bermuda
                then (if exerciseDates -> adjustableDates exists
                    then AdjustableDatesResolution(exerciseDates -> adjustableDates)
                        max [ item ]
                        extract item)
    alias timeToOptionExpiryInYears:
        if transactionEffectiveDate exists and optionExpiry exists
        then DateDifferenceYears(transactionEffectiveDate, optionExpiry)
    alias genericDurationInYears:
        if (assetClass = StandardizedScheduleAssetClassEnum -> InterestRates or assetClass = StandardizedScheduleAssetClassEnum -> Credit)
        then (if productClass = StandardizedScheduleProductClassEnum -> Swap
                    or productClass = StandardizedScheduleProductClassEnum -> SwapWithCallableBermudanRightToEnterExitSwaps
                    or productClass = StandardizedScheduleProductClassEnum -> CrossCurrencySwap
                    or productClass = StandardizedScheduleProductClassEnum -> ForwardRateAgreement
                    or productClass = StandardizedScheduleProductClassEnum -> SingleNameCreditDefaultSwap
                    or productClass = StandardizedScheduleProductClassEnum -> IndexCDS
                    or productClass = StandardizedScheduleProductClassEnum -> IndexTranche
                    or productClass = StandardizedScheduleProductClassEnum -> CreditNthToDefault
            then transactionTenorInYears
            else if (productClass = StandardizedScheduleProductClassEnum -> Swaption or productClass = StandardizedScheduleProductClassEnum -> SwaptionStraddle)
            then (if timeToOptionExpiryInYears exists
                        and underlyingTransactionTenorInYears exists
                then timeToOptionExpiryInYears + underlyingTransactionTenorInYears
                else if timeToOptionExpiryInYears exists
                then timeToOptionExpiryInYears
                else if underlyingTransactionTenorInYears exists
                then underlyingTransactionTenorInYears)
            else if productClass = StandardizedScheduleProductClassEnum -> Option
            then timeToOptionExpiryInYears // IR Exotic swap with an exotic coupon against a floating leg not supported
                // Credit Total return swap on a bond not supported
            )
    alias auxiliarDurationInYears:
        DateDifferenceYears(AuxiliarEffectiveDate(trade), AuxiliarTerminationDate(trade))
    set durationInYears:
        if genericDurationInYears exists
        then genericDurationInYears
        else auxiliarDurationInYears

    post-condition PositiveDuration: <"Ensure duration is greater than 0.">
        if durationInYears exists then durationInYears > 0

func GetStandardizedScheduleMarginRate: <"Computes the margin rate, which is required in the calculation of the gross initial margin. It depends exclusively on the asset class of the trade and, in some cases, on the duration as well.">
    inputs:
        assetClass StandardizedScheduleAssetClassEnum (1..1)
        durationInYears number (1..1)
    output:
        percentage number (1..1)
    set percentage:
        if assetClass = StandardizedScheduleAssetClassEnum -> InterestRates
        then (if durationInYears <= 2
            then 1.0
            else if durationInYears > 2 and durationInYears <= 5
            then 2.0
            else if durationInYears > 5
            then 4.0)
        else if assetClass = StandardizedScheduleAssetClassEnum -> Credit
        then (if durationInYears <= 2
            then 2.0
            else if durationInYears > 2 and durationInYears <= 5
            then 5.0
            else if durationInYears > 5
            then 10.0)
        else if assetClass = StandardizedScheduleAssetClassEnum -> ForeignExchange
        then 6.0
        else if assetClass = StandardizedScheduleAssetClassEnum -> Equity
        then 15.0
        else if assetClass = StandardizedScheduleAssetClassEnum -> Commodity
        then 15.0

func StandardizedScheduleMonetaryNotionalFromResolvablePQ: <"Extracts the notional amount for all products that have it populated in the resolvable priceQuantity.">
    inputs:
        priceQuantity ResolvablePriceQuantity (0..1)
    output:
        notional number (0..1)

    set notional:
        if priceQuantity -> quantitySchedule exists
                and priceQuantity -> quantitySchedule -> unit -> currency exists
        then (if priceQuantity -> quantitySchedule -> multiplier exists
            then priceQuantity -> quantitySchedule -> value * priceQuantity -> quantitySchedule -> multiplier -> value
            else priceQuantity -> quantitySchedule -> value)

func StandardizedScheduleMonetaryNotionalCurrencyFromResolvablePQ: <"Extracts the notional currency for all products that have it populated in the resolvable priceQuantity.">
    inputs:
        priceQuantity ResolvablePriceQuantity (0..1)
    output:
        notionalCurrency string (0..1)

    set notionalCurrency:
        if priceQuantity -> quantitySchedule exists
                and priceQuantity -> quantitySchedule -> unit -> currency exists
        then (if priceQuantity -> quantitySchedule -> multiplier exists
            then priceQuantity -> quantitySchedule -> multiplier -> unit -> currency
            else priceQuantity -> quantitySchedule -> unit -> currency)

func StandardizedScheduleFXSwapNotional: <"Extracts the notional amount and currency of an FX swap.">
    inputs:
        farLeg SettlementPayout (0..1)
        tradeLot TradeLot (0..1)
    output:
        quantity NonNegativeQuantitySchedule (0..1)
    alias priceQuantity:
        tradeLot -> priceQuantity
            filter (item -> price = farLeg -> priceQuantity -> priceSchedule)
            then only-element
    alias exchangedCurrencies: priceQuantity -> quantity
    alias extractedExchangedCurrency:
        if exchangedCurrencies -> unit -> currency any = "USD"
        then (exchangedCurrencies
            filter unit -> currency = "USD"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "EUR"
        then (exchangedCurrencies
            filter unit -> currency = "EUR"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "JPY"
        then (exchangedCurrencies
            filter unit -> currency = "JPY"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "GBP"
        then (exchangedCurrencies
            filter unit -> currency = "GBP"
            then only-element)
        else if exchangedCurrencies -> unit -> currency any = "CHF"
        then (exchangedCurrencies
            filter unit -> currency = "CHF"
            then only-element)
        else (exchangedCurrencies
            sort [ item -> unit -> currency ]
            first)
    set quantity: extractedExchangedCurrency

func StandardizedScheduleFXVarianceNotionalAmount: <"Extracts the notional amount of an FX variance swap.">
    inputs:
        performancePayout PerformancePayout (0..1)
    output:
        amount number (0..1)
    alias varianceReturnTerms: performancePayout -> returnTerms -> varianceReturnTerms
    alias vegaNotionalAmount: varianceReturnTerms -> vegaNotionalAmount
    alias fixedRate: varianceReturnTerms -> varianceStrikePrice
    set amount: (vegaNotionalAmount -> value) / (0.02 * (fixedRate -> value))

func StandardizedScheduleOptionNotionalAmount: <"Extracts the notional amount of a CO or EQ option.">
    inputs:
        optionPayout OptionPayout (0..1)
    output:
        amount number (0..1)
    alias strikePrice: optionPayout -> strike -> strikePrice -> value
    alias notionalQuantity:
        optionPayout -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: strikePrice * notionalQuantity

func StandardizedScheduleEquityForwardNotionalAmount: <"Extracts the notional amount of an EQ forward.">
    inputs:
        settlementPayout SettlementPayout (0..1)
    output:
        amount number (0..1)
    alias forwardPrice:
        settlementPayout -> priceQuantity -> priceSchedule only-element -> value
    alias notionalQuantity:
        settlementPayout -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: forwardPrice * notionalQuantity

func StandardizedScheduleVarianceSwapNotionalAmount: <"Extracts the notional amount of an EQ variance swap.">
    inputs:
        performancePayout PerformancePayout (0..1)
    output:
        amount number (0..1)
    alias varianceAmount:
        performancePayout -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
            then if item >= 1 then 0.01 * item else item
    alias volatilityStrikePrice:
        performancePayout -> returnTerms -> varianceReturnTerms -> volatilityStrikePrice -> value
    set amount: 200 * varianceAmount * volatilityStrikePrice

func StandardizedScheduleCommodityForwardNotionalAmount: <"Extracts the notional amount of a CO forward. Floating price forwards not supported.">
    inputs:
        economicTerms EconomicTerms (0..1)
    output:
        amount number (0..1)
    alias forwardPrice:
        economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> value
    alias notionalQuantity:
        economicTerms -> payout -> SettlementPayout only-element -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: forwardPrice * notionalQuantity

func StandardizedScheduleCommoditySwapFixedFloatNotionalAmount: <"Extracts the notional amount of a CO fixed float swap.">
    inputs:
        economicTerms EconomicTerms (0..1)
    output:
        amount number (0..1)
    alias fixedPrice:
        economicTerms -> payout -> FixedPricePayout only-element -> fixedPrice -> price -> value
    alias notionalQuantity:
        economicTerms -> payout -> CommodityPayout only-element -> priceQuantity -> quantitySchedule
            then (if multiplier exists
                then value * multiplier -> value
                else value)
    set amount: fixedPrice * notionalQuantity

func Qualify_Credit_NthToDefault: <"Qualifies a product as a CR basket Nth to default by checking that 1) it is a credit product with a basket underlier and 2) nth to default information is populated.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> basketReferenceInformation -> nthToDefault exists

func Qualify_InterestRate_Swaption_Straddle: <"Qualifies a product as an IR swaption straddle by checking that it is indeed an IR swaption with the option type populated as Straddle.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        Qualify_InterestRate_Option_Swaption(economicTerms)
            and economicTerms -> payout -> OptionPayout only-element -> optionType = OptionTypeEnum -> Straddle

func Qualify_InterestRate_SwapWithCallableBermudanRightToEnterExitSwaps: <"Qualifies a product as an IR swap with bermudan/callable right to enter/exit swaps, by checking it is an IR swap that has an optional early termination with Bermudan style.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_Product boolean (1..1)
    set is_Product:
        Qualify_BaseProduct_IRSwap(economicTerms)
            and economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseTerms -> style = OptionExerciseStyleEnum -> Bermuda

func GetNetInitialMarginFromExposure: <"Computes the net initial margin, taking the gross initial margin result and the mark to market value for each trade in the portfolio.">
    inputs:
        exposure Exposure (0..1)
    output:
        initialMargin StandardizedScheduleInitialMargin (0..1)
    alias tradePortfolio: exposure -> tradePortfolio
    alias positions: tradePortfolio -> positions
    alias tradeInitialMargin:
        positions
            extract
                StandardizedScheduleTradeInfo {
                    assetClass: BuildStandardizedSchedule(item -> tradeReference -> trade) -> assetClass,
                    productClass: BuildStandardizedSchedule(item -> tradeReference -> trade) -> productClass,
                    grossInitialMargin: GetGrossInitialMarginFromStandardizedSchedule(
                            BuildStandardizedSchedule(item -> tradeReference -> trade)
                        ),
                    markToMarketValue: item -> tradeReference -> valuationHistory
                        filter method = ValuationTypeEnum -> MarkToMarket
                        then only-element
                        then amount
                }
    alias totalGIM: tradeInitialMargin -> grossInitialMargin -> value sum
    alias netCurrentReplacementCost: tradeInitialMargin -> markToMarketValue -> value sum
    alias grossCurrentReplacementCost:
        tradeInitialMargin -> markToMarketValue
            filter item -> value > 0
            then value sum
    alias netToGrossRatio: netCurrentReplacementCost / grossCurrentReplacementCost
    add initialMargin -> tradeInfo: tradeInitialMargin
    set initialMargin -> netInitialMargin -> value:
        0.4 * totalGIM + 0.6 * totalGIM * netToGrossRatio
    set initialMargin -> netInitialMargin -> unit -> currency:
        tradeInitialMargin -> markToMarketValue -> unit -> currency distinct only-element

    post-condition NonNegativeNetInitialMargin: <"Ensure net initial margin is non-negative">
        initialMargin -> netInitialMargin -> value >= 0

    post-condition TotalGIMAddition: <"Ensure that only a single currency exists">
        tradeInitialMargin -> grossInitialMargin -> unit -> currency distinct count = 1

    post-condition NGRAddition: <"Ensure that only a single currency exists">
        tradeInitialMargin -> markToMarketValue -> unit -> currency distinct count = 1


================================================================================
FILE: rosetta-source/src/main/rosetta/margin-schedule-type.rosetta
================================================================================

namespace cdm.margin.schedule
version "${project.version}"

import cdm.base.staticdata.asset.common.*
import cdm.observable.asset.*

type StandardizedSchedule:
    assetClass StandardizedScheduleAssetClassEnum (1..1)
    productClass StandardizedScheduleProductClassEnum (1..1)
    notional number (1..1)
    notionalCurrency string (1..1)
    durationInYears number (0..1)

    condition PositiveNotional: <"Ensure notional is greater than 0">
        notional > 0

    condition ValidCurrency: <"Ensure Currency is an ISO 3-Letter Currency Code">
        notionalCurrency to-enum ISOCurrencyCodeEnum exists

    condition PositiveDuration: <"Ensure duration is greater than 0.">
        if durationInYears exists then durationInYears > 0

type StandardizedScheduleTradeInfo:
    assetClass StandardizedScheduleAssetClassEnum (0..1)
    productClass StandardizedScheduleProductClassEnum (0..1)
    grossInitialMargin Money (0..1)
    markToMarketValue Money (0..1)

    condition PositiveGrossInitialMargin: <"Ensure gross initial margin is greater than 0">
        grossInitialMargin -> value > 0

    condition SameCurrencies: <"Ensure that only a single currency exists">
        grossInitialMargin -> unit -> currency = markToMarketValue -> unit -> currency

type StandardizedScheduleInitialMargin:
    tradeInfo StandardizedScheduleTradeInfo (0..*)
    netInitialMargin Money (1..1)

    condition NonNegativeNetInitialMargin: <"Ensure net initial margin is non-negative">
        netInitialMargin -> value >= 0


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-calculatedrate-enum.rosetta
================================================================================

namespace cdm.observable.asset.calculatedrate : <"Support for calculated floating rates such as lookback compound or observation shift compound rates">
version "${project.version}"

enum CalculationMethodEnum: <"What calculation type is required, averaging or compounding. This enumeration is used to represent the definitions of modular calculated rates as described in the 2021 ISDA Definitions, section 7.">
    Averaging <"Averaging, i.e. arithmetic averaging.">
    Compounding <"Compounding, i.e. geometric averaging following an ISDA defined formula.">
    CompoundedIndex <"A rate based on an index that is computed by a rate administrator.  The user is responsible for backing out the rate by applying a simple formula.">

enum InflationCalculationMethodEnum: <"Indicates how to use the inflation index to calculate the payment (e.g. Ratio, Return, Spread). Added for Inflation Asset Swap">
    Ratio <"(Inflation Index Final / Inflation Index Base). Inflation Index Final is inflation index for Reference Month that is the Lag number of months prior to Payment Date (subject to interpolation). Inflation Index Base subject to the Calculation Style. Used in inflation asset swaps to calculate the inflation coupons and principal exchange.">
    Return <"(Inflation Index Final / Inflation Index Base -1). Inflation Index Final is the inflation index for Reference Month that is the Lag number of months prior to Payment Date (subject to interp). Inflation Index Base subject to the Calculation Style. Used in market standard ZC Inflation swaps.">
    Spread <"Inflation Index Final - Inflation Index Base). Inflation Index Final is Index for Ref month the Lag months prior to Payment Date (subject to interp). Inflation Index Base subject to the Calculation Style. Typically used for fixing locks.">

enum InflationCalculationStyleEnum: <"Indicates the style of how the inflation index calculates the payment (e.g. YearOnYear, ZeroCoupon).">
    YearOnYear <"YearOnYear means Inflation Index Base is the inflation index for Reference Month that is 12 months prior to Inflation Index Final (subject to interpolation). Inflation Index Base is cashflow dependent.">
    ZeroCoupon <"ZeroCoupon means Inflation Index Base used in the CalculationMethod is the inflation index for the Reference Month that is the lag number of months prior to Effective Date in the case of a swap, or Bond Interest Accrual Date in the case of an Asset Swap (subject to interpolation). Inflation Index Base has the same value for each inflation cashflow and Principal Exchange calculation within the trade.">

enum ObservationPeriodDatesEnum: <"The enumerated values to specify whether rate calculations occur relative to the first or last day of a calculation period. Done in uppercase due to a bug in code generation. This enumeration is used to represent the definitions of modular calculated rates as described in the 2021 ISDA Definitions, section 7.">
    SetInAdvance <"Calculations occur relative to the first day of a calculation period.">
    Standard <"Calculations occur relative to the last day of a calculation period (set in arrears).">
    FixingDate <"Calculations occur relative to a previously defined reset date, e.g. for a fallback rate.">

enum CalculationShiftMethodEnum: <" the specific calculation method, e.g. lookback. This enumeration is used to represent the definitions of modular calculated rates as described in the 2021 ISDA Definitions, section 7.">
    Lookback <"Calculations and weighting are done with respect to the calculation period, but observations are shifted back by several days.">
    ObservationPeriodShift <"the observation period is shifted by several days prior to rate setting, and weightings are done with respect to the obseration period.">
    RateCutOff <"Calculations cut the rate off several business days prior to rate setting (Lockout).">
    NoShift <"calculations occur without any shifting, e.g. OIS Compounding/Basic Averaging style.">


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-calculatedrate-func.rosetta
================================================================================

namespace cdm.observable.asset.calculatedrate : <"Support for calculated floating rates such as lookback compound or observation shift compound rate.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.math.*
import cdm.observable.asset.*
import cdm.product.asset.floatingrate.*
import cdm.product.common.schedule.*

// =====================================================================
//
// Calculated rate functions
//
// these functions perform the necessary calculations on calculated rates,
// such as OIS Compound, lookback compound, etc.
// These calculations are described in Section 7 of the 2021 ISDA Definitions.
//
// ======================================================================
func EvaluateCalculatedRate: <"Evaluate a calculated rate as described in the 2021 ISDA Definitions.">
    inputs:
        interestRateIndex InterestRateIndex (1..1) <"The base floating rate index.">
        calculationParameters FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
        resetDates ResetDates (0..1) <"Reset structure (needed only for fallback rates, otherwise will be empty).">
        calculationPeriod CalculationPeriodBase (1..1) <"Calculation period for which we want to determine the rate.">
        priorCalculationPeriod CalculationPeriodBase (0..1) <"The prior calculation period (needed only for set in advance observation shift rate.">
        dayCount DayCountFractionEnum (1..1) <"The day count fraction in effect on the stream.">
    output:
        results FloatingRateSettingDetails (1..1) <"detailed results of the floating rate calculation.">

    alias rate: interestRateIndex

    // work out the observation dates needed and the weight for each
    alias datesAndWeights:
        GenerateObservationDatesAndWeights(
                calculationParameters,
                resetDates,
                calculationPeriod,
                priorCalculationPeriod
            )

    // get the observations
    alias observationDates: datesAndWeights -> observationDates
    alias observations: IndexValueObservationMultiple(observationDates, rate)

    // apply observation parameters (caps/floors)
    alias processedObservations: ProcessObservations(calculationParameters, observations)

    // perform the calculation (compounding or averaging)
    alias calculationMethod: calculationParameters -> calculationMethod
    alias isCompounding: calculationMethod = CalculationMethodEnum -> Compounding
    alias weights: datesAndWeights -> weights
    alias yearFraction: YearFractionForOneDay(dayCount) // the year fraction of 1 business day (needed for compounding formula)
    alias calculationResults:
        if isCompounding
        then ApplyCompoundingFormula(processedObservations, weights, yearFraction)
        else ApplyAveragingFormula(observations, weights)

    // record the results
    set results -> calculationDetails: calculationResults
    add results -> calculationDetails -> observations -> observationDates:
        datesAndWeights -> observationDates
    add results -> calculationDetails -> observations -> weights: datesAndWeights -> weights
    add results -> calculationDetails -> observations -> observedRates: observations
    add results -> calculationDetails -> observations -> processedRates:
        processedObservations
    set results -> floatingRate: calculationResults -> calculatedRate

func GenerateObservationDatesAndWeights: <"Apply shifts to generate the list of observation dates and weights for each of those date.">
    inputs:
        calculationParams FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
        resetDates ResetDates (0..1) <"Reset structure (needed only for fallback rates, otherwise will be empty.">
        calculationPeriod CalculationPeriodBase (1..1) <"Calculation period for which we want to determine the rate.">
        priorCalculationPeriod CalculationPeriodBase (0..1) <"The prior calculation period (needed only for set in advance observation shift rate.">
    output:
        results CalculatedRateObservationDatesAndWeights (1..1) <"observation dates and corresponding weight.">

    // set up some convenience accessors
    alias obsShift: calculationParams -> observationShiftCalculation
    alias lockout: calculationParams -> lockoutCalculation
    alias specifiedLockout:
        if lockout -> offsetDays exists
        then lockout -> offsetDays
        else 5
    alias lockoutDays:
        if (lockout exists) then specifiedLockout else 0
    alias businessDays: GetAllBusinessCenters(calculationParams -> applicableBusinessDays)

    // work out the calculation period for which the rate will actually be computed (might be the prior period or based on resetDates)
    alias calculateRelative:
        if obsShift -> calculationBase exists
        then obsShift -> calculationBase
        else ObservationPeriodDatesEnum -> Standard
    alias adjustedCalculationPeriod:
        ComputeCalculationPeriod(
                calculationPeriod,
                priorCalculationPeriod,
                calculateRelative,
                resetDates
            )

    // generate the (shifted) observation period and then the observation dates
    alias observationPeriod:
        DetermineObservationPeriod(adjustedCalculationPeriod, calculationParams)
    alias observationDates:
        GenerateObservationDates(observationPeriod, businessDays, lockoutDays)

    // record the results
    add results -> observationDates: observationDates
    add results -> weights:
        GenerateWeightings(
                calculationParams,
                results -> observationDates,
                observationPeriod,
                adjustedCalculationPeriod,
                lockoutDays
            )

// possibly record some other intermediate results to aid debugging/understanding?
func ComputeCalculationPeriod: <"Determine the calculation period to use for computing the calculated rate (it may not be the same as the normal calculation period, for instance if the rate is set in advance.">
    [codeImplementation]
    inputs:
        calculationPeriod CalculationPeriodBase (1..1) <"The current calculation period for which the rate is neede.">
        priorCalculationPeriod CalculationPeriodBase (0..1) <"The prior actual or deemed calculation period, if neede.">
        calculateRelativeTo ObservationPeriodDatesEnum (0..1) <"How the calculation is done with respect to the base calculation perio.">
        resetDates ResetDates (0..1) <"The resetDates structure, if needed, e.g. for fallback rate.">
    output:
        result CalculationPeriodBase (1..1) <"The calculation period over which the calculated rate should be calculate.">

func ComputeCalculationPeriod(calculateRelativeTo: ObservationPeriodDatesEnum -> SetInAdvance):
    set result: priorCalculationPeriod

func ComputeCalculationPeriod(calculateRelativeTo: ObservationPeriodDatesEnum -> Standard):
    set result: calculationPeriod

func ComputeCalculationPeriod(calculateRelativeTo: ObservationPeriodDatesEnum -> FixingDate):
    // TODO : this should use the code in Evaluate Term Rate to do the offset calculation (needs refactoring)
    alias resetRelativeTo: resetDates -> resetRelativeTo
    alias isStart: resetRelativeTo = ResetRelativeToEnum -> CalculationPeriodStartDate
    alias calcPd:
        if (isStart)
        then priorCalculationPeriod
        else calculationPeriod
    alias fixingOffsetDays: resetDates -> fixingDates -> periodMultiplier
    alias businessCenters:
        GetAllBusinessCenters(resetDates -> resetDatesAdjustments -> businessCenters)
    alias endDate:
        AddBusinessDays(calcPd -> adjustedEndDate, fixingOffsetDays, businessCenters)
    alias startDate:
        AddBusinessDays(calcPd -> adjustedStartDate, fixingOffsetDays, businessCenters)
    set result -> adjustedEndDate: endDate
    set result -> adjustedStartDate: startDate

func DetermineObservationPeriod: <"Determine any applicable offsets/shifts for the period for observing an index, and then generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shift.">
    inputs:
        adjustedCalculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the rate is being computed, after any adjustment.">
        calculationParams FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
    output:
        observationPeriod CalculationPeriodBase (1..1) <"The resulting observation period.">

    // convenience alias to categorize the shift types and calculate the business days to use
    alias obsShift: calculationParams -> observationShiftCalculation
    alias lookback: calculationParams -> lookbackCalculation
    alias businessDays: calculationParams -> applicableBusinessDays
    alias additionalBusinessDays: obsShift -> additionalBusinessDays
    alias allBusinessDays:
        [businessDays, additionalBusinessDays]
            extract GetAllBusinessCenters(item)
            then flatten

    // determine the shift amount
    alias shift:
        if (obsShift exists)
        then obsShift -> offsetDays
        else if lookback exists
        then lookback -> offsetDays
        else 0 // shift amount
        // default to 5 days if not specified (this is the default value from the 2021 Definitions)
    alias shiftDefaulted: if shift exists then shift else 5

    // calculate and return the shifted observation period
    set observationPeriod:
        GenerateObservationPeriod(
                adjustedCalculationPeriod,
                allBusinessDays,
                shiftDefaulted
            )

func GenerateObservationPeriod: <"Generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts.">
    inputs:
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the rate is being compute.">
        businessCenters BusinessCenterEnum (0..*) <"The business centers to be used for shifting.">
        shiftDays int (0..1) <"The amount of any shift.">
    output:
        observationPeriod CalculationPeriodBase (1..1) <"The resulting observation period.">

    // calculate the starting and ending dates
    alias calcStart: calculationPeriod -> adjustedStartDate
    alias calcEnd: calculationPeriod -> adjustedEndDate
    alias obsStart: AddBusinessDays(calcStart, -1 * shiftDays, businessCenters)
    alias obsEnd: AddBusinessDays(calcEnd, -1 * shiftDays, businessCenters)

    // record results
    set observationPeriod -> adjustedStartDate: obsStart
    set observationPeriod -> adjustedEndDate: obsEnd

func GenerateObservationDates: <"Generate the list of observation dates given an observation period.">
    inputs:
        observationPeriod CalculationPeriodBase (1..1) <"The given observation period.">
        businessCenters BusinessCenterEnum (0..*) <"The observation date.">
        lockoutDays int (0..1) <"The number of lockout date.">
    output:
        observationDates date (0..*) <"The resulting list of observation date.">

    // work out the final date of the observations  - we skip observing on the last day of the observation period
    alias days: 1 + (if (lockoutDays exists) then lockoutDays else 0)
    alias endDate:
        AddBusinessDays(observationPeriod -> adjustedEndDate, -1 * days, businessCenters)

    // create the list of observation dates - all business days between the start and end dates
    add observationDates:
        GenerateDateList(observationPeriod -> adjustedStartDate, endDate, businessCenters)

func GenerateWeightings: <"Determine the weighting dates and the corresponding weights to be used for weighting observation.">
    inputs:
        calculationParams FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
        observationDates date (0..*)
        observationPeriod CalculationPeriodBase (1..1) <"The resulting observation period.">
        adjustedCalculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the rate is being computed, after any adjustment.">
        lockoutDays int (1..1) <"The number of lockout day.">
    output:
        weights number (0..*) <"A vector of weights, typically numbers between 1 and 3.">

    alias weightingDates:
        DetermineWeightingDates(
                calculationParams,
                observationDates,
                observationPeriod,
                adjustedCalculationPeriod,
                lockoutDays
            )

    set weights: GenerateWeights(weightingDates)

func DetermineWeightingDates: <"Determine the dates to be used for weighting observation.">
    inputs:
        calculationParams FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
        observationDates date (0..*)
        observationPeriod CalculationPeriodBase (1..1) <"The resulting observation period.">
        adjustedCalculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the rate is being computed, after any adjustment.">
        lockoutDays int (1..1) <"The number of lockout day.">
    output:
        weightingDates date (0..*)

    // set up some convenience aliases
    alias obsShift: calculationParams -> observationShiftCalculation
    alias lookback: calculationParams -> lookbackCalculation
    alias businessCenters:
        GetAllBusinessCenters(calculationParams -> applicableBusinessDays)

    // work out the date list for calculating weights
    alias baseWeightingDates:
        if obsShift exists
        then observationDates
        else GenerateObservationDates(
                adjustedCalculationPeriod,
                businessCenters,
                lockoutDays
            )
    alias wtPeriod:
        if (lookback exists)
        then adjustedCalculationPeriod
        else observationPeriod
    alias weightingDatesAll:
        AppendDateToList(baseWeightingDates, wtPeriod -> adjustedEndDate) // including final date to compute weight
    add weightingDates: weightingDatesAll

func ProcessObservations: <"Apply daily observation parameters to rate observation.  These are discussed in the 2021 ISDA Definitions, section 7.2.3 and 7.2.4.">
    inputs:
        calculationParameters FloatingRateCalculationParameters (1..1) <"Floating rate definition for the calculated rate.">
        rawObservations number (0..*)
    output:
        processedObservations number (0..*)

    // set up convenience aliases
    alias params: calculationParameters -> observationParameters
    alias cap: if params exists then params -> observationCapRate
    alias floor: if params exists then params -> observationFloorRate

    // apply the daily cap and floor rates using vector math operations
    alias cappedObservations:
        if cap exists
        then VectorScalarOperation(ArithmeticOperationEnum -> Min, rawObservations, cap)
        else rawObservations
    alias flooredObservations:
        if floor exists
        then VectorScalarOperation(
                    ArithmeticOperationEnum -> Max,
                    cappedObservations,
                    floor
                )
        else cappedObservations

    add processedObservations: flooredObservations

func GenerateWeights: <"Recursively creates a list of weights based on the date difference between successive days.">
    inputs:
        weightingDates date (0..*) <"A list of dates for which weightings are require.">
    output:
        weights number (0..*) <"A vector of weights, typically numbers between 1 and 3.">

    alias active: weightingDates count > 1 // do we still have more than one date in the list?
    alias refDate: weightingDates last // find the last date in the supplied list of dates
    alias remainingDates: PopOffDateList(weightingDates) // determine the prior list of dates, i.e. omitting the last in the list
    alias prevDate: remainingDates last // find the second to last date in the supplied list of dates
    alias diff: DateDifference(prevDate, refDate) // the weight is the date difference between the supplied ref date and the last one in the list
    alias remainingWeights: GenerateWeights(remainingDates) // recursively generate weights for earlier part of the list
    // if we have >= 1 in the list, add the date difference to the list of weights from the prior part of the list, else return nothing
    add weights:
        if active then AppendToVector(remainingWeights, diff * 1.0) // else null (empty list)

// -----------------------------------------------
//
// Calculated rate formula processing (compounding or averaging)
//
// -----------------------------------------------
func ApplyCompoundingFormula: <"Implements the compounding formula:   Product of ( 1 + (rate * weight) / basis), then backs out the final rate. This is used to support section 7.3 of the 2021 ISDA Definitions.">
    inputs:
        observations number (0..*) <"A vector of observation value.">
        weights number (0..*) <"A vector of weights (should be same size as observations, 1 weight per observation.">
        yearFrac number (1..1) <"Year fraction of a single day (i.e. 1/basis.">
    output:
        results CalculatedRateDetails (1..1) <"Details of the compounding calculation.">

    // weight the observations
    alias weightedObservations:
        VectorOperation(ArithmeticOperationEnum -> Multiply, observations, weights)

    // scale the weighted observations based on the basis
    alias scaledAndWeightedObservations:
        VectorScalarOperation(
                ArithmeticOperationEnum -> Multiply,
                weightedObservations,
                yearFrac
            )

    // compute series of growth factors by adding 1 to the scaled and weighted observations
    alias growthFactors:
        VectorScalarOperation(
                ArithmeticOperationEnum -> Add,
                scaledAndWeightedObservations,
                1.0
            )

    // compute a growth curve by successively applying the growth factors
    alias growthCurve: VectorGrowthOperation(1.0, growthFactors)

    // find the final value of the growth curve (the product of all the growth factors times)
    alias finalValue: growthCurve last

    // find the values to scale by to compute the rate
    alias totalWeight: weights sum
    alias overallYearFrac: totalWeight * yearFrac

    // compute the final calculated rate
    alias calculatedRate: (finalValue - 1) / overallYearFrac

    // record results
    set results -> aggregateValue: finalValue
    set results -> aggregateWeight: totalWeight
    set results -> calculatedRate: calculatedRate
    add results -> compoundedGrowth: growthCurve
    add results -> growthFactor: growthFactors
    add results -> weightedRates: weightedObservations

func ApplyAveragingFormula: <"Implements the weighted arithmetic averaging formula.  Sums the weighted rates and divides by the total weight.  This is used to support section 7.4 of the 2021 ISDA Definitions.">
    inputs:
        observations number (0..*) <"a vector of observation value.">
        weights number (0..*) <"a vector of weights (should be same size as observations, 1 weight per observation.">
    output:
        results CalculatedRateDetails (1..1) <"Details of the averaging calculation.">

    // weight the observations
    alias weightedObservations:
        VectorOperation(ArithmeticOperationEnum -> Multiply, observations, weights)

    // sum the weighted observations
    alias totalWeightedObservations: weightedObservations sum

    // sum the weights
    alias totalWeight: weights sum

    // compute the final calculated rate
    alias calculatedRate: totalWeightedObservations / totalWeight

    // record results
    set results -> aggregateValue: totalWeightedObservations
    set results -> aggregateWeight: totalWeight
    set results -> calculatedRate: calculatedRate
    add results -> weightedRates: weightedObservations

// =====================================================================
//
// Index value lookup (observation) functions
//
// these functions allow retrieval of the value of an index on a date or set of dates
//
// ======================================================================
func IndexValueObservation: <"Retrieve the values of the supplied index on the specified observation date.">
    [codeImplementation]
    // data provider - implementation provides observed value from data source
    inputs:
        observationDate date (1..1)
        interestRateIndex InterestRateIndex (1..1)
    output:
        observedValue number (1..1)

func IndexValueObservationMultiple: <"Retrieve the values of the supplied index on the specified observation dates.">
    inputs:
        observationDate date (0..*)
        interestRateIndex InterestRateIndex (1..1)
    output:
        observedValues number (0..*)

    add observedValues:
        observationDate extract IndexValueObservation(item, interestRateIndex)


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-calculatedrate-type.rosetta
================================================================================

namespace cdm.observable.asset.calculatedrate : <"Floating amount calculations for calculated rates.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.asset.rates.*

type FloatingRateCalculationParameters: <"Defines the structures needed to represent the calculation parameters for daily averaged and compounded modular rates as defined in the 2021 ISDA Definitions in Section 7. This type is used to represent modular computed rates in interestRatePayouts.">
    calculationMethod CalculationMethodEnum (1..1) <"calculation type (averaging or compounding).">
    observationShiftCalculation ObservationShiftCalculation (0..1) <"any obervation shift parameters if applicable.">
    lookbackCalculation OffsetCalculation (0..1) <"any lookback  parameters if applicable.">
    lockoutCalculation OffsetCalculation (0..1) <"any lockout  parameters if applicable.">
    applicableBusinessDays BusinessCenters (0..1) <"the business days that are applicable for the calculation.">
    observationParameters ObservationParameters (0..1) <" any applicable observation parameters, such as daily caps or floors.">

type FallbackRateParameters: <"Defines the structure needed to represent fallback rate parameters. This type is used to represent modular computed rates in interestRatePayouts.">
    floatingRateIndex FloatingRateIndexEnum (1..1) <"The floating rate index that is used as the basis of the fallback rate.">
    effectiveDate date (0..1) <"The date the fallback rate takes effect.">
    calculationParameters FloatingRateCalculationParameters (0..1) <"Support for modular calculated rates, such such as lockout compound calculations.">
    spreadAdjustment number (0..1) <"The economic spread applied to the underlying fallback rate to replicate the original risky rate.">

type OffsetCalculation: <"Defines business day shifts for daily componded or averaged rates.  This type is used for lookback and lockout rates. This type is used to represent modular computed rates in interestRatePayouts.">
    offsetDays int (0..1) <"The number of business days offset.">

type ObservationShiftCalculation: <"Parameters to describe the observation shift for a daily compounded or averaged floating rate. This type is used to represent modular computed rates in interestRatePayouts.">
    offsetDays int (0..1) <"The number of days of observation shift.">
    calculationBase ObservationPeriodDatesEnum (0..1) <"Whether the rate is calculated in advance, in arrears, or relative to a reset date.">
    additionalBusinessDays BusinessCenters (0..1) <"Any additional business days that be applicable.">

type ObservationParameters: <"Parameters on daily observed computed rates, specifically daily caps and floors. This type is used to represent modular computed rates in interestRatePayouts.">
    observationCapRate number (0..1) <"A daily observation cap rate.">
    observationFloorRate number (0..1) <"A daily observation floor rate.">

type CalculatedRateDetails: <"Type for reporting details of calculated rates, including the observations that went into the final reported rate.">
    observations CalculatedRateObservations (0..1) <"The observation dates and weights for each observation date.">
    weightedRates number (0..*) <"The weighted value of each observation.">
    growthFactor number (0..*) <"The daily growth factors, showing the weighted rates divided by the day count basis plus one, giving how much the value grows for each step in the calculation.">
    compoundedGrowth number (0..*) <"The compounding curve, showing how the initial value grew during the calculation period.">
    aggregateValue number (0..1) <"The total sum or product of all the individual terms that went into the calculated rate.">
    aggregateWeight number (0..1) <"The total weight of all the terms that went into the calculated rate.">
    calculatedRate number (0..1) <"The resulting calculated weight.">

type CalculatedRateObservations: <"Type for reporting observations that went into the final reported rate.">
    observationDates date (0..*) <"The observation date upon which the rate is observed.">
    weights number (0..*) <"The corresponding weight for each date.">
    observedRates number (0..*) <"The value observed for that date">
    processedRates number (0..*) <"The value after any processing, such as application of caps or floors.">

type CalculatedRateObservationDatesAndWeights: <"Type for reporting the observations dates and the corresponding weights going into a daily calculated rate">
    observationDates date (0..*) <"The observation date upon which the rate is observed.">
    weights number (0..*) <"The corresponding weight for each date.">


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-enum.rosetta
================================================================================

namespace cdm.observable.asset : <"Observable asset concepts: schedule, settlement, price and quantity notation etc.">
version "${project.version}"

import cdm.base.*
import cdm.mapping.config.*

enum InformationProviderEnum: <"The enumerated values to specify the list of information providers.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/information-provider"]

    AssocBanksSingapore <"The Association of Banks in Singapore.">
    BancoCentralChile <"The central bank of Chile.">
    BankOfCanada <"The central bank of Canada.">
    BankOfEngland <"The Bank Of England.">
    BankOfJapan <"The central bank of Japan.">
    Bloomberg <"Bloomberg LP.">
    EuroCentralBank <"The European Central Bank.">
    FederalReserve <"The Federal Reserve, the central bank of the United States.">
    FHLBSF <"The Federal Home Loan Bank of San Francisco, or its successor.">
    ICESWAP <"ICESWAP Rate Administrator which means ICE Benchmark Administration, or any successor thereto, as administrator of the ICE Swap Rate.">
    ISDA <"International Swaps and Derivatives Association, Inc.">
    Refinitiv <"Refinitiv, formerly Thomson Reuters Financial & Risk.">
    ReserveBankAustralia <"The Reserve Bank of Australia.">
    ReserveBankNewZealand <"The Reserve Bank of New Zealand.">
    Reuters <"Reuters Group Plc.">
    SAFEX <"South African Futures Exchange, or its successor.">
    Telerate <"Telerate, Inc.">
    TOKYOSWAP <"The Tokyo Swap Reference Rate (or TSR) Administrator, which means Refinitiv Asia Pacific Limited, or any successor thereto, as administrator of the TSR.">

enum PriceExpressionEnum: <"Enumerated values to specify whether the price is expressed in absolute or relative terms.">
    AbsoluteTerms <"The price is expressed as an absolute amount.">
    PercentageOfNotional <"The price is expressed in percentage of the notional amount.">
    ParValueFraction <"Denotes a price expressed in percentage of face value with fractions which is used for quoting bonds, e.g. 101 3/8 indicates that the buyer will pay 101.375 of the face value.">
    PerOption <"Denotes a price expressed per number of options.">

enum QuotationSideEnum: <"The enumerated values to specify the side from which perspective a value is quoted.">
    Afternoon <"Denotes a value as the Afternoon fixing reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Ask <"Denotes a value 'asked' by a seller for an asset, i.e. the value at which a seller is willing to sell.">
    Bid <"Denotes a value 'bid' by a buyer for an asset, i.e. the value a buyer is willing to pay.">
    Closing <"Denotes a value as the Closing price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    High <"Denotes a value as the High price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Index <"Denotes a value as the Index price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    MeanOfBidAndAsk <"Denotes a value as the Average of the Bid and Ask prices reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    LocationalMarginal <"Denotes a value as the Locational Marginal price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Low <"Denotes a value as the Low price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    MarginalHourly <"Denotes a value as the Marginal Hourly price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    MarketClearing <"Denotes a value as the Market Clearing price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    MeanOfHighAndLow <"Denotes a value as the Average of the High and Low prices reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Morning <"Denotes a value as the Morning fixing reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Official <"Denotes a value as the Official price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Opening <"Denotes a value as the Opening price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    OSP <"Denotes a value as the Official Settlement Price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Settlement <"Denotes a value as the Settlement price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Spot <"Denotes a value as the Spot price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    Mid <"Denotes a value as the Average of the Midpoint of prices reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    NationalSingle <"Denotes a value as the National Single price reported in or by the relevant Price Source as specified in the relevant Confirmation.">
    WeightedAverage <"Denotes a value as the Volume Weighted Average of prices effective on the Pricing Date.">
    UnWeightedAverage <"Denotes a value as the Non-volume Weighted Average of prices effective on the Pricing Date.">

enum QuotationStyleEnum: <"The enumerated values to specify the actual quotation style (e.g. PointsUpFront, TradedSpread) used to quote a credit default swap fee leg.">
    PointsUpFront <"When quotation style is 'PointsUpFront', the initialPoints element of the Credit Default Swap feeLeg should be populated">
    TradedSpread <"When quotation style is 'TradedSpread', the marketFixedRate element of the Credit Default Swap feeLeg should be populated">
    Price <"When quotation style is 'Price', the marketPrice element of the Credit Default Swap feeLeg should be populated">

enum ValuationMethodEnum: <"The enumerated values to specify the ISDA defined methodology for determining the final price of the reference obligation for purposes of cash settlement.">
    Market
    Highest
    AverageMarket
    AverageHighest
    BlendedMarket
    BlendedHighest
    AverageBlendedMarket
    AverageBlendedHighest

enum CommodityReferencePriceEnum: <"The enumeration values to specify the Commodity Reference Prices specified in the Annex to the 2005 ISDA Commodity Definitions.">
    // [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/commodity-reference-price"]
    ALUMINIUM_ALLOY_LME_15_MONTH displayName "ALUMINIUM ALLOY-LME 15 MONTH" <"Per 2005 ISDA Commodity Definitions, Sub-Annex A, Section 7.1 Commodity Reference Prices, as amended and supplemented through the date on which parties enter into the relevant transaction.">
    COAL_CENTRAL_APPALACHIAN_NYMEX displayName "COAL-CENTRAL APPALACHIAN-NYMEX" <"A code for the NYMEX Central Appalachian Coal commodity">
    COCOA_ICE displayName "COCOA-ICE" <"A code for the ICE Futures U.S. (‘ICUS’) Cocoa commodity">
    COFFEE_ARABICA_ICE displayName "COFFEE ARABICA-ICE" <"A code for the ICUS Coffee C commodity">
    COFFEE_ROBUSTA_ICE displayName "COFFEE ROBUSTA-ICE" <"A code for the ICUS Coffee C commodity">
    COPPER_COMEX displayName "COPPER-COMEX" <"A code for the COMEX (‘CMX’) Copper Grade #1 commodity">
    CORN_CBOT displayName "CORN-CBOT" <"A code for the Chicago Board of Trade (‘CBOT’) Corn commodity">
    COTTON_NO__2_ICE displayName "COTTON NO. 2-ICE" <"A code for the ICUS Cotton No. 2 commodity">
    ETHANOL_CBOT displayName "ETHANOL-CBOT" <"A code for the CBOT Ethanol commodity">
    FEEDER_CATTLE_CME displayName "FEEDER CATTLE-CME" <"A code for the CME Feeder Cattle commodity">
    FROZEN_CONCENTRATED_ORANGE_JUICE_NO__1_ICE displayName "FROZEN CONCENTRATED ORANGE JUICE NO. 1-ICE" <"A code for the ICUS Frozen Concentrated Orange Juice commodity">
    GASOLINE_RBOB_NEW_YORK_ICE displayName "GASOLINE-RBOB-NEW YORK-ICE" <"A code for the NYMEX Gasoline Blendstock (RBOB) commodity">
    GASOLINE_RBOB_NEW_YORK_NYMEX displayName "GASOLINE-RBOB-NEW YORK-NYMEX" <"A code for the NYMEX Gasoline Blendstock (RBOB) commodity">
    GOLD_COMEX displayName "GOLD-COMEX" <"A code for the CMX Gold commodity">
    HEATING_OIL_NEW_YORK_NYMEX displayName "HEATING OIL-NEW YORK-NYMEX" <"A code for the NYMEX No. 2 Heating Oil, New York Harbor commodity">
    LEAN_HOGS_CME displayName "LEAN HOGS-CME" <"A code for the CME Lean Hogs commodity">
    LIVE_CATTLE_CME displayName "LIVE CATTLE-CME" <"A code for the CME Live Cattle commodity">
    LUMBER_CME displayName "LUMBER-CME" <"A code for the CME Random Length Lumber commodity">
    MILK_CLASS_III_CME displayName "MILK-CLASS III-CME" <"A code for the CME Milk Class III commodity">
    MILK_NONFAT_DRY_CME displayName "MILK-NONFAT-DRY-CME" <"A code for the CME Non Fat Dry Milk commodity">
    NATURAL_GAS_NYMEX displayName "NATURAL GAS-NYMEX" <"A code for the NYMEX Natural Gas commodity">
    NATURAL_GAS_PEPL__TEXOK_MAINLINE__INSIDE_FERC displayName "NATURAL GAS-PEPL (TEXOK MAINLINE)-INSIDE FERC" <"A code for the NYMEX Panhandle Basis Swap commodity">
    NATURAL_GAS_W__TEXAS__WAHA__INSIDE_FERC displayName "NATURAL GAS-W. TEXAS (WAHA)-INSIDE FERC" <"A code for the NYMEX Waha Basis Swap commodity">
    OATS_CBOT displayName "OATS-CBOT" <"A code for the CBOT Oats commodity">
    OIL_WTI_NYMEX displayName "OIL-WTI-NYMEX" <"A code for the NYMEX Crude Oil, Light Sweet commodity">
    PALLADIUM_NYMEX displayName "PALLADIUM-NYMEX" <"A code for the NYMEX Palladium commodity">
    PLATINUM_NYMEX displayName "PLATINUM-NYMEX" <"A code for the NYMEX Platinum commodity">
    RICE_CBOT displayName "RICE-CBOT" <"A code for the CBOT Rough Rice commodity">
    SILVER_COMEX displayName "SILVER-COMEX" <"A code for the CMX Silver commodity">
    SOYBEANS_CBOT displayName "SOYBEANS-CBOT" <"A code for the CBOT Soybeans commodity">
    SOYBEAN_MEAL_CBOT displayName "SOYBEAN MEAL-CBOT" <"A code for the CBOT Soybean Meal commodity">
    SOYBEAN_OIL_CBOT displayName "SOYBEAN OIL-CBOT" <"A code for the CBOT Soybean Oil commodity">
    SUGAR___11__WORLD__ICE displayName "SUGAR # 11 (WORLD)-ICE" <"A code for the ICUS Sugar No. 11 commodity">
    SUGAR___16__US__ICE displayName "SUGAR # 16 (US)-ICE" <"A code for the ICUS Sugar No. 16 commodity">
    WHEAT_CBOT displayName "WHEAT-CBOT" <"A code for the CBOT Wheat commodity">
    WHEAT_HRW_KCBOT displayName "WHEAT HRW-KCBOT" <"A code for the Kansas City Board of Trade (‘KCBT’)Wheat commodity">
    WHEAT_RED_SPRING_MGE displayName "WHEAT RED SPRING-MGE" <"A code for the Wheat commodity">

enum QuoteBasisEnum: <"The enumerated values to specify how an exchange rate is quoted.">
    Currency1PerCurrency2 <"The amount of currency1 for one unit of currency2">
    Currency2PerCurrency1 <"The amount of currency2 for one unit of currency1">

enum QuotationRateTypeEnum: <"The enumerated values to specify the type of quotation rate to be obtained from each cash settlement reference bank.">
    Bid <"A bid rate.">
    Ask <"An ask rate.">
    Mid <"A mid-market rate.">
    ExercisingPartyPays <"If optional early termination is applicable to a swap transaction, the rate, which may be a bid or ask rate, which would result, if seller is in-the-money, in the higher absolute value of the cash settlement amount, or, is seller is out-of-the-money, in the lower absolute value of the cash settlement amount.">

enum CreditRatingAgencyEnum: <"Represents the enumerated values to specify the rating agencies.">
    // [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/credit-rating-agency"]
    [synonym AcadiaSoft_AM_1_0 value "AgencyEnum"]

    AMBest <"A. M. Best">
    CBRS <"Canadian Bond Rating Service">
    DBRS <"Dominion Bond Rating Service">
        [synonym AcadiaSoft_AM_1_0 value "DBRS"]
    Fitch <"Fitch">
        [synonym AcadiaSoft_AM_1_0 value "FITCH"]
    Japanagency <"Japan Credit Rating Agency, Ltd.">
    Moodys <"Moody's">
        [synonym AcadiaSoft_AM_1_0 value "MOODYS"]
    RatingAndInvestmentInformation <"Rating And Investment Information, Inc.">
    StandardAndPoors <"Standard And Poor's">
        [synonym AcadiaSoft_AM_1_0 value "STANDARD_POORS"]

enum CreditRatingOutlookEnum: <"Represents the enumerated values to specify the credit rating outlook.">
    Positive <"Denotes a rating may be raised.">
    Negative <"Denotes a rating may be lowered.">
    Stable <"Denotes a rating is not likely to change.">
    Developing <"Denotes a rating may be raised, lowered, or affirmed.">

enum CreditRatingCreditWatchEnum: <"Represents the enumerated values to specify the credit watch rating.">
    Positive <"Denotes a rating may be raised.">
    Negative <"Denotes a rating may be lowered.">
    Developing <"Denotes a rating may be raised, lowered, or affirmed.">

enum CreditNotationMismatchResolutionEnum: <"Represents an enumeration list to identify the characteristics of the rating if there are several agency issue ratings but not equivalent, reference will be made to label characteristics of the rating such as the lowest/highest available.">
    Lowest <"Denotes the lowest credit notation if several notations are listed.">
    Highest <"Denotes the highest credit notation if several notations are listed.">
    ReferenceAgency <"Denotes that a credit notation issued from a defined reference agency is used if several notations are listed.">
    Average <"Denotes the average credit notation if several notations are listed.">
    SecondBest <"Denotes the second best credit notation if several notations are listed.">
    Other <"Utilised where bespoke language represents the label characteristics of the rating.">

enum CreditNotationBoundaryEnum: <"Identifies an agency rating as a simple scale boundary of minimum or maximum.">
    Minimum <"Denotes a minumum boundary">
    Maximum <"Denotes a maxiumum boundary">

enum InterpolationMethodEnum: <"The enumerated values to specify the interpolation method, e.g. linear.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/interpolation-method"]

    Linear <"Linear Interpolation applicable.">
    LinearZeroYield <"Linear Interpolation applicable.">
    None <"No Interpolation applicable.">

enum SettlementRateOptionEnum: <"The enumerated values to specify the settlement rate options as specified in the Annex A to the 1998 FX and Currency Options Definitions.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/settlement-rate-option"]

    ARS_BNAR_ARS01 displayName "ARS.BNAR/ARS01" <"The Spot Rate for a Rate Calculation Date will be the Argentine Peso/U.S. Dollar Specified Rate, expressed as the amount of Argentine Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Buenos Aires and New York) which appears on the Reuters Screen BNAR Page at the close of business in Buenos Aires on that Rate Calculation Date.">
    ARS_EMTA_INDICATIVE_SURVEY_RATE_ARS04 displayName "ARS.EMTA.INDICATIVE.SURVEY.RATE/ARS04" <"The Spot Rate for a Rate Calculation Date will be the Argentine Peso/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Argentine Pesos per one U.S. Dollar, for settlement on the same day, as published on EMTA's web site (www.emta.org) at approximately 1:00 p.m. (Buenos Aires time), or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA ARS Indicative Survey Methodology (which means a methodology, dated as of January 2, 2003, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Argentine Peso/U.S. Dollar markets for the purpose of determining the EMTA ARS Indicative Survey Rate).">
    ARS_EMTA_INDUSTRY_SURVEY_RATE_ARS03 displayName "ARS.EMTA.INDUSTRY.SURVEY.RATE/ARS03" <"The Spot Rate for a Rate Calculation Date will be the Argentine Peso/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Argentine Pesos per one U.S. Dollar, for settlement on the same day, as published on EMTA's web site (www.emta.org) at approximately 1:00 p.m. (Buenos Aires time), or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA ARS Industry Survey Methodology (which means a methodology, dated as of January 2, 2003, as amended from time to time, for a centralized industry-wide survey of financial institutions in Buenos Aires that are active participants in the Argentine Peso/U.S. Dollar spot markets for the purpose of determining the EMTA ARS Industry Survey Rate).">
    ARS_MAE_ARS05 displayName "ARS.MAE/ARS05" <"The Spot Rate for a Rate Calculation Date will be the volume weighted average Argentine Peso/U.S. Dollar Rate of all trades executed in the electronic market for a Rate Calculation Day expressed as the amount of Argentine Pesos per one U.S. Dollar, for settlement on the same day, reported by the Mercado Abierto Electronico (the 'MAE') at approximately 3:00 pm, Buenos Aires time, and published on the FOREX-MAE Page as the 'PPN' rate ('Promedio Ponderado Noticiado') on www.mae.com.ar on that Rate Calculation Date.">
    ARS_OFFICIAL_RATE_ARS02 displayName "ARS.OFFICIAL.RATE/ARS02" <"The Spot Rate for a Rate Calculation Date will be the Argentine Peso/U.S. Dollar offered rate for U.S. Dollars, expressed as the amount of Argentine Pesos per one U.S. Dollar, for settlement on the same day quoted by Banco de la Nacion (in accordance with the Convertibility Law of March 27, 1991 and Regulatory Decree No. 529/91 of April 1, 1991, as may be amended from time to time) for that Rate Calculation Date.">
    BRL_BRBY_BRL01 displayName "BRL.BRBY/BRL01" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar Specified Rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) which appears on the Reuters Screen BRBY Page under the caption 'INTBK FLTING (LAST)' at approximately 11:00 a.m., Sao Paulo time, on that Rate Calculation Date.">
    BRL_EMTA_INDICATIVE_SURVEY_RATE_BRL13 displayName "BRL.EMTA.INDICATIVE.SURVEY.RATE/BRL13" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days, as published on EMTA's web site (www.emta.org) at approximately 12:00 p.m. (Sao Paulo time), or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA BRL Indicative Survey Methodology (which means a methodology, dated as of March 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Brazilian Real/U.S. Dollar markets for the purpose of determining the EMTA BRL Indicative Survey Rate).">
    BRL_EMTA_INDUSTRY_SURVEY_RATE_BRL12 displayName "BRL.EMTA.INDUSTRY.SURVEY.RATE/BRL12" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days, as published on EMTA's web site (www.emta.org) at approximately 3:45 p.m. (Sao Paulo time), or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA BRL Industry Survey Methodology (which means a methodology, dated as of March 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions in Brazil that are active participants in the Brazilian Real/U.S. Dollar spot markets for the purpose of determining the EMTA BRL Industry Survey Rate).">
    BRL_OFFICIAL_RATE_BRL02 displayName "BRL.OFFICIAL.RATE/BRL02" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar Specified Rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) reported by the Banco Central do Brasil in the 'Diario Oficial da Uniao' on the first Business Day following that Rate Calculation Date.">
    BRL_PCOT_COMMERCIAL_BRL03 displayName "BRL.PCOT-COMMERCIAL/BRL03" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar commercial rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) reported by the Banco Central do Brasil on SISBACEN Data System under transaction code PCOT- 390, Option 3, at the Specified Time, if any, on that Rate Calculation Date.">
    BRL_PCOT_FLOATING_BRL04 displayName "BRL.PCOT-FLOATING/BRL04" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar floating rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) reported by the Banco Central do Brasil on SISBACEN Data System under transaction code PCOT- 390, Option 3, at the Specified Time, if any, on that Rate Calculation Date.">
    BRL_PTAX_BRL09 displayName "BRL.PTAX/BRL09" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar offered rate for U.S. Dollars, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days reported by the Banco Central do Brasil on SISBACEN Data System under transaction code PTAX-800 ('Consulta de Cambio' or Exchange Rate Inquiry), Option 5 ('Cotacoes para Contabilidade' or 'Rates for Accounting Purposes') by approximately 6:00 p.m., Sao Paulo time, on that Rate Calculation Date.">
    BRL_PTAX_COMMERCIAL_BRL05 displayName "BRL.PTAX-COMMERCIAL/BRL05" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar commercial rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) reported by the Banco Central do Brasil on SISBACEN Data System under transaction code PTAX- 800 ('Consultas de Cambio' or Exchange Rate Inquiry), Option 5 ('Cotacoes para Contabilidad' or Rates for Accounting Purposes) market type 'L' (corresponding to U.S. Dollars traded in the foreign exchange market segment officially denominated 'Livre' and commonly known as 'Comercial') as of 7:30 p.m., Sao Paulo time, on that Rate Calculation Date.">
    BRL_PTAX_COMMERCIAL_BRFR_BRL06 displayName "BRL.PTAX-COMMERCIAL.BRFR/BRL06" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar commercial rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) reported by the Banco Central do Brasil which appears on the Reuters Screen BRFR Page at PTAX-800 as of 11:00 a.m., Sao Paulo time, on the first Business Day following that Rate Calculation Date. 23">
    BRL_PTAX_FLOATING_BRL07 displayName "BRL.PTAX-FLOATING/BRL07" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar floating rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) reported by the Banco Central do Brasil on SISBACEN Data System under transaction code PTAX- 800 ('Consultas de Cambio' or Exchange Rate Inquiry), Option 5 ('Cotacoes para Contabilidad' or Rates for Accounting Purposes) market type 'F' (corresponding to U.S. Dollars traded in the foreign exchange market segment officially denominated 'Flutuante') as of 7:30 p.m., Sao Paulo time, on that Rate Calculation Date.">
    BRL_PTAX_FLOATING_BRFR_BRL08 displayName "BRL.PTAX-FLOATING.BRFR/BRL08" <"The Spot Rate for a Rate Calculation Date will be the Brazilian Real/U.S. Dollar floating rate, expressed as the amount of Brazilian Reais per one U.S. Dollar, for settlement in two Business Days (where such days are Business Days in both Sao Paulo and New York) reported by the Banco Central do Brasil on the SISBACEN Data System which appears on the Reuters Screen BRFR Page at PTAX-800 as of 11:00 a.m., Sao Paulo time, on the first Business Day following that Rate Calculation Date.">
    CLP_BCCH_CLP01 displayName "CLP.BCCH/CLP01" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar observado rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) reported by the Banco Central de Chile which appears on the Reuters Screen BCCH Page under the caption 'OBSERVADO' at 10:00 a.m., Santiago time, on the first Business Day following that Rate Calculation Date.">
    CLP_CHILD_INFORMAL_CLP02 displayName "CLP.CHILD-INFORMAL/CLP02" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar informal rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) of the informal exchange market which appears on the Reuters Screen CHILD Page at the Specified Time, if any, on that Rate Calculation Date.">
    CLP_CHILD_INTERBANK_CLP03 displayName "CLP.CHILD-INTERBANK/CLP03" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar interbank rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) reported by the Banco Central de Chile for the formal exchange market which appears on the Reuters Screen CHILD Page at the Specified Time, if any, on that Rate Calculation Date.">
    CLP_CHILD_OBSERVADO_CLP04 displayName "CLP.CHILD-OBSERVADO/CLP04" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar observado rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) reported by the Banco Central de Chile which appears on the Reuters Screen CHILD Page on the first Business Day following that Rate Calculation Date.">
    CLP_CHILG_INFORMAL_CLP05 displayName "CLP.CHILG-INFORMAL/CLP05" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar informal rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) of the informal exchange market which appears on the Reuters Screen CHILG Page at the Specified Time, if any, on that Rate Calculation Date.">
    CLP_CHILG_INTERBANK_CLP06 displayName "CLP.CHILG-INTERBANK/CLP06" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar interbank rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) reported by the Banco Central de Chile for the formal exchange market which appears on the Reuters Screen CHILG Page at the Specified Time, if any, on that Rate Calculation Date.">
    CLP_CHILG_OBSERVADO_CLP07 displayName "CLP.CHILG-OBSERVADO/CLP07" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar observado rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) reported by the Banco Central de Chile which appears on the Reuters Screen CHILG Page under 'OBSERVADO' at the Specified Time, if any, on the first Business Day following that Rate Calculation Date.">
    CLP_DOLAR_OBS_CLP10 displayName "CLP.DOLAR.OBS/CLP10" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar 'observado' rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement in one Business Day reported by the Banco Central de Chile (www.bcentral.cl) as the 'Dolar Observado' (Dollar Observado) rate by not later than 10:30 a.m., Santiago time, on the first Business Day following that Rate Calculation Date.">
    CLP_EMTA_INDICATIVE_SURVEY_RATE_CLP11 displayName "CLP.EMTA.INDICATIVE.SURVEY.RATE/CLP11" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day, as published on EMTA's web site (www.emta.org) at approximately 11:00 a.m., Santiago time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA CLP Indicative Survey Methodology (which means a methodology, dated as of August 1, 2006, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Chilean Peso/U.S. Dollar markets for the purpose of determining the EMTA CLP Indicative Survey Rate).">
    CLP_OFFICIAL_RATE_CLP08 displayName "CLP.OFFICIAL.RATE/CLP08" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar Specified Rate, expressed as the amount of Chilean Pesos per one U.S. Dollar (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York), calculated in accordance with Title I, Chapter 1 Number 6 of the Compendium of International Exchange Norms of the Banco Central de Chile and published by the Banco Central de Chile at the Specified Time, if any, on the first Business Day following that Rate Calculation Date.">
    CLP_TELERATE_38942_CLP09 displayName "CLP.TELERATE.38942/CLP09" <"The Spot Rate for a Rate Calculation Date will be the Chilean Peso/U.S. Dollar observado rate, expressed as the amount of Chilean Pesos per one U.S. Dollar, for settlement on the same day (or, if such day is not a Business Day in New York, for settlement on the first succeeding day that is a Business Day in both Santiago and New York) reported by the Banco Central de Chile which appears on the Telerate Page 38942 opposite the caption 'Observado' at the Specified Time, if any, on the first Business Day following the Rate Calculation Date.">
    CNY_SAEC_CNY01 displayName "CNY.SAEC/CNY01" <"The Spot Rate for a Rate Calculation Date will be the Chinese Renminbi/U.S. Dollar official fixing rate, expressed as the amount of Chinese Renminbi per one U.S. Dollar, for settlement in two Business Days reported by the People's Bank of China, Beijing, People's Republic of China, which appears on the Reuters Screen 'SAEC' Page opposite the symbol 'USDCNY=' at approximately 9:15 a.m., Beijing time, on that Rate Calculation Date.">
    CNY_SFEMC_INDICATIVE_SURVEY_RATE_CNY02 displayName "CNY.SFEMC.INDICATIVE.SURVEY.RATE/CNY02" <"The Spot Rate for a Rate Calculation Date will be the Chinese Renminbi/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Chinese Renminbi per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m. (Singapore time), or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate will be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC CNY Indicative Survey Methodology (which means a methodology, dated as of December 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Chinese Renminbi/U.S. Dollar markets for the purpose of determining the SFEMC CNY Indicative Survey Rate).">
    COP_CO_COL03_COP01 displayName "COP.CO/COL03/COP01" <"The Spot Rate for a Rate Calculation Date will be the Colombian Peso/U.S. Dollar fixing rate, expressed as the amount of Colombian Pesos per one U.S. Dollar, for settlement on the same day (unless such day is not a Business Day in New York, then for settlement on the first succeeding day that is a Business Day in Bogota and New York) reported by the Colombian Banking Superintendency which appears on the Reuters Screen CO/COL03 Page opposite the caption 'TRCM' ('Tasa de Cierre Representative del Mercado' or closing market price) at 12:00 noon, Bogota time, on the first Business Day following that Rate Calculation Date.">
    COP_EMTA_INDICATIVE_SURVEY_RATE_COP03 displayName "COP.EMTA.INDICATIVE.SURVEY.RATE/COP03" <"The Spot Rate for a Rate Calculation Date will be the Colombian Peso/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Colombian Pesos per one U.S. Dollar, for settlement on the same day, as published on EMTA's web site (www.emta.org) at approximately 11:30 a.m., Bogota time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA COP Indicative Survey Methodology (which means a methodology, dated as of August 1, 2006, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Colombian Peso/U.S. Dollar markets for the purpose of determining the EMTA COP Indicative Survey Rate).">
    COP_TRM_COP02 displayName "COP.TRM/COP02" <"The Spot Rate for a Rate Calculation Date will be the Colombian Peso/U.S. Dollar fixing rate, expressed as the amount of Colombian Pesos per one U.S. Dollar, for settlement on the same day reported by the Colombian Financial Superintendency (www.banrep.gov.co) as the 'Tasa Representativa del Mercado (TRM)' (also referred to as the 'Tasa de Cambio Representativa del Mercado' (TCRM)) by not later than 10:30 a.m., Bogota time, on the first Business Day following that Rate Calculation Date.">
    CURRENCY_IMPLIED_RATE__ADR__CURA1 displayName "CURRENCY-IMPLIED.RATE.(ADR)/CURA1" <"the Spot Rate for a Rate Calculation Date will be the Reference Currency/U.S. Dollar exchange rate, expressed as the amount of Reference Currency per one U.S. Dollar, determined on the basis of quotations provided by Reference Dealers on that Rate Calculation Date of that day's price of a Specified Company's American Depositary Receipt or American Depositary Receipts (the 'ADR' or 'ADRs', as appropriate) and the price of the local share or shares of such Specified Company of the same type and in the same quantity represented by such ADR or ADRs, as the case may be (the 'Share' or 'Shares', as appropriate). The Calculation Agent will request each of the Reference Dealers to provide a firm quotation of (A) in the case where one ADR represents less than one Share, its bid and offer price (in the Reference Currency) for one Share and its bid and offer price (in U.S. Dollars) for the number of ADRs which represent such Share and (B) in all other cases, its bid and offer price (in the Reference Currency) for the Share or Shares, as the case may be, and its bid and offer price (in U.S. Dollars) for one ADR. If one or more quotations are provided, the rate for a Rate Calculation Date will equal the ratio of (1) the arithmetic mean of the midpoint of the bid and offer prices quoted in the Reference Currency by each Reference Dealer for such Share or Shares, as the case may be, and (2) the arithmetic mean of the midpoint of the bid and offer prices quoted in U.S. Dollars by each Reference Dealer for such ADR or ADRs, as the case may be, subject to an adjustment, if any, by the Calculation Agent to reduce the effect of momentary disparities in the prices of the Share or Shares and the ADR or ADRs, as appropriate. The quotations used to determine the Spot Rate for a Rate Calculation Date will be determined in each case at the Specified Time on the Rate Calculation Date or, if no such time is specified, the time chosen by the Calculation Agent.">
    CURRENCY_IMPLIED_RATE__LOCAL_ASSET__CURA2 displayName "CURRENCY-IMPLIED.RATE.(LOCAL.ASSET)/CURA2" <"The Spot Rate for a Rate Calculation Date will be the Reference Currency/Settlement Currency exchange rate, expressed as the amount of Reference Currency per one unit of Settlement Currency, determined on the basis of quotations provided by Reference Dealers on that Rate Calculation Date for that day's price of Local Assets. The Calculation Agent will request each of the Reference Dealers to provide a firm quotation of its bid and offer price (in both the Reference Currency and the Settlement Currency) for an amount of Local Assets whose face value equals the Specified Amount. If one or more quotations are provided, the rate for a Rate Calculation Date will equal the ratio of (A) the arithmetic mean of the midpoint of the bid and offer prices quoted in the Reference Currency by each Reference Dealer for such Local Assets and (B) the arithmetic mean of the midpoint of the bid and offer prices quoted in the Settlement Currency by each Reference Dealer for such Local Assets. The quotations used to determine the Spot Rate for a Rate Calculation Date will be determined in each case at the Specified Time on the Rate Calculation Date or, if no such time is specified, the time chosen by the Calculation Agent.">
    CURRENCY_MUTUAL_AGREEMENT_CURA3 displayName "CURRENCY-MUTUAL.AGREEMENT/CURA3" <"The Spot Rate for a Rate Calculation Date will be the Reference Currency/Settlement Currency Specified Rate, expressed as the amount of the Reference Currency per one unit of Settlement Currency, for settlement on the Settlement Date agreed upon by the parties on or prior to that Rate Calculation Date (or, if different, the day on which rates for that date would, in the ordinary course, be published or announced).">
    CURRENCY_REFERENCE_DEALERS_CURA4 displayName "CURRENCY-REFERENCE.DEALERS/CURA4" <"The Spot Rate for a Rate Calculation Date will be determined on the basis of quotations provided by Reference Dealers on that Rate Calculation Date of that day's Specified Rate, expressed as the amount of Reference Currency per one unit of Settlement Currency, for settlement on the Settlement Date. The Calculation Agent will request the Specified Office of each of the Reference Dealers to provide a firm quotation of its Specified Rate for a transaction where the amount of Reference Currency equals the Specified Amount. If four quotations are provided, the rate for a Rate Calculation Date will be the arithmetic mean of the Specified Rates, without regard to the Specified Rates having the highest and lowest value. If exactly three quotations are provided, the rate for a Rate Calculation Date will be the Specified Rate provided by the Reference Dealer that remains after disregarding the Specified Rates having the highest and lowest values. For this purpose, if more than one quotation has the same highest value or lowest value, then the Specified Rate of one of such quotations shall be disregarded. If exactly two quotations are provided, the rate for a Rate Calculation Date will be the arithmetic mean of the Specified Rates. If only one quotation is provided, the rate for a Rate Calculation Date will be the Specified Rate quoted by that Reference Dealer. The quotations used to determine the Spot Rate for a Rate Calculation Date will be determined in each case at the Specified Time on that Rate Calculation Date or, if no such time is specified, the time chosen by the Calculation Agent.">
    CURRENCY_WHOLESALE_MARKET_CURA5 displayName "CURRENCY-WHOLESALE.MARKET/CURA5" <"The Spot Rate for a Rate Calculation Date will be determined by the Calculation Agent on the basis of that day's Specified Rate, expressed as the amount of Reference Currency per one unit of Settlement Currency, in a legal and customary wholesale market in which there is no, or minimal, Governmental Authority controls or interference, except as a participant in such market.">
    ECS_DNRP_ECS01 displayName "ECS.DNRP/ECS01" <"The Spot Rate for a Rate Calculation Date will be the Ecuadorian Sucre/U.S. Dollar Specified Rate, expressed as the amount of Ecuadorian Sucres per one U.S. Dollar, for settlement in one Business Day (where such day is a Business Day in Guayaquil and New York) which appears on Reuters Screen DNRP Page at 12:00 noon, Guayaquil time, on that Rate Calculation Date.">
    IDR_ABS_IDR01 displayName "IDR.ABS/IDR01" <"The Spot Rate for a Rate Calculation Date will be the Indonesian Rupiah/U.S. Dollar spot rate at 11:00 a.m., Singapore time, expressed as the amount of Indonesian Rupiah per one U.S. Dollar, for settlement in two Business Days, reported by the Association of Banks in Singapore which appears on the Telerate Page 50157 to the right of the caption 'Spot' under the column 'IDR' at approximately 11:30 a.m., Singapore time, on that Rate Calculation Date.">
    IDR_JISDOR_IDR04 displayName "IDR.JISDOR/IDR04" <"The Spot Rate for a Rate Calculation Date will be the Indonesian Rupiah/U.S. Dollar weighted average spot rate in the interbank market based on traded IDR/USD spot foreign exchange transactions during a specified time period which are captured on a real time basis, expressed as the amount of Indonesian Rupiah per one U.S. Dollar, for settlement in two Business Days, published by Bank Indonesia at approximately 10:00 a.m., Jakarta time, on that Rate Calculation Date as the Jakarta Interbank Spot Dollar Rate USD - IDR on Bank Indonesia's website or otherwise made available by Bank Indonesia (or its successor as administrator).">
    IDR_SFEMC_INDICATIVE_SURVEY_RATE_IDR02 displayName "IDR.SFEMC.INDICATIVE.SURVEY.RATE/IDR02" <"The Spot Rate for a Rate Calculation Date will be the Indonesian Rupiah/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Indonesian Rupiah per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m., Singapore time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate will be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC IDR Indicative Survey Methodology (which means a methodology, dated as of December 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Indonesian Rupiah/U.S. Dollar markets for the purpose of determining the SFEMC IDR Indicative Survey Rate).">
    IDR_VWAP_IDR03 displayName "IDR.VWAP/IDR03" <"The Spot Rate for a Rate Calculation Date will be the Indonesian Rupiah/U.S. Dollar implied spot rate expressed as the amount of Indonesian Rupiah per one U.S. Dollar, for settlement in two Business Days, reported by ABS Benchmarks Administration Co Pte. Ltd. (or its successor as administrator or sponsor of that rate), which appears on Thomson Reuters Screen ABSFIX01 Page at approximately 11:30 a.m., Singapore time, on that Rate Calculation Date.">
    ILS_BOIJ_ILS01 displayName "ILS.BOIJ/ILS01" <"The Spot Rate for a Rate Calculation Date will be the Israeli Shekel/U.S. Dollar Specified Rate, expressed as the amount of Israeli Shekels per one U.S. Dollar, for settlement in two Business Days which appears on the Reuters Screen BOIJ Page as of 1:00 p.m., Tel Aviv time, on that Rate Calculation Date.">
    ILS_FXIL_ILS02 displayName "ILS.FXIL/ILS02" <"The Spot Rate for a Rate Calculation Date will be the Israeli Shekel/U.S. Dollar Specified Rate, expressed as the amount of Israeli Shekels per one U.S. Dollar, for settlement in two Business Days which appears on the Reuters Screen FXIL Page as of 1:00 p.m., Tel Aviv time, on that Rate Calculation Date.">
    INR_FBIL_INR01 displayName "INR.FBIL/INR01" <"The Spot Rate for a Rate Calculation Date will be the Indian Rupee/U.S. Dollar reference rate, expressed as the amount of Indian Rupee per one U.S. Dollar, for settlement in two Business Days, reported by Financial Benchmarks India Pvt. Ltd. (www.fbil.org.in) at approximately 1:30 p.m., Mumbai time, or as soon thereafter as practicable, on that Rate Calculation Date.">
    INR_RBIB_INR01 displayName "INR.RBIB/INR01" <"The Spot Rate for a Rate Calculation Date will be the Indian Rupee/U.S. Dollar reference rate, expressed as the amount of Indian Rupee per one U.S. Dollar, for settlement in two Business Days reported by the Reserve Bank of India which appears on the Reuters Screen RBIB Page at approximately 12:30 p.m., Mumbai time, or as soon thereafter as practicable, on that Rate Calculation Date.">
    INR_SFEMC_INDICATIVE_SURVEY_RATE_INR02 displayName "INR.SFEMC.INDICATIVE.SURVEY.RATE/INR02" <"The Spot Rate for a Rate Calculation Date will be the Indian Rupee/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Indian Rupee per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m. (Singapore time), or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate will be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC INR Indicative Survey Methodology (which means a methodology, dated as of December 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Indian Rupee/U.S. Dollar markets for the purpose of determining the SFEMC INR Indicative Survey Rate).">
    KRW_KEBEY_KRW01 displayName "KRW.KEBEY/KRW01" <"The Spot Rate for a Rate Calculation Date will be the Korean Won/U.S. Dollar Specified Rate, expressed as the amount of Korean Won per one U.S. Dollar, for settlement in two Business Days which appears on the Reuters Screen KEBEY Page at the Specified Time, if any, on that Rate Calculation Date.">
    KRW_KFTC18_KRW02 displayName "KRW.KFTC18/KRW02" <"The Spot Rate for a Rate Calculation Date will be the Korean Won/U.S. Dollar market average rate, expressed as the amount of Korean Won per one U.S. Dollar, for settlement in two Business Days reported by the Korea Financial Telecommunications and Clearing Corporation which appears on the Reuters Screen KFTC18 Page to the right of the caption 'USD Today' that is available at approximately 3:30 p.m., Seoul time, on the Rate Calculation Date or as soon thereafter as practicable.">
    KRW_SFEMC_INDICATIVE_SURVEY_RATE_KRW04 displayName "KRW.SFEMC.INDICATIVE.SURVEY.RATE/KRW04" <"The Spot Rate for a Rate Calculation Date will be the Korean Won/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Korean Won per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m., Singapore time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate will be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC KRW Indicative Survey Methodology (which means a methodology, dated as of December 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Korean Won/U.S. Dollar markets for the purpose of determining the SFEMC KRW Indicative Survey Rate).">
    KRW_TELERATE_45644_KRW03 displayName "KRW.TELERATE.45644/KRW03" <"The Spot Rate for a Rate Calculation Date will be the Korean Won/U.S. Dollar market average rate, expressed as the amount of Korean Won per one U.S. Dollar, for settlement in two Business Days reported by the Korea Financial Telecommunications and Clearing Corporation which appears on Telerate Page 45644 to the right of the caption 'USD Today' that is available at approximately 3:30 p.m., Seoul time, on the Rate Calculation Date or as soon thereafter as practicable.">
    KZT_EMTA_INDICATIVE_SURVEY_RATE_KZT02 displayName "KZT.EMTA.INDICATIVE.SURVEY.RATE/KZT02" <"The Spot Rate for a Rate Calculation Date will be the Kazakhstan Tenge / U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Kazakhstan Tenge per one U.S. Dollar, for settlement on the same Business Day, as published on EMTA's website (www.emta.org) at approximately 1:00 p.m., Almaty time, or as soon thereafter as practicable, on that Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA KZT Indicative Survey Methodology (which means a methodology, dated as of March 16, 2009, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Kazakhstan Tenge/U.S. Dollar markets for the purpose of determining the EMTA KZT Indicative Survey Rate).">
    KZT_KASE_KZT01 displayName "KZT.KASE/KZT01" <"The Spot Rate for a Rate Calculation Date will be the Kazakhstan Tenge / U.S. Dollar weighted average rate, expressed as the amount of Kazakhstan Tenge per one U.S. Dollar, for settlement on the same Business Day reported by the Kazakhstan Stock Exchange (www.kase.kz) at approximately 11:00 am, Almaty time, on that Rate Calculation Date.">
    LBP_BDLX_LBP01 displayName "LBP.BDLX/LBP01" <"The Spot Rate for a Rate Calculation Date will be the Lebanese Pound/U.S. Dollar Specified Rate, expressed as the amount of Lebanese Pounds per one U.S. Dollar, for settlement in two Business Days which appears on the Reuters Screen BDLX Page as of 12:00 noon, Beirut time, on that Rate Calculation Date.">
    MAD_OFFICIAL_RATE_MAD01 displayName "MAD.OFFICIAL.RATE/MAD01" <"The Spot Rate for a Rate Calculation Date will be the Moroccan Dirham/U.S. Dollar Specified Rate, expressed as the amount of Moroccan Dirham per one U.S. Dollar, for settlement in two Business Days reported by the Central Bank of Morocco as of 1:00 p.m., Rabat time, on that Rate Calculation Date.">
    MXP_BNMX_MXP01 displayName "MXP.BNMX/MXP01" <"The Spot Rate for a Rate Calculation Date will be the Mexican Pesos/U.S. Dollar Specified rate, expressed as the amount of Mexican Pesos per one U.S. Dollar, for settlement in two Business Days reported by Banco de Mexico which appears on the Reuters Screen BNMX Page opposite the caption 'Fix' at the close of business in Mexico City on that Rate Calculation Date.">
    MXP_FIXING_RATE_MXP02 displayName "MXP.FIXING.RATE/MXP02" <"The Spot Rate for a Rate Calculation Date will be the Mexican Peso/U.S. Dollar fixing rate, expressed as the amount of Mexican Pesos per one U.S. Dollar, for settlement in two Business Days which is published by Banco de Mexico in the Official Gazette of the Federation pursuant to the 'Disposiciones aplicables a la determinacion del tipo de Cambio para solventar obligaciones denominadas en moneda extranjera pagaderas en la Republica Mexicana' (Rules applicable to determine the exchange rate to pay obligations denominated in foreign currency payable in Mexico) on the first Business Day following that Rate Calculation Date.">
    MXP_MEX01_MXP03 displayName "MXP.MEX01/MXP03" <"The Spot Rate for a Rate Calculation Date will be the Mexican Peso/U.S. Dollar fixing rate, expressed as the amount of Mexican Pesos per one U.S. Dollar, for settlement in two Business Days reported by Banco de Mexico which appears on Reuters Screen MEX01 Page under the heading 'MXNFIX=RR', at the close of business in Mexico City on that Rate Calculation Date.">
    MXP_PUBLISHED_MXP04 displayName "MXP.PUBLISHED/MXP04" <"The Spot Rate for a Rate Calculation Date will be the Mexican Peso/U.S. Dollar fixing rate, expressed as the amount of Mexican Pesos per one U.S. Dollar, for settlement in two Business Days which is published by the Bolsa Mexicana de Valores, S.A. de C.V. (as established in Section 2 of the 'Resolution concerning the exchange rate applicable for calculating the Mexican Peso equivalent of principal and interest of Mexican Treasury Notes denominated in foreign currency and payable in Mexican Pesos' published in the Diario Oficial de la Federacion on November 11, 1991) in the Movimiento Diario del Mercado de Valores de la Bolsa Mexicana de Valores, S.A. de C.V. under the heading 'Movimiento Diario del Mercado de Valores' on that Rate Calculation Date.">
    MYR_ABS_MYR01 displayName "MYR.ABS/MYR01" <"The Spot Rate for a Rate Calculation Date will be the Malaysian Ringgit/U.S. Dollar spot rate at 11:00 a.m., Singapore time, expressed as the amount of Malaysian Ringgit per one U.S. Dollar, for settlement in two Business Days, reported by the Association of Banks in Singapore, which appears on the Telerate Page 50157 to the right of the caption 'Spot' under the column 'MYR' at approximately 11:30 a.m., Singapore time, on that Rate Calculation Date.">
    MYR_KL_REF_MYR04 displayName "MYR.KL.REF/MYR04" <"The Spot Rate for a Rate Calculation Date will be the Malaysian Ringgit/U.S. Dollar reference rate, expressed as the amount of Malaysian Ringgit per one U.S. Dollar, for settlement in two Business Days, calculated and reported by Bank Negara Malaysia as its Kuala Lumpur USD/MYR Reference Rate, which appears on Thomson Reuters Screen MYRFIX2 Page at approximately 3:30 p.m., Kuala Lumpur time, on that Rate Calculation Date.">
    MYR_PPKM_MYR03 displayName "MYR.PPKM/MYR03" <"The Spot Rate for a Rate Calculation Date will be the Malaysian Ringgit/U.S. Dollar spot rate expressed as the amount of Malaysian Ringgit per one U.S. Dollar, for settlement in two Business Days, reported by Persatuan Pasaran Kewangan Malaysia (ACI - Malaysia), which appears on Thomson Reuters Screen MYRFIX2 Page at approximately 11:10 a.m., Kuala Lumpur time, on that Rate Calculation Date.">
    MYR_SFEMC_INDICATIVE_SURVEY_RATE_MYR02 displayName "MYR.SFEMC.INDICATIVE.SURVEY.RATE/MYR02" <"The Spot Rate for a Rate Calculation Date will be the Malaysian Ringgit/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Malaysian Ringgit per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m., Singapore time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate will be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC MYR Indicative Survey Methodology (which means a methodology, dated as of July 15, 2005, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Malaysian Ringgit/U.S. Dollar markets for the purpose of determining the SFEMC MYR Indicative Survey Rate).">
    PEN_EMTA_INDICATIVE_SURVEY_RATE_PEN04 displayName "PEN.EMTA.INDICATIVE.SURVEY.RATE/PEN04" <"The Spot Rate for a Rate Calculation Date will be the Peruvian Sol/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Peruvian Soles per one U.S. Dollar, for settlement on the same day, as published on EMTA's web site (www.emta.org) at approximately 11:00 a.m., Lima time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA PEN Indicative Survey Methodology (which means a methodology, dated as of August 1, 2006, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Peruvian Sol/U.S. Dollar markets for the purpose of determining the EMTA PEN Indicative Survey Rate).">
    PEN_INTERBANK_AVE_PEN05 displayName "PEN.INTERBANK.AVE/PEN05" <"The Spot Rate for a Rate Calculation Date will be the Peruvian Sol/U.S. Dollar average exchange rate in the interbank market expressed as the amount of Peruvian New Soles per one U.S. Dollar for settlement on the same day reported by the Banco Central de Reserva del Peru (www.bcrp.gob.pe) as the 'Tipo de Cambio Interbancario Promedio' at approximately 2:00 p.m., Lima time, on that Rate Calculation Date.">
    PEN_PDSB_PEN01 displayName "PEN.PDSB/PEN01" <"The Spot Rate for a Rate Calculation Date will be the Peruvian Sol/U.S. Dollar fixing rate (mid market last), expressed as the amount of Peruvian Sols per one U.S. Dollar, for settlement on that same day which appears on the Reuters Screen PDSB Page opposite the caption 'PEN=' as of 12:00 noon, Lima time, on that Rate Calculation Date.">
    PEN_WT_AVE_PEN03 displayName "PEN.WT.AVE/PEN03" <"The Spot Rate for a Rate Calculation Date will be the midpoint of the Peruvian Sol/U.S. Dollar closing weighted average bid and offer ('compra y venta') exchange rates expressed as the amount of Peruvian New Soles per one U.S. Dollar for settlement on the same day, reported by the Superintendencia de Banca, Seguros y AFP (www.sbs.gob.pe) of the Republic of Peru at approximately 5:00 p.m., Lima time, on that Rate Calculation Date.">
    PHP_BAPPESO_PHP06 displayName "PHP.BAPPESO/PHP06" <"The Spot Rate for a Rate Calculation Date will be the Philippine Peso/U.S. Dollar morning weighted average rate for that Rate Calculation Date, expressed as the amount of Philippine Pesos per one U.S. Dollar, for settlement in one Business Day, sponsored by Bankers Association of the Philippines (www.bap.org.ph) as its 'BAP AM Weighted Average Rate' at approximately 11:30 a.m., Manila time, or as soon thereafter as practicable, on that Rate Calculation Date.">
    PHP_PDSPESO_PHP06 displayName "PHP.PDSPESO/PHP06" <"The Spot Rate for a Rate Calculation Date will be the Philippine Peso/U.S. Dollar morning weighted average rate for that Rate Calculation Date, expressed as the amount of Philippine Pesos per one U.S. Dollar, for settlement in one Business Day reported by the Philippine Dealing System PDEX which appears on the Reuters Screen PDSPESO Page to the right of the caption 'AM WT AVE' at approximately 11:30 a.m., Manila time, or as soon thereafter as practicable, on that Rate Calculation Date.">
    PHP_PHPESO_PHP01 displayName "PHP.PHPESO/PHP01" <"The Spot Rate for a Rate Calculation Date will be the Philippine Peso/U.S. Dollar tom rate (mid market), expressed as the amount of Philippine Pesos per one U.S. Dollar, for settlement in one Business Day which appears on the Reuters Screen PHPESO Page at approximately 11:00 a.m., Manila time, on that Rate Calculation Date.">
    PHP_SFEMC_INDICATIVE_SURVEY_RATE_PHP05 displayName "PHP.SFEMC.INDICATIVE.SURVEY.RATE/PHP05" <"The Spot Rate for a Rate Calculation Date will be the Philippine Peso/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Philippine Pesos per one U.S. Dollar, for settlement in one Business Day, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m., Singapore time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate will be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC PHP Indicative Survey Methodology (which means a methodology, dated as of December 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Philippine Peso/U.S. Dollar markets for the purpose of determining the SFEMC PHP Indicative Survey Rate).">
    PHP_TELERATE_15439_PHP03 displayName "PHP.TELERATE.15439/PHP03" <"The Spot Rate for a Rate Calculation Date will be the Philippine Peso/U.S. Dollar tom rate (mid market), expressed as the amount of Philippine Pesos per one U.S. Dollar, for settlement in one Business Day which appears on the Telerate Page 15439 at approximately 11:00 a.m., Manila time, on that Rate Calculation Date.">
    PHP_TELERATE_2920_PHP02 displayName "PHP.TELERATE.2920/PHP02" <"The Spot Rate for a Rate Calculation Date will be the Philippine Peso/U.S. Dollar Specified Rate, expressed as the amount of Philippine Pesos per one U.S. Dollar, for settlement in one Business Day which appears on the Telerate Page 2920 at the Specified Time, if any, on that Rate Calculation Date.">
    PKR_SBPK_PKR01 displayName "PKR.SBPK/PKR01" <"The Spot Rate for a Rate Calculation Date will be the Pakistani Rupee/U.S. Dollar reference rate expressed as the amount of Pakistani Rupees per one U.S. Dollar, for settlement in two Business Days reported by the State Bank of Pakistan (www.sbp.org.pk) at approximately 2:30 pm, Karachi time, on that Rate Calculation Date.">
    PKR_SFEMC_INDICATIVE_SURVEY_RATE_PKR02 displayName "PKR.SFEMC.INDICATIVE.SURVEY.RATE/PKR02" <"The Spot Rate for a Rate Calculation Date will be the Pakistani Rupee/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Pakistani Rupees per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m. Singapore time, or as soon thereafter as practicable, on that Rate Calculation Date. The Spot Rate shall be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC PKR Indicative Survey Methodology (which means a methodology, dated as of July 14, 2008, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Pakistani Rupee/U.S. Dollar markets for the purpose of determining the SFEMC PKR Indicative Survey Rate).">
    PLZ_NBPQ_PLZ01 displayName "PLZ.NBPQ/PLZ01" <"The Spot Rate for a Rate Calculation Date will be the Polish Zloty/U.S. Dollar Specified Rate, expressed as the amount of Polish Zloty per one U.S. Dollar, for settlement in two Business Days reported by the National Bank of Poland which appears on the Reuters Screen NBPQ Page at the Specified Time, if any, on that Rate Calculation Date.">
    PLZ_NBPR_PLZ02 displayName "PLZ.NBPR/PLZ02" <"The Spot Rate for a Rate Calculation Date will be the Polish Zloty/U.S. Dollar fixing rate, expressed as the amount of Polish Zloty per one U.S. Dollar, for settlement in two Business Days reported by the National Bank of Poland which appears on the Reuters Screen NBPR Page at the Specified Time, if any, on that Rate Calculation Date.">
    RUB_CME_EMTA_RUB03 displayName "RUB.CME-EMTA/RUB03" <"The Spot Rate for a Rate Calculation Date will be the Russian Ruble/U.S. Dollar Specified Rate, expressed as the amount of Russian Rubles per one U.S. Dollar, for settlement in one Business Day, calculated by the Chicago Mercantile Exchange ('CME') and as published on CME's website, which appears on the Reuters Screen EMTA Page, at approximately 1:30 p.m., Moscow time, on that Rate Calculation Date. The Spot Rate shall be calculated by the CME pursuant to the Chicago Mercantile Exchange / EMTA, Inc. Daily Russian Ruble Per U.S. Dollar Reference Rate Methodology (which means a methodology, effective as of June 16, 2005, as amended from time to time, for a centralized industry-wide survey of financial institutions in Russia that are active participants in the Russian Ruble/U.S. Dollar spot market for the purpose of determining the RUB CME-EMTA Rate).">
    RUB_EMTA_INDICATIVE_SURVEY_RATE_RUB04 displayName "RUB.EMTA.INDICATIVE.SURVEY.RATE/RUB04" <"The Spot Rate for a Rate Calculation Date will be the Russian Ruble/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Russian Rubles per one U.S. Dollar, for settlement in one Business Day, as published on EMTA's web site (www.emta.org) at approximately 2:45 p.m., Moscow time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA RUB Indicative Survey Methodology (which means a methodology dated as of June 16, 2005, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Russian Ruble/U.S. Dollar spot market for the purpose of determining the EMTA RUB Indicative Survey Rate).">
    RUB_MICEXFRX_RUB01 displayName "RUB.MICEXFRX/RUB01" <"The Spot Rate for a Rate Calculation Date will be the Russian Ruble/U.S. Dollar Specified Rate, expressed as the amount of Russian Rubies per one U.S. Dollar, for settlement on the same day reported by the Moscow Interbank Currency Exchange which appears on the Reuters Screen MICEXFRX Page as of 10:30 a.m., Moscow time, on that Rate Calculation Date.">
    RUB_MMVB_RUB02 displayName "RUB.MMVB/RUB02" <"The Spot Rate for a Rate Calculation Date will be the Russian Ruble/U.S. Dollar Specified Rate, expressed as the amount of Russian Rubies per one U.S. Dollar, for settlement on the same day reported by the Moscow Interbank Currency Exchange which appears on the Reuters Screen MMVB Page as of 10:30 a.m., Moscow time, on that Rate Calculation Date.">
    SGD_VWAP_SGD3 displayName "SGD.VWAP/SGD3" <"The Spot Rate for a Rate Calculation Date will be the Singapore Dollar/U.S. Dollar spot rate expressed as the amount of Singapore Dollar per one U.S. Dollar for settlement in two Business Days, reported by ABS Benchmarks Administration Co Pte. Ltd. (or its successor as administrator or sponsor of the rate), which appears on Thomson Reuters Screen ABSFIX01 Page at approximately 11:30 a.m., Singapore time, on that Rate Calculation Date.">
    SKK_NBSB_SKK01 displayName "SKK.NBSB/SKK01" <"The Spot Rate for a Rate Calculation Date will be the Slovak Koruna/U.S. Dollar Specified Rate, expressed as the amount of Slovak Koruna per one U.S. Dollar, for settlement in two Business Days reported by the National Bank of Slovakia which appears on the Reuters Screen NBSB Page as of 11:40 a.m., Bratislava time, on that Rate Calculation Date.">
    THB_ABS_THB01 displayName "THB.ABS/THB01" <"The Spot Rate for a Rate Calculation Date will be the Thai Baht/U.S. Dollar spot rate at 11:00 a.m., Singapore time, expressed as the amount of Thai Bhaht per one U.S. Dollar, for settlement in two Business Days, reported by the Association of Banks in Singapore which appears on the Reuters Screen ABSIRFIX01 Page to the right of the caption 'Spot' under the column 'THB' at approximately 11:30 a.m., Singapore time, on that Rate Calculation Date.">
    THB_VWAP_THB01 displayName "THB.VWAP/THB01" <"The Spot Rate for a Rate Calculation Date will be the Thai Baht / U.S. Dollar spot rate expressed as the amount of Thai Baht per one U.S. Dollar for settlement in two Business Days, reported by ABS Benchmarks Administration Co Pte. Ltd. (or its successor as administrator or sponsor of the rate), which appears on Thomson Reuters Screen ABSFIX01 Page at approximately 11:30 a.m., Singapore time, on that Rate Calculation Date.">
    TWD_SFEMC_INDICATIVE_SURVEY_RATE_TWD04 displayName "TWD.SFEMC.INDICATIVE.SURVEY.RATE/TWD04" <"The Spot Rate for a Rate Calculation Date will be the Taiwanese Dollar/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Taiwanese Dollars per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m., Singapore time, or as soon thereafter as practicable, on such Rate Calculation Date. The Spot Rate will be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC TWD Indicative Survey Methodology (which means a methodology, dated as of December 1, 2004, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Taiwanese Dollar/U.S. Dollar markets for the purpose of determining the SFEMC TWD Indicative Survey Rate).">
    TWD_TAIFX1_TWD03 displayName "TWD.TAIFX1/TWD03" <"The Spot Rate for a Rate Calculation Date will be the Taiwanese Dollar/U.S. Dollar spot rate, expressed as the amount of Taiwanese Dollars per one U.S. Dollar, for settlement in two Business Days, reported by the Taipei Forex Inc. which appears on the Reuters Screen TAIFX1 Page under the heading 'Spot' as of 11:00 a.m. Taipei time, on that Rate Calculation Date, or if no rate appears as of 11:00 a.m., Taipei time, the rate that first appears in any of the next succeeding 15 minute intervals after such time, up to and including 12:00 noon, Taipei time on that Rate Calculation Date.">
    TWD_TELERATE_6161_TWD01 displayName "TWD.TELERATE.6161/TWD01" <"The Spot Rate for a Rate Calculation Date will be the Taiwanese Dollar/U.S. Dollar spot rate, expressed as the amount of Taiwanese Dollars per one U.S. Dollar, for settlement in two Business Days, reported by the Taipei Forex Inc. which appears on the Telerate Page 6161 under the heading 'Spot' as of 11:00 a.m., Taipei time, on that Rate Calculation Date, or if no rate appears as of 11:00 a.m., Taipei time, the rate that first appears in any of the next succeeding 15 minute intervals after such time, up to and including 12:00 noon, Taipei time, on that Rate Calculation Date.">
    TWD_TFEMA_TWD02 displayName "TWD.TFEMA/TWD02" <"The Spot Rate for a Rate Calculation Date will be the Taiwanese Dollar/U.S. Dollar Specified Rate, expressed as the amount of Taiwanese Dollars per one U.S. Dollar, for settlement in two Business Days which appears on the Reuters Screen TFEMA Page as of 11:00 a.m., Taipei time, on that Rate Calculation Date.">
    UAH_EMTA_INDICATIVE_SURVEY_RATE_UAH03 displayName "UAH.EMTA.INDICATIVE.SURVEY.RATE/UAH03" <"The Spot Rate for a Rate Calculation Date will be the Ukrainian Hryvnia/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Ukrainian Hryvnia per one U.S. Dollar, for settlement on the same Business Day, as published on EMTA's website (www.emta.org) at approximately 2:00 p.m., Kiev time, or as soon thereafter as practicable, on that Rate Calculation Date. The Spot Rate shall be calculated by EMTA (or a service provider EMTA may select in its sole discretion) pursuant to the EMTA UAH Indicative Survey Methodology (which means a methodology, dated as of March 16, 2009, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Ukrainian Hryvnia / U.S. Dollar markets for the purpose of determining the EMTA UAH Indicative Survey Rate).">
    UAH_EMTA_INDUSTRY_SURVEY_RATE_UAH02 displayName "UAH.EMTA.INDUSTRY.SURVEY.RATE/UAH02" <"The Spot Rate for a Rate Calculation Date will be the Ukrainian Hryvnia/U.S. Dollar Specified Rate for U.S. Dollars expressed as the amount of Ukrainian Hryvnia per one U.S. Dollar, for settlement on the same Business Day calculated by Thomson Reuters pursuant to the EMTA UAH Industry Survey Methodology, which rate appears on EMTA's website (www.emta.org) and on Thomson Reuters Page EMTAUAHFIX at approximately 11:30 am, Kiev time, on that Rate Calculation Date. The 'EMTA UAH Industry Survey Methodology' as used herein means the methodology dated as of March 16, 2009, for a centralized industry wide survey of financial institutions in the Ukrainian Hryvnia/U.S. Dollar spot market for the purposes of determining the EMTA UAH Industry Survey Rate.">
    UAH_GFI_UAH01 displayName "UAH.GFI/UAH01" <"The Spot Rate for a Rate Calculation Date will be the Ukrainian Hryvnia/U.S. Dollar spot rate, expressed as the amount of Ukrainian Hryvnia per one U.S. Dollar, for settlement on the same Business Day reported by GFI Brokers on Thomson Reuters Page GFIU by 9:30 am, London time, on that Rate Calculation Date.">
    VEF_FIX_VEF01 displayName "VEF.FIX/VEF01" <"The Spot Rate for a Rate Calculation Date will be the midpoint of the Venezuelan Bolivar /U.S. Dollar Tipo de Cambio De Referencia buying and selling rates, expressed as the amount of Venezuelan Bolivar per one U.S. Dollar, for settlement in two Business Days reported by the Banco Central de Venezuela (www.bcv.org.ve) at approximately 5:00 p.m., Caracas time, on that Rate Calculation Date.">
    VND_ABS_VND01 displayName "VND.ABS/VND01" <"The Spot Rate for a Rate Calculation Date will be the Vietnamese Dong/U.S. Dollar spot rate at 11:00 a.m., Singapore time, expressed as the amount of Vietnamese Dong per one U.S. Dollar, for settlement in two Business Days reported by the Association of Banks in Singapore, which appears on the Reuters Screen ABSIRFIX01 Page to the right of the caption 'Spot' under the column 'VND' at approximately 11:30 a.m., Singapore time, on that Rate Calculation Date.">
    VND_FX_VND02 displayName "VND.FX/VND02" <"The Spot Rate for a Rate Calculation Date will be the Vietnamese Dong/U.S. Dollar spot rate expressed as the amount of Vietnamese Dong per one U.S. Dollar, for settlement in two Business Days which appears on Reuters Screen VNDFIX=VN Page under the caption 'Spot' and to the right of the caption 'Average' at approximately 11:00 am, Hanoi time, on that Rate Calculation Date.">
    VND_SFEMC_INDICATIVE_SURVEY_RATE_VND03 displayName "VND.SFEMC.INDICATIVE.SURVEY.RATE/VND03" <"The Spot Rate for a Rate Calculation Date will be the Vietnamese Dong/U.S. Dollar Specified Rate for U.S. Dollars, expressed as the amount of Vietnamese Dong per one U.S. Dollar, for settlement in two Business Days, as published on SFEMC's website (www.sfemc.org) at approximately 3:30 p.m., Singapore time, or as soon as thereafter as practicable, on that Rate Calculation Date. The Spot Rate shall be calculated by SFEMC (or a service provider SFEMC may select in its sole discretion) pursuant to the SFEMC VND Indicative Survey Methodology (which means a methodology, dated as of July 14, 2008, as amended from time to time, for a centralized industry-wide survey of financial institutions that are active participants in the Vietnamese Dong/U.S. Dollar markets for the purpose of determining the SFEMC VND Indicative Survey Rate).">

enum PartyDeterminationEnum: <"The enumerated values to specify how a calculation agent will be determined.">
    ExercisingParty <"The party that gives notice of exercise. Per 2000 ISDA Definitions, Section 11.1. Parties, paragraph (d).">
    NonExercisingParty <"The party that is given notice of exercise. Per 2000 ISDA Definitions, Section 11.1. Parties, paragraph (e).">
    AsSpecifiedInMasterAgreement <"The Calculation Agent is determined by reference to the relevant master agreement.">
    AsSpecifiedInStandardTermsSupplement <"The Calculation Agent is determined by reference to the relevant standard terms supplement.">
    Both <"Both parties with joined rights to be a calculation agent.">

enum PriceTypeEnum: <"Provides enumerated values for types of prices in the Price data type in order to explain how to interpret the amount and use it in calculations.">
    AssetPrice <"Denotes a price expressed as a cash amount in a given currency to purchase a unit of an asset (e.g. a security or a commodity).">
    CashPrice <"Denotes a price expressed as a cash amount for an upfront fee or other purposes. For example, {amount, unitOfAmount, PerUnitOfAmount} = [12,500, USD, null] = USD 12,500.">
    Correlation <"Denotes a price expressed as the weighted average of all pairwise correlation coefficients.">
    Dividend <"Denotes a price expressed as the dividend payment from a index or share.">
    ExchangeRate <"Denotes a rate to convert one currency or other measure of value to another. Foreign Exchange rates are represented in decimals, e.g. {amount, unitOfAmount, PerUnitOfAmount} = [1.23, USD, GBP] = USD 1.23 for every 1 GBP.">
    InterestRate <"Denotes a price expressed as a rate to be applied to quantity/notional amount and represented as decimal, e.g. {amount, unitOfAmount, PerUnitOfAmount} = [0.08, EUR, EUR] = 8%  of the EUR notional quantity/amount or 8 cents for every EUR of notional amount.">
        [docReference ICMA GMRA namingConvention "Pricing Rate"
			provision "As defined in the GMRA, paragraph 2(ll) The pricing rate is the per annum percentage rate for calculation of the Price Differential agreed to by Buyer and Seller in relation to that Transaction."]
		[docReference ICMA ERCCBestPractice namingConvention "Pricing Rate"
			provision "ERCC Guide: Annex II  Glossary of repo terminology. Repo rate is the market term for the annualised percentage rate of interest on the cash in a repo. Legally-speaking, however, the term is a misnomer, as the legal form of a repo is not an interest-paying loan or deposit. Rather, the return is just the difference between two securities prices. In the GMRA, the repo rate is called the Pricing Rate. Traditionally, the repo rate was the price of a Repurchase Transaction but Buy/Sell-Backs are now often quoted in the same way."]
    Variance <"Denotes a price expressed as the the arithmetic average of the squared differences from the mean value of an observable price.">
    Volatility <"Denotes a price expressed as the the square root of the arithmetic average of the squared differences from the mean value of an observable price.">

enum CashPriceTypeEnum: <"Provides a list of possible types of cash prices, applicable when PriceTypeEnum is itself of type CashPrice.">
    Premium <"Denotes the amount payable by the buyer to the seller for an option. The premium is paid on the specified premium payment date or on each premium payment date if specified.">
    Fee <"A generic term for describing a non-scheduled cashflow that can be associated either with the initial contract, with some later corrections to it (e.g. a correction to the day count fraction that has a cashflow impact) or with some lifecycle events. Fees that are specifically associated with termination and partial termination, increase, amendment, and exercise events are qualified accordingly.">
    Discount <"Denotes a discount factor expressed as a decimal, e.g. 0.95.">

enum FeeTypeEnum: <"The enumerated values to specify an event that has given rise to a fee.">
    Assignment <"A cash flow resulting from the assignment of a contract to a new counterparty.">
    BrokerageCommission <"The brokerage commission.">
    Increase <"A cash flow associated with an increase lifecycle event.">
    Novation <"The novation fee.">
    PartialTermination <"A cash flow associated with a partial termination lifecycle event.">
    Premium <"Denotes the amount payable by the buyer to the seller for an option. The premium is paid on the specified premium payment date or on each premium payment date if specified.">
    Renegotiation <"A cash flow associated with a renegotiation lifecycle event.">
    Termination <"A cash flow associated with a termination lifecycle event.">
    Upfront <"An upfront cashflow associated to the swap to adjust for a difference between the swap price and the current market price.">
    CreditEvent <"A cash flow associated with a credit event.">
    CorporateAction <"A cash flow associated with a corporate action">

enum PremiumTypeEnum: <"The enumerated values to specify the premium type for forward start options.">
    PrePaid
    PostPaid
    Variable
    Fixed

enum PriceOperandEnum:
    AccruedInterest
    Commission
    ForwardPoint

enum CsaTypeEnum: <"How is the Creadit Support Annex defined for this transaction as defined in the 2021 ISDA Definitions, section 18.2.1 ">
    NoCSA  displayName "NoCSA" <"There is no CSA applicable">
    ExistingCSA  displayName "ExistingCSA" <"Thre is an existing Credit Support Annex">
    ReferenceVMCSA displayName "ReferenceVMCSA" <"There is a bilateral Credit Support Annex specific to the transaction">


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-fro-enum.rosetta
================================================================================

namespace cdm.observable.asset.fro : <"Support for floating rate option definitions.">
version "${project.version}"

enum FloatingRateIndexCategoryEnum: <"Top level ISDA FRO category.">
    ScreenRate displayName "Screen Rate" <"The rate is observed directly from a screen.">
    Calculated displayName "Calculated Rate" <"The rate is calculated by the calculation agents from multiple observations.">
    ReferenceBanks displayName "Reference Banks Rate" <"The rate is obtained by polling several other banks.">

enum FloatingRateIndexStyleEnum: <"Second level ISDA FRO category.">
    AverageFRO displayName "Average FRO" <"An ISDA-defined calculated rate done using arithmetic averaging.">
    CompoundedFRO displayName"Compounded FRO" <"An ISDA-defined calculated rate done using arithmetic averaging.">
    CompoundedIndex displayName "Compounded Index" <"A published index calculated using compounding.">
    Index displayName "Index" <"A published index using a methodology defined by the publisher, e.g. S&P 500.">
    Other displayName "Other"
    Overnight displayName "Overnight Rate"
    PublishedAverage displayName "Published Average Rate" <" A published rate computed using an averaging methodology.">
    SpecifiedFormula displayName "Specified Formula"
    SwapRate displayName "Swap Rate" <"A rate representing the market rate for swaps of a given maturity.">
    TermRate displayName "Term Rate" <"A rate specified over a given term, such as a libor-type rate.">

enum FloatingRateIndexCalculationMethodEnum: <"3rd level ISDA FRO category.">
    OISCompound displayName "OIS Compounding" <"A calculation methodology using the ISDA-defined OIS compounding formula.">
    Average  displayName "Overnight Averaging" <"A calculation methodology using the arithmetic mean.">
    Compounded displayName "Compounded Index"
    AllInCompounded displayName "All-In Compounded Index"


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-fro-func.rosetta
================================================================================

namespace cdm.observable.asset.fro : <"Support for floating rate option definitions.">
version "${project.version}"

import cdm.base.staticdata.asset.rates.*
import cdm.event.common.*
import cdm.legaldocumentation.common.*
import cdm.observable.asset.fro.*

// =====================================================================
//
// Floating Rate Index reference data and validation functions
//
// these functions allow retrieval of the reference data for a floating rate index,
// and validation that it is a valid floating rate index name
//
// ======================================================================
func FloatingRateIndexMetadata: <"Retrieve all available metadata for the floating rate index.">
    [codeImplementation]
    inputs:
        floatingRateIndexName FloatingRateIndexEnum (1..1) <"The name of the floating rate index.">
    output:
        floatingRateIndexDescription FloatingRateIndexDefinition (0..1) <"The detailed description of the index if available, null otherwise.">

func ValidateFloatingRateIndexName: <"Return whether the supplied floating rate index name is valid for the supplied contractual definitions.">
    inputs:
        floatingRateIndexName FloatingRateIndexEnum (1..1) <"The name of the floating rate index.">
        contractualDefs ContractualDefinitionsEnum (0..1) <"The contractual definitions to validate against.">
    output:
        isValid boolean (1..1) <"True if this is a floating rate index name that is valid.">

    alias defs: FloatingRateIndexMetadata(floatingRateIndexName)
    alias isPresent: defs exists
    alias defsOk:
        defs -> supportedDefinition -> contractualDefinitionIdentifier -> contractualDefinitionType contains contractualDefs
    alias okDefs:
        if contractualDefs exists then defsOk else defs exists

    set isValid: okDefs

func FilterInvalidFloatingRateIndexTradeDate: <"Returns the invalid floating rate index or indices of a trade based on their metadata and the trade date.">
    inputs:
        tradeState TradeState (1..1) <"The input is a trade to validate its floating rate index based on the trade date">
    output:
        invalidFloatingRateIndex FloatingRateIndexEnum (0..*) <"The invalid floating rate index or indices of a trade based on their metadata and the trade date.">

    set invalidFloatingRateIndex:
        tradeState -> trade -> tradeLot -> priceQuantity -> observable -> Index -> InterestRateIndex -> FloatingRateIndex -> floatingRateIndex
            extract FloatingRateIndexMetadata
            then filter
                history -> startDate > tradeState -> trade -> tradeDate or history -> endDate < tradeState -> trade -> tradeDate
            then extract item -> fro -> floatingRateIndex


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-fro-type.rosetta
================================================================================

namespace cdm.observable.asset.fro : <"Support for floating rate option definitions.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.identifier.*
import cdm.legaldocumentation.common.*
import cdm.observable.asset.fro.*

// =====================================================================
//
// Floating Rate Index  Definitions
//
// these types are used to hold reference data about floating rate indexes
//
// ======================================================================
type FloatingRateIndexDefinition:
    fro FloatingRateIndexIdentification (1..1) <"The underlying FRO name and designated maturity.">
    calculationDefaults FloatingRateIndexCalculationDefaults (0..1) <"Any calculation default values.">
    supportedDefinition ContractualDefinition (0..*) <"The definition version or versions supported by the FRO.">
    definitionalSource string (0..1) <"The source of an FRO, particularly if not a Contractual Definition (e.g. the broker rates matrix).">
    designatedMaturityApplicable boolean (0..1)
    mappings FloatingRateIndexMappings (0..1) <"Any mappings to other FRos.">
    externalMappings FloatingRateIndexExternalMappings (0..1) <"Any mappings to other codes for this index.">
    inLoan boolean (0..1) <"YES / NO to flag FROs identified by the FpML Syndicated Loan WG as having underlying benchmark that may also be referenced in syndicated loans.">
    history FroHistory (0..1) <"FRO History">
    deprecationReason string (0..1) <"Deprecation and Code Descriptions">
    fpmlDescription string (0..1) <"FpML Description">

type FloatingRateIndexIdentification:
    floatingRateIndex FloatingRateIndexEnum (0..1) <"The reference index that is used to specify the floating interest rate. The FpML standard maintains the list of such indices, which are positioned as enumeration values as part of the CDM.">
        [metadata scheme]
    currency ISOCurrencyCodeEnum (0..1) <"FRO currency - 3 character ISO currrency code">
    froType string (0..1) <"FRO type (e.g. OIS)">

type FloatingRateIndexCalculationDefaults: <"This holds the rate calculation defaults applicable for a floating rate index.">
    category FloatingRateIndexCategoryEnum (0..1) <"The ISDA FRO category (e.g. screen rate or calculated rate).">
    indexStyle FloatingRateIndexStyleEnum (0..1) <"The ISDA FRO style (e.g. term rate, swap rate, etc).">
    method FloatingRateIndexCalculationMethodEnum (0..1) <"The ISDA FRO calculation method (e.g. OIS Compounding).">
    fixing FloatingRateIndexFixingDetails (0..*) <"The default fixing details.">
    dayCountFraction DayCountFractionEnum (0..1) <"The default day count fraction.">
    applicableBusinessDays BusinessCenters (0..1) <"The default applicable business days.">
    publicationCalendar BusinessCenterEnum (0..1) <"Publication Calendar (e.g. EUR-ICESWAP)">

type ContractualDefinition:
    identifier Identifier (0..1) <"Corresponds to the unique identifier of the Contractual Definition in which the code is published">
    contractualDefinitionIdentifier ContractualDefinitionIdentifier (0..1) <"Contractual Definition Identifier in which the code is published. Includes Document Type and Document Version">
    publicationDate date (0..1) <"2021-06-11">

    condition Choice: <"Choice between document uuid or document type and version">
        optional choice identifier, contractualDefinitionIdentifier

type ContractualDefinitionIdentifier:
    contractualDefinitionType ContractualDefinitionsEnum (1..1) <"e.g. ISDA2021Definitions">
    contractualDefinitionVersion string (0..1) <"e.g. V1">

type FloatingRateIndexMap: <"A map for a single FRO to or from an equivalent or similar FRO in a different contractual definitions version.">
    index FloatingRateIndexEnum (0..*) <" The FRO name that is being mapped to/from.">
    contractualDefinitionIdentifier ContractualDefinitionIdentifier (0..1) <"Contractual Definition to which the map applies. Includes Document Type and Document Version">
    identifier Identifier (0..1) <"Corresponds to the unique identifier of the Contractual Definition to which the map applies">

    condition Choice: <"Choice between document uuid or document type and version">
        optional choice identifier, contractualDefinitionIdentifier

type FloatingRateIndexMappings: <"This type defines mappings between FROs in different definitional versions.">
    mapsTo FloatingRateIndexMap (0..1) <"The successor FRO that this index maps to.">
    mapsFrom FloatingRateIndexMap (0..*) <"The predecessor FRO(s) that this index maps to.">

type FloatingRateIndexExternalMap: <"A map for a single FRO to or from an equivalent or similar codes in a different standard such as ISO.">
    externalId string (1..1) <" The FRO name that is being mapped to/from.">
    externalStandard string (0..1) <"The standard/version to which the map applies.">

type FloatingRateIndexExternalMappings: <"Represents the mappings of FRO codes to other.">
    isoCode FloatingRateIndexExternalMap (0..1)

type FroHistory: <"FRO History">
    startDate date (0..1) <"The date the Floating Rate Option was added to the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. 2017/04/06)">
    firstDefinedIn ContractualDefinition (0..1) <"The supplement or version the FRO was first added to the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. S52)">
    updateDate date (0..1) <"The date the Floating Rate Option was last updated in the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. 2021/06/11)">
    lastUpdatedIn ContractualDefinition (0..1) <"The supplement or version the FRO was last updated in the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. FRO-M-V1)">
    endDate date (0..1) <"The date the Floating Rate Option was removed from the 2006 Definitions or 2021 Floating Rate Matrix. (e.g. 2014/01/01)">

type FloatingRateIndexFixingDetails: <"This type holds parameters defining the fixingt time and offset for a floating rate index.">
    fixingTime FloatingRateIndexFixingTime (0..1) <"Parameters defining the normal fixing time (can vary by index tenor / designated maturity).">
    fixingOffset BusinessDayOffset (0..1) <"Parameters defining the normal fixing offset (can vary by index tenor / designated maturity).">

type FloatingRateIndexFixingTime extends BusinessCenterTime: <"This type holds parameters defining the normal fixing time for a floating rate index.">
    designatedMaturity string (0..1) <"Allows a designed maturity to be specified for the fixing time.">
    fixingTimeDefinition string (0..1) <"Legal text that underlies the Fixing Time. ISDA Fixing Time Definition. (e.g. 09:30, Sydney time).">
    fixingReason string (0..1) <"Fixing Reason">

type FloatingRateIndexFixingOffset extends BusinessDayOffset: <"This type holds parameters defining the normal fixing offset for a floating rate index.">
    designatedMaturity string (0..1) <"Allows a reason to be specified for using the alternative fixing offset.">

type BusinessDayOffset extends Period: <"This allows an offset to be specified as, for instance, N business days, with a business centers specified as included.">
    businessCenters BusinessCenters (0..1) <"The business centers for the offset.">
    fixingOffsetDefinition string (0..1) <"Legal text that underlies the Fixing Offset. ISDA Fixing Offset Definition. (e.g. One day that is either a Sydney Business Day or a Melbourne Business Day following the Reset Date)">
    fixingOffsetReason string (0..1) <"Fixing Offset Reason">


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-func.rosetta
================================================================================

namespace cdm.observable.asset : <"Observable concepts applicable to assets: price, reference price, valuation method etc.">
version "${project.version}"

import cdm.base.math.*
import cdm.observable.asset.*

func FilterPrice: <"Filter list of prices based on price type.">
    inputs:
        prices PriceSchedule (0..*) <"List of prices to filter.">
        priceType PriceTypeEnum (1..1) <"The price type to filter by: asset price, cash price, exchange rate etc.">
        arithmeticOperators ArithmeticOperationEnum (0..*) <"Optionally filter based on the type of operator, e.g. if price is specified as a spread or a multiplier. Several operators can be passed as arguments (e.g. [ Add, Subtract ]).">
        priceExpression PriceExpressionEnum (0..1) <"Optionally filter by type of price expression: percentage of notional, par value fraction">
    output:
        price PriceSchedule (0..1)

    set price: <"Return as single element rather than a list.">
        prices
            filter item -> priceType = priceType
            then filter
                if arithmeticOperators exists
                then arithmeticOperators contains item -> arithmeticOperator
                else True
            then filter
                if priceExpression exists
                then item -> priceExpression = priceExpression
                else True
            then only-element

func InterestRateObservableCondition: <"Implementation for PriceQuantity.InterestRateObservable condition.">
    inputs:
        pq PriceQuantity (1..1)
    output:
        valid boolean (0..1)

    set valid:
        if pq -> observable -> Index -> InterestRateIndex exists and pq -> price exists
        then pq -> price
                extract [
                    priceType = PriceTypeEnum -> InterestRate and arithmeticOperator exists
                ] all = True

func ObservableIsCommodity: <"Validates whether all of the constituents of an Observable are Commodities.">
    inputs:
        observable Observable (0..1)
    output:
        valid boolean (1..1)

    set valid:
        if observable -> Asset exists
        then observable -> Asset -> Commodity exists
        else if observable -> Basket exists
        then observable -> Basket -> basketConstituent extract [ Asset -> Commodity exists ]
            all = True
        else if observable -> Index exists
        then observable -> Index ->> assetClass = Commodity
        else False


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-asset-type.rosetta
================================================================================

namespace cdm.observable.asset : <"Observable concepts applicable to assets: price, reference price, valuation method etc.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.party.*
import cdm.mapping.config.*
import cdm.observable.common.*
import cdm.product.asset.*

type IndexBase extends AssetBase: <"Identifies an index by referencing an identifier.">
    name string (0..1) <"A description of the Index.">
        [metadata scheme]
    provider LegalEntity (0..1) <"The organisation that creates or maintains the Index.">
    assetClass AssetClassEnum (0..1) <"The Asset Class of the Index.">

choice Index: <"An Index is an Observable which is computed based on the prices, rates or valuations of a number of assets that are tracked in a standardized way.  Examples include equity market indices as well as indices on interest rates, inflation and credit instruments.">
    CreditIndex <"An index based on credit risk, typically composed using corporate debt instruments in a region or industry sector, e.g. the iTraxx indices.">
    EquityIndex <"An index based on equity securities, e.g. the S&P 500.">
    InterestRateIndex <"An index based in interest rates or inflation rates in a certain market.">
        [metadata location]
    ForeignExchangeRateIndex <"A rate based on the exchange of a pair of cash assets in specific currencies, e.g. USD versus GBP.">
    OtherIndex <"An index created by a market participant which doesn't align with the other index types.">

choice InterestRateIndex: <"An index based in interest rates or inflation rates in a certain market.">
    FloatingRateIndex <"An interest rate index which can change over time, e.g. the SONIA (Sterling Overnight Index Average) in the UK.">
    InflationIndex <"An index that measures inflation in a specific market, e.g. the US Consumer Price Index.">

type FloatingRateIndex extends IndexBase: <"Specification of an interest rate index which can change over time, e.g. the SONIA (Sterling Overnight Index Average) in the UK.">
    floatingRateIndex FloatingRateIndexEnum (1..1) <"The reference index that is used to specify the floating interest rate.">
        [metadata scheme]
    indexTenor Period (0..1) <"The ISDA Designated Maturity, i.e. the floating rate tenor.">

    condition InterestRateAssetClass: <"The asset class must be Interest Rate.">
        assetClass = AssetClassEnum -> InterestRate

type ForeignExchangeRateIndex extends IndexBase: <"Specification of a rate based on the exchange of a pair of cash assets in specific currencies, e.g. USD versus GBP.">
    quotedCurrencyPair QuotedCurrencyPair (1..1) <"Describes the composition of a rate that has been quoted or is to be quoted.">
        [metadata location]
    primaryFxSpotRateSource InformationSource (1..1) <"Specifies the primary source from which a rate should be observed.">
    secondaryFxSpotRateSource InformationSource (0..1) <"Specifies an alternative, or secondary, source from which a rate should be observed.">

    condition FXAssetClass: <"The asset class must be Foreign Exchange.">
        assetClass = AssetClassEnum -> ForeignExchange

type InflationIndex extends IndexBase: <"Specification of an index that measures inflation in a specific market, e.g. the US Consumer Price Index.">
    inflationRateIndex InflationRateIndexEnum (1..1) <"The reference index that is used to specify the inflation interest rate.">
        [metadata scheme]
    indexTenor Period (0..1) <"The ISDA Designated Maturity, i.e. the floating rate tenor.">

    condition InterestRateAssetClass: <"The asset class must be Interest Rate.">
        assetClass = AssetClassEnum -> InterestRate

type CreditIndex extends IndexBase: <"Specification of an index based on credit risk, typically composed using corporate debt instruments in a region or industry sector, e.g. the iTraxx indices.">
    [metadata key]
    indexSeries int (0..1) <"A CDS index series identifier, e.g. 1, 2, 3 etc.">
    indexAnnexVersion int (0..1) <"A CDS index series version identifier, e.g. 1, 2, 3 etc.">
    indexAnnexDate date (0..1) <"A CDS index series annex date.">
    indexAnnexSource IndexAnnexSourceEnum (0..1) <"A CDS index series annex source.">
        [metadata scheme]
    excludedReferenceEntity ReferenceInformation (0..*) <"Excluded reference entity.">
    tranche Tranche (0..1) <"This element contains CDS tranche terms.">
    settledEntityMatrix SettledEntityMatrix (0..1) <"Used to specify the Relevant Settled Entity Matrix when there are settled entities at the time of the trade.">
    indexFactor number (0..1) <"Index Factor is the index version factor or percent, expressed as an absolute decimal value between 0 and 1, that multiplied by the original notional amount yields the notional amount covered by the seller of protection.">
    seniority CreditSeniorityEnum (0..1) <"Seniority of debt instruments comprising the index.">

    condition IndexSeries: <"FpML specifies the type associated to indexSeries as a positive integer.">
        if indexSeries exists then indexSeries >= 0

    condition IndexAnnexVersion: <"FpML specifies the type associated to indexVersion as a positive integer.">
        if indexAnnexVersion exists then indexAnnexVersion >= 0

    condition IndexFactor: <"Index factor is expressed as a decimal and should be a positive number between o and 1.">
        if indexFactor exists
        then indexFactor >= 0 and indexFactor <= 1

    condition CreditAssetClass: <"The asset class must be Credit.">
        assetClass = AssetClassEnum -> Credit

type EquityIndex extends IndexBase: <"Specification of an index based on equity securities, e.g. the S&P 500..">

    condition EquityAssetClass: <"The asset class must be Equity.">
        assetClass = AssetClassEnum -> Equity

type OtherIndex extends IndexBase: <"Specification of a user-defined index that does not meet the criteria of other Index data types.">
    description string (0..1) <"A description that defines the OtherIndex.">

    condition AssetClassRequired: <"The asset class must be explicitly set.">
        assetClass exists

type PriceQuantity: <"Defines a settlement as an exchange between two parties of a specified quantity of an asset (the quantity) against a specified quantity of another asset (the price). The settlement is optional and can be either cash or physical. The quantity can additionally be specified in terms of one or more currency amounts. In the case of non-cash products, the settlement of the price/quantity would not be specified here and instead would be delegated to the product mechanics, as parameterised by the price/quantity values.">
    [metadata key]
    price PriceSchedule (0..*) <"Specifies a price to be used for trade amounts and other purposes.">
        [metadata location]
    quantity NonNegativeQuantitySchedule (0..*) <"Specifies a quantity to be associated with an event, for example a trade amount.">
        [metadata location]
    observable Observable (0..1) <"Specifies the object to be observed for a price, it could be an asset or an index. The cardinality is optional as some quantity / price cases have no observable (e.g. a fixed rate in a given currency).">
        [metadata location]
    effectiveDate AdjustableOrRelativeDate (0..1) <"Specifies the date at which the price and quantity become effective. This day may be subject to adjustment in accordance with a business day convention, or could be specified as relative to a trade date, for instance. Optional cardinality, as the effective date is usually specified in the product definition, so it may only need to be specified as part of the PriceQuantity in an increase/decrease scenario for an existing trade.">

    condition NonCurrencyQuantities: <"There should be at most one quantity which is not a currency, except for commodities where there may be two.">
        (quantity count - quantity -> unit -> currency count) <= 1 or (observable -> Asset -> Commodity exists
            and quantity -> unit -> capacityUnit exists and (quantity count - quantity -> unit -> currency count) <= 2)

    condition ArithmeticOperator: <"When observable is InterestRateIndex, and price exists, then price should have an arithmetic operator.">
        if observable -> Index -> InterestRateIndex exists and price exists
        then price -> arithmeticOperator exists

    condition InterestRateObservable: <"When the observable is an interest rate index, the price type must be interest rate and the arithmetic operator must be specified.">
        InterestRateObservableCondition

type PremiumExpression: <"This class corresponds to the FpML Premium.model group for representing the option premium when expressed in a way other than an amount.">
    premiumType PremiumTypeEnum (0..1) <"Forward start premium type">
    pricePerOption Money (0..1) <"The amount of premium to be paid expressed as a function of the number of options.">
    percentageOfNotional number (0..1) <"The amount of premium to be paid expressed as a percentage of the notional value of the transaction. A percentage of 5% would be expressed as 0.05.">

type CashPrice: <"Specifies the nature of a cash price either as a fee type, cash price type, or premium expression.">
    cashPriceType CashPriceTypeEnum (1..1) <"Specifies the type of Cash Price.">
    premiumExpression PremiumExpression (0..1) <"Specifies a premium when expressed in a way other than an amount, and any required forward starting price definition.">
    feeType FeeTypeEnum (0..1) <"Specifies the event type associated with a fee.">

    condition PremiumType: <"Premium type can only be specified when the cash price type is a premium.">
        if premiumExpression exists
        then cashPriceType = CashPriceTypeEnum -> Premium

type PriceComposite: <"Defines the inputs required to calculate a price as a simple composite of 2 other values. The inputs consist of 2 numbers and a simple arithmetic operator. This generic data type applies to a variety of use cases where a price is obtained by simple composition, e.g. dirty = clean + accrued (Bond), forward rate = spot rate + forward point (FX) etc.">
    baseValue number (1..1) <"The 1st value in the arithmetic operation, which may be non-commutative in some cases: Subtract, Divide). This 1st operand is called 'baseValue' as it refers to the price anchor in the arithmetic operation: e.g. the clean price (Bond) or the spot rate (FX).">
    operand number (1..1) <"The 2nd value in the arithmetic operation, which may be non-commutative in some cases: Subtract, Divide). The 2nd operand is called 'operand' to distinguish it from the 1st one which is the price anchor.">
    arithmeticOperator ArithmeticOperationEnum (1..1) <"Specifies the arithmetic operator via an enumeration.">
    operandType PriceOperandEnum (0..1) <"Optionally qualifies the type of operand: e.g. accrued or forward point.">

    condition ArithmeticOperator: <"If operand type is accrued or forward point, then operator must be either add or subtract.">
        if operandType = PriceOperandEnum -> ForwardPoint
                or operandType = PriceOperandEnum -> AccruedInterest
        then arithmeticOperator = ArithmeticOperationEnum -> Add
                or arithmeticOperator = ArithmeticOperationEnum -> Subtract

type PriceSchedule extends MeasureSchedule: <"Specifies the price of a financial instrument in a trade as a schedule of measures. A price generically expresses the value of an exchange as a ratio: it measures the amount of one thing needed to be exchanged for 1 unit of another thing (e.g. cash in a specific currency in exchange for a bond or share). This generic representation can be used to support any type of financial price beyond just cash price: e.g. an interest rate, a foreign exchange rate, etc. This data type is generically based on a schedule and can also be used to represent a price as a single value.">

    perUnitOf UnitType (0..1) <"Provides an attribute to define the unit of the thing being priced. For example, {amount, unitOfAmount, PerUnitOfAmount} = [10, EUR, Shares] = (10.00 EUR/SHARE) * (300,000 SHARES) = EUR 3,000,000.00 (Shares cancel out in the calculation).">
    priceType PriceTypeEnum (1..1) <"Specifies the price type as an enumeration: interest rate, exchange rate, asset price etc. This attribute is mandatory so that prices can always be clasiffied according to their type. The price type implies some constraints on the price's units.">
    priceExpression PriceExpressionEnum (0..1) <"(Optionally) Specifies whether the price is expressed in absolute or percentage terms.">
    composite PriceComposite (0..1) <"(Optionally) Specifies the underlying price components if the price can be expressed as a composite: e.g. dirty price = clean price + accrued.">
    arithmeticOperator ArithmeticOperationEnum (0..1) <"(Optionally) When the price is to be understood as an operator to apply to an observable, i.e. a spread, multiplier or min/max.">
    cashPrice CashPrice (0..1) <"(Optionally when the price type is cash) Additional attributes that further define a cash price, e.g. what type of fee it is.">

    condition UnitOfAmountExists: <"Requires that a unit of amount must be specified for price unless price type is Variance, Volatility or Correlation.">
        if priceType = PriceTypeEnum -> Variance
                or priceType = PriceTypeEnum -> Volatility
                or priceType = PriceTypeEnum -> Correlation
        then unit is absent and perUnitOf is absent
        else unit exists and perUnitOf exists

    condition PositiveAssetPrice: <"Requires that per FpML rules, the FX rate must be a positive value.">
        if (priceType = PriceTypeEnum -> ExchangeRate or priceType = PriceTypeEnum -> AssetPrice)
                and arithmeticOperator is absent
        then value > 0

    condition PositiveSpotRate: <"Requires that per FpML rules, the spot rate must be a positive value, for example for FX or Commodities.">
        if (priceType = PriceTypeEnum -> ExchangeRate or priceType = PriceTypeEnum -> AssetPrice)
                and composite -> baseValue exists
        then composite -> baseValue > 0

    condition PositiveCashPrice: <"Requires that any price expressed as a cash price and generating a cashflow must be positive">
        if priceType = PriceTypeEnum -> CashPrice
        then value > 0 or datedValue -> value all > 0

    condition CurrencyUnitForInterestRate: <"Requires that the unit of amount for an interest rate must be a currency.">
        if priceType = PriceTypeEnum -> InterestRate
        then unit -> currency exists

    condition Choice: <"The price can be specified mutually exclusively as a cashflow, an operator (e.g. a spread or multiplier), or a composite.">
        optional choice cashPrice, arithmeticOperator, composite

    condition CashPrice: <"If a cash price type is specified, the price type must be cash, otherwise it must be non-cash.">
        if cashPrice exists
        then priceType = PriceTypeEnum -> CashPrice

    condition ArithmeticOperator: <"Operator must not be subtract or divide.">
        arithmeticOperator <> ArithmeticOperationEnum -> Subtract
            and arithmeticOperator <> ArithmeticOperationEnum -> Divide

    condition SpreadPrice: <"A spread type can only be specified when the price type is an asset price or an interest rate.">
        if arithmeticOperator = ArithmeticOperationEnum -> Add
        then priceType = PriceTypeEnum -> AssetPrice
                or priceType = PriceTypeEnum -> InterestRate

    condition ForwardPoint: <"If composite operand type is ForwardPoint then the price type must be ExchangeRate.">
        if composite -> operandType = PriceOperandEnum -> ForwardPoint
        then priceType = PriceTypeEnum -> ExchangeRate

    condition AccruedInterest: <"If composite operand type is AccruedInterest then the price type must be AssetPrice.">
        if composite -> operandType = PriceOperandEnum -> AccruedInterest
        then priceType = PriceTypeEnum -> AssetPrice

type Price extends PriceSchedule: <"Specifies a price as a single value to be associated to a financial product. This data type extends PriceSchedule and requires that only the amount value exists.">

    condition AmountOnlyExists: <"The amount must exist when the price represents a single value, and steps must be absent.">
        value exists and datedValue is absent

choice Observable: <"Specifies the object to be observed for a price, it could be an asset or a reference.">
    Asset <"The object to be observed is an Asset, ie something that can be owned and transferred in the financial markets.">
    Basket <"The object to be observed is a Basket, ie a collection of Observables with an identifier and optional weightings.">
    Index <"The object to be observed is an Index, ie an observable computed on the prices, rates or valuations of a number of assets.">

type Basket extends AssetBase: <"Defines a custom basket by referencing an identifier and its constituents.">
    basketConstituent BasketConstituent (1..*) <"Identifies the constituents of the basket">
        [metadata location]

type BasketConstituent extends Observable: <"Identifies the constituents of the basket">
    quantity NonNegativeQuantitySchedule (0..*) <"Specifies a quantity schedule to be associated to an individual underlier that is a basket constituent. The multiple cardinality is aligned to the one of the PriceQuantity->quantity that this quantity is referencing.">
        [metadata address "pointsTo"=PriceQuantity->quantity]
    initialValuationPrice PriceSchedule (0..*) <"Specifies an initial price schedule to be associated to an individual underlier that is a basket constituent. The multiple cardinality is aligned to the one of the PriceQuantity->price that this price is referencing.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies an interim price schedule to be associated to an individual underlier that is a basket constituent. The multiple cardinality is aligned to the one of the PriceQuantity->price that this price is referencing.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"Specifies a final price schedule to be associated to an individual underlier that is a basket constituent. The multiple cardinality is aligned to the one of the PriceQuantity->price that this price is referencing.">
        [metadata address "pointsTo"=PriceQuantity->price]

    condition BasketsOfBaskets: <"To prevent endless looping, baskets of baskets are not supported.">
        Basket is absent

type InformationSource: <"A class defining the source for a piece of information (e.g. a rate fix or an FX fixing). The attribute names have been adjusted from FpML to address the fact that the information is not limited to rates.">

    sourceProvider InformationProviderEnum (1..1) <"An information source for obtaining a market data point. For example Bloomberg, Reuters, Telerate, etc.">
        [metadata scheme]
        [synonym FIX_5_0_SP2 value "RateSource" tag 1446]
    sourcePage string (0..1) <"A specific page for the source for obtaining a market data point. In FpML, this is specified as a scheme, rateSourcePageScheme, for which no coding Scheme or URI is specified.">
        [metadata scheme]
    sourcePageHeading string (0..1) <"The heading for the source on a given source page.">

type Money extends Quantity: <"Defines a monetary amount in a specified currency.">
    [metadata key]

    condition CurrencyUnitExists:
        unit -> currency exists

type QuotedCurrencyPair: <"A class that describes the composition of a rate that has been quoted or is to be quoted. This includes the two currencies and the quotation relationship between the two currencies and is used as a building block throughout the FX specification.">

    currency1 string (1..1) <"The first currency specified when a pair of currencies is to be evaluated.">
        [metadata scheme]
    currency2 string (1..1) <"The second currency specified when a pair of currencies is to be evaluated.">
        [metadata scheme]
    quoteBasis QuoteBasisEnum (1..1) <"The method by which the exchange rate is quoted.">

type Curve:
    [deprecated]
    interestRateCurve InterestRateCurve (0..1)
    commodityCurve CommodityReferencePriceEnum (0..1)
        [metadata scheme]

    condition Curve:
        one-of

type InterestRateCurve:
    [deprecated]
    floatingRateIndex FloatingRateIndexEnum (1..1)
        [metadata scheme]
    tenor Period (1..1)

type TransactedPrice: <" A class to represent the transacted price attributes that are positioned as part of the FpML FeeLeg.">

    marketFixedRate number (0..1) <"An optional element that only has meaning in a credit index trade. This element contains the credit spread ('fair value') at which the trade was executed. Unlike the fixedRate of an index, the marketFixedRate varies over the life of the index depending on market conditions. The marketFixedRate is the price of the index as quoted by trading desks.">
    initialPoints number (0..1) <"An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints value of 5% would be represented as 0.05. The initialPoints element is an alternative to marketFixedRate in quoting the traded level of a trade. When initialPoints is used, the traded level is the sum of fixedRate and initialPoints. The initialPoints is one of the items that are factored into the initialPayment calculation and is payable by the Buyer to the Seller. Note that initialPoints and marketFixedRate may both be present in the same document when both implied values are desired.">
    marketPrice number (0..1) <"An optional element that only has meaning in a credit index trade. This element contains the price at which the trade was executed and is used instead of marketFixedRate on credit trades on certain indicies which are quoted using a price rather than a spread.">
    quotationStyle QuotationStyleEnum (0..1) <"An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints value of 5% would be represented as 0.05. The initialPoints element is an alternative to marketFixedRate in quoting the traded level of a trade. When initialPoints is used, the traded level is the sum of fixedRate and initialPoints. The initialPoints is one of the items that are factored into the initialPayment calculation and is payable by the Buyer to the Seller. Note that initialPoints and marketFixedRate may both be present in the same document when both implied values are desired.">

type ReferenceSwapCurve: <"A complex type used to specify the option and convertible bond option strike when expressed in reference to a swap curve.">

    swapUnwindValue SwapCurveValuation (1..1)
    makeWholeAmount MakeWholeAmount (0..1) <"Amount to be paid by the buyer of the option if the option is exercised prior to the Early Call Date. (The market practice in the convertible bond option space being that the buyer should be penalised if he/she exercises the option early on.)">

type MakeWholeAmount extends SwapCurveValuation: <"A class to specify the amount to be paid by the buyer of the option if the option is exercised prior to the Early Call Date (typically applicable to the convertible bond options).">

    interpolationMethod InterpolationMethodEnum (0..1) <"The type of interpolation method that the calculation agent reserves the right to use.">
    earlyCallDate date (1..1) <"Date prior to which the option buyer will have to pay a Make Whole Amount to the option seller if he/she exercises the option.">
        [metadata id]

type SwapCurveValuation: <"A class to specify a valuation swap curve, which is used as part of the strike construct for the bond and convertible bond options.">

    floatingRateIndex FloatingRateIndexEnum (1..1)
    indexTenor Period (0..1) <"The ISDA Designated Maturity, i.e. the tenor of the floating rate.">
    spread number (1..1) <"Spread in basis points over the floating rate index.">
    side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the measure.">

type ValuationDates: <"Defines how and when a performance type option or performance type swap is to be valued, including initial, interim and final valuation dates.">

    initialValuationDate PerformanceValuationDates (0..1) <"Specifies the initial valuation dates of the underlyer.">
    interimValuationDate PerformanceValuationDates (0..1) <"Specifies the interim valuation dates of the underlyer.">
    finalValuationDate PerformanceValuationDates (1..1) <"Specifies the final valuation dates of the underlyer.">

type PerformanceValuationDates: <"Defines how and when a performance type option or performance type swap is to be valued.">
    [metadata key]

    determinationMethod DeterminationMethodEnum (1..1) <"Specifies the method according to which an amount or a date is determined.">
    valuationDates AdjustableRelativeOrPeriodicDates (0..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Pricing Date">
    valuationDate AdjustableOrRelativeDate (0..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Pricing Date">
    valuationTime BusinessCenterTime (0..1) <"The specific time of day at which the calculation agent values the underlying. The SpecificTime is the only case when the valuationTime (time + business center location  e.g. 10:00:00 USNY) should be provided. You should be able to provide just the valuationTime without valuationTimeType, which infer that this is a specific time.">
    valuationTimeType TimeTypeEnum (0..1) <"The time of day at which the calculation agent values the underlying, for example the official closing time of the exchange.">

type FxRateSourceFixing: <"Describes a rate source to be fixed and the date the fixing occurs">

    settlementRateSource FxSettlementRateSource (1..1)
    fixingDate AdjustableDate (1..1) <"The date on which the fixing is scheduled to occur.">

type FxInformationSource extends InformationSource: <"Information source specific to Foreign Exchange products.">

    fixingTime BusinessCenterTime (0..1) <"The time that the fixing will be taken along with a business center to define the time zone.">

type FallbackReferencePrice: <"The method, prioritised by the order it is listed in this element, to get a replacement rate for the disrupted settlement rate option.">

    valuationPostponement ValuationPostponement (0..1) <"Specifies how long to wait to get a quote from a settlement rate option upon a price source disruption.">
    fallBackSettlementRateOption SettlementRateOptionEnum (0..*) <"This settlement rate option will be used in its place.">
        [metadata scheme]
    fallbackSurveyValuationPostponement boolean (0..1) <"Request rate quotes from the market. This element is set as type Empty in FpML. When present, the FpML synonym is mapped to a value True in the CDM.">
    calculationAgentDetermination CalculationAgent (0..1) <"The calculation agent will decide the rate.">

    condition MaximumDaysOfPostponement: <"FpML specifies maximumDaysOfPostponement as a positive integer.">
        if valuationPostponement exists
        then valuationPostponement -> maximumDaysOfPostponement > 0

    condition FallbackCalculationAgent:
        if calculationAgentDetermination -> calculationAgentParty exists
        then calculationAgentDetermination -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentFallback

type ValuationPostponement: <"Specifies how long to wait to get a quote from a settlement rate option upon a price source disruption.">

    maximumDaysOfPostponement int (1..1) <"The maximum number of days to wait for a quote from the disrupted settlement rate option before proceeding to the next method.">

type FxRate: <"A class describing the rate of a currency conversion: pair of currency, quotation mode and exchange rate.">

    quotedCurrencyPair QuotedCurrencyPair (1..1) <"Defines the two currencies for an FX trade and the quotation relationship between the two currencies.">
    rate number (0..1) <"The rate of exchange between the two currencies of the leg of a deal. Must be specified with a quote basis.">

type FxSpotRateSource: <"A class defining the rate source and fixing time for an FX rate.">

    primarySource InformationSource (1..1) <"The primary source for where the rate observation will occur. Will typically be either a page or a reference bank published rate.">
    secondarySource InformationSource (0..1) <"An alternative, or secondary, source for where the rate observation will occur. Will typically be either a page or a reference bank published rate.">

type RateObservation: <"A class defining parameters associated with an individual observation or fixing. This class forms part of the cashflow representation of a stream.">
    [metadata key]

    resetDate date (0..1) <"The reset date.">
    adjustedFixingDate date (0..1) <"The adjusted fixing date, i.e. the actual date the rate is observed. The date should already be adjusted for any applicable business day convention.">
    observedRate number (0..1) <"The actual observed rate before any required rate treatment is applied, e.g. before converting a rate quoted on a discount basis to an equivalent yield. An observed rate of 5% would be represented as 0.05.">
    treatedRate number (0..1) <"The observed rate after any required rate treatment is applied. A treated rate of 5% would be represented as 0.05.">
    observationWeight int (0..1) <"The number of days weighting to be associated with the rate observation, i.e. the number of days such rate is in effect. This is applicable in the case of a weighted average method of calculation where more than one reset date is established for a single calculation period.">
    rateReference RateObservation (0..1) <"A pointer style reference to a floating rate component defined as part of a stub calculation period amount component. It is only required when it is necessary to distinguish two rate observations for the same fixing date which could occur when linear interpolation of two different rates occurs for a stub calculation period.">
        [metadata reference]
    forecastRate number (0..1) <"The value representing the forecast rate used to calculate the forecast future value of the accrual period.A value of 1% should be represented as 0.01.">
    treatedForecastRate number (0..1) <"The value representing the forecast rate after applying rate treatment rules. A value of 1% should be represented as 0.01.">

    condition PositiveObservationWeight: <"FpML specifies observationWeight as a positive integer.">
        if observationWeight exists then observationWeight >= 0

type CreditNotation: <"Represents a class to specify the credit notation as the combination of agency, notation, scale and debt type qualifications.">

    agency CreditRatingAgencyEnum (1..1) <"Specifies The credit agency to which the other variables (notation, scale, debt type) refer to.">
    notation string (1..1) <"Specifies The credit rating notation. As it varies among credit rating agencies, FpML doesn't specify a default scheme.">
        [metadata scheme]
    scale string (0..1) <"Specifies the credit rating scale, with a typical distinction between short term, long term. FpML doesn't specify a default scheme, which is hence not specified as an enumeration as part of the CDM.">
        [metadata scheme]
    debt CreditRatingDebt (0..1) <"Specifies the credit rating debt type (e.g. long term, high yield, deposits, ...) associated with the credit rating notation and scale.">
    outlook CreditRatingOutlookEnum (0..1) <"Assesses the potential direction of a long-term credit rating over the intermediate term, which is generally up to two years for investment grade and generally up to one year for speculative grade.">
    creditWatch CreditRatingCreditWatchEnum (0..1) <"Indicates the potential direction of a short-term or long-term rating. It focuses on identifiable events and short-term trends that cause ratings to be placed under special surveillance.">

type CreditNotations: <"Represents the credit rating notation higher level construct, which provides the ability to specify multiple rating notations.">

    creditNotation CreditNotation (0..1) <"Specifies only one credit notation is determined.">
    creditNotations MultipleCreditNotations (0..1) <"Specifies if several credit notations exist, alongside an 'any' or 'all' or all condition.">

    condition:
        one-of

type CreditRatingDebt: <"Specifies the credit rating debt type(s) associated with the credit rating notation and scale. When several debt types are specified, they must be qualified through an 'any' or 'all'.">

    debtType string (0..1) <"Specifies when there is only one debt type. FpML doesn't specify values in relation to the associated scheme, which is hence not specified as an enumeration as part of the CDM.">
        [metadata scheme]
    debtTypes MultipleDebtTypes (0..1) <"Specifies if there are several debt types, alongside an 'any' or 'all' or all condition. As an example, Baa1 rating is required for any long term debt and deposit.">

    condition:
        one-of

type MultipleCreditNotations: <"Represetns a class to specify multiple credit notations alongside a conditional 'any' or 'all' qualifier.">

    condition QuantifierEnum (1..1) <"An enumerated element, to qualify whether All or Any credit notation applies.">
    creditNotation CreditNotation (2..*) <"At least two credit notations much be specified.">
        [metadata scheme]
    mismatchResolution CreditNotationMismatchResolutionEnum (0..1)
    referenceAgency CreditRatingAgencyEnum (0..1)

    condition ReferenceAgency: <"If the mismatch resolution is ReferenceAgency, ensure that the reference agency is specified.">
        if mismatchResolution = CreditNotationMismatchResolutionEnum -> ReferenceAgency
        then referenceAgency exists

type MultipleDebtTypes: <"Represents a class to specify multiple credit debt types alongside a conditional 'any' or 'all' qualifier.">

    condition QuantifierEnum (1..1) <"An enumerated attribute, to qualify whether All or Any debt type applies.">
    debtType string (2..*) <"The type of debt, e.g. long term debt, deposit, ... FpML doesn't specific a scheme value, hence no enumeration is specified as part of the CDM. At least two debt types much be specified.">
        [metadata scheme]

type FxSettlementRateSource: <"The source of the Foreign Exchange settlement rate.">

    settlementRateOption string (0..1) <"Indicates that an officially defined rate settlement rate option will be the used for the fixing.">
        [metadata scheme]
    nonstandardSettlementRate FxInformationSource (0..1) <"Indicates that a non-standard rate source will be used for the fixing.">

    condition FxSettlementRateSourceChoice:
        required choice settlementRateOption, nonstandardSettlementRate

type CalculationAgent: <"A class defining the ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">

    calculationAgentParty AncillaryRoleEnum (0..1) <"Specifies the party which is the ISDA Calculation Agent for the trade. If more than one party is referenced then the parties are assumed to be co-calculation agents, i.e. they have joint responsibility.">
    calculationAgentPartyEnum PartyDeterminationEnum (0..1) <"Specifies the ISDA calculation agent responsible for performing duties as defined in the applicable product definitions. For example, the Calculation Agent may be defined as being the Non-exercising Party.">
    calculationAgentBusinessCenter BusinessCenterEnum (0..1) <"The city in which the office through which ISDA Calculation Agent is acting for purposes of the transaction is located The short-form confirm for a trade that is executed under a Sovereign or Asia Pacific Master Confirmation Agreement ( MCA ), does not need to specify the Calculation Agent. However, the confirm does need to specify the Calculation Agent City. This is due to the fact that the MCA sets the value for Calculation Agent but does not set the value for Calculation Agent City.">
        [metadata scheme]

    condition CalculationAgentChoice: <"Choice rule to represent an FpML choice construct.">
        optional choice calculationAgentParty, calculationAgentPartyEnum

type SettlementRateOption: <"Defines the settlement rate option to use for fixing in case of cash settlement. Currently only applicable to foreign exchange fixing in case of cross-currency settlement.">
    settlementRateOption SettlementRateOptionEnum (1..1) <"The rate source for the conversion to the settlement currency. This source is specified through a scheme that reflects the terms of the Annex A to the 1998 FX and Currency Option Definitions.">
        [metadata scheme]
    priceSourceDisruption PriceSourceDisruption (0..1) <"An attribute defining the parameters to get a new quote when a settlement rate option is disrupted.">

type MultipleValuationDates extends SingleValuationDate:
    businessDaysThereafter int (0..1) <"The number of business days between successive valuation dates when multiple valuation dates are applicable for cash settlement. ISDA 2003 Term: Business Days thereafter.">
    numberValuationDates int (0..1) <"Where multiple valuation dates are specified as being applicable for cash settlement, this element specifies (a) the number of applicable valuation dates, and (b) the number of business days after satisfaction of all conditions to settlement when the first such valuation date occurs, and (c) the number of business days thereafter of each successive valuation date. ISDA 2003 Term: Multiple Valuation Dates.">
    condition BusinessDaysThereafter: <"FpML specifies businessDaysThereafter as a PositiveInteger.">
        if businessDaysThereafter exists
        then businessDaysThereafter >= 0

    condition NumberValuationDates: <"FpML specifies numberValuationDates as a PositiveInteger.">
        if numberValuationDates exists then numberValuationDates >= 0

type SingleValuationDate: <"A class to specify the number of business days after satisfaction of all conditions to settlement.">
    businessDays int (0..1) <"A number of business days. Its precise meaning is dependant on the context in which this element is used. ISDA 2003 Term: Business Day.">
    condition NonNegativeBusinessDays: <"FpML specifies businessDays as a NonNegativeInteger.">
        if businessDays exists then businessDays >= 0

type ValuationSource: <"A class describing the method for obtaining a settlement rate, specified through either an information source (page), a settlement rate option (fixing) or by using quotes from reference banks.">
    quotedCurrencyPair QuotedCurrencyPair (0..1) <"Defines the two currencies for an FX trade and the quotation relationship between the two currencies.  This attribute was formerly part of 'fxSettlementTerms', which is now being harmonised into a common 'CashSettlementTerms' that includes a 'ValuationDate'.">
        [metadata address "pointsTo"=Observable->Index->ForeignExchangeRateIndex->quotedCurrencyPair]
    informationSource FxSpotRateSource (0..1) <"The information source where a published or displayed market rate will be obtained, e.g. Telerate Page 3750.">
    settlementRateOption SettlementRateOption (0..1) <"The rate option to use for the fixing. Currently only applicable to foreign exchange fixing in case of cross-currency settlement.">
    referenceBanks ReferenceBanks (0..1) <"A container for a set of reference institutions that may be called upon to provide rate quotations as part of the method to determine the applicable cash settlement amount. If institutions are not specified, it is assumed that reference institutions will be agreed between the parties on the exercise date, or in the case of swap transaction to which mandatory early termination is applicable, the cash settlement valuation date.">
    dealerOrCCP AncillaryEntity (0..1) <"Holds an identifier for the reference entity that is agreed by both parties as a basis for cash settlement calculations. This could be a dealer from whom quotations are obtained by the calculation agent on the reference obligation for purposes of cash settlement in a credit event. ISDA 2003 Term: Dealer. This could be the clearing organization (CCP, DCO) to which the trade should be cleared, as applicable for cash-settled swaptions.">

    condition InformationSource: <"An information source must be provided.">
        required choice informationSource, settlementRateOption, referenceBanks, dealerOrCCP

type PriceSourceDisruption: <"A data defining:  the parameters used to get a price quote to replace the settlement rate option that is disrupted.">
    fallbackReferencePrice FallbackReferencePrice (1..1) <"The method, prioritised by the order it is listed in this element, to get a replacement rate for the disrupted settlement rate option.">

type ValuationMethod: <"Specifies the parameters required to obtain a valuation, including the source, quotation method (bid, mid etc.) and any applicable quotation amount.">
    valuationSource ValuationSource (1..1) <"The source for obtaining a valuation. This may come from some information source (e.g. Reuters), from a rate option fixing (e.g. FX fixing for cross-currency settlement), or from a set of reference banks. This is a mandatory attribute as the valuation method relies on one of those sources to be specified.">
    quotationMethod QuotationRateTypeEnum (0..1) <"The type of price quotations to be requested from dealers when determining the market value of the reference obligation for purposes of cash settlement, or which rate quote is to be observed for a fixing. For example, Bid, Offer, Mid-market or Exercising Party Pays. ISDA 2003 Term: Quotation Method. The meaning of Exercising Party Pays is defined in the 2000 ISDA Definitions, Section 17.2. Certain Definitions Relating to Cash Settlement, paragraph (j).">
    valuationMethod ValuationMethodEnum (0..1) <"The ISDA defined methodology for determining the final price of the reference obligation for purposes of cash settlement. (ISDA 2003 Term: Valuation Method). For example, Market, Highest etc.">
    quotationAmount Money (0..1) <"In the determination of a cash settlement amount, if weighted average quotations are to be obtained, the quotation amount specifies an upper limit to the outstanding principal balance of the reference obligation for which the quote should be obtained. If not specified, the ISDA definitions provide for a fallback amount equal to the floating rate payer calculation amount. ISDA 2003 Term: Quotation Amount.">
    minimumQuotationAmount Money (0..1) <"In the determination of a cash settlement amount, if weighted average quotations are to be obtained, the minimum quotation amount specifies a minimum intended threshold amount of outstanding principal balance of the reference obligation for which the quote should be obtained. If not specified, the ISDA definitions provide for a fallback amount of the lower of either USD 1,000,000 (or its equivalent in the relevant obligation currency) or the quotation amount. ISDA 2003 Term: Minimum Quotation Amount.">
    cashCollateralValuationMethod CashCollateralValuationMethod (0..1) <"Specifies the parameters representing several mid-market valuation and replacement value methods.">

    condition FpML_cd_37: <"FpML validation rule cd-37 - If condition quotationAmount is true, and if condition minimumQuotationAmount is true, and if both amounts have the same-currency, then quotationAmount/amount must be greater or equal to minimumQuotationAmount/amount.">
        if (quotationAmount exists and minimumQuotationAmount exists)
                and quotationAmount -> unit -> currency = minimumQuotationAmount -> unit -> currency
        then quotationAmount -> value > minimumQuotationAmount -> value

    condition Dealer: <"When a quotation amount is specified, the dealer from which to obtain the quotation must be specified in the valuation source. This is typically applicable to determine the recovery amount in a credit event.">
        if quotationAmount exists or minimumQuotationAmount exists
        then valuationSource -> dealerOrCCP -> legalEntity exists

type CashCollateralValuationMethod: <"This type is a generic structure that can represent the parameters of several mid-market valuation and replacement value methods described in the 2021 ISDA Definitions.">
    applicableCsa CsaTypeEnum (0..1) <"This may be used to specify what type of CSA (credit support annex/agreement) is to be used for cash settlement purposes.">
    cashCollateralCurrency string (0..1) <"This may be used to indicate the currency of cash collateral for cash settlement purposes.">
    cashCollateralInterestRate string (0..1) <"This may be used to indicate the interest rate to be used for cash collateral for cash settlement purposes.">
        [metadata scheme]
    agreedDiscountRate string (0..1) <"This may be used to indicate the discount rate to be used for cash collateral for cash settlement purposes.">
        [metadata scheme]
    protectedParty PartyDeterminationEnum (0..2) <"This may be used to specify which party is protected (e.g. under Replacement Value cash settlement methods).">
    prescribedDocumentationAdjustment boolean (0..1) <"This may be used to indicate that 'prescribed documentation adjustment' is applicable.">

type DividendApplicability: <"The parameters which define whether dividends are applicable">

    optionsExchangeDividends boolean (0..1) <"If present and true, then options exchange dividends are applicable.">
    additionalDividends boolean (0..1) <"If present and true, then additional dividends are applicable.">
    allDividends boolean (0..1) <"Represents the European Master Confirmation value of 'All Dividends' which, when applicable, signifies that, for a given Ex-Date, the daily observed Share Price for that day is adjusted (reduced) by the cash dividend and/or the cash value of any non cash dividend per Share (including Extraordinary Dividends) declared by the Issuer. All Dividends in accordance with the ISDA 2002 Equity Derivatives Definitions.">


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-common-enum.rosetta
================================================================================

namespace cdm.observable.common
version "${project.version}"

import cdm.base.*

enum TimeTypeEnum: <"The enumerated values to specify points in the day when option exercise and valuation can occur.">
    Close <"The official closing time of the exchange on the valuation date.">
    Open <"The official opening time of the exchange on the valuation date.">
    OSP <"The time at which the official settlement price is determined.">
    SpecificTime <"The time specified in the element equityExpirationTime or valuationTime (as appropriate).">
    XETRA <"The time at which the official settlement price (following the auction by the exchange) is determined by the exchange.">
    DerivativesClose <"The official closing time of the derivatives exchange on which a derivative contract is listed on that security underlier.">
    AsSpecifiedInMasterConfirmation <"The time is determined as provided in the relevant Master Confirmation.">

enum DeterminationMethodEnum: <"The enumerated values to specify the method according to which an amount or a date is determined.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/determination-method"]

    AgreedInitialPrice <"Agreed separately between the parties.">
    AsSpecifiedInMasterConfirmation <"As specified in Master Confirmation.">
    CalculationAgent <"Determined by the Calculation Agent.">
    ClosingPrice <"Official Closing Price.">
    DividendCurrency <"Determined by the Currency of Equity Dividends.">
    ExpiringContractLevel <"The initial Index Level is the level of the Expiring Contract as provided in the Master Confirmation.">
    HedgeExecution <"Determined by the Hedging Party.">
    IssuerPaymentCurrency <"Issuer Payment Currency.">
    NAV <"Net Asset Value.">
    OpenPrice <"Opening Price of the Market.">
    OSPPrice <"OSP Price.">
    SettlementCurrency <"Settlement Currency.">
    StrikeDateDetermination <"Date on which the strike is determined in respect of a forward starting swap.">
    TWAPPrice <"Official TWAP Price.">
    ValuationTime <"Price determined at valuation time.">
    VWAPPrice <"Official VWAP Price.">


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-common-func.rosetta
================================================================================

namespace cdm.observable.common
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.observable.asset.*

func ResolveTimeZoneFromTimeType: <"Defines inputs and outputs needed to derive the time and time-zone for a product identifier">
    [codeImplementation]
    inputs:
        assetIdentifier AssetIdentifier (1..1)
        timeType TimeTypeEnum (1..1)
        determinationMethod DeterminationMethodEnum (1..1)
    output:
        time TimeZone (1..1)

func CashPriceQuantityNoOfUnitsTriangulation: <"Data rule to check the relationship between cash price, notional and number of units.">
    inputs:
        quantity NonNegativeQuantitySchedule (0..*)
        price PriceSchedule (0..*)
    output:
        success boolean (1..1)

    alias notional:
        FilterQuantityByCurrencyExists(quantity)
            extract value
            then distinct
            then only-element

    alias noOfUnits:
        FilterQuantityByFinancialUnit(quantity, FinancialUnitEnum -> Share)
            extract value
            then only-element

    alias cashPrice:
        price
            filter priceType = PriceTypeEnum -> AssetPrice
            then extract value
            then only-element

    set success:
        if cashPrice exists and noOfUnits exists and notional exists
        then cashPrice * noOfUnits = notional
        else True


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-desc.rosetta
================================================================================

namespace cdm.observable : <"Observable concepts: market data, holiday calendars etc.">
version "${project.version}"


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-event-enum.rosetta
================================================================================

namespace cdm.observable.event : <"Observable event concepts: extraordinary event, trigger event, disruption event etc.">
version "${project.version}"

enum IndexEventConsequenceEnum: <"The enumerated values to specify the consequences of Index Events.">
    CalculationAgentAdjustment <"Calculation Agent Adjustment.">
    NegotiatedCloseOut <"Negotiated Close Out.">
    CancellationAndPayment <"Cancellation and Payment.">
    RelatedExchange <"Related Exchange.">

enum MarketDisruptionEnum: <"The enumerated values to specify the handling of an averaging date market disruption for an equity derivative transaction.">
    ModifiedPostponement <"As defined in section 6.7 paragraph (c) sub-paragraph (iii) of the ISDA 2002 Equity Derivative definitions.">
    Omission <"As defined in section 6.7 paragraph (c) sub-paragraph (i) of the ISDA 2002 Equity Derivative definitions.">
    Postponement <"As defined in section 6.7 paragraph (c) sub-paragraph (ii) of the ISDA 2002 Equity Derivative definitions.">

enum TriggerTypeEnum: <"The enumerated values to specify whether an option will trigger or expire depending upon whether the spot rate is above or below the barrier rate.">
    EqualOrLess <"The underlier price must be equal to or less than the Trigger level.">
    EqualOrGreater <"The underlier price must be equal to or greater than the Trigger level.">
    Equal <"The underlier price must be equal to the Trigger level.">
    Less <"The underlier price must be less than the Trigger level.">
    Greater <"The underlier price must be greater than the Trigger level.">

enum TriggerTimeTypeEnum: <"The enumerated values to specify the time of day which would be considered for valuing the knock event.">
    Closing <"The close of trading on a day would be considered for valuation.">
    Anytime <"At any time during the Knock Determination period (continuous barrier).">

enum ShareExtraordinaryEventEnum: <"The enumerated values to specify the consequences of extraordinary events relating to the underlying.">
    AlternativeObligation <"The trade continues such that the underlying now consists of the New Shares and/or the Other Consideration, if any, and the proceeds of any redemption, if any, that the holder of the underlying Shares would have been entitled to.">
    CancellationAndPayment <"The trade is cancelled and a cancellation fee will be paid by one party to the other.">
    OptionsExchange <"The trade will be adjusted by the Calculation Agent in accordance with the adjustments made by any exchange on which options on the underlying are listed.">
    CalculationAgent <"The Calculation Agent will determine what adjustment is required to offset any change to the economics of the trade. If the Calculation Agent cannot achieve this, the trade goes to Cancellation and Payment with the Calculation Agent deciding on the value of the cancellation fee. Adjustments may not be made to account solely for changes in volatility, expected dividends, stock loan rate or liquidity.">
    ModifiedCalculationAgent <"The Calculation Agent will determine what adjustment is required to offset any change to the economics of the trade. If the Calculation Agent cannot achieve this, the trade goes to Cancellation and Payment with the Calculation Agent deciding on the value of the cancellation fee. Adjustments to account for changes in volatility, expected dividends, stock loan rate or liquidity are allowed.">
    PartialCancellationAndPayment <"Applies to Basket Transactions. The portion of the Basket made up by the affected Share will be cancelled and a cancellation fee will be paid from one party to the other. The remainder of the trade continues.">
    Component <"If this is a Share-for-Combined merger event (Shares are replaced with New Shares and Other Consideration), then different treatment can be applied to each component if the parties have specified this.">

enum RestructuringEnum: <"The enumerated values to specify the form of the restructuring credit event that is applicable to the credit default swap.">
    ModModR <"Restructuring (Section 4.7) and Modified Restructuring Maturity Limitation and Conditionally Transferable Obligation (2014 Definitions: Section 3.31, 2003 Definitions: 2.32) apply.">
    ModR <"Restructuring (Section 4.7) and Restructuring Maturity Limitation and Fully Transferable Obligation (2014 Definitions: Section 3.31, 2003 Definitions: 2.32) apply.">
    R <"Restructuring as defined in the applicable ISDA Credit Derivatives Definitions. (2003 or 2014).">


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-event-func.rosetta
================================================================================

namespace cdm.observable.event : <"Observable event concepts: extraordinary event, trigger event, disruption event etc.">
version "${project.version}"

import cdm.base.math.*
import cdm.event.common.*
import cdm.observable.asset.*
import cdm.product.template.*

func Create_AssetPayoutTradeStateWithObservations: <"Attaches a set of Observations to a Security Finance Transaction.">
    inputs:
        billingInstruction BillingRecordInstruction (1..1)
    output:
        tradeState TradeState (1..1)

    alias assetPayout:
        billingInstruction -> tradeState -> trade -> product -> economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout only-element

    alias date: billingInstruction -> recordEndDate

    set tradeState: billingInstruction -> tradeState

    add tradeState -> resetHistory:
        Create_AssetReset(assetPayout, billingInstruction -> observation, date)

func Create_AssetReset: <"Defines how to resolve the reset value for an equity payout.">
    inputs:
        assetPayout AssetPayout (1..1) <"Represents the AssetPayout to which the reset will apply.">
        observation Observation (1..*) <"Represents the observations that will be used to compute the reset value.">
        resetDate date (1..1) <"Specifies the date of the reset.">
    output:
        reset Reset (1..1)

    set reset -> resetValue: <"Assigns the observed value to the reset value.">
        ResolveObservationAverage(observation)
    // work out the average as the value to be used in the calculation
    set reset -> resetDate: resetDate

    add reset -> observations: <"Assigns the observation required to compute the rest value as audit.">
        observation

    set reset -> averagingMethodology -> averagingMethod -> calculationMethod:
        AveragingCalculationMethodEnum -> Arithmetic

func ResolveObservationAverage: <"Specifies the interface that should be used by implementors to resolve a single observation when provided many, applying the averaging method, if one is provided.">
    inputs:
        observations Observation (1..*)
    output:
        resetValue Price (1..1)

    alias firstObservedValue: observations -> observedValue first

    condition UnitsMatch:
        observations -> observedValue -> unit all = firstObservedValue -> unit

    set resetValue -> value: observations -> observedValue -> value sum / observations count
    set resetValue -> unit: firstObservedValue -> unit
    set resetValue -> perUnitOf: firstObservedValue -> perUnitOf
    set resetValue -> priceExpression: firstObservedValue -> priceExpression
    set resetValue -> priceType: firstObservedValue -> priceType


================================================================================
FILE: rosetta-source/src/main/rosetta/observable-event-type.rosetta
================================================================================

namespace cdm.observable.event : <"Observable event concepts: extraordinary event, trigger event, disruption event etc.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.party.*
import cdm.observable.asset.*
import cdm.observable.common.*

type Trigger: <"Trigger point at which feature is effective.">

    level PriceSchedule (0..2) <"The trigger level.">
    creditEvents CreditEvents (0..1)
    creditEventsReference CreditEvents (0..1)
        [metadata reference]
    triggerType TriggerTypeEnum (0..1) <"The Triggering condition.">
    triggerTimeType TriggerTimeTypeEnum (0..1) <"The valuation time type of knock condition.">

    condition Choice1: <" Choice rule to represent an FpML choice construct.">
        required choice level, creditEvents , creditEventsReference

type TriggerEvent: <"Observation point for trigger.">

    schedule AveragingSchedule (0..*) <"A derivative schedule.">
    triggerDates DateList (0..1) <"The trigger Dates.">
    trigger Trigger (1..1) <"The trigger level">
    featurePayment FeaturePayment (0..1) <"The feature payment, i.e. the payment made following trigger occurrence.">

type CreditEvents: <"A class to specify the applicable Credit Events that would trigger a settlement, as specified in the related Confirmation and defined in the ISDA 2014 Credit Definition article IV section 4.1.">
    [metadata key]

    bankruptcy boolean (0..1) <"A credit event. The reference entity has been dissolved or has become insolvent. It also covers events that may be a precursor to insolvency such as instigation of bankruptcy or insolvency proceedings. Sovereign trades are not subject to Bankruptcy as 'technically' a Sovereign cannot become bankrupt. ISDA 2003 Term: Bankruptcy.">
    failureToPay FailureToPay (0..1) <"A credit event. This credit event triggers, after the expiration of any applicable grace period, if the reference entity fails to make due payments in an aggregate amount of not less than the payment requirement on one or more obligations (e.g. a missed coupon payment). ISDA 2003 Term: Failure to Pay.">
    failureToPayPrincipal boolean (0..1) <"A credit event. Corresponds to the failure by the Reference Entity to pay an expected principal amount or the payment of an actual principal amount that is less than the expected principal amount. ISDA 2003 Term: Failure to Pay Principal.">
    failureToPayInterest boolean (0..1) <"A credit event. Corresponds to the failure by the Reference Entity to pay an expected interest amount or the payment of an actual interest amount that is less than the expected interest amount. ISDA 2003 Term: Failure to Pay Interest.">
    obligationDefault boolean (0..1) <"A credit event. One or more of the obligations have become capable of being declared due and payable before they would otherwise have been due and payable as a result of, or on the basis of, the occurrence of a default, event of default or other similar condition or event other than failure to pay. ISDA 2003 Term: Obligation Default.">
    obligationAcceleration boolean (0..1) <"A credit event. One or more of the obligations have been declared due and payable before they would otherwise have been due and payable as a result of, or on the basis of, the occurrence of a default, event of default or other similar condition or event other than failure to pay (preferred by the market over Obligation Default, because more definitive and encompasses the definition of Obligation Default - this is more favorable to the Seller). Subject to the default requirement amount. ISDA 2003 Term: Obligation Acceleration.">
    repudiationMoratorium boolean (0..1) <"A credit event. The reference entity, or a governmental authority, either refuses to recognise or challenges the validity of one or more obligations of the reference entity, or imposes a moratorium thereby postponing payments on one or more of the obligations of the reference entity. Subject to the default requirement amount. ISDA 2003 Term: Repudiation/Moratorium.">
    restructuring Restructuring (0..1) <"A credit event. A restructuring is an event that materially impacts the reference entity's obligations, such as an interest rate reduction, principal reduction, deferral of interest or principal, change in priority ranking, or change in currency or composition of payment. ISDA 2003 Term: Restructuring.">
    governmentalIntervention boolean (0..1) <"A credit event. A governmental intervention is an event resulting from an action by a governmental authority that materially impacts the reference entity's obligations, such as an interest rate reduction, principal reduction, deferral of interest or principal, change in priority ranking, or change in currency or composition of payment. ISDA 2014 Term: Governmental Intervention.">
    distressedRatingsDowngrade boolean (0..1) <"A credit event. Results from the fact that the rating of the reference obligation is down-graded to a distressed rating level. From a usage standpoint, this credit event is typically not applicable in case of RMBS trades.">
    maturityExtension boolean (0..1) <"A credit event. Results from the fact that the underlier fails to make principal payments as expected.">
    writedown boolean (0..1) <"A credit event. Results from the fact that the underlier writes down its outstanding principal amount.">
    impliedWritedown boolean (0..1) <"A credit event. Results from the fact that losses occur to the underlying instruments that do not result in reductions of the outstanding principal of the reference obligation.">
    defaultRequirement Money (0..1) <"In relation to certain credit events, serves as a threshold for Obligation Acceleration, Obligation Default, Repudiation/Moratorium and Restructuring. Market standard is USD 10,000,000 (JPY 1,000,000,000 for all Japanese Yen trades). This is applied on an aggregate or total basis across all Obligations of the Reference Entity. Used to prevent technical/operational errors from triggering credit events. ISDA 2003 Term: Default Requirement.">
    creditEventNotice CreditEventNotice (0..1) <"A specified condition to settlement. An irrevocable written or verbal notice that describes a credit event that has occurred. The notice is sent from the notifying party (either the buyer or the seller) to the counterparty. It provides information relevant to determining that a credit event has occurred. This is typically accompanied by Publicly Available Information. ISDA 2003 Term: Credit Event Notice.">

type CreditEventNotice:

    notifyingParty CounterpartyRoleEnum (1..2) <"The notifying party is the party that notifies the other party when a credit event has occurred by means of a credit event notice. If more than one party is referenced as being the notifying party then either party may notify the other of a credit event occurring. ISDA 2003 Term: Notifying Party.">
    businessCenter BusinessCenterEnum (0..1) <"Inclusion of this business center element implies that Greenwich Mean Time in Section 3.3 of the 2003 ISDA Credit Derivatives Definitions is replaced by the local time of the city indicated by the businessCenter element value.">
    publiclyAvailableInformation PubliclyAvailableInformation (0..1) <"A specified condition to settlement. Publicly available information means information that reasonably confirms any of the facts relevant to determining that a credit event or potential repudiation/moratorium, as applicable, has occurred. The ISDA defined list (2003) is the market standard and is considered comprehensive, and a minimum of two differing public sources must have published the relevant information, to declare a Credit Event. ISDA 2003 Term: Notice of Publicly Available Information Applicable.">

type FailureToPay:

    applicable boolean (1..1) <"Indicates whether the failure to pay provision is applicable.">
    gracePeriodExtension GracePeriodExtension (0..1) <"If this element is specified, indicates whether or not a grace period extension is applicable. ISDA 2003 Term: Grace Period Extension Applicable.">
    paymentRequirement Money (0..1) <"Specifies a threshold for the failure to pay credit event. Market standard is USD 1,000,000 (JPY 100,000,000 for Japanese Yen trades) or its equivalent in the relevant obligation currency. This is applied on an aggregate basis across all Obligations of the Reference Entity. Intended to prevent technical/operational errors from triggering credit events. ISDA 2003 Term: Payment Requirement">

type GracePeriodExtension:

    applicable boolean (1..1) <"Indicates whether the grace period extension provision is applicable.">
    gracePeriod Offset (0..1) <"The number of calendar or business days after any due date that the reference entity has to fulfil its obligations before a failure to pay credit event is deemed to have occurred. ISDA 2003 Term: Grace Period.">

type PubliclyAvailableInformation:

    standardPublicSources boolean (0..1) <"If this element is specified and set to 'true', indicates that ISDA defined Standard Public Sources are applicable.">
    publicSource string (0..*) <"A public information source, e.g. a particular newspaper or electronic news service, that may publish relevant information used in the determination of whether or not a credit event has occurred. ISDA 2003 Term: Public Source.">
    specifiedNumber int (0..1) <"The minimum number of the specified public information sources that must publish information that reasonably confirms that a credit event has occurred. The market convention is two. ISDA 2003 Term: Specified Number.">
    condition SourceChoice: <" FpML validation rule cd-36 - Context: PubliclyAvailableInformation (complex type). Either standardPublicSources or at least one publicSource element must exist.">
        required choice standardPublicSources, publicSource

    condition PositiveSpecifiedNumber: <" FpML specifies specifiedNumber as a positiveInteger.">
        if specifiedNumber exists then specifiedNumber >= 0

type Restructuring:

    applicable boolean (1..1) <"Indicates whether the restructuring provision is applicable.">
    restructuringType RestructuringEnum (0..1) <"Specifies the type of restructuring that is applicable.">
        [metadata scheme]
    multipleHolderObligation boolean (0..1) <"In relation to a restructuring credit event, unless multiple holder obligation is not specified restructurings are limited to multiple holder obligations. A multiple holder obligation means an obligation that is held by more than three holders that are not affiliates of each other and where at least two thirds of the holders must agree to the event that constitutes the restructuring credit event. ISDA 2003 Term: Multiple Holder Obligation.">
    multipleCreditEventNotices boolean (0..1) <"Presence of this element and value set to 'true' indicates that Section 3.9 of the 2003 Credit Derivatives Definitions shall apply. Absence of this element indicates that Section 3.9 shall not apply. NOTE: Not allowed under ISDA Credit 1999.">

type FeaturePayment: <"Payment made following trigger occurrence.">
    [metadata key]

    payerReceiver PartyReferencePayerReceiver (1..1) <"This attribute doesn't exist as part of the FpML construct, which makes use of the PayerReceiver.model group.">
    levelPercentage number (0..1) <"The trigger level percentage.">
    amount number (0..1) <"The monetary quantity in currency units.">
    time TimeTypeEnum (0..1) <"The feature payment time.">
    currency string (0..1) <"The currency in which an amount is denominated.">
        [metadata scheme]
    paymentDate AdjustableOrRelativeDate (0..1) <"The feature payment date.">

    condition FeaturePaymentChoice: <" Choice rule to represent an FpML choice construct.">
        required choice levelPercentage, amount

    condition Amount: <" The amount attribute is specified in FpML as non-negative decimal.">
        if amount exists then amount >= 0.0

type Observation: <"Defines a single, numerical value that was observed in the marketplace. Observations of market data are made independently to business events or trade life-cycle events, so data instances of Observation can be created independently of any other model type, hence it is annotated as a root type. Observations will be broadly reused in many situations, so references to Observation are supported via the 'key' annotation.">
    [rootType]
    [metadata key]
    observedValue Price (1..1) <"Specifies the observed value as a number.">
    observationIdentifier ObservationIdentifier (1..1) <"Represents the observation was made i.e. how to uniquely identify the observed value among the population of all available market data.">

type ObservationIdentifier: <"Defines the parameters needed to uniquely identify a piece of data among the population of all available market data.">
    observable Observable (1..1) <"Represents the asset or rate to which the observation relates.">
    observationDate date (1..1) <"Specifies the date value to use when resolving the market data.">
    observationTime TimeZone (0..1) <"Represents the time and time-zone.">
    informationSource InformationSource (0..1) <"Represents where the market data published and should be observed.">
    determinationMethodology DeterminationMethodology (0..1) <"Specifies the method according to which an amount or a date is determined.">

type DeterminationMethodology: <"Specifies the method according to which an amount or a date is determined.">
    determinationMethod DeterminationMethodEnum (0..1) <"Represents a more granular dimention of observation. Typically relevent for resolving a unique equity price, which can be expressed as trade-weighted or volume-weighted averages.">
    averagingMethod AveragingCalculationMethodEnum (0..1) <"Specifies enumerations for the type of averaging calculation.">

func ResolveObservation: <"Specifies the interface that should be used by implementors to resolve a single observation when provided many, applying the averaging method, if one is provided.">
    [codeImplementation]
    inputs:
        identifiers ObservationIdentifier (1..*)
        averagingMethod AveragingCalculationMethod (0..1)
    output:
        observation Observation (1..1)


================================================================================
FILE: rosetta-source/src/main/rosetta/product-asset-calculation-func.rosetta
================================================================================

namespace cdm.product.asset.calculation: <"Product-related, asset class-specific calculation concepts, such as day counting and calculating accruals.">
version "${project.version}"

import cdm.base.datetime.daycount.*
import cdm.base.math.*
import cdm.observable.asset.*
import cdm.product.asset.*
import cdm.product.asset.floatingrate.*
import cdm.product.common.schedule.*

// =====================================================================
//
// Fixed Amount Calculation definitions
//
// These functions return the calculated fixed amount.
//
// ======================================================================
// TODO: should this be enhanced to support spreads and do spread-exclusive calculations for compounding?
func FixedAmountCalculation: <"Calculates the fixed amount for a calculation period by looking up the notional and the fixed rate and multiplying by the year fraction.">
    inputs:
        interestRatePayout InterestRatePayout (1..1)
        calculationPeriod CalculationPeriodBase (1..1)
        notional number (0..1)
    output:
        fixedAmountDetails FixedAmountCalculationDetails (1..1)

    alias fixedRate: GetFixedRate(interestRatePayout, calculationPeriod)
    alias calculationAmount: GetNotionalAmount(interestRatePayout, calculationPeriod)
    alias dcf: interestRatePayout -> dayCountFraction
    alias yearFraction: CalculateYearFraction(interestRatePayout, dcf, calculationPeriod)
    alias calcAmt:
        if notional exists
        then notional
        else calculationAmount -> value

    set fixedAmountDetails -> calculationPeriod: calculationPeriod
    set fixedAmountDetails -> calculationPeriodNotionalAmount -> value: calcAmt
    set fixedAmountDetails -> calculationPeriodNotionalAmount -> unit -> currency:
        calculationAmount -> unit -> currency
    set fixedAmountDetails -> fixedRate: fixedRate
    set fixedAmountDetails -> yearFraction: yearFraction
    set fixedAmountDetails -> calculatedAmount:
        calcAmt * fixedAmountDetails -> fixedRate * fixedAmountDetails -> yearFraction

func GetFixedRate: <"Look up the fixed rate for a calculation period.">
    [calculation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the spread.">
    output:
        fixedRate number (0..1) <"the fixed rate value value for the period.">

    set fixedRate:
        GetRateScheduleAmount(
                interestRatePayout -> rateSpecification -> FixedRateSpecification -> rateSchedule,
                calculationPeriod -> adjustedStartDate
            )

// =====================================================================
//
// Floating Rate Amount Calculation definitions
//
// these functions perform the floating amount calculations
//
// ======================================================================
func FloatingAmountCalculation: <"Calculate a floating amount for a calculation period by determining the raw floating rate, applying any rate treatments, looking up the calculation period notional, then performing the multiplication of the notional, rate, and year fraction.  Floating amount calculations are described in the 2021 ISDA Definitions in Section 6 and 7.">
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"The interest rate stream for which the floating amount calculation is being done.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the floating rate calculation is being done.">
        isInitialPeriod boolean (1..1) <"Is this the initial calculation period?.">
        suppliedNotional number (0..1)
        suppliedRate number (0..1)
    output:
        result FloatingAmountCalculationDetails (1..1) <"The details of the floating rate calculation, including raw rate, rate treatment details, notional, and calculated cashlow amount.">

    // Get the floating rate before treatments
    alias floatingRateSetting:
        if suppliedRate is absent
        then DetermineFloatingRateReset(interestRatePayout, calculationPeriod)

    set result:
        ApplyFloatingRateSetting(
                interestRatePayout,
                calculationPeriod,
                isInitialPeriod,
                suppliedNotional,
                suppliedRate,
                floatingRateSetting
            )

func ApplyFloatingRateSetting: <"Calculate a floating amount for a calculation period by determining the raw floating rate, applying any rate treatments, looking up the calculation period notional, then performing the multiplication of the notional, rate, and year fraction.  Floating amount calculations are described in the 2021 ISDA Definitions in Section 6 and 7.">
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"The interest rate stream for which the floating amount calculation is being done.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the floating rate calculation is being done.">
        isInitialPeriod boolean (1..1) <"Is this the initial calculation period?.">
        suppliedNotional number (0..1)
        suppliedRate number (0..1)
        floatingRateSetting FloatingRateSettingDetails (0..1) <"Details of the rate observation/calculation corresonding to the supplied rate definition and calculation period.">
    output:
        result FloatingAmountCalculationDetails (1..1) <"The details of the floating rate calculation, including raw rate, rate treatment details, notional, and calculated cashlow amount.">

    alias floatingRate: floatingRateSetting -> floatingRate

    // apply rate treatments/processing
    alias processingParameters:
        GetFloatingRateProcessingParameters(interestRatePayout, calculationPeriod)
    alias processedRateDetails:
        if suppliedRate exists
        then DefaultFloatingRate(suppliedRate)
        else ApplyFloatingRateProcessing(
                processingParameters,
                floatingRate,
                calculationPeriod,
                isInitialPeriod
            )

    // determine notional, year fraction, and perform the final calculation
    alias periodNotional: GetNotionalAmount(interestRatePayout, calculationPeriod)
    alias notional:
        if suppliedNotional exists
        then suppliedNotional
        else periodNotional -> value
    alias currency: periodNotional -> unit -> currency

    set result:
        CalculateFloatingCashFlow(
                interestRatePayout,
                calculationPeriod,
                notional,
                currency,
                floatingRateSetting,
                processedRateDetails
            )

func DefaultFloatingRate:
    inputs:
        suppliedRate number (1..1)
    output:
        processedRateDetails FloatingRateProcessingDetails (1..1) <"Results are details of the rate treatment.">

    set processedRateDetails -> processedRate: suppliedRate

func CalculateFloatingCashFlow:
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"The interest rate stream for which the floating amount calculation is being done.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the floating rate calculation is being done.">
        notional number (0..1)
        currency string (0..1)
        floatingRateSetting FloatingRateSettingDetails (0..1) <"Details of the rate observation/calculation corresponding to the supplied rate definition and calculation period.">
        processedRateDetails FloatingRateProcessingDetails (1..1) <"Results are details of the rate treatment.">
    output:
        result FloatingAmountCalculationDetails (1..1) <"The details of the floating rate calculation, including raw rate, rate treatment details, notional, and calculated cashflow amount.">

    alias appliedRate: processedRateDetails -> processedRate
    alias spreadExclusiveRate: processedRateDetails -> spreadExclusiveRate

    alias dcf: interestRatePayout -> dayCountFraction
    alias yearFraction: CalculateYearFraction(interestRatePayout, dcf, calculationPeriod)
    alias annualAccrual: notional * appliedRate
    alias notionalAccrual: notional * yearFraction
    alias cashflow: notionalAccrual * appliedRate
    alias spreadExclusiveCashflow: notionalAccrual * spreadExclusiveRate

    // record results
    set result -> calculationPeriod: calculationPeriod
    set result -> calculationPeriodNotionalAmount -> value: notional
    set result -> calculationPeriodNotionalAmount -> unit -> currency: currency
    set result -> floatingRate:
        if floatingRateSetting exists then floatingRateSetting

    set result -> processingDetails: processedRateDetails
    set result -> appliedRate: appliedRate
    set result -> yearFraction: yearFraction
    set result -> calculatedAmount: cashflow
    set result -> spreadExclusiveCalculatedAMount: spreadExclusiveCashflow

func Create_CalculationPeriodBase: <"Create a CalculationPeriodBase type from CalculationPeriodData type.">
    inputs:
        calcPeriodData CalculationPeriodData (1..1) <"A supplied CalculationPeriodData structure.">
    output:
        calcPeriod CalculationPeriodBase (1..1) <"The corresponding CalculationPeriodBase structure.">

    set calcPeriod -> adjustedStartDate: calcPeriodData -> startDate
    set calcPeriod -> adjustedEndDate: calcPeriodData -> endDate

//-------------------------------------------------------
// The following functions look up current notional
//-------------------------------------------------------
func GetNotionalAmount: <"Look up the notional amount in effect for a calculation period.">
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the notional.">
    output:
        notional Money (1..1) <"The notional that is in effect starting from the adjustedPeriodStartDate.">

    set notional -> value: <"Look up and return the notional from the notional schedule.">
        GetQuantityScheduleStepValues(
                interestRatePayout -> priceQuantity -> quantitySchedule,
                calculationPeriod -> adjustedStartDate
            )
            last
    set notional -> unit -> currency:
        interestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency

func GetQuantityScheduleStepValues: <"Find all schedule step values whose stepDate is before or equal to the supplied periodStartDate.  Returns a list of step values starting from the initial quantity value, to the last step value before the periodStartDate.">
    inputs:
        schedule NonNegativeQuantitySchedule (1..1) <"The quantity schedule being looked up from.">
        periodStartDate date (1..1) <"The date for which the quantity is required.">
    output:
        stepValues number (0..*)

    add stepValues: <"Add initial step value.">
        schedule -> value
    add stepValues: <"Add all schedule step values whose stepDate is before or equal to the supplied periodStartDate.">
        schedule -> datedValue
            filter date <= periodStartDate
            then extract value

// -----------------------------------------------
//
// Day count and year fraction calculation
//
// -----------------------------------------------
func CalculateYearFraction: <"Calculate the year fraction for a single calculation period, by invoking the base year fraction logic">
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"The interest rate payout for which the year fraction is needed">
        dcf DayCountFractionEnum (1..1) <"The day count fraction convention to use">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the year fraction is needed">
    output:
        yearFrac number (1..1)

    // some convenience aliases to access start and end dates
    alias start: calculationPeriod -> adjustedStartDate
    alias end: calculationPeriod -> adjustedEndDate
    alias termination:
        interestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate

    // calculate the number of calculation periods in a year
    alias periodsInYear: <"Number of calculation periods in a year.">
        PeriodsInYear(
                interestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency
            )

    set yearFrac: YearFraction(dcf, start, end, termination, periodsInYear)


================================================================================
FILE: rosetta-source/src/main/rosetta/product-asset-enum.rosetta
================================================================================

namespace cdm.product.asset : <"Product concepts applicable to specific asset classes.">
version "${project.version}"

import cdm.base.*
import cdm.mapping.config.*

enum BankHolidayTreatmentEnum: <"Defines whether the bank holidays are treated as weekdays or weekends in terms of delivery profile in the context of commodity products, in particular those with peak or off-peak delivery profiles.">
    AsWeekday <"Bank holidays treated as weekdays.">
    AsWeekend <"Bank holidays treated as weekends.">

enum CompoundingMethodEnum: <"The enumerated values to specify the type of compounding, e.g. flat, straight.">
    Flat <"Flat compounding. Compounding excludes the spread. Note that the first compounding period has it's interest calculated including any spread then subsequent periods compound this at a rate excluding the spread.">
    None <"No compounding is to be applied.">
    Straight <"Straight compounding. Compounding includes the spread.">
    SpreadExclusive <"Spread Exclusive compounding.">

enum DayDistributionEnum: <"Denotes the method by which the pricing days are distributed across the pricing period.">
    All
    First
    Last
    Penultimate

enum DiscountingTypeEnum: <"The enumerated values to specify the method of calculating discounted payment amounts. This enumerations combines the FpML DiscountingTypeEnum and FraDiscountingEnum enumerations.">
    Standard <"As specified by the 2006 ISDA Definitions, Section 8.4. Discounting, paragraph (a).">
    FRA <"As specified by the 2006 ISDA Definitions, Section 8.4. Discounting, paragraph (b).">
    FRAYield <"As specified by the 2006 ISDA Definitions, Section 8.4. Discounting, paragraph (e).">
    AFMA <"As specified by the Australian Financial Markets Association (AFMA) OTC Financial Product Conventions. This discounting method should not be used for a trade documented under a legal framework where the 2006 ISDA Definitions have been incorporated.">

enum DividendAmountTypeEnum: <"The enumerated values to specify whether the dividend is paid with respect to the Dividend Period.">
    RecordAmount <"The record date for a dividend occurs during a dividend period.">
    ExAmount <"The ex-date for a dividend occurs during a dividend period.">
    PaidAmount <"The payment date for a dividend occurs during a dividend period.">
    AsSpecifiedInMasterConfirmation <"The Amount is determined as provided in the relevant Master Confirmation.">

enum DividendCompositionEnum: <"The enumerated values to specify how the composition of Dividends is to be determined.">
    EquityAmountReceiverElection <"The Equity Amount Receiver determines the composition of dividends (subject to conditions).">
    CalculationAgentElection <"The Calculation Agent determines the composition of dividends (subject to conditions).">

enum DividendDateReferenceEnum: <"The enumerated values to specify the date by reference to which the dividend will be paid.">
    AdHocDate <"The dividend date will be specified ad-hoc by the parties, typically on the dividend ex-date.">
    CashSettlementPaymentDate <"If 'Dividend Payment Date(s)' is specified in the Transaction Supplement as 'Cash Settlement Payment Date', then the Dividend Payment Date in respect of a Dividend Amount shall be the Cash Settlement Payment Date relating to the end of the Dividend Period during which the Shares commenced trading 'ex' the relevant dividend on the Exchange.">
    CashSettlePaymentDateExDiv <"If 'Dividend Payment Date(s)' is specified in the Transaction Supplement as 'Cash Settlement Payment Date – Ex Dividend'', then the Dividend Payment Date in respect of a Dividend Amount shall be the Cash Settlement Payment Date relating to the end of the Dividend Period during which the Shares commenced trading 'ex' the relevant dividend on the Exchange.">
    CashSettlePaymentDateIssuerPayment <"If 'Dividend Payment Date(s)' is specified in the Transaction Supplement as 'Cash Settlement Payment Date – Issuer Payment', then the Dividend Payment Date in respect of a Dividend Amount shall be the Cash Settlement Payment Date relating to the end of the Dividend Period during which the issuer pays the relevant dividend to a holder of record provided that in the case where the Equity Amount Payer is the party specified to be the sole Hedging Party and the Hedging Party has not received the Dividend Amount by such date, then the date falling a number of Currency Business Days as specified in the Cash Settlement Payment Date after actual receipt by the Hedging Party of the Received Ex Amount or Paid Ex Amount (as applicable).">
    CumulativeEquityExDiv <"Total of dividends which go ex, paid on next following Equity Payment Date, which is immediately following the Dividend Period during which the Shares commence trading ex-dividend on the Exchange.">
    CumulativeEquityPaid <"Total of paid dividends, paid on next following Equity Payment Date, which is immediately following the Dividend Period during which the dividend is paid by the Issuer to the holders of record of a Share.">
    CumulativeEquityExDivBeforeReset <"Total of paid dividends, paid on next following Equity Payment Date, which is immediately following the Dividend Ex Date, unless the Dividend Ex Date is between the Equity Valuation and Payment Date in which case the dividend is deferred to the following Equity Payment Date">
    CumulativeEquityPaidBeforeReset <"Total of paid dividends, paid on next following Equity Payment Date, which is immediately following the Dividend Pay Date, unless the Dividend Pay Date is between the Equity Valuation and Payment Date (not including the Valuation Date) in which case the dividend is deferred to the following Equity Payment Date">
    CumulativeEquityPaidInclReset <"Total of paid dividends, paid on next following Equity Payment Date, which is immediately following the Dividend Pay Date, unless the Dividend Pay Date is between the Equity Valuation and Payment Date (including the Valuation Date) in which case the dividend is deferred to the following Equity Payment Date">
    CumulativeInterestExDiv <"Total of dividends which go ex, paid on next following Interest Payment Date, which is immediately following the Dividend Period during which the Shares commence trading ex-dividend on the Exchange, or where the date on which the Shares commence trading ex-dividend is a Payment Date, such Payment Date.">
    CumulativeInterestPaid <"Total of paid dividends, paid on next following Interest Payment Date, which is immediately following the Dividend Period during which the dividend is paid by the Issuer to the holders of record of a Share.">
    CumulativeInterestPaidInclReset <"Total of paid dividends, paid on next following Interest Payment Date, which is immediately following the Dividend Pay Date, unless the Dividend Pay Date is between the Equity Valuation and Payment Date (including the Valuation Date) in which case the dividend is deferred to the following Interest Payment Date.">
    CumulativeInterestPaidBeforeReset <"Total of paid dividends, paid on next following Interest Payment Date, which is immediately following the Dividend Pay Date, unless the Dividend Pay Date is between the Equity Valuation and Payment Date (not including the Valuation Date) in which case the dividend is deferred to the following Interest Payment Date.">
    DividendPaymentDate <"Date on which the dividend will be paid by the issuer.">
    DividendValuationDate <"In respect of each Dividend Period, the relevant Dividend Valuation Date.">
    EquityPaymentDate <"Equity payment date of the swap.">
    ExDate <"Date on which a holder of the security is entitled to the dividend.">
    FloatingAmountPaymentDate <"If 'Dividend Payment Date(s)' is specified in the Transaction Supplement as 'Floating Amount Payment Date', then the Dividend Payment Date in respect of a Dividend Amount shall be the first Payment Date falling at least one Settlement Cycle after the date that the Shares have commenced trading 'ex' the relevant dividend on the Exchange.">
    FollowingPaymentDate <"The next payment date of the swap.">
    RecordDate <"Date on which the dividend will be recorded in the books of the paying agent.">
    SharePayment <"If 'Dividend Payment Date(s)' is specified in the Transaction Supplement as 'Share Payment', then the Dividend Payment Date in respect of a Dividend Amount shall fall on a date on or before the date that is two (or any other number that is specified in the Transaction Supplement) Currency Business Days following the day on which the Issuer of the Shares pays the relevant dividend to holders of record of the Shares.">
    TerminationDate <"Termination date of the swap.">
    TradeDate <"Trade date of the swap">
    UnwindOrEquityExDiv <"Pays a fraction of the Dividend Amount on each Unwind Trade Settlement Date which occurs after the Dividend Ex Date, until position is fully unwound OR on the next Equity Pay Date after the Dividend Pay Date. This will be whichever date comes first or a combination of both.">
    UnwindOrEquityPaid <"Pays a fraction of the Dividend Amount on each Unwind Trade Settlement Date which occurs after the Dividend Pay Date, until position is fully unwound OR on the next Equity Pay Date after the Dividend Pay Date. This will be whichever date comes first or a combination of both.">
    UnwindOrInterestExDiv <"Pays a fraction of the Dividend Amount on each Unwind Trade Settlement Date which occurs after the Dividend Ex Date, until position is fully unwound OR on the next Interest Pay Date after the Dividend Ex Date. This will be whichever date comes first or a combination of both.">
    UnwindOrInterestPaid <"Pays a fraction of the Dividend Amount on each Unwind Trade Settlement Date which occurs after the Dividend Pay Date, until position is fully unwound OR on the next Interest Pay Date after the Dividend Pay Date. This will be whichever date comes first or a combination of both.">
    UnwindExDiv <"Pays a fraction of the total on each Unwind Trade Settlement Date which occurs after the Dividend Ex Date, until trade is fully unwound.">
    UnwindPaid <"Pays a fraction of the total on each Unwind Trade Settlement Date which occurs after the Dividend Pay Date, until trade is fully unwound.">

enum DividendEntitlementEnum: <"The enumerated values to specify the date on which the receiver of the equity payout is entitled to the dividend.">
    ExDate <"Dividend entitlement is on the dividend ex-date.">
    RecordDate <"Dividend entitlement is on the dividend record date.">
        [synonym FIX_5_0_SP2 value "RecordDate"]

enum DividendPeriodEnum: <"2002 ISDA Equity Derivatives Definitions: First Period, Second Period |">
    FirstPeriod <"2002 ISDA Equity Derivatives Definitions: First Period means each period from, and including, one Cash Settlement Payment Date or Settlement Date, as the case may be, to, but excluding, the next following Cash Settlement Payment Date or Settlement Date, as the case may be, except that (i) the initial Dividend Period will commence on, and include, the Clearance System Business Day that is one Settlement Cycle following the Trade Date and (ii) the final Dividend Period will end on, but exclude, the final Cash Settlement Payment Date or Settlement Date, as the case may be.">
    SecondPeriod <"2002 ISDA Equity Derivatives Definitions: Second Period means each period from, but excluding, one Valuation Date to, and including, the next Valuation Date, except that (i) the initial Dividend Period will commence on, but exclude, the Trade Date and (ii) the final Dividend Period will end on, and include, the final Valuation Date or, in respect of a Physically-settled Forward Transaction to which Variable Obligation is not applicable, the date that is one Settlement Cycle prior to the Settlement Date.">

enum IndexAnnexSourceEnum: <"The enumerated values to specify the CDX index annex source.">
    MasterConfirmation <"As defined in the relevant form of Master Confirmation applicable to the confirmation of Dow Jones CDX indices.">
    Publisher <"As defined in the relevant form of Master Confirmation applicable to the confirmation of Dow Jones CDX indices.">

enum InterestShortfallCapEnum: <"The enumerated values to specify the interest shortfall cap, applicable to mortgage derivatives.">
    Fixed
    Variable

enum LoadTypeEnum: <"Specifies the load type of the delivery.">
    BaseLoad <"Base load">
    PeakLoad <"Peak load">
    OffPeak <"Off-peak load">
    BlockHours <"Block Hours">
    Shaped <"Shaped">
    GasDay <"Gas Day">
    Other <"Other">

enum NegativeInterestRateTreatmentEnum: <"The enumerated values to specify the method of calculating payment obligations when a floating rate is negative (either due to a quoted negative floating rate or by operation of a spread that is subtracted from the floating rate).">
    NegativeInterestRateMethod <"Negative Interest Rate Method. Per 2000 ISDA Definitions, Section 6.4 Negative Interest Rates, paragraphs (b) and (c).">
    ZeroInterestRateMethod <"Zero Interest Rate Method. Per 2000 ISDA Definitions, Section 6.4. Negative Interest Rates, paragraphs (d) and (e).">
    ZeroInterestRateExcludingSpreadMethod <"Per 2021 ISDA Definitions section 6.8.6">

enum NonCashDividendTreatmentEnum: <"The enumerated values to specify the treatment of Non-Cash Dividends.">
    PotentialAdjustmentEvent <"The treatment of any non-cash dividend shall be determined in accordance with the Potential Adjustment Event provisions.">
    CashEquivalent <"Any non-cash dividend shall be treated as a Declared Cash Equivalent Dividend.">

enum RateTreatmentEnum: <"The enumerated values to specify the methods for converting rates from one basis to another.">
    BondEquivalentYield <"Bond Equivalent Yield. Per Annex to the 2000 ISDA Definitions (June 2000 Version), Section 7.3. Certain General Definitions Relating to Floating Rate Options, paragraph (g).">
    MoneyMarketYield <"Money Market Yield. Per Annex to the 2000 ISDA Definitions (June 2000 Version), Section 7.3. Certain General Definitions Relating to Floating Rate Options, paragraph (h).">

enum ReturnTypeEnum: <"The enumerated values to specify the type of return associated the equity payout.">
    Price <"Price return, i.e. excluding dividends.">
    Total <"Total return, i.e. including dividend and price components.">

enum SettledEntityMatrixSourceEnum: <"The enumerated values to specify the relevant settled entity matrix source.">
    ConfirmationAnnex <"The Relevant Settled Entity Matrix shall be the list agreed for this purpose by the parties. The list is not included as part of the electronic confirmation.">
    NotApplicable <"The term is not applicable.">
    Publisher <"The Settled Entity Matrix published by the Index Publisher.">

enum SpreadScheduleTypeEnum: <"The enumerated values to specify a long or short spread value.">
    Long <"Represents a Long Spread Schedule. Spread schedules defined as 'Long' will be applied to Long Positions.">
    Short <"Represents a Short Spread Schedule. Spread schedules defined as 'Short' will be applied to Short Positions.">

enum RollSourceCalendarEnum: <"Used in conjunction with an exchange-based pricing source. Identifies a date source calendar from which the pricing dates and thus roll to the next contract will be based off (e.g. pricing is based on the NYMEX WTI First Nearby Futures Contract, if Future is chosen, the pricing will roll to the next futures contract on expiration, if ListedOption is chosen, the pricing will roll to the next futures contract on the Option expiration date which is three business days before the expiration of the NYMEX WTI futures contract.) Omitting this element will result in the default behavior expected with the pricing source described within the commodity element.">
    ListedOption
    Future

enum CreditSeniorityEnum: <"Seniority of debt instruments comprising the index.">
    [docReference ISDA FpML_Coding_Scheme schemeLocation "http://www.fpml.org/coding-scheme/credit-seniority"]

    Other <"Other as defined under EMIR.">
    SeniorLossAbsorbingCapacity <"Senior Loss Absorbing Capacity (RED Tier Code: SNRLAC).">
    SeniorSec <"Senior domestic (RED Tier Code: SECDOM).">
    SeniorUnSec <"Senior foreign (RED Tier Code: SNRFOR).">
    SubLowerTier2 <"Subordinate, Lower Tier 2 (RED Tier Code: SUBLT2).">
    SubTier1 <"Subordinate Tier 1 (RED Tier Code: PREFT1).">
    SubTier3 <"Subordinate, Tier 3.">
    SubUpperTier2 <"Subordinate, Upper Tier 2 (RED Tier Code: JRSUBUT2).">

enum RealisedVarianceMethodEnum: <"The contract specifies which price must satisfy the boundary condition.  Used for variance, volatility and correlation caps and floors.">

    Previous <"For a return on day T, the observed price on T-1 must be in range.">
    Last <"For a return on day T, the observed price on T must be in range.">
    Both <"For a return on day T, the observed prices on both T and T-1 must be in range">

enum FPVFinalPriceElectionFallbackEnum: <"Specifies the fallback provisions in respect to the applicable Futures Price Valuation.">

    FPVClose <"In respect of the Early Final Valuation Date, the provisions for FPV Close shall apply.">
    FPVHedgeExecution <"In respect of the Early Final Valuation Date, the provisions for FPV Hedge Execution shall apply.">

enum FinalPrincipalExchangeCalculationEnum: <"To be specified only for products that embed a redemption payment.">
    Floored <"If Floored is set then Principal Exchange takes the form: Notional Amount * Max(1, Index Final/ Index Base).">
    NonFloored <"If NonFloored is set then the Principal Exchange takes the form: Notional Amount * Index Final / Index Base.">

enum SpreadCalculationMethodEnum: <"Method by which spread is calculated. For example on an asset swap: 'ParPar' or 'Proceeds' may be the method indicated.">
    ParPar
    Proceeds


================================================================================
FILE: rosetta-source/src/main/rosetta/product-asset-floatingrate-enum.rosetta
================================================================================

namespace cdm.product.asset.floatingrate : <"Product-related, asset class-specific floating-rate index concepts, such as rate definitions ">
version "${project.version}"

enum FloatingRateIndexProcessingTypeEnum: <"This enumeration provides guidance on how to process a given floating rate index.  It's based on the ISDA Floating Rate Index information, but transforms it into the specific categories needed for calculation ">
    Screen <"These values are just looked up from the screen and applied.">
    CompoundIndex <"A published index calculated using compounding; the implied rate must be backed out.">
    OIS <"These are calculated by the calculation agent based on a standard OIS FRO definition.">
    OvernightAvg <"These are calculated by the calculation agent based on a standard overnight averaging FRO definition.">
    Modular <"These are calculated by the calculation agent based on deal-specific parameters (e.g. lookback compound based on an RFR).">
    RefBanks <"These must be looked up using a manual process">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-asset-floatingrate-func.rosetta
================================================================================

namespace cdm.product.asset.floatingrate : <"Product-related, asset class-specific floating-rate index concepts, such as rate definitions .">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.observable.asset.*
import cdm.observable.asset.calculatedrate.*
import cdm.observable.asset.fro.*
import cdm.product.asset.*
import cdm.product.asset.calculation.*
import cdm.product.common.schedule.*

//-------------------------------------------------------
// The following functions determine the type of rate and what to do for each
//-------------------------------------------------------
func DetermineFloatingRateReset: <"Get the value of a floating rate by either observing it directly or performing a rate calculation.  This function works differently depending on the rate category and style, as described in the 2021 ISDA Definitions, Section 6.6.">
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"Floating rate stream definition.">
        calcPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the rate.">
    output:
        floatingRate FloatingRateSettingDetails (1..1) <"Details of the rate observation/calculation corresonding to the supplied rate definition and calculation period.">

    // figure out the characteristics of the rate
    alias rateDef: interestRatePayout -> rateSpecification -> FloatingRateSpecification
    alias processingType: GetFloatingRateProcessingType(rateDef) // get a processing category that will be used to dermine how to process the rate, based on the rate category, style, and calculation method
    // perform the relevant operation (look up a term rate or do the rate calculation for a calculated rate)
    set floatingRate:
        ProcessFloatingRateReset(interestRatePayout, calcPeriod, processingType)

func GetFloatingRateProcessingType: <"Get a classification of  the floating rate is processed. This is based on FRO category, style, and calculation method, as described in the 2021 ISDA Definitions Section 6.6.  The categorization information is obtained from the FRO metadata. .">
    inputs:
        rateDef FloatingRateSpecification (1..1) <"Specification details of the floating rate.">
    output:
        processingType FloatingRateIndexProcessingTypeEnum (1..1) <"The processing category for the rate .">

    // is it a modular calculated rate?
    alias isCalculatedRate: rateDef -> calculationParameters exists
    // look up the floating rate option definition from the metadata
    alias floatingRateDefinition:
        FloatingRateIndexMetadata(
                rateDef -> rateOption -> FloatingRateIndex -> floatingRateIndex
            )
    alias calcDefaults: floatingRateDefinition -> calculationDefaults
    alias category: calcDefaults -> category
    alias idxStyle: calcDefaults -> indexStyle
    alias method: calcDefaults -> method

    // determine the processing category for FROs that have embedded calculations
    alias calcProcessingType:
        if (idxStyle = FloatingRateIndexStyleEnum -> CompoundedFRO and method = FloatingRateIndexCalculationMethodEnum -> OISCompound)
        then FloatingRateIndexProcessingTypeEnum -> OIS
        else if (idxStyle = FloatingRateIndexStyleEnum -> AverageFRO and method = FloatingRateIndexCalculationMethodEnum -> Average)
        then FloatingRateIndexProcessingTypeEnum -> OvernightAvg

    // determine the processing category for FROs for which we have metadata
    alias definitionProcessingType:
        if category = FloatingRateIndexCategoryEnum -> ScreenRate
        then FloatingRateIndexProcessingTypeEnum -> Screen
        else calcProcessingType

    // categorize the rates based on the floating rate specification in the payout and based on the FRO definition from the metadata and output the resulting category
    alias processingCategory:
        if (isCalculatedRate = True)
        then FloatingRateIndexProcessingTypeEnum -> Modular
        else (if floatingRateDefinition -> fro exists
        then definitionProcessingType
        else FloatingRateIndexProcessingTypeEnum -> Screen)

    // return the processing category
    set processingType: processingCategory

func ProcessFloatingRateReset: <"Entry point for the function that performs the floating rate resetting operation.  There are different variations depending on the processing type (e.g. screen rate, OIS, modular calculated rate. .">
    [codeImplementation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"Floating rate stream definition.">
        calcPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the rate.">
        processingType FloatingRateIndexProcessingTypeEnum (1..1) <"The rate processing type (e.g. Screen Rate, OIS); this drives how the resetting calculation is done. .">
    output:
        floatingRate FloatingRateSettingDetails (1..1) <"Details of the rate observation/calculation.">

func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum -> Screen): <"Evaluate the rate for a screen rate - call logic to determine how to observe the screen rate.">
    [calculation]
    // set up convenience aliases
    alias resetDates: interestRatePayout -> resetDates
    alias rateDef: interestRatePayout -> rateSpecification -> FloatingRateSpecification
    set floatingRate: EvaluateScreenRate(rateDef, resetDates, calcPeriod) // Call the screen rate evaluation logic

func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum -> Modular): <"Evaluate the rate for a modular calculated rate.  Call the calculated rate calculation logic to determine the value of the reset.">
    [calculation]
    // set up convenience aliases
    alias rateDef: interestRatePayout -> rateSpecification -> FloatingRateSpecification
    alias resetDates: interestRatePayout -> resetDates
    alias dayCount: interestRatePayout -> dayCountFraction
    alias fro: rateDef -> rateOption
    alias calcParams: rateDef -> calculationParameters

    // determine the prior calculation period corresponding to this period, in case needed.  (used for set-in-advance calculated rates and some fallback rates.)
    alias priorCalculationPeriod:
        Create_CalculationPeriodBase(
                CalculationPeriod(
                        interestRatePayout -> calculationPeriodDates,
                        calcPeriod -> adjustedStartDate
                    )
            )

    // call the calculated rate evaluation logic
    set floatingRate:
        EvaluateCalculatedRate(
                fro,
                calcParams,
                resetDates,
                calcPeriod,
                priorCalculationPeriod,
                dayCount
            )

func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum -> OIS): <"Evaluate the rate for an OIS calculated rate. Call the calculated rate calculation logic to determine the value of the reset.  See the 2021 ISDA Definitions Section 6.6.3.">
    [calculation]
    // set up convenience aliases
    alias rateDef: interestRatePayout -> rateSpecification -> FloatingRateSpecification
    alias resetDates: interestRatePayout -> resetDates
    alias dayCount: interestRatePayout -> dayCountFraction
    alias fro: rateDef -> rateOption
    // create a pseudo calculation parameters block to drive the OIS calculation
    alias calcParams:
        GetCalculatedFROCalculationParameters(
                resetDates,
                CalculationMethodEnum -> Compounding
            )

    // call the calculated rate evaluation logic to evaluate the OIS rate
    set floatingRate:
        EvaluateCalculatedRate(
                fro,
                calcParams,
                resetDates,
                calcPeriod,
                calcPeriod,
                dayCount
            )

func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum -> OvernightAvg): <"Evaluate the rate for a daily average calculated FRO. Call the calculated rate calculation logic to determine the value of the reset. See the 2021 ISDA Definitions Section 6.6.3.">
    [calculation]
    // set up convenience aliases
    alias rateDef: interestRatePayout -> rateSpecification -> FloatingRateSpecification
    alias resetDates: interestRatePayout -> resetDates
    alias dayCount: interestRatePayout -> dayCountFraction
    alias rateOption: rateDef -> rateOption
    // create a pseudo calculation parameters block to drive the averaging calculation
    alias calcParams:
        GetCalculatedFROCalculationParameters(
                resetDates,
                CalculationMethodEnum -> Averaging
            )

    // call the calculated rate evaluation logic to evaluate the daily average rate
    set floatingRate:
        EvaluateCalculatedRate(
                rateOption,
                calcParams,
                resetDates,
                calcPeriod,
                calcPeriod,
                dayCount
            )

func GetCalculatedFROCalculationParameters: <"Initialize a calculation parameters block for an OIS or a daily average rate. Used to support FROs that include an embedded calculation.">
    inputs:
        resetDates ResetDates (1..1) <"The reset dates for the interest rate payout for which the calculated rate is being computed.">
        calcMethod CalculationMethodEnum (1..1) <"Whether the rate is a compound (OIS) or daily average rate.">
    output:
        calcParams FloatingRateCalculationParameters (1..1) <"A calculation parameters block.">

    // generate and output the required type
    set calcParams -> calculationMethod: calcMethod
    set calcParams -> applicableBusinessDays: resetDates -> fixingDates -> businessCenters

func ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum -> CompoundIndex): <"Call the compounded index processing logic to calculate the reset.">

// TODO:  this will depend on exactly how FpML implements this.
//-------------------------------------------------------
// The following functions do rate reset processing for Screen Rates
//-------------------------------------------------------
func EvaluateScreenRate: <"Evaluate/lookup the value of a screen rate.">
    inputs:
        rateDef FloatingRate (1..1) <"Floating rate definition.">
        resetDates ResetDates (1..1) <"Reset dates for observing the rate.">
        calculationPeriod CalculationPeriodBase (1..1) <"Calculation period for which you want the rate.">
    output:
        details FloatingRateSettingDetails (1..1) <"Resulting details of the rate setting .">

    // figure out the date for which the rate is needed
    alias resetDate: DetermineResetDate(resetDates, calculationPeriod)
    alias fixingDate: DetermineFixingDate(resetDates, resetDate)

    // look up the rate on that date
    alias observedRate: IndexValueObservation(fixingDate, rateDef -> rateOption)
    // record relevant dates and observed rate
    set details -> resetDate: resetDate
    set details -> observationDate: fixingDate
    set details -> floatingRate: observedRate

func DetermineResetDate: <"Determine the value of the reset date given a reset dates structure and a calculation paeriod for which it's needed. Reset dates are defined in the 2021 ISDA Definition in Section 6.5.5.">
    inputs:
        resetDates ResetDates (1..1) <"Reset dates for observing the rate.">
        calculationPeriod CalculationPeriodBase (1..1) <"Calculation period for which you want the rate.">
    output:
        resetDate date (1..1) <"The date upon which the rate should be observed. .">

    // figure out the date for which the rate is needed
    alias resetRelativeTo: resetDates -> resetRelativeTo
    alias isStart: resetRelativeTo = ResetRelativeToEnum -> CalculationPeriodStartDate
    alias reset:
        if (isStart)
        then calculationPeriod -> adjustedStartDate
        else calculationPeriod -> adjustedEndDate

    set resetDate: reset

func DetermineFixingDate: <"Determine the observation (fixing) date needed given a reset dates structure and a reset date.">
    inputs:
        resetDates ResetDates (1..1) <"Reset date parameters for observing the rate.">
        resetDate date (1..1) <"The date that the rate is needed for.">
    output:
        fixingDate date (1..1) <"The date upon which the rate should be observed. .">

    alias fixingOffsetDays: resetDates -> fixingDates -> periodMultiplier
    alias businessCenters:
        GetAllBusinessCenters(resetDates -> fixingDates -> businessCenters)
    alias fixDate: AddBusinessDays(resetDate, fixingOffsetDays, businessCenters)

    set fixingDate: fixDate

// =====================================================================
//
// Rate processing and treatment functions
//
// these functions retrieve and apply processing and treatment parameters for a floating rate.
// This includes multipliers, spreads, caps/floors, rate treatment, rounding, and negative treatment.
//
// ======================================================================
//-------------------------------------------------------------
// The following functions look up processing parameters
//-------------------------------------------------------------
func GetFloatingRateProcessingParameters: <"Determine the processing parameters to use from the InterestRatePayout by looking them up if necessary from the corresponding schedules in the interest rate stream.">
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the calculation is being perfmored (needed to look up paramters).">
    output:
        processingParameters FloatingRateProcessingParameters (1..1) <"The processing parameters.">

    // look up parameters
    alias spreadRate: SpreadAmount(interestRatePayout, calculationPeriod)
    alias multiplier: MultiplierAmount(interestRatePayout, calculationPeriod)
    alias cap: CapRateAmount(interestRatePayout, calculationPeriod)
    alias floor: FloorRateAmount(interestRatePayout, calculationPeriod)

    alias rounding:
        interestRatePayout -> rateSpecification -> FloatingRateSpecification -> finalRateRounding
    alias negativeTreatment:
        interestRatePayout -> rateSpecification -> FloatingRateSpecification -> negativeInterestRateTreatment
    alias treatment:
        interestRatePayout -> rateSpecification -> FloatingRateSpecification -> rateTreatment

    set processingParameters -> initialRate:
        interestRatePayout -> rateSpecification -> FloatingRateSpecification -> initialRate
    set processingParameters -> spread: spreadRate
    set processingParameters -> multiplier: multiplier
    set processingParameters -> treatment: treatment
    set processingParameters -> capRate: cap
    set processingParameters -> floorRate: floor
    set processingParameters -> rounding: rounding
    set processingParameters -> negativeTreatment: negativeTreatment

func SpreadAmount: <"Look up the spread amount for a calculation period.">
    [calculation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the spread.">
    output:
        spread number (0..1) <"The spread value for the period.">

    set spread:
        GetRateScheduleAmount(
                interestRatePayout -> rateSpecification -> FloatingRateSpecification -> spreadSchedule,
                calculationPeriod -> adjustedStartDate
            )

func MultiplierAmount: <"Look up the multiplier amount for a calculation period.">
    [calculation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the multiplier.">
    output:
        multiplier number (0..1) <"The multiplier in effect from the calculation period start date.">

    set multiplier:
        GetRateScheduleAmount(
                interestRatePayout -> rateSpecification -> FloatingRateSpecification -> floatingRateMultiplierSchedule,
                calculationPeriod -> adjustedStartDate
            )

func CapRateAmount: <"Look up the cap rate amount for a calculation period.">
    [calculation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the cap rate.">
    output:
        capRate number (0..1) <"The cap rate in effect from the calculation period start date.">

    set capRate: <"Look up and return the rate for the period start date.">
        GetRateScheduleAmount(
                interestRatePayout -> rateSpecification -> FloatingRateSpecification -> capRateSchedule,
                calculationPeriod -> adjustedStartDate
            )

func FloorRateAmount: <"Look up the floor rate amount for a calculation period.">
    [calculation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"An interest rate stream.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which you want the floor rate.">
    output:
        floorRate number (0..1) <"The cap rate in effect from the calculation period start date.">

    set floorRate: <"Look up and return the rate for the period start date.">
        GetRateScheduleAmount(
                interestRatePayout -> rateSpecification -> FloatingRateSpecification -> floorRateSchedule,
                calculationPeriod -> adjustedStartDate
            )

func GetRateScheduleAmount: <"Get the rate for the period start date.">
    inputs:
        schedule RateSchedule (1..1) <"The rate schedule.">
        periodStartDate date (1..1) <"The start date for which you want the rate.">
    output:
        amount number (1..1)

    set amount: GetRateScheduleStepValues(schedule, periodStartDate) last

func GetRateScheduleStepValues: <"Get all rate schedule step values whose stepDate is before or equal to the supplied periodStartDate.  Returns a list of step values starting from the initial rate.">
    inputs:
        schedule RateSchedule (1..1) <"The rate schedule.">
        periodStartDate date (1..1) <"The start date for which you want the rate.">
    output:
        stepValues number (0..*)

    add stepValues: <"Add initial step value.">
        schedule -> price -> value
    add stepValues: <"Add all schedule step values whose stepDate is before or equal to the supplied periodStartDate.">
        schedule -> price -> datedValue
            filter date <= periodStartDate
            then extract value

//-------------------------------------------------------------
// The following functions apply processing parameters
//-------------------------------------------------------------
func ApplyFloatingRateProcessing: <"Perform rate treatments on floating rates, such as applying spreads, multipliers, caps and floors, rounding, and negative interest treatment. TODO: initialRate needs to be supported.  Also, to support compounding methods, it may be necessary to split the before spread and after spread values and return both, so that cashflows can be computed both ways. This may require this function to be redesigned or split into pieces (e.g. factor out the post-spread processing).  Rate treatments are described in Section 6 of the 2021 ISDA Definitions.  Negative treatment does not correctly support the case where compounded periods are applicable and will need to be enhanced for that case when compounding calculations are developed.">
    inputs:
        processing FloatingRateProcessingParameters (1..1) <"THe parameters to be used for processing, such as multipliers, spreads, cap rates, etc.">
        rawRate number (1..1) <"The floating rate prior to treatment, either a single term rate, or a calculated rate such as an OIS or lookback compounded rate.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for with the processing need to be performed.">
        isInitialPeriod boolean (1..1) <"Is this the initial calculation period of the payout?">
    output:
        details FloatingRateProcessingDetails (1..1) <"Results are details of the rate treatment.">

    // evaluate any floating rate multiplier (these are not described in the ISDA Definition but are included in FpML to support Inverse Floaters.  The multiplier typically 1 or -1 and is applied prior to other treatments.
    alias multiplier: processing -> multiplier
    alias multiplied: rawRate * multiplier
    alias multipliedRate:
        if multiplier exists then multiplied else rawRate
    // evaluate US Dollar treatments (described in Section 6.9 of the 2021 ISDA Definitions)
    alias treatedRate:
        ApplyUSRateTreatment(multipliedRate, processing -> treatment, calculationPeriod) * 1.0

    // begin evaluating the floating negative treatment, in section 5.8 of the 2021 ISDA definitions
    alias negativeTreatment: processing -> negativeTreatment
    // the following linne addresses section 6.8.6.  If the rate is negative prior to the spread, set it to 0
    alias negativeTreatedRate:
        if (negativeTreatment = NegativeInterestRateTreatmentEnum -> ZeroInterestRateExcludingSpreadMethod)
        then Max(0.0, treatedRate)
        else treatedRate

    // add spread (covered in section 6.5.4 and other places)
    alias spreadRate: processing -> spread
    alias added: negativeTreatedRate + spreadRate
    alias ratePlusSpread:
        if spreadRate exists then added else negativeTreatedRate
    // the following line addresses section 6.8.4.  If the rate is negative after the spread, set it to 0
    alias negativeTreatedRatePlusSpread:
        if (negativeTreatment = NegativeInterestRateTreatmentEnum -> ZeroInterestRateMethod)
        then Max(0.0, ratePlusSpread)
        else ratePlusSpread

    // initial rate - if the initial rate is specified and it is the initial (first) period, use the initial rate instead.  This sets up aliases to support that
    alias doInitialRate:
        if (isInitialPeriod = True and processing -> initialRate exists)
        then True
        else False
    alias initialRate: processing -> initialRate -> value
    alias initialRatePluSpread: initialRate + spreadRate
    alias initialRatePlusSpread:
        if (spreadRate exists)
        then initialRatePluSpread
        else initialRate

    // return the key inputs
    set details -> processingParameters: processing
    set details -> rawRate: rawRate

    // calculate and return the processes rate, both including and excluding the spread
    set details -> processedRate:
        if (doInitialRate = True)
        then initialRatePluSpread
        else ApplyFloatingRatePostSpreadProcessing(ratePlusSpread, processing)
    set details -> spreadExclusiveRate:
        if (doInitialRate = True)
        then initialRate
        else ApplyFloatingRatePostSpreadProcessing(negativeTreatedRate, processing)

func ApplyFloatingRatePostSpreadProcessing: <"Perform post-spread rate treatments on floating rates, such as applying caps and floors, rounding, and negative interest treatment.  TODOO:  initialRate needs to be supported.  Also, to support compounding methods, it may be necessary to split the before spread and after spread values and return both, so that cashflows can be computed both ways.  This may require this function to be redesigned or split into pieces (e.g. factor out the post-spread processing).">
    inputs:
        inputRate number (1..1) <"The floating rate prior to post-sprad, either a single term rate, or a calculated rate such as an OIS or lookback compounded rate.">
        processing FloatingRateProcessingParameters (1..1)
    output:
        processedRate number (1..1) <"rate after post-spread processing.">

    // apply any caps and floors on the rate
    alias cappedAndFlooredRate: ApplyCapsAndFloors(processing, inputRate)
    // calculate and output the rounded rate
    set processedRate: ApplyFinalRateRounding(cappedAndFlooredRate, processing -> rounding)

func ApplyCapsAndFloors: <"Apply any cap or floor rate as a constraint on a regular swap rate, as discussed in the 2021 ISDA Definitions, section 6.5.8 and 6.5.9.">
    [calculation]
    inputs:
        processing FloatingRateProcessingParameters (1..1)
        inputRate number (1..1) <"The floating rate prior to treatment, either a single term rate, or a calculated rate such as an OIS or lookback compounded rate.">
    output:
        cappedAndFlooredRate number (1..1) <"The rate after application of cap and/or floor.">

    alias cap: processing -> capRate
    alias floor: processing -> floorRate
    alias cappedRate:
        if cap exists and inputRate > cap then cap else inputRate
    alias flooredRate:
        if floor exists and cappedRate < floor
        then floor
        else cappedRate
    set cappedAndFlooredRate: flooredRate

func ApplyUSRateTreatment: <"Apply the US rate treatment logic where applicable (Bond Equivalent Yield, Money Market Yield, as described in the 2021 ISDA Definitions, section 6.9.">
    inputs:
        baseRate number (1..1) <"Rate before treatment.">
        rateTreatment RateTreatmentEnum (1..1) <"type of treatment.">
        calculationPeriod CalculationPeriodBase (1..1) <"The calculation period over which the rate is computed.">
    output:
        treatedRate number (1..1) <"rate after treatment.">

    set treatedRate: baseRate // temporary, stub definition until support is added

func ApplyFinalRateRounding: <"Apply the final rate rounding treatment logic as described in the 2021 ISDA Definitions, section 4.8.1.">
    [calculation]
    inputs:
        baseRate number (1..1) <"Rate before rounding.">
        finalRateRounding Rounding (0..1) <"type of rounding (precision and direction).">
    output:
        roundedRate number (1..1) <"rate after rounding.">

    alias precision:
        if finalRateRounding -> precision exists
        then finalRateRounding -> precision
        else 7
    alias direction:
        if finalRateRounding -> roundingDirection exists
        then finalRateRounding -> roundingDirection
        else RoundingDirectionEnum -> Nearest

    set roundedRate: RoundToPrecision(baseRate, precision, direction, False)


================================================================================
FILE: rosetta-source/src/main/rosetta/product-asset-floatingrate-type.rosetta
================================================================================

namespace cdm.product.asset.floatingrate : <"Product-related, asset class-specific floating-rate index concepts, such as rate definitions.">
version "${project.version}"

import cdm.base.math.*
import cdm.observable.asset.*
import cdm.observable.asset.calculatedrate.*
import cdm.product.asset.*
import cdm.product.common.schedule.*

// =====================================================================
//
// Floating Rate Amount Calculation Results
//
// these types are used to hold detailed results from floating amount calculations
//
// ======================================================================
type FloatingAmountCalculationDetails: <"Type for reporting the detailed results of calculating a cash flow for a calculation period.  This is enhanced relative to the FpML-based cashflows structure to allow more information to be returned about daily compounded rates.">
    calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the floating calculation was performed.">
    calculationPeriodNotionalAmount Money (1..1) <"The notional in effect during the calculation period.">
    floatingRate FloatingRateSettingDetails (0..1) <"The details of the floating rate setting.  (If it is a calculated rate, details of that calculation will be inside that.">
    processingDetails FloatingRateProcessingDetails (0..1) <"Details fo the floating rate treatment after the rate is observed or calculated.  This will include details of things like multipliers, spreads, caps and floors, and the raw and treated rates.">
    appliedRate number (1..1) <"The rate that was actually applied, after all calculations and treatments.">
    yearFraction number (1..1) <"The fraction of a year that this calculation represents, according to the day count fraction method.">
    calculatedAmount number (1..1) <"The amount of the cash flow that was computed, including any spreads and other processing.">
    spreadExclusiveCalculatedAMount number (1..1) <"The amount of the cash flow excluding any spread, for subsequent processing.">

type FloatingRateSettingDetails: <"Type for reporting the raw (untreated) observed or calculated rate for a calculation period.  If this is a calculated rate, it allows details of the observations and the resulting rate to be returned.">
    calculationDetails CalculatedRateDetails (0..1) <"Calculated rate details (observation dates, values, and weights).">
    observationDate date (0..1) <"The day upon which the rate was observed (for term rates).">
    resetDate date (0..1) <"The day for which the rate is needed (e.g. period beginning or end date).">
    floatingRate number (1..1) <"The resulting rate that was observed or calculated.">

type FloatingRateProcessingDetails: <"Type for reporting the details of the rate treatment.  This could potentially be replaced by the existing FloatingRateDefinition type , but this is slightly more detailed.">
    rawRate number (1..1) <"The raw or untreated rate, prior to any of the rate treatments.">
    processingParameters FloatingRateProcessingParameters (0..1)
    processedRate number (1..1) <"The value of the rate after processing.">
    spreadExclusiveRate number (1..1) <"The value of the processed rate without the spread applied, for subsequent compounding, etc.">

type FloatingRateProcessingParameters: <"Type to hold the processing parameters that should be or were used to calculate a floating amount.  These parameters can vary over a schedule so this type holds the acutal values applicable to this calculation.">
    initialRate Price (0..1) <"The rate to be applied for the initial period.">
    multiplier number (0..1) <"floating rate multiplier.">
    spread number (0..1) <"spread to be added to the floating rate.">
    treatment RateTreatmentEnum (0..1) <"US rate treatment (Bond Equivalent Yield or Money Market Yield, if applicable.">
    capRate number (0..1) <"capt to be applied to the floating rate.">
    floorRate number (0..1) <"floor to be applied to the floating rate.">
    rounding Rounding (0..1) <"THe final rate rounding to be applied.">
    negativeTreatment NegativeInterestRateTreatmentEnum (0..1) <"How to handle negative interest rates.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-asset-func.rosetta
================================================================================

namespace cdm.product.asset : <"Product concepts applicable to specific asset classes.">
version "${project.version}"

import cdm.base.math.*
import cdm.base.staticdata.asset.rates.*
import cdm.event.common.*
import cdm.observable.asset.*
import cdm.product.asset.calculation.*
import cdm.product.common.schedule.*
import cdm.product.template.*

func FixedAmount: <"2006 ISDA Definition Article 5 Section 5.1. Calculation of a Fixed Amount: The Fixed Amount payable by a party on a Payment Date will be: (a) if an amount is specified for the Swap Transaction as the Fixed Amount payable by that party for that Payment Date or for the related Calculation Period, that amount; or (b) if an amount is not specified for the Swap Transaction as the Fixed Amount payable by that party for that Payment Date or for the related Calculation Period, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Fixed Amount = Calculation Amount × Fixed Rate × Day Count Fraction.">
    [calculation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"description of the interest rate payout">
        notional number (0..1) <"The notional quantity to use">
        date date (0..1) <"The date to use to obtain the calculation period">
        calculationPeriodData CalculationPeriodData (0..1) <"full details of the calculation period">
    output:
        fixedAmount number (1..1)

    alias calculationPeriod:
        if calculationPeriodData exists
        then calculationPeriodData
        else CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)

    alias calcPeriodBase: Create_CalculationPeriodBase(calculationPeriod)

    alias fixedAmountCalc:
        FixedAmountCalculation(interestRatePayout, calcPeriodBase, notional)

    set fixedAmount: fixedAmountCalc -> calculatedAmount

func FloatingAmount: <"2006 ISDA Definition Article 6 Section 6.1. Calculation of a Floating Amount: Subject to the provisions of Section 6.4 (Negative Interest Rates), the Floating Amount payable by a party on a Payment Date will be: (a) if Compounding is not specified for the Swap Transaction or that party, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Floating Amount = Calculation Amount × Floating Rate + Spread × Floating Rate Day Count Fraction (b) if 'Compounding' is specified to be applicable to the Swap Transaction or that party and 'Flat Compounding' is not specified, an amount equal to the sum of the Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period; or (c) if 'Flat Compounding' is specified to be applicable to the Swap Transaction or that party, an amount equal to the sum of the Basic Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period plus the sum of the Additional Compounding Period Amounts for each such Compounding Period.">
    [calculation]
    inputs:
        interestRatePayout InterestRatePayout (1..1) <"full description of the interest rate payout">
        rate number (0..1) <"the floating rate to use; if omitted it is retrieved/calculated based on the interest rate payout and floating index ">
        notional number (0..1) <"the notional; if omitted it is obtained from the payout">
        date date (0..1) <"The date to use to obtain the calculation period">
        calculationPeriodData CalculationPeriodData (0..1) <"full details of the calculation period">
    output:
        floatingAmount number (1..1)

    alias calculationPeriod:
        if calculationPeriodData exists
        then calculationPeriodData
        else CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)
    alias calcPeriodBase: Create_CalculationPeriodBase(calculationPeriod)
    alias floatingCalc:
        FloatingAmountCalculation(interestRatePayout, calcPeriodBase, False, notional, rate)

    set floatingAmount: floatingCalc -> calculatedAmount

/* DayCountFraction has been removed and replaced by YearFraction in base-datetime-daycount-func */
func ResolveRateIndex: <"The function to specify that the floating rate index enumeration will be expressed as a number once the rate is observed.">
    [codeImplementation]
    inputs:
        index FloatingRateIndexEnum (1..1)
    output:
        rate number (1..1)

func ResolvePerformancePeriodStartPrice: <"Resolves the price from the end of the previous period. If first period, then take the initial price.">
    inputs:
        performancePayout PerformancePayout (1..1)
        price PriceSchedule (0..*)
        observable Observable (0..1)
        adjustedDate date (1..1)
    output:
        startPrice PriceSchedule (1..1)

    alias adjustedValuationDates:
        AdjustedValuationDates(performancePayout -> valuationDates)

    set startPrice: <"The initial price is taken from the original contract when Resetting for the first time i.e. when the number of updated contracts is one.">
        if adjustedDate < adjustedValuationDates first
        then performancePayout -> initialValuationPrice only-element
        else ResolveEquityInitialPrice(price)

func ResolveEquityInitialPrice: <"To be replaced by full resolve price function implementation.">
    inputs:
        price PriceSchedule (0..*)
    output:
        initialPrice PriceSchedule (0..1)

    set initialPrice:
        price
            filter perUnitOf -> financialUnit = FinancialUnitEnum -> Share
            then extract
                Price {
                    value: item -> value,
                    unit: item -> unit,
                    perUnitOf: item -> perUnitOf,
                    priceType: item -> priceType,
                    priceExpression: item -> priceExpression,
                    composite: item -> composite,
                    arithmeticOperator: item -> arithmeticOperator,
                    cashPrice: item -> cashPrice,
                    datedValue: empty
                }
            then only-element

func DividendCashSettlementAmount: <"Based on the following legal text: means, in respect of a Dividend Period and the related Dividend Cash Settlement Date, an amount in the Settlement Currency determined by the Calculation Agent for such Dividend Period to which the Dividend Cash Settlement Amount relates, pursuant to the following formula: Dividend Cash Settlement Amount = Record Amount × Number Of Securities.">
    inputs:
        numberOfSecurities number (1..1)
        declaredDividend number (1..1)
    output:
        dividendCashSettlementAmount number (1..1)

    set dividendCashSettlementAmount: declaredDividend * numberOfSecurities

func ExtractFixedLeg: <"Extract interest rate payout containing fix rate specification.">
    inputs:
        interestRatePayouts InterestRatePayout (0..*)
    output:
        fixedRatePayout InterestRatePayout (0..1)

    set fixedRatePayout:
        interestRatePayouts
            filter rateSpecification -> FixedRateSpecification exists
            then only-element


================================================================================
FILE: rosetta-source/src/main/rosetta/product-asset-type.rosetta
================================================================================

namespace cdm.product.asset : <"Product concepts applicable to specific asset classes.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.credit.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.asset.commodity.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.observable.asset.*
import cdm.observable.asset.calculatedrate.*
import cdm.observable.common.*
import cdm.observable.event.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.template.*

type CommodityPayout extends PayoutBase: <"Payout based on the averaged price of a referenced underlier. (e.g. Commodities). Can represent both average (average of many) & bullet (average of 1) pricing">
    averagingFeature AveragingCalculation (0..1) <"Indicates if the averaging calculation, when applicable, is weighted or unweighted.">
    commodityPriceReturnTerms CommodityPriceReturnTerms (0..1) <"Defines parameters in which the commodity price is assessed.">
    pricingDates PricingDates (1..1) <"Specifies specific dates or parametric rules for the dates on which the price will be determined.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    calculationPeriodDates CalculationPeriodDates (0..1) <"Defines the calculation period dates schedule.">
    paymentDates PaymentDates (1..1) <"Defines the payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
    underlier Underlier (1..1) <"Identifies the underlying product that is referenced for pricing of the applicable leg in a swap. Referenced in the '2018 ISDA CDM Equity Confirmation for Security Equity Swap' as Security.">
    fxFeature FxFeature (0..1) <"Defines quanto or composite FX features that are included in the swap leg.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition CalculationPeriod: <"The calculation periods are either specified parametrically via CalculationPeriodDates or non-parametrically via SchedulePeriod.">
        required choice schedule, calculationPeriodDates

    condition CommodityUnderlier: <"The underlier for a CommodityPayout should be a commodity.">
        if underlier -> Observable exists
        then ObservableIsCommodity(underlier -> Observable)
        else if underlier -> Product -> TransferableProduct -> economicTerms -> payout only-element -> OptionPayout exists
        then ObservableIsCommodity(
                    underlier -> Product -> TransferableProduct -> economicTerms -> payout only-element -> OptionPayout -> underlier -> Observable
                ) // Commodity Option
        else if underlier -> Product -> TransferableProduct -> economicTerms -> payout only-element -> SettlementPayout exists
        then ObservableIsCommodity(
                    underlier -> Product -> TransferableProduct -> economicTerms -> payout only-element -> SettlementPayout -> underlier -> Observable
                ) // Commodity Future
        else False

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

type AssetDeliveryInformation: <"Contains the information relative to the delivery of the asset.">
    periods AssetDeliveryPeriods (0..1) <"Defines the periods of delivery, including the delivery profile.">
    location LocationIdentifier (0..*) <"Defines the location of the delivery of the commodity.">
    deliveryCapacity Quantity (0..1) <"The number of units included in the transaction for each delivery interval">
    commodityGrade ProductGradeEnum (0..*) <"Grade of product being delivered (e.g., grade of oil).">

type AssetDeliveryPeriods: <"Defines the periods of delivery, including the delivery profile.">
    profile AssetDeliveryProfile (0..*) <"Defines the delivery profile of the asset, including the load type and the delivery intervals.">
    startDate date (0..1) <"Delivery start date">
    endDate date (0..1) <"Delivery end date">

type CalculationScheduleDeliveryPeriods extends AssetDeliveryPeriods: <"Period and time profile over which the delivery takes place.">
    deliveryCapacity Quantity (0..1) <"The number of units included in the transaction for each delivery interval">
    priceTimeIntervalQuantity Price (0..1) <"Price per quantity per delivery time interval.">

type AssetDeliveryProfile: <"Defines the delivery profile of the asset, including the load type and the delivery intervals.">
    loadType LoadTypeEnum (0..1) <"Identification of the delivery profile.">
    block AssetDeliveryProfileBlock (0..*) <"Defines a delivery profile block, including start and end time, days of the week, duration, delivery capacity and price time interval quantity.">
    bankHolidaysTreatment BankHolidayTreatmentEnum (0..1) <"Specifies whether the dates defined include holidays or not.">

type AssetDeliveryProfileBlock: <"Defines a delivery profile block, including start and end time, days of the week, duration, delivery capacity and price time interval quantity.">
    startTime time (0..1) <"The start time of the delivery interval for each block or shape.">
    endTime time (0..1) <"The end time of the delivery interval for each block or shape.">
    dayOfWeek DayOfWeekEnum (0..7) <"The days of the week of the delivery.">
    deliveryCapacity Quantity (0..1) <"The number of units included in the transaction for each delivery interval">
    priceTimeIntervalQuantity Price (0..1) <"Price per quantity per delivery time interval.">

type CreditDefaultPayout extends PayoutBase: <" The credit default payout specification provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms. The associated globalKey denotes the ability to associate a hash value to the CreditDefaultPayout instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    generalTerms GeneralTerms (1..1) <"The specification of the non-monetary terms for the Credit Derivative Transaction, including the buyer and seller and selected items from the ISDA 2014 Credit Definition article II, such as the reference obligation and related terms.">
    protectionTerms ProtectionTerms (0..*) <"Specifies the terms for calculating a payout to protect the buyer of the swap in the case of a qualified credit event. These terms include the applicable credit events, the reference obligation, and in the case of a CDS on mortgage-backed securities, the floatingAmountEvents.">
    transactedPrice TransactedPrice (0..1) <"The qualification of the price at which the contract has been transacted, in terms of market fixed rate, initial points, market price and/or quotation style. In FpML, those attributes are positioned as part of the fee leg.">

    condition FpML_cd_12: <"FpML validation rule cd-12 - If referencePrice exists, referencePrice must be greater or equal to 0">
        if generalTerms -> referenceInformation -> referencePrice exists
        then generalTerms -> referenceInformation -> referencePrice -> value >= 0

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

type GeneralTerms: <" A class specifying a set of non-monetary terms for the Credit Derivative Transaction, including the buyer and seller and selected items from the ISDA 2014 Credit Definition article II, such as the reference obligation and related terms. The CDM GeneralTerms class corresponds to the FpML GeneralTerms complex type, except that the effectiveDate and scheduledTerminationDate have been positioned as part of the InterestRatePayout class in the CDM instead of in GeneralTerms.">

    referenceInformation ReferenceInformation (0..1) <"This attribute contains all the terms relevant to defining the reference entity and reference obligation(s).">
    indexReferenceInformation CreditIndex (0..1) <"This attribute contains all the terms relevant to the underlying Index.">
    basketReferenceInformation BasketReferenceInformation (0..1) <"This attribute contains all the terms relevant to defining the Credit Default Swap Basket.">
    additionalTerm string (0..*) <"This attribute is used for representing information contained in the Additional Terms field of the 2003 Master Credit Derivatives confirm.">
        [metadata scheme]
    substitution boolean (0..1) <"Value of this attribute set to 'true' indicates that substitution is applicable.">
    modifiedEquityDelivery boolean (0..1) <"Value of this attribute set to 'true' indicates that modified equity delivery is applicable.">

    condition GeneralTermsChoice: <"Choice rule to represent an FpML choice construct.">
        required choice referenceInformation, indexReferenceInformation, basketReferenceInformation

    condition FpML_cd_41: <"FpML validation rule cd-41 - If indexReferenceInformation/tranche does not exist, then modifiedEquityDelivery must not exist.">
        if indexReferenceInformation -> tranche is absent
        then modifiedEquityDelivery is absent

    condition FpML_cd_42: <"FpML validation rule cd-42 - If basketReferenceInformation does not exist, then substitution must not exist.">
        if basketReferenceInformation is absent
        then substitution is absent

    condition BasketReferenceInformationNameOrId: <"The BasketReferenceInformation requires either a basket name or a basket identifier.">
        if basketReferenceInformation exists
        then basketReferenceInformation -> basketName exists
                or basketReferenceInformation -> basketId exists

type InterestRatePayout extends PayoutBase: <" A class to specify all of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg). The associated globalKey denotes the ability to associate a hash value to the InterestRatePayout instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    rateSpecification RateSpecification (0..1) <"The specification of the rate value(s) applicable to the contract using either a floating rate calculation, a single fixed rate, a fixed rate schedule, or an inflation rate calculation.">
    dayCountFraction DayCountFractionEnum (0..1) <"The day count fraction. The cardinality has been relaxed when compared with the FpML interest rate swap for the purpose of accommodating standardized credit default swaps which DCF is not explicitly stated as part of the economic terms. The data rule InterestRatePayout_dayCountFraction requires that the DCF be stated for interest rate products.">
        [metadata scheme]
    calculationPeriodDates CalculationPeriodDates (0..1) <"The parameters used to generate the calculation period dates schedule, including the specification of any initial or final stub calculation periods.">
    paymentDates PaymentDates (0..1) <"The payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the reset dates).">
    paymentDate AdjustableDate (0..1) <"The payment date, where only one date is specified, as for the FRA product.">
    paymentDelay boolean (0..1) <"Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a payment delay of 5 days between the coupon date of the reference obligation and the payment date of the synthetic swap. CMBS do not, on the other hand, with both payment dates being on the 25th of each month.">
    resetDates ResetDates (0..1) <"The reset dates schedule, i.e. the dates on which the new observed index value is applied for each period and the interest rate hence begins to accrue.">
    discountingMethod DiscountingMethod (0..1) <"The parameters specifying any discounting conventions that may apply. This element must only be included if discounting applies.">
    compoundingMethod CompoundingMethodEnum (0..1) <"If one or more calculation period contributes to a single payment amount this element specifies whether compounding is applicable and, if so, what compounding method is to be used. This element must only be included when more than one calculation period contributes to a single payment amount.">
    cashflowRepresentation CashflowRepresentation (0..1) <"The cashflow representation of the swap stream.">
    stubPeriod StubPeriod (0..1) <"The stub calculation period amount parameters. This element must only be included if there is an initial or final stub calculation period. Even then, it must only be included if either the stub references a different floating rate tenor to the regular calculation periods, or if the stub is calculated as a linear interpolation of two different floating rate tenors, or if a specific stub rate or stub amount has been negotiated.">
    bondReference BondReference (0..1) <"Reference to a bond underlier to represent an asset swap or Condition Precedent Bond.">
    fixedAmount calculation (0..1) <"Fixed Amount Calculation">
    floatingAmount calculation (0..1) <"Floating Amount Calculation">
    spreadCalculationMethod SpreadCalculationMethodEnum (0..1) <"Method by which spread is calculated. For example on an asset swap: 'ParPar' or 'Proceeds' may be the method indicated.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition InterestRatePayoutChoice: <"The paymentDates attributes is applicable to interest rate payouts with periodic payments, while the paymentDate reflects the FpML FRA implementation where one specific date is specified.">
        optional choice paymentDates, paymentDate

    condition FutureValueNotional: <"The BRL CDI future value notional only applies to a fixed Rate Schedule.">
        if rateSpecification -> FixedRateSpecification is absent
        then priceQuantity -> futureValueNotional is absent

    condition TerminationDate: <"FpML states that the value date associated with the future value notional should match the adjusted termination date.">
        if priceQuantity -> futureValueNotional exists
        then priceQuantity -> futureValueNotional -> valueDate = calculationPeriodDates -> terminationDate -> adjustableDate -> adjustedDate

    condition RateSpecification: <"Zero Coupon Swaps with a Known Amount are expressed without the rate specification and the known amount expressed as a price. ">
        if rateSpecification is absent
        then priceQuantity -> priceSchedule exists

    condition FpML_ird_6: <"FpML validation rule ird-6 - If paymentDates/firstPaymentDate exists, and if calculationPeriodDates/effectiveDate exists, then paymentDates/firstPaymentDate must be after calculationPeriodDates/effectiveDate/unadjustedDate.">
        if paymentDates -> firstPaymentDate exists
                and calculationPeriodDates -> effectiveDate exists
        then paymentDates -> firstPaymentDate > calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

    condition FpML_ird_23: <"FpML validation rule ird-23 - If the initialStub exists, the calculationPeriodDates element referenced by the @href attribute of stubCalculationPeriodAmount/calculationPeriodDatesReference contains firstRegularPeriodStartDate.">
        if stubPeriod -> initialStub exists
        then calculationPeriodDates -> firstRegularPeriodStartDate exists

    condition FpML_ird_24: <"FpML validation rule ird-24 - The finalStub exists if and only if the calculationPeriodDates element referenced by calculationPeriodDates/@href contains a lastRegularPeriodEndDate.">
        if stubPeriod -> finalStub exists
        then calculationPeriodDates -> lastRegularPeriodEndDate exists

    condition InitialStubFinalStub: <"Data rule to represent the FpML nested XML construct as part of StubCalculationPeriodAmount.">
        if stubPeriod exists
        then stubPeriod -> initialStub exists or stubPeriod -> finalStub exists

    condition CashSettlementTerms: <"Cash Settlements Terms must exist when the settlement currency is different to the notional currency of the trade.">
        if settlementTerms -> settlementCurrency exists
                and (settlementTerms -> settlementCurrency <> priceQuantity -> quantitySchedule -> unit -> currency
                    or settlementTerms -> settlementCurrency <> priceQuantity -> quantityMultiplier -> fxLinkedNotionalSchedule -> varyingNotionalCurrency)
        then (settlementTerms -> cashSettlementTerms -> valuationMethod exists and settlementTerms -> cashSettlementTerms -> valuationDate exists)
                or priceQuantity -> quantityMultiplier -> fxLinkedNotionalSchedule -> fxSpotRateSource exists

    condition FpML_ird_7_1: <"FpML validation rule ird-7 1/2 - The existence of compoundingMethod is prohibited when the calculation period and payment frequencies are the same.">
        if paymentDates -> paymentFrequency -> period = calculationPeriodDates -> calculationPeriodFrequency -> period
                and paymentDates -> paymentFrequency -> periodMultiplier = calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier
        then (compoundingMethod is absent or compoundingMethod = CompoundingMethodEnum -> None)

    condition FpML_ird_7_2: <"FpML validation rule ird-7 2/2 - The existence of compoundingMethod is required when the calculation period and payment frequencies differ.">
        if (paymentDates -> paymentFrequency -> period exists
                    and calculationPeriodDates -> calculationPeriodFrequency -> period exists
                    and paymentDates -> paymentFrequency -> period <> calculationPeriodDates -> calculationPeriodFrequency -> period)
                or (paymentDates -> paymentFrequency -> periodMultiplier exists
                    and calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier exists
                    and paymentDates -> paymentFrequency -> periodMultiplier <> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
        then compoundingMethod exists

    condition FpML_ird_9: <"FpML validation rule ird-9 - If calculationPeriodAmount/calculation/compoundingMethod exists, then resetDates must exist.">
        if compoundingMethod exists and compoundingMethod <> CompoundingMethodEnum -> None
        then resetDates exists

    condition FpML_ird_29: <"FpML validation rule ird-29 - If compoundingMethod exists, then fixedRateSchedule must not exist.">
        if compoundingMethod exists and compoundingMethod <> CompoundingMethodEnum -> None
        then rateSpecification -> FixedRateSpecification is absent

    condition CalculationPeriodDatesFirstCompoundingPeriodEndDate: <"FpML specifies that the firstCompoundingPeriodEndDate must only be specified when the compounding method is specified and not equal to a value of None.">
        if compoundingMethod is absent or compoundingMethod = CompoundingMethodEnum -> None
        then calculationPeriodDates -> firstCompoundingPeriodEndDate is absent

choice RateSpecification: <" A data type to specify the fixed interest rate, floating interest rate or inflation rate.">

    FixedRateSpecification <"The fixed rate or fixed rate specification expressed as explicit fixed rates and dates.">
    FloatingRateSpecification <"The floating interest rate specification, which includes the definition of the floating rate index. the tenor, the initial value, and, when applicable, the spread, the rounding convention, the averaging method and the negative interest rate treatment.">
    InflationRateSpecification <"An inflation rate calculation definition.">

type DividendPayoutRatio: <"A class describing the dividend payout ratio associated with an equity underlier. In certain cases the actual ratio is not known on trade inception, and only general conditions are then specified.">

    totalRatio number (1..1) <"Specifies the total actual dividend payout ratio associated with the equity underlier. A ratio of 90% should be expressed at 0.90.">
    cashRatio number (0..1) <"Specifies the cash actual dividend payout ratio associated with the equity underlier. A ratio of 90% should be expressed at 0.90.">
    nonCashRatio number (0..1) <"Specifies the non cash actual dividend payout ratio associated with the equity underlier. A ratio of 90% should be expressed at 0.90.">
    basketConstituent BasketConstituent (0..1) <"In the case of a basket underlier, specifies to which component of the basket this particular set of dividend payout ratios correspond.">
        [metadata address "pointsTo"=PriceQuantity->observable->Basket->basketConstituent]

    condition DividendPayoutRatioTotal: <"The dividend payout ratio should be comprised between 0 and 100%, meaning 0 and 1.">
        totalRatio >= 0 and totalRatio <= 1

    condition DividendPayoutRatioCash: <"The cash dividend payout ratio should be comprised between 0 and 100%, meaning 0 and 1.">
        if cashRatio exists then cashRatio >= 0 and totalRatio <= 1

    condition DividendPayoutRatioNonCash: <"The non cash dividend payout ratio should be comprised between 0 and 100%, meaning 0 and 1.">
        if nonCashRatio exists
        then nonCashRatio >= 0 and totalRatio <= 1

type AdditionalFixedPayments: <"A class to specify the events that will give rise to the payment additional fixed payments.">

    interestShortfallReimbursement boolean (0..1) <"An additional Fixed Payment Event. Corresponds to the payment by or on behalf of the Issuer of an actual interest amount in respect to the reference obligation that is greater than the expected interest amount. ISDA 2003 Term: Interest Shortfall Reimbursement.">
    principalShortfallReimbursement boolean (0..1) <"An additional Fixed Payment Event. Corresponds to the payment by or on behalf of the Issuer of an actual principal amount in respect to the reference obligation that is greater than the expected principal amount. ISDA 2003 Term: Principal Shortfall Reimbursement.">
    writedownReimbursement boolean (0..1) <"An Additional Fixed Payment. Corresponds to the payment by or on behalf of the issuer of an amount in respect to the reference obligation in reduction of the prior writedowns. ISDA 2003 Term: Writedown Reimbursement.">

type BasketReferenceInformation: <"CDS Basket Reference Information.">

    basketName string (0..1) <"The name of the basket expressed as a free format string. FpML does not define usage rules for this element.">
        [metadata scheme]
    basketId string (0..*) <"A CDS basket identifier.">
        [metadata scheme]
    referencePool ReferencePool (1..1) <"This element contains all the reference pool items to define the reference entity and reference obligation(s) in the basket.">
    nthToDefault int (0..1) <"N th reference obligation to default triggers payout.">
    mthToDefault int (0..1) <"M th reference obligation to default to allow representation of N th to M th defaults.">
    tranche Tranche (0..1) <"This element contains CDS tranche terms.">

    condition BasketReferenceInformationChoice: <"Choice rule to represent an FpML choice construct. This choice rule is complemented by the data rule BasketReferenceInformation_nthToDefault to represent the FpML construct where there is a choice between a tranche element and a [required nthToDefault, optional mthToDefault] branch.">
        required choice nthToDefault, tranche

    condition NthToDefault: <"As part of the branch of the choice node, FpML requires the nthToDefault element to be present, while the mthToDefault one is optional.">
        if mthToDefault exists then nthToDefault exists

    condition MthToDefault: <"FpML validation rule cd-39 - Context: BasketReferenceInformation (complex type). If nthToDefault exists, and if mthToDefault exists, then nthToDefault must be less than mthToDefault.">
        if (nthToDefault exists and mthToDefault exists)
        then nthToDefault < mthToDefault

type FloatingAmountEvents: <"A class to specify the ISDA terms relating to the floating rate payment events and the implied additional fixed payments, applicable to the credit derivatives transactions on mortgage-backed securities with pay-as-you-go or physical settlement.">

    failureToPayPrincipal boolean (0..1) <"A floating rate payment event. Corresponds to the failure by the Reference Entity to pay an expected principal amount or the payment of an actual principal amount that is less than the expected principal amount. ISDA 2003 Term: Failure to Pay Principal.">
    interestShortfall InterestShortFall (0..1) <"A floating rate payment event. With respect to any Reference Obligation Payment Date, either (a) the non-payment of an Expected Interest Amount or (b) the payment of an Actual Interest Amount that is less than the Expected Interest Amount. ISDA 2003 Term: Interest Shortfall.">
    writedown boolean (0..1) <"A floating rate payment event. Results from the fact that the underlier writes down its outstanding principal amount. ISDA 2003 Term: Writedown.">
    impliedWritedown boolean (0..1) <"A floating rate payment event. Results from the fact that losses occur to the underlying instruments that do not result in reductions of the outstanding principal of the reference obligation.">
    floatingAmountProvisions FloatingAmountProvisions (0..1) <"Specifies the floating amount provisions associated with the floatingAmountEvents.">
    additionalFixedPayments AdditionalFixedPayments (0..1) <"Specifies the events that will give rise to the payment additional fixed payments.">

type FloatingAmountProvisions:

    wacCapInterestProvision boolean (0..1) <"As specified by the ISDA Supplement for use with trades on mortgage-backed securities, 'WAC Cap' means a weighted average coupon or weighted average rate cap provision (however defined in the Underlying Instruments) of the Underlying Instruments that limits, increases or decreases the interest rate or interest entitlement, as set out in the Underlying Instruments on the Effective Date without regard to any subsequent amendment The presence of the element with value set to 'true' signifies that the provision is applicable. From a usage standpoint, this provision is typically applicable in the case of CMBS and not applicable in case of RMBS trades.">
    stepUpProvision boolean (0..1) <"As specified by the ISDA Standard Terms Supplement for use with trades on mortgage-backed securities. The presence of the element with value set to 'true' signifies that the provision is applicable. If applicable, the applicable step-up terms are specified as part of that ISDA Standard Terms Supplement. From a usage standpoint, this provision is typically applicable in the case of RMBS and not applicable in case of CMBS trades.">

type InterestShortFall: <"A class to specify the interest shortfall floating rate payment event.">

    interestShortfallCap InterestShortfallCapEnum (1..1) <"Specifies the nature of the interest Shortfall cap (i.e. Fixed Cap or Variable Cap) in the case where it is applicable. ISDA 2003 Term: Interest Shortfall Cap.">
    compounding boolean (1..1)
    rateSource FloatingRateIndexEnum (0..1) <"The rate source in the case of a variable cap.">
        [metadata scheme]

type ProtectionTerms: <"A class to specify the terms for calculating a payout to protect the buyer of the swap in the case of a qualified credit event. These terms include the applicable credit events, the reference obligation, and in the case of a CDS on mortgage-backed securities, the floatingAmountEvents.">
    [metadata key]

    creditEvents CreditEvents (0..1) <"Specifies the applicable Credit Events that would trigger a settlement, as specified in the related Confirmation and defined in the ISDA 2014 Credit Definition article IV section 4.1.">
    obligations Obligations (0..1) <"The underlying obligations of the reference entity on which you are buying or selling protection. The credit events Failure to Pay, Obligation Acceleration, Obligation Default, Restructuring, Repudiation/Moratorium are defined with respect to these obligations.">
    floatingAmountEvents FloatingAmountEvents (0..1) <"This element contains the ISDA terms relating to the floating rate payment events and the implied additional fixed payments, applicable to the credit derivatives transactions on mortgage-backed securities with pay-as-you-go or physical settlement.">

type ReferenceInformation: <"A class specifying the Credit Default Swap Reference Information.">

    referenceEntity LegalEntity (1..1) <"The corporate or sovereign entity which is subject to the swap transaction and any successor that assumes all or substantially all of its contractual and other obligations. Reference Entities cannot be senior or subordinated. It is the obligations of the Reference Entities that can be senior or subordinated. ISDA 2014 Credit definitions article II section 2.1: `Reference Entity` means the entity specified as such in the related Confirmation.">
    referenceObligation ReferenceObligation (0..*) <"The Reference Obligation is a financial instrument that is either issued or guaranteed by the reference entity. It serves to clarify the precise reference entity protection is being offered upon, and its legal position with regard to other related firms (parents/subsidiaries). Furthermore the Reference Obligation is ALWAYS deliverable and establishes the Pari Passu ranking (as the deliverable bonds must rank equal to the reference obligation). ISDA 2003 Term: Reference Obligation.">
    noReferenceObligation boolean (0..1) <"Used to indicate that there is no Reference Obligation associated with this Credit Default Swap and that there will never be one.">
    unknownReferenceObligation boolean (0..1) <"Used to indicate that the Reference obligation associated with the Credit Default Swap is currently not known. This is not valid for Legal Confirmation purposes, but is valid for earlier stages in the trade life cycle (e.g. Broker Confirmation).">
    allGuarantees boolean (0..1) <"Indicates whether an obligation of the Reference Entity, guaranteed by the Reference Entity on behalf of a non-Affiliate, is to be considered an Obligation for the purpose of the transaction. It will be considered an obligation if allGuarantees is applicable (true) and not if allGuarantees is inapplicable (false). ISDA 2003 Term: All Guarantees.">
    referencePrice Price (0..1) <"Used to determine (a) for physically settled trades, the Physical Settlement Amount, which equals the Floating Rate Payer Calculation Amount times the Reference Price and (b) for cash settled trades, the Cash Settlement Amount, which equals the greater of (i) the difference between the Reference Price and the Final Price and (ii) zero. ISDA 2003 Term: Reference Price.">
    referencePolicy boolean (0..1) <"Applicable to the transactions on mortgage-backed security, which can make use of a reference policy. Presence of the element with value set to 'true' indicates that the reference policy is applicable; absence implies that it is not.">
    securedList boolean (0..1) <"With respect to any day, the list of Syndicated Secured Obligations of the Designated Priority of the Reference Entity published by Markit Group Limited or any successor thereto appointed by the Specified Dealers (the 'Secured List Publisher') on or most recently before such day, which list is currently available at [http://www.markit.com]. ISDA 2003 Term: Relevant Secured List.">

    condition ReferenceInformationChoice: <"Choice rule to represent an FpML choice construct.">
        required choice referenceObligation, noReferenceObligation , unknownReferenceObligation

type ReferenceObligation: <"A class to specify the reference obligation that is associated with a credit derivative instrument.">
    security Security (0..1) <"Identifies the underlying asset when it is a security, such as a bond or convertible bond. The security data type requires one or more productIdentifiers, specificaiton of the security type (e.g. debt), and includes optional attributes to specify a debt class, such as asset-backed, as well as seniority.">
    loan Loan (0..1) <"Identifies the underlying asset when it is a loan.">
    primaryObligor LegalEntity (0..1) <"The entity primarily responsible for repaying debt to a creditor as a result of borrowing or issuing bonds. ISDA 2003 Term: Primary Obligor.">
    primaryObligorReference LegalEntity (0..1) <"A pointer style reference to a reference entity defined elsewhere in the document. Used when the reference entity is the primary obligor.">
        [metadata reference]
    guarantor LegalEntity (0..1) <"The party that guarantees by way of a contractual arrangement to pay the debts of an obligor if the obligor is unable to make the required payments itself. ISDA 2003 Term: Guarantor.">
    guarantorReference string (0..1) <"A pointer style reference to a reference entity defined elsewhere in the document. Used when the reference entity is the guarantor.">
    standardReferenceObligation boolean (0..1) <"Indicates if the reference obligation is a Standard Reference Obligation. ISDA 2014 Term: Standard Reference Obligation.">

    condition AssetChoice: <"Represents the choice in a CDS contract.">
        required choice security, loan

    condition MustBeDebtSecurity: <"Only debt securities can be used as the reference obligation for a credit derivative.">
        if security exists
        then security -> instrumentType = InstrumentTypeEnum -> Debt

    condition LegalEntityChoice: <"Represents the choice in a CDS contract..">
        optional choice primaryObligor, primaryObligorReference

type ReferencePair:

    referenceEntity LegalEntity (1..1) <"The corporate or sovereign entity on which you are buying or selling protection and any successor that assumes all or substantially all of its contractual and other obligations. It is vital to use the correct legal name of the entity and to be careful not to choose a subsidiary if you really want to trade protection on a parent company. Please note, Reference Entities cannot be senior or subordinated. It is the obligations of the Reference Entities that can be senior or subordinated. ISDA 2003 Term: Reference Entity.">
    referenceObligation ReferenceObligation (0..1) <"The Reference Obligation is a financial instrument that is either issued or guaranteed by the reference entity. It serves to clarify the precise reference entity protection is being offered upon, and its legal position with regard to other related firms (parents/subsidiaries). Furthermore the Reference Obligation is ALWAYS deliverable and establishes the Pari Passu ranking (as the deliverable bonds must rank equal to the reference obligation). ISDA 2003 Term: Reference Obligation.">
    noReferenceObligation boolean (0..1) <"Used to indicate that there is no Reference Obligation associated with this Credit Default Swap and that there will never be one.">
    entityType EntityTypeEnum (1..1) <"Defines the reference entity types corresponding to a list of types in the ISDA First to Default documentation.">
        [metadata scheme]

    condition ReferenceChoice: <"Choice rule to represent an FpML choice construct.">
        required choice referenceObligation, noReferenceObligation

type ReferencePool: <"This type contains all the reference pool items to define the reference entity and reference obligation(s) in the basket.">

    referencePoolItem ReferencePoolItem (1..*) <"This type contains all the constituent weight and reference information.">

    condition FpML_cd_44_openUnits: <"FpML validation rule cd-44 - All referencePoolItem/constituentWeight must have the same name of child element.">
        if referencePoolItem -> constituentWeight -> openUnits exists
        then referencePoolItem -> constituentWeight -> basketPercentage is absent

    condition FpML_cd_44_basketPercentage: <"FpML validation rule cd-44 - All referencePoolItem/constituentWeight must have the same name of child element.">
        if referencePoolItem -> constituentWeight -> basketPercentage exists
        then referencePoolItem -> constituentWeight -> openUnits is absent

type ReferencePoolItem: <"This type contains all the constituent weight and reference information.">

    constituentWeight ConstituentWeight (0..1) <"Describes the weight of each of the constituents within the basket. If not provided, it is assumed to be equal weighted.">
    referencePair ReferencePair (1..1)
    protectionTermsReference ProtectionTerms (0..1) <"Reference to the documentation terms applicable to this item.">
        [metadata reference]
    cashSettlementTermsReference CashSettlementTerms (0..1) <"Reference to the cash settlement terms applicable to this item.">
        [metadata reference]
    physicalSettlementTermsReference PhysicalSettlementTerms (0..1) <"Reference to the physical settlement terms applicable to this item.">
        [metadata reference]

    condition SettlementChoice: <"A choice rule between a reference to the cash or physical settlement terms.">
        optional choice cashSettlementTermsReference, physicalSettlementTermsReference

type SettledEntityMatrix: <"A class to specify the Relevant Settled Entity Matrix.">

    matrixSource SettledEntityMatrixSourceEnum (1..1) <"Relevant settled entity matrix source.">
        [metadata scheme]
    publicationDate date (0..1) <"Specifies the publication date of the applicable version of the matrix. When this element is omitted, the Standard Terms Supplement defines rules for which version of the matrix is applicable.">

type Tranche: <"The class to represent a CDS Tranche.">

    attachmentPoint number (1..1) <"Lower bound percentage of the loss that the Tranche can endure, expressed as a decimal. An attachment point of 5% would be represented as 0.05. The difference between Attachment and Exhaustion points is called the width of the Tranche.">
    exhaustionPoint number (1..1) <"Upper bound percentage of the loss that the Tranche can endure, expressed as a decimal. An exhaustion point of 5% would be represented as 0.05. The difference between Attachment and Exhaustion points is call the width of the Tranche.">
    incurredRecoveryApplicable boolean (0..1) <"Outstanding Swap Notional Amount is defined at any time on any day, as the greater of: (a) Zero; If Incurred Recovery Amount Applicable: (b) The Original Swap Notional Amount minus the sum of all Incurred Loss Amounts and all Incurred Recovery Amounts (if any) determined under this Confirmation at or prior to such time.Incurred Recovery Amount not populated: (b) The Original Swap Notional Amount minus the sum of all Incurred Loss Amounts determined under this Confirmation at or prior to such time.">

    condition AttachmentPoint: <"FpML definition associated with the attachmentPoint element specifies that a schema facet to constraint the value between 0 to 1 will be introduced in FpML 4.3.">
        attachmentPoint >= 0.0 and attachmentPoint <= 1.0

    condition ExhaustionPoint: <"FpML definition associated with the exhaustionPoint element specifies that a schema facet to constraint the value between 0 to 1 will be introduced in FpML 4.3.">
        exhaustionPoint >= 0.0 and exhaustionPoint <= 1.0

    condition AttachmentPointLessThanExhaustionPoint: <"FpML validation rule cd-40 - Context: Tranche (complex type) attachmentPoint must be less or equal to exhaustionPoint.">
        attachmentPoint <= exhaustionPoint

type DividendCurrency: <"A class to specify the currency in which the dividends will be denominated, i.e. either in the dividend currency or in a currency specified as part of the contract.">

    currency string (0..1) <"The currency in which the dividend is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]
    determinationMethod DeterminationMethodEnum (0..1) <"Specifies the method according to which the dividend is determined, e.g. the dividend currency.">
    currencyReference string (0..1) <"Reference to a currency specified elsewhere in the document">
        [metadata reference]

    condition:
        one-of

type DividendDateReference: <"A class to specify the dividend date by reference to another date, with the ability to apply and offset. This class doesn't exist in FpML and is meant to simplify the choice constraint associated with the DividendPaymentDate class.">

    dateReference DividendDateReferenceEnum (1..1) <"Specification of the dividend date using an enumeration, with values such as the pay date, the ex-date or the record date.">
    paymentDateOffset Offset (0..1) <"Only to be used when SharePayment has been specified in the dividendDateReference element. The number of Currency Business Days following the day on which the Issuer of the Shares pays the relevant dividend to holders of record of the Shares.">

    condition PaymentDateOffset: <" FpML specifies that paymentDateOffset is only to be used when SharePayment has been specified in the dividendDateReference element.">
        if paymentDateOffset exists
        then dateReference = DividendDateReferenceEnum -> SharePayment

type DividendPaymentDate: <"A class describing the date on which the dividend will be paid/received. This class is also used to specify the date on which the FX rate will be determined, when applicable.">

    dividendDateReference DividendDateReference (0..1)
    dividendDate AdjustableOrRelativeDate (0..1)
        [metadata reference]

    condition:
        one-of

type DividendReturnTerms: <"A class describing the conditions governing the payment of dividends to the receiver of the equity return, with the exception of the dividend payout ratio, which is defined for each of the underlying components.">

    dividendPayoutRatio DividendPayoutRatio (0..*) <"Specifies the dividend payout ratio associated with each underlier. In FpML 5.10 the payout is positioned at the underlier level, although there is an intent to reconsider this approach and position it at the leg level. This is approach adopted by the CDM.">
    dividendReinvestment boolean (0..1) <"Boolean element that defines whether the dividend will be reinvested or not.">
    dividendEntitlement DividendEntitlementEnum (0..1) <"Defines the date on which the receiver of the equity return is entitled to the dividend.">
    dividendAmountType DividendAmountTypeEnum (0..1) <"Specifies whether the dividend is paid with respect to the Dividend Period.">
    performance calculation (0..1) <"Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance'. Cumulative performance is used as a notional multiplier factor on both legs of an Equity Swap.">
    firstOrSecondPeriod DividendPeriodEnum (0..1) <"2002 ISDA Equity Derivatives Definitions: Dividend Period as either the First Period or the Second Period. | ">
    extraordinaryDividendsParty AncillaryRoleEnum (0..1) <"Specifies the party which determines if dividends are extraordinary in relation to normal levels.">
    excessDividendAmount DividendAmountTypeEnum (0..1) <"Determination of Gross Cash Dividend per Share.">
    dividendCurrency DividendCurrency (0..1) <"Specifies the currency in which the dividend will be denominated, e.g. the dividend currency, or a specified currency. This class is not specified as such in FpML, which makes use of the CurrencyAndDeterminationMethod.model to specify such terms.">
    nonCashDividendTreatment NonCashDividendTreatmentEnum (0..1) <"Specifies the treatment of Non-Cash Dividends.">
    dividendComposition DividendCompositionEnum (0..1) <"Specifies how the composition of Dividends is to be determined.">
    specialDividends boolean (0..1) <"Specifies the method according to which special dividends are determined.">
    materialDividend boolean (0..1) <"If present and true, then material non cash dividends are applicable.">
    dividendPeriod DividendPeriod (0..*) <"One to many time bounded dividend payment periods, each with a dividend payment date per period.">

    condition DividendPeriod: <"FpML specifies a choice between dividendPeriod on one end, and dividendPeriodEffectiveDate and dividendPeriodEndDate on the other end.">
        if firstOrSecondPeriod exists
        then dividendPeriod -> startDate is absent and dividendPeriod -> endDate is absent

    condition ExtraordinaryDividendsParty:
        if extraordinaryDividendsParty exists
        then extraordinaryDividendsParty = AncillaryRoleEnum -> ExtraordinaryDividendsParty

type DividendPeriod: <"Time bounded dividend payment periods, each with a dividend payment date per period.">

    startDate DividendPaymentDate (0..1) <"Dividend period start date.">
    endDate DividendPaymentDate (0..1) <"Dividend period end date.">
    dateAdjustments BusinessDayAdjustments (1..1) <"Date adjustments for all unadjusted dates in this dividend period.">
    basketConstituent BasketConstituent (0..1) <"For basket underliers, reference to the basket component which is paying dividends in the specified period.">
        [metadata address "pointsTo"=PriceQuantity->observable->Basket->basketConstituent]
    dividendPaymentDate DividendPaymentDate (1..1) <"Specifies when the dividend will be paid to the receiver of the equity return. Has the meaning as defined in the ISDA 2002 Equity Derivatives Definitions. Is not applicable in the case of a dividend reinvestment election.">
    dividendValuationDate AdjustableOrRelativeDate (0..1) <"Specifies the dividend valuation dates of the swap.">

type PriceReturnTerms:

    returnType ReturnTypeEnum (1..1) <"The type of return associated with the equity swap.">
    conversionFactor number (0..1) <"Defines the conversion applied if the quantity unit on contract is different from unit on referenced underlier.">
    performance calculation (0..1) <"Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance'. Cumulative performance is used as a notional multiplier factor on both legs of an Equity Swap.">

type ReturnTermsBase: <"Contains all common elements in variance, volatility and correlation return Terms.">

    valuationTerms ValuationTerms (1..1) <"Contains all non-date valuation information.">
    annualizationFactor int (0..1) <"This specifies the numerator of an annualization factor. Frequently this number is equal to the number of observations of prices in a year e.g. 252.">
    dividendApplicability DividendApplicability (0..1) <"The parameters which define whether dividends are applicable">
    equityUnderlierProvisions EquityUnderlierProvisions (0..1) <"Contains Equity Underlyer provisions regarding jurisdiction and fallbacks.">
    sharePriceDividendAdjustment boolean (0..1) <"Indicates whether the price of shares is adjusted for dividends or not.">
    expectedN int (1..1) <"Expected number of trading days.">
    initialLevel number (0..1) <"Contract will strike off this initial level. Providing just the initialLevel without initialLevelSource, infers that this is AgreedInitialPrice - a specified Initial Index Level.">
    initialLevelSource DeterminationMethodEnum (0..1) <"In this context, this is AgreedInitialPrice - a specified Initial Index Level.">
    meanAdjustment boolean (0..1) <"Specifies whether Mean Adjustment is applicable or not in the calculation of the Realized Volatility, Variance or Correlation">
    performance calculation (0..1) <"Performance calculation, in accordance with Part 1 Section 12 of the 2018 ISDA CDM Equity Confirmation for Security Equity Swap, Para 75. 'Equity Performance'. Cumulative performance is used as a notional multiplier factor on both legs of an Equity Swap.">

    condition InitialLevelOrInitialLevelSource: <"At least one of initialLevel and initialLevelSource must be present, or both">
        if initialLevel is absent
        then initialLevelSource exists
                and if initialLevelSource is absent
                    then initialLevel exists

    condition PositiveExpectedN: <"The number of expected trading dates must be positive">
        expectedN > 0

type VarianceReturnTerms extends ReturnTermsBase:

    varianceStrikePrice Price (0..1) <"Variance Strike Price in accordance with the ISDA 2011 Equity Derivatives Definitions.">
    volatilityStrikePrice Price (0..1) <"Volatility Strike Price in accordance with the ISDA 2011 Equity Derivatives Definitions.">
    varianceCapFloor VarianceCapFloor (0..1) <"Contains possible barriers for variance products, both variance-based and underlier price based">
    volatilityCapFloor VolatilityCapFloor (0..1) <"Contains containing volatility-based barriers">
    vegaNotionalAmount NonNegativeQuantitySchedule (0..1) <"Vega Notional represents the approximate gain/loss at maturity for a 1% difference between RVol (realised vol) and KVol (strike vol). It does not necessarily represent the Vega Risk of the trade.">
    // vegaNotionalAmount is only present here in varianceReturnTerms because it is an optional complement to the varianceAmount expressed in payoutQuantity.quantitySchedule.initialQuantity.amount.   In volatilityReturnTerms this element does not exist because the vegaNotionalAmount is compulsory and should therefore be expressed in payoutQuantity.quantitySchedule.initialQuantity.amount. in the corresponding units.
    exchangeTradedContractNearest Observable (0..1) <"Specification of the exchange traded contract nearest.">
        [metadata address "pointsTo"=PriceQuantity->observable]

    condition Positive_VegaNotionalAmount: <"When the optional vegaNotionalAmount is present in the varianceReturnTerms, it needs to have a positive value.">
        if vegaNotionalAmount -> value exists
        then vegaNotionalAmount -> value > 0

    condition UnderlierMustBeListedDerivative: <"If an exchange traded contract nearest is specified, it must have a listed derivative as underlier.">
        if exchangeTradedContractNearest exists
        then exchangeTradedContractNearest -> Asset -> Instrument -> ListedDerivative exists

    condition ReferenceContract: <"If futurePriceValuation is true, an exchange traded contract is used as a reference, therefore such contract must be specified in exchangeTradedContractNearest">
        if valuationTerms -> futuresPriceValuation = True
        then exchangeTradedContractNearest exists

    condition StrikePriceMustExist: <"The strike price must be present, but it can be expressed in either variance or volatility terms">
        required choice volatilityStrikePrice, varianceStrikePrice

    condition NonNegativeStrikePrice: <"The strike price must have a positive value">
        if volatilityStrikePrice -> value exists
        then volatilityStrikePrice -> value >= 0 and if varianceStrikePrice -> value exists
                then varianceStrikePrice -> value >= 0

type VolatilityReturnTerms extends ReturnTermsBase:

    volatilityStrikePrice Price (1..1) <"Volatility Strike Price in accordance with the ISDA 2011 Equity Derivatives Definitions.">
    volatilityCapFloor VolatilityCapFloor (0..1) <"Contains volatility-based barriers">
    exchangeTradedContractNearest ListedDerivative (0..1) <"Specification of the exchange traded contract nearest.">

type CorrelationReturnTerms extends ReturnTermsBase:

    correlationStrikePrice Price (1..1) <"Correlation Strike Price in accordance with the ISDA 2011 Equity Derivatives Definitions.">
    boundedCorrelation NumberRange (0..1) <"Describes correlation bounds, which form a cap and a floor on the realized correlation.">
    numberOfDataSeries int (0..1) <"Number of data series, normal market practice is that correlation data sets are drawn from geographic market areas, such as America, Europe and Asia Pacific, each of these geographic areas will have its own data series to avoid contagion.">

    condition PositiveNumberOfDataSeries: <"The number of data series must be positive">
        if numberOfDataSeries exists then numberOfDataSeries > 0

    condition CorrelationValue: <"The correlation strike price is a decimal with allowed values only between 1 and -1">
        correlationStrikePrice -> value > -1 and correlationStrikePrice -> value < 1

type ValuationTerms:
    futuresPriceValuation boolean (0..1) <"The official settlement price as announced by the related exchange is applicable, in accordance with the ISDA 2002 definitions.">
    optionsPriceValuation boolean (0..1) <"The official settlement price as announced by the related exchange is applicable, in accordance with the ISDA 2002 definitions">
    numberOfValuationDates int (0..1) <"The number of valuation dates between valuation start date and valuation end date.">
    dividendValuationDates AdjustableRelativeOrPeriodicDates (0..1) <"Specifies the dividend valuation dates of the swap.">
    fPVFinalPriceElectionFallback FPVFinalPriceElectionFallbackEnum (0..1) <"Specifies the fallback provisions for Hedging Party in the determination of the Final Price.">
    multipleExchangeIndexAnnexFallback boolean (0..1) <"For an index option transaction, a flag to indicate whether a relevant Multiple Exchange Index Annex is applicable to the transaction. This annex defines additional provisions which are applicable where an index is comprised of component securities that are traded on multiple exchanges.">
    componentSecurityIndexAnnexFallback boolean (0..1) <"For an index option transaction, a flag to indicate whether a relevant Component Security Index Annex is applicable to the transaction.">
    // valuationPriceInitial Price (0..1) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
    // valuationPriceFinal Price (0..1) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Final Price | Specifies the final valuation price of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
    condition PositiveNumberOfValuationDates: <"The number of valuation dates must be positive.">
        if numberOfValuationDates exists
        then numberOfValuationDates > 0

type EquityUnderlierProvisions:
    multipleExchangeIndexAnnexFallback boolean (0..1) <"For an index option or swap transaction, a flag to indicate whether a relevant Multiple Exchange Index Annex is applicable to the transaction. This annex defines additional provisions which are applicable where an index is comprised of component securities that are traded on multiple exchanges.">
    componentSecurityIndexAnnexFallback boolean (0..1) <"For an index option or swap transaction, a flag to indicate whether a relevant Component Security Index Annex is applicable to the transaction.">
    localJurisdiction string (0..1) <"The ISO 3166 standard code for the country within which the postal address is located.">
        [metadata scheme]
    relevantJurisdiction string (0..1) <"The ISO 3166 standard code for the country within which the postal address is located.">
        [metadata scheme]

    condition ComponentSecurityOrMultipleExchange: <"If multipleExchangeIndexAnnexFallback is present then componentSecurityIndexAnnexFallback must be absent and vice versa.">
        optional choice multipleExchangeIndexAnnexFallback, componentSecurityIndexAnnexFallback

type VarianceCapFloor:

    varianceCap boolean (1..1) <"If present and true, then variance cap is applicable.">
    unadjustedVarianceCap number (0..1) <"For use when varianceCap is applicable. Contains the scaling factor of the Variance Cap that can differ on a trade-by-trade basis in the European market. For example, a Variance Cap of 2.5^2 x Variance Strike Price has an unadjustedVarianceCap of 2.5.">
    boundedVariance BoundedVariance (0..1) <"Conditions which bound variance. The contract specifies one or more boundary levels. These levels are expressed as prices for confirmation purposes Underlyer price must be equal to or higher than Lower Barrier is known as Up Conditional Swap Underlyer price must be equal to or lower than Upper Barrier is known as Down Conditional Swap Underlyer price must be equal to or higher than Lower Barrier and must be equal to or lower than Upper Barrier is known as Barrier Conditional Swap.">

    condition PositiveUnadjustedVarianceCap: <"Unadjusted variance cap must be positive">
        if unadjustedVarianceCap exists then unadjustedVarianceCap > 0

    condition CapFloorApplicability: <"Caps/floors can and must be specified if varianceCap is set to true. If false, barriers cannot be established">
        if varianceCap = True
        then unadjustedVarianceCap exists or boundedVariance exists // If CapFloor is applicable at least one cap expression must exist
        else unadjustedVarianceCap is absent and boundedVariance is absent // If CapFloor is not applicable, then there cannot be any volatility caps

type BoundedVariance:

    realisedVarianceMethod RealisedVarianceMethodEnum (1..1) <"The contract specifies which price must satisfy the boundary condition.">
    daysInRangeAdjustment boolean (1..1) <"The contract specifies whether the notional should be scaled by the Number of Days in Range divided by the Expected N. The number of Days in Ranges refers to the number of returns that contribute to the realized volatility.">
    upperBarrier number (0..1) <"All observations above this price level will be excluded from the variance calculation.">
    lowerBarrier number (0..1) <"All observations below this price level will be excluded from the variance calculation.">

    condition NonNegativeBarriers: <"Barriers cannot be set to negative values">
        if upperBarrier exists
        then upperBarrier >= 0 and if lowerBarrier exists
                then lowerBarrier >= 0

type VolatilityCapFloor: <"Contains volatility-based barriers. Volatility Cap needs to be specified in accordance with the ISDA 2011 Equity Derivatives Definitions.">

    applicable boolean (1..1) <"Indicates whether the volatility cap is applicable in accordance with the ISDA 2011 Equity Derivatives Definitions. Setting the element 'applicable' to 'False' - means No Volatility Cap and no 'totalVolatilityCap' or 'volatilityCapFactor' should be provided. Setting the element 'applicable' to 'True' - means Volatility Cap election, then 'totalVolatilityCap' or 'volatilityCapFactor' should be provided, otherwise it defaults to volatilityCapFactor=2.5.">
    totalVolatilityCap number (0..1) <"Volatility Cap Amount in accordance with the ISDA 2011 Equity Derivatives Definitions. This means the Volatility Cap Amount election is a number.">
    volatilityCapFactor number (0..1) <"Volatility Cap Amount in accordance with the ISDA 2011 Equity Derivatives Definitions. The Calculated VolCapAmt can be optionally provided.">

    condition CapFloorApplicability: <"Caps/floors can and must be specified if applicable is set to true. If false, barriers cannot be established">
        if applicable = True
        then totalVolatilityCap exists or volatilityCapFactor exists // If CapFloor is applicable at least one cap expression must exist
        else totalVolatilityCap is absent and volatilityCapFactor is absent // If CapFloor is not applicable, then there cannot be any volatility caps

    condition PositiveCaps: <"Barriers must be set to positive values">
        if totalVolatilityCap exists
        then totalVolatilityCap >= 0 and if volatilityCapFactor exists
                then volatilityCapFactor >= 0

type BoundedCorrelation: <"Describes correlation bounds, which form a cap and a floor on the realized correlation.">
    minimumBoundaryPercent number (0..1) <"Minimum Boundary as a percentage of the Strike Price.">
    maximumBoundaryPercent number (0..1) <"Maximum Boundary as a percentage of the Strike Price.">

type ForeignExchange: <"From FpML: A type defining either a spot or forward FX transactions.">
    [deprecated]
    exchangedCurrency1 Cashflow (1..1) <"This is the first of the two currency flows that define a single leg of a standard foreign exchange transaction.">
    exchangedCurrency2 Cashflow (1..1) <"This is the second of the two currency flows that define a single leg of a standard foreign exchange transaction.">
    tenorPeriod Period (0..1) <"A tenor expressed as a period type and multiplier (e.g. 1D, 1Y, etc.)">

type BondReference: <"Reference to a bond underlier to represent an asset swap or Condition Precedent Bond.">

    bond Security (1..1) <"Reference to a bond underlier.">
    conditionPrecedentBond boolean (1..1) <"To indicate whether the Condition Precedent Bond is applicable. The swap contract is only valid if the bond is issued and if there is any dispute over the terms of fixed stream then the bond terms would be used.">
    discrepancyClause boolean (0..1) <"To indicate whether the Discrepancy Clause is applicable.">
    couponRate FixedRateSpecification (0..1) <"Specifies the coupon rate (expressed in percentage) of a fixed income security or convertible bond.">

    condition BondUnderlier: <"The underlier should be a bond.">
        bond -> instrumentType = InstrumentTypeEnum -> Debt

type CashflowRepresentation: <"A data defining:  the cashflow representation of a swap trade.">

    cashflowsMatchParameters boolean (1..1) <"A true/false flag to indicate whether the cashflows match the parametric definition of the stream, i.e. whether the cashflows could be regenerated from the parameters without loss of information.">
    paymentCalculationPeriod PaymentCalculationPeriod (0..*) <"The adjusted payment date and associated calculation period parameters required to calculate the actual or projected payment amount. A list of payment calculation period elements may be ordered in the document by ascending adjusted payment date. An FpML document containing an unordered list of payment calculation periods is still regarded as a conformant document.">

type DiscountingMethod: <"A data defining:  discounting information. The 2000 ISDA definitions, section 8.4. discounting (related to the calculation of a discounted fixed amount or floating amount) apply. This type must only be included if discounting applies.">

    discountingType DiscountingTypeEnum (1..1) <"The discounting method that is applicable.">
    discountRate number (0..1) <"A discount rate, expressed as a decimal, to be used in the calculation of a discounted amount. A discount amount of 5% would be represented as 0.05.">
    discountRateDayCountFraction DayCountFractionEnum (0..1) <"A discount day count fraction to be used in the calculation of a discounted amount.">
        [metadata scheme]

    condition DiscountRate: <"In FpML discountingRate and discountRateDayCountFraction are part of an optional node, with discountingRate as the required element as part of that node.">
        if discountRateDayCountFraction exists
        then discountRate exists

type FloatingRateDefinition: <"A data defining:  parameters associated with a floating rate reset. This data forms:  part of the cashflows representation of a stream.">

    calculatedRate number (0..1) <"The final calculated rate for a calculation period after any required averaging of rates A calculated rate of 5% would be represented as 0.05.">
    rateObservation RateObservation (0..*) <"The details of a particular rate observation, including the fixing date and observed rate. A list of rate observation elements may be ordered in the document by ascending adjusted fixing date. An FpML document containing an unordered list of rate observations is still regarded as a conformant document.">
    floatingRateMultiplier number (0..1) <"A rate multiplier to apply to the floating rate. The multiplier can be a positive or negative decimal. This element should only be included if the multiplier is not equal to 1 (one).">
    spread number (0..1) <"The ISDA Spread, if any, which applies for the calculation period. The spread is a per annum rate, expressed as a decimal. For purposes of determining a calculation period amount, if positive the spread will be added to the floating rate and if negative the spread will be subtracted from the floating rate. A positive 10 basis point (0.1%) spread would be represented as 0.001.">
    capRate Strike (0..*) <"The cap rate, if any, which applies to the floating rate for the calculation period. The cap rate (strike) is only required where the floating rate on a swap stream is capped at a certain strike level. The cap rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A cap rate of 5% would be represented as 0.05.">
    floorRate Strike (0..*) <"The floor rate, if any, which applies to the floating rate for the calculation period. The floor rate (strike) is only required where the floating rate on a swap stream is floored at a certain strike level. The floor rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. The floor rate of 5% would be represented as 0.05.">

    condition FloatingRateMultiplier: <"FpML specifies that the floatingRateMultiplier should only be included if different from 1.">
        if floatingRateMultiplier exists
        then floatingRateMultiplier <> 1

type InflationRateSpecification extends FloatingRateSpecification: <"A data to:  specify the inflation rate.">

    inflationLag Offset (1..1) <"An off-setting period from the payment date which determines the reference period for which the inflation index is observed.">
    indexSource string (1..1) <"The reference source such as Reuters or Bloomberg. FpML specifies indexSource to be of type rateSourcePageScheme, but without specifying actual values.">
        [metadata scheme]
    mainPublication string (1..1) <"The current main publication source such as relevant web site or a government body. FpML specifies mainPublication to be of type mainPublicationSource, but without specifying actual values.">
        [metadata scheme]
    interpolationMethod InterpolationMethodEnum (1..1) <"The method used when calculating the Inflation Index Level from multiple points. The most common is Linear.">
        [metadata scheme]
    initialIndexLevel number (0..1) <"Initial known index level for the first calculation period.">
    fallbackBondApplicable boolean (1..1) <"The applicability of a fallback bond as defined in the 2006 ISDA Inflation Derivatives Definitions, sections 1.3 and 1.8.">
    calculationMethod InflationCalculationMethodEnum (0..1) <"Indicates how to use the inflation index to calculate the payment (e.g. Ratio, Return, Spread). Added for Inflation Asset Swap">
    calculationStyle InflationCalculationStyleEnum (0..1) <"Indicates the style of how the inflation index calculates the payment (e.g. YearOnYear, ZeroCoupon).">
    finalPrincipalExchangeCalculation FinalPrincipalExchangeCalculationEnum (0..1) <"To be specified only for products that embed a redemption payment.">

    condition InflationIndex:
        rateOption -> InflationIndex exists

type FloatingRateBase: <"A class defining a floating interest rate through the specification of the floating rate index, the tenor, the multiplier schedule, the spread, the qualification of whether a specific rate treatment and/or a cap or floor apply.">
    [metadata key]

    rateOption InterestRateIndex (0..1)
        [metadata address "pointsTo"=Observable->Index->InterestRateIndex]
    spreadSchedule SpreadSchedule (0..1) <"The ISDA Spread or a Spread schedule expressed as explicit spreads and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The spread is a per annum rate, expressed as a decimal. For purposes of determining a calculation period amount, if positive the spread will be added to the floating rate and if negative the spread will be subtracted from the floating rate. A positive 10 basis point (0.1%) spread would be represented as 0.001.">
    capRateSchedule StrikeSchedule (0..1) <"The cap rate or cap rate schedule, if any, which applies to the floating rate. The cap rate (strike) is only required where the floating rate on a swap stream is capped at a certain level. A cap rate schedule is expressed as explicit cap rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The cap rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A cap rate of 5% would be represented as 0.05.">
    floorRateSchedule StrikeSchedule (0..1) <"The floor rate or floor rate schedule, if any, which applies to the floating rate. The floor rate (strike) is only required where the floating rate on a swap stream is floored at a certain strike level. A floor rate schedule is expressed as explicit floor rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The floor rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A floor rate of 5% would be represented as 0.05.">

type FloatingRate extends FloatingRateBase:
    floatingRateMultiplierSchedule RateSchedule (0..1) <"A rate multiplier or multiplier schedule to apply to the floating rate. A multiplier schedule is expressed as explicit multipliers and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in the calculationPeriodDatesAdjustments. The multiplier can be a positive or negative decimal. This element should only be included if the multiplier is not equal to 1 (one) for the term of the stream.">
    rateTreatment RateTreatmentEnum (0..1) <"The specification of any rate conversion which needs to be applied to the observed rate before being used in any calculations. The two common conversions are for securities quoted on a bank discount basis which will need to be converted to either a Money Market Yield or Bond Equivalent Yield. See the Annex to the 2000 ISDA Definitions, Section 7.3. Certain General Definitions Relating to Floating Rate Options, paragraphs (g) and (h) for definitions of these terms.">
    calculationParameters FloatingRateCalculationParameters (0..1) <"Support for modular calculated rates, such such as lockout compound calculations.">
    fallbackRate FallbackRateParameters (0..1) <"Definition of any fallback rate that may be applicable.">

type FloatingRateSpecification extends FloatingRate: <"A class to specify the floating interest rate by extending the floating rate definition with a set of attributes that specify such rate: the initial value specified as part of the trade, the rounding convention, the averaging method and the negative interest rate treatment.">

    initialRate Price (0..1) <"The initial floating rate reset agreed between the principal parties involved in the trade. This is assumed to be the first required reset rate for the first regular calculation period. It should only be included when the rate is not equal to the rate published on the source implied by the floating rate index. An initial rate of 5% would be represented as 0.05.">
    finalRateRounding Rounding (0..1) <"The rounding convention to apply to the final rate used in determination of a calculation period amount.">
    averagingMethod AveragingWeightingMethodEnum (0..1) <"If averaging is applicable, this component specifies whether a weighted or unweighted average method of calculation is to be used. The component must only be included when averaging applies.">
    negativeInterestRateTreatment NegativeInterestRateTreatmentEnum (0..1) <"The specification of any provisions for calculating payment obligations when a floating rate is negative (either due to a quoted negative floating rate or by operation of a spread that is subtracted from the floating rate).">

type FixedRateSpecification: <"Type defining the specification for a fixed rate.">
    [metadata key]
    rateSchedule RateSchedule (0..1) <"The fixed rate or fixed rate schedule expressed as explicit fixed rates and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">

type FutureValueAmount: <"A class defining a currency and a future value date.">
    quantity NonNegativeQuantitySchedule (0..1)
        [metadata address "pointsTo"=PriceQuantity->quantity]
    currency string (1..1) <"The currency in which the an amount is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]
    calculationPeriodNumberOfDays int (1..1) <"The number of days from the adjusted calculation period start date to the adjusted value date, calculated in accordance with the applicable day count fraction.">
    valueDate date (1..1) <"Adjusted value date of the future value amount.">

    condition PositiveCalculationPeriodNumberOfDays: <"FpML specifies calculationPeriodNumberOfDays as a positiveInteger.">
        calculationPeriodNumberOfDays >= 0

type SpreadSchedule extends RateSchedule: <"Adds an optional spread type element to the Schedule to identify a long or short spread value.">

    spreadScheduleType SpreadScheduleTypeEnum (0..1) <"An element which purpose is to identify a long or short spread value.">
        [metadata scheme]

type StubFloatingRate: <"A class defining a floating rate.">

    floatingRateIndex FloatingRateIndexEnum (1..1) <"The floating rate index.">
    indexTenor Period (0..1) <"The ISDA Designated Maturity, i.e. the tenor of the floating rate.">
    floatingRateMultiplierSchedule Schedule (0..1) <"A rate multiplier or multiplier schedule to apply to the floating rate. A multiplier schedule is expressed as explicit multipliers and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in the calculationPeriodDatesAdjustments. The multiplier can be a positive or negative decimal. This element should only be included if the multiplier is not equal to 1 (one) for the term of the stream.">
    spreadSchedule SpreadSchedule (0..*) <"The ISDA Spread or a Spread schedule expressed as explicit spreads and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The spread is a per annum rate, expressed as a decimal. For purposes of determining a calculation period amount, if positive the spread will be added to the floating rate and if negative the spread will be subtracted from the floating rate. A positive 10 basis point (0.1%) spread would be represented as 0.001.">
    rateTreatment RateTreatmentEnum (0..1) <"The specification of any rate conversion which needs to be applied to the observed rate before being used in any calculations. The two common conversions are for securities quoted on a bank discount basis which will need to be converted to either a Money Market Yield or Bond Equivalent Yield. See the Annex to the 2000 ISDA Definitions, Section 7.3. Certain General Definitions Relating to Floating Rate Options, paragraphs (g) and (h) for definitions of these terms.">
    capRateSchedule StrikeSchedule (0..*) <"The cap rate or cap rate schedule, if any, which applies to the floating rate. The cap rate (strike) is only required where the floating rate on a swap stream is capped at a certain level. A cap rate schedule is expressed as explicit cap rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The cap rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A cap rate of 5% would be represented as 0.05.">
    floorRateSchedule StrikeSchedule (0..*) <"The floor rate or floor rate schedule, if any, which applies to the floating rate. The floor rate (strike) is only required where the floating rate on a swap stream is floored at a certain strike level. A floor rate schedule is expressed as explicit floor rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The floor rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A floor rate of 5% would be represented as 0.05.">

type StubValue: <"A type defining how a stub calculation period amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating rate tenors many be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3 Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">

    floatingRate StubFloatingRate (0..2) <"The rates to be applied to the initial or final stub may be the linear interpolation of two different rates. While the majority of the time, the rate indices will be the same as that specified in the stream and only the tenor itself will be different, it is possible to specift two different rates. For example, a 2 month stub period may use the linear interpolation of a 1 month and 3 month rate. The different rates would be specified in this component. Note that a maximum of two rates can be specified. If a stub period uses the same floating rate index, including tenor, as the regular calculation periods then this should not be specified again within this component, i.e. the stub calculation period amount component may not need to be specified even if there is an initial or final stub period. If a stub period uses a different floating rate index compared to the regular calculation periods then this should be specified within this component. If specified here, they are likely to have id attributes, allowing them to be referenced from within the cashflows component.">
    stubRate number (0..1) <"An actual rate to apply for the initial or final stub period may have been agreed between the principal parties (in a similar way to how an initial rate may have been agreed for the first regular period). If an actual stub rate has been agreed then it would be included in this component. It will be a per annum rate, expressed as a decimal. A stub rate of 5% would be represented as 0.05.">
    stubAmount Money (0..1) <"An actual amount to apply for the initial or final stub period may have been agreed between the two parties. If an actual stub amount has been agreed then it would be included in this component.">

    condition:
        one-of

type FixedAmountCalculationDetails: <"Type for reporting the detailed results of calculating a cash flow for a calculation period.  This is enhanced relative to the FpML-based cashflows structure to allow more information to be returned about daily compounded rates.">
    calculationPeriod CalculationPeriodBase (1..1) <"The calculation period for which the floating calculation was performed.">
    calculationPeriodNotionalAmount Money (1..1) <"The notional in effect during the calculation period.">
    fixedRate number (1..1) <"The value of the fixed rate that was used.">
    yearFraction number (1..1) <"The fraction of a year that this calculation represents, according to the day count fraction method.">
    calculatedAmount number (1..1) <"The amount of the cash flow that was computed, including any spreads and other processing.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-collateral-enum.rosetta
================================================================================

namespace cdm.product.collateral
version "${project.version}"

import cdm.base.staticdata.party.*
import cdm.mapping.config.*

enum CollateralTypeEnum: <"Specifies the types of collateral that are accepted by the Lender">
    Cash <"Security Lending Trades against Cash collateral">
    NonCash <"Security Lending Trades against NonCash collateral">
    CashPool <"Security Lending Trades against CashPool collateral">

enum ConcentrationLimitTypeEnum: <"Represents the enumerated values to identify where a concentration limit is applied.">
    Asset <"Specifies a limit on a single asset in the portfolio">
    BaseCurrencyEquivalent <"Specifies a limit on all cash valued in the base currency of the portfolio.">
    Issuer <"Specifies a limit on a single issuer in the portfolio.">
    PrimaryExchange <"Specifies a limit on a single exchange in the portfolio.">
    IndustrySector <"Specifies a limit on a single industry sector in the portfolio.">
    UltimateParentInstitution <"Specifies a limit on a single issuer in the portfolio at the ultimate parent institution level.">
    IssueOutstandingAmount <"Specifies a limit of the issue compared to the outstanding amount of the asset on the market.">
    MarketCapitalisation <"Specifies a limit of the issue calculated as a percentage of the market capitalisation of the asset on the market.">

enum AverageTradingVolumeMethodologyEnum: <"Indicates the type of equity average trading volume (single) the highest amount on one exchange, or (consolidated) volumes across more than one exchange.">
    Single <"Single, the highest amount on one exchange.">
    Consolidated <"Consolidated volume across more than one exchange.">

enum CreditSupportAgreementTypeEnum: <"The enumerated values to specify the type of Credit Support Agreement governing the transaction.">
    CreditSupportDeed <"A Credit Support Deed legal agreement.">
    CreditSupportAnnex <"A Credit Support Annex legal agreement.">
        [synonym AcadiaSoft_AM_1_0 value "CSA"]
    CollateralTransferAgreement <"A Collateral Transfer Agreement">

type ContactElection: <"A class to specify the parties' election to specify contact information, in relation to elections such as the Addresses for Transfer or the Demand and Notices as specified in the ISDA Credit Support Annex agreement.">
    partyElection PartyContactInformation (2..2) <"The parties' contact information election.">

enum AlternativeToInterestAmountEnum: <"If there is an alternative to interest amounts, how is it specified?">
    Standard <"Interest amount is not transferred if transfer would create or increase a delivery amount.">
    ActualAmountReceived <"The standard calculation of the Interest Amount is replaced with the amount of interest the secured party actually receives in relation to the Cash collateral.">
    TransferIfDeliveryAmountBelowMTA <"Interest amount is not transferred if transfer would create or increase a delivery amount. (This is the 'Standard' provision). However, interest Amount will be transferred if Delivery Amount is below Minimum Transfer Amount.">
    Other <"An other alternative option outside these choices that can be described as an alternative provision.">

enum CollateralInterestHandlingEnum: <"How is collateral interest to be handled?">
    Transfer <" Transfer the interest each period ">
    Adjust <" Adjust the collateral balance to include the interest amount ">
    Transfer_or_Adjust <" Transfer the interest if it meets certain criteria, or otherwise adjust the collateral balance to reflect the interest amount  ">

enum DeliveryAmountElectionEnum: <"The enumerated values to specify the application of Interest Amount with respect to the Delivery Amount through standard language.">
    LastLocalBusinessDay <"The delivery only includes `Transfer on last Local Business Day.">
    LastAndAnyLocalBusinessDay <"The delivery includes both `Transfer on last Local Business Day` and `Transfer a Delivery Amount (IM) consisting of cash on any Local Business Day.`">

enum CollateralMarginTypeEnum: <"The enumerated values to specify the type of margin for which a legal agreement is named.">
    VariationMargin <"Denotes a margin agreement that is identified for use with Variation Margin/VM.">
    InitialMargin <"Denotes a margin agreement that is identified for use with Initial Margin/IM.">

enum RatingPriorityResolutionEnum: <"Represents an enumeration list to identify which Collateral Criteria type should have priority over others. If set to 'Issuer', the rating in the 
Issuer Criteria has priority or is used if there is no Asset criteria. If set to 'Asset', the rating in the Asset Criteria has priority or is used if there is no Issuer rating.">
    Issuer <"Denotes that the Issuer Criteria has priority.">
    Asset <"Denotes that the Asset Criteria has priority.">
    Lowest <"Denotes that lowest rating should be used if several criteria apply.">
    Highest <"Denotes that highest rating should be used if several criteria apply.">
    Average <"Denotes that average rating should be used if several criteria apply.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-collateral-func.rosetta
================================================================================

namespace cdm.product.collateral
version "${project.version}"

import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.party.*
import cdm.product.template.*

// New functions added to ease the creation of Collateral Criteria
func CloneEligibleCollateralWithChangedTreatment: <"Creates a new Eligible Collateral Specification based on an input specification but with one changed criteria and with one changed treatment.">
    inputs:
        inputSpecification EligibleCollateralSpecification (1..1)
        changedCriteria CollateralCriteria (1..1)
        changedTreatment CollateralTreatment (1..1)
    output:
        outputSpecification EligibleCollateralSpecification (1..1)

    condition NoLogicApplied:
        changedCriteria -> AllCriteria is absent
            and changedCriteria -> AnyCriteria is absent
            and changedCriteria -> NegativeCriteria is absent

    set outputSpecification: inputSpecification
    set outputSpecification -> criteria -> treatment: changedTreatment
    set outputSpecification -> criteria -> collateralCriteria: changedCriteria

func CreateAndCriteria: <"Combines multiple CollateralCriteria together using AND logic.">
    inputs:
        inputCriteria CollateralCriteria (2..*)
    output:
        outputCriteria CollateralCriteria (1..1)

    set outputCriteria -> AllCriteria -> allCriteria: inputCriteria

func CreateOrCriteria: <"Combines multiple CollateralCriteria together using OR logic.">
    inputs:
        inputCriteria CollateralCriteria (2..*)
    output:
        outputCriteria CollateralCriteria (1..1)

    set outputCriteria -> AnyCriteria -> anyCriteria: inputCriteria

// Functions to check Eligibility
func CheckEligibilityForProduct:
    [codeImplementation]
    inputs:
        specifications EligibleCollateralSpecification (1..*) <"Specifications that determine which collateral meets the eligibility and can be used/posted for delivery. For ICMA usecase - this is the basket(s). For ISDA usecase these are the Elegibility Schedule Lists.">
        product TransferableProduct (0..1)
    output:
        eligibilityResult CheckEligibilityResult (0..1)

type EligibilityQuery: <"Query to check against an EligibleCollateralSpecification">
    maturity number (1..1) <"Maturity in years">
    collateralAssetType AssetType (1..1) <"The asset product type.">
    assetCountryOfOrigin ISOCountryCodeEnum (1..1) <"The asset country of origin.">
    denominatedCurrency CurrencyCodeEnum (1..1) <"The underlying asset denominated currency.">
    agencyRating AgencyRatingCriteria (1..1) <"The agency rating based on default risk and creditors claim in event of default associated with specific instrument.">
    issuerType CollateralIssuerType (1..1) <"Represents a filter based on the type of entity issuing the asset.">
    issuerName LegalEntity (1..1) <"Specifies the issuing entity name or LEI.">

func CheckEligibilityByDetails: <"This function when presented with a set of Asset and Issuer details to be potentially posted as collateral, will check against a set of given Eligibility Criteria or Basket (EligibleCollateralSpecification) to determine which collateral meets the eligibility and can be used/posted for delivery.">
    inputs:
        specification EligibleCollateralSpecification (1..1) <"Specifications that determine which collateral meets the eligibility and can be used/posted for delivery. For ICMA usecase - this is the basket(s). For ISDA usecase these are the Eligibility Schedule Lists.">
        query EligibilityQuery (1..1) <"The eligibility query defines the criteria to filter the specifications that will be used to find the eligibility result. For ICMA usecase - The asset infomation related to potential collateral available in your inventory you can use for the Repo trade. For ISDA - the questions related to the asset infomation you can post as collateral. For ICMA usecase - The issuer infomation related to the potential collateral available in your inventory you can use for the Repo trade. For ISDA - the questions related to the issuer infomation you can post as collateral.">
    output:
        eligibilityResult CheckEligibilityResult (1..1)

    // remove the criteria which have not been explicitly included
    alias filteredCriteria: specification -> criteria filter treatment -> isIncluded

    // assess all the included criteria in the specification against the query
    alias checkedCriteria:
        filteredCriteria filter CheckCriteria(item -> collateralCriteria, query)

    // specification is eligible if more than one criteria remains after evaluation
    set eligibilityResult -> isEligible: checkedCriteria count > 0
    set eligibilityResult -> eligibilityQuery: query
    set eligibilityResult -> specification: specification
    add eligibilityResult -> matchingEligibleCriteria: checkedCriteria

func CheckCriteria: <"This function takes a single criteria and evaluates it against the criteria.  This function handles the recursive use of AND and OR logic.">
    inputs:
        inputCriteria CollateralCriteria (1..1)
        query EligibilityQuery (1..1)
    output:
        isEligible boolean (1..1)

    set isEligible: False

    set isEligible:
        inputCriteria switch
            // if AND/OR logic attribute used, recurse through criteria and evaluate all
            AllCriteria then allCriteria extract CheckCriteria(item, query) then all = True,
            AnyCriteria then anyCriteria extract CheckCriteria(item, query) then any = True,
            // reverse the inclusion if NOT logic used
            NegativeCriteria then CheckCriteria(negativeCriteria, query) = False,
            // otherwise evaluate each of the Criteria variables against the query
            CollateralIssuerType then  CheckIssuerType(item, query),
            AssetType then CheckAssetType(item, query),
            IssuerCountryOfOrigin then CheckCountryOfOrigin(item -> issuerCountryOfOrigin, query),
            AssetCountryOfOrigin then CheckCountryOfOrigin(item -> assetCountryOfOrigin, query),
            CurrencyCodeEnum then CheckDenominatedCurrency(item, query),
            IssuerName then CheckIssuerName(item, query),
            IssuerAgencyRating then CheckAgencyRating(item -> issuerAgencyRating, query),
            SovereignAgencyRating then CheckAgencyRating(item -> sovereignAgencyRating, query),
            AssetAgencyRating then CheckAgencyRating(item -> assetAgencyRating, query),
            AssetMaturity then CheckMaturity(item, query),
            default False

type CheckEligibilityResult: <"Result for the CheckEligibilityByDetails and CheckEligibilityForProduct functions">
    isEligible boolean (1..1) <"a simple boolean which is set to true if the asset described in the EligibilityQuery input is eligible">
    matchingEligibleCriteria EligibleCollateralCriteria (0..*) <"if there was a match, this will be the one or more criteria that were supplied in the EligbilityCollateralSpecification which matched with the query input">
    eligibilityQuery EligibilityQuery (1..1) <"a copy of the input query that was checked against the eligible collateral specification">
    specification EligibleCollateralSpecification (1..1) <"a copy of the input EligbilityCollateralSpecification that was checked against the query">

func CheckCountryOfOrigin:
    inputs:
        countryOfOrigin ISOCountryCodeEnum (0..1)
        query EligibilityQuery (1..1)
    output:
        isEqual boolean (1..1)

    set isEqual:
        countryOfOrigin is absent or countryOfOrigin contains query -> assetCountryOfOrigin

func CheckAgencyRating:
    inputs:
        agencyRatings AgencyRatingCriteria (0..1)
        query EligibilityQuery (1..1)
    output:
        isEqual boolean (1..1)

    set isEqual:
        agencyRatings is absent
            or (agencyRatings
                then filter
                    creditNotation -> notation contains query -> agencyRating -> creditNotation -> notation
                        // then filter qualifier = query -> agencyRating -> qualifier
                then filter
                    referenceAgency is absent
                        or referenceAgency = query -> agencyRating -> referenceAgency
                then item exists
                )

func CheckAssetType:
    inputs:
        collateralAssetTypes AssetType (0..1)
        query EligibilityQuery (1..1)
    output:
        isEqual boolean (1..1)

    set isEqual:
        collateralAssetTypes is absent
            or (collateralAssetTypes
                then filter assetType = query -> collateralAssetType -> assetType
                then filter
                    debtType is absent
                        or debtType -> debtClass = query -> collateralAssetType -> debtType -> debtClass
                then filter
                    securityType is absent
                        or securityType = query -> collateralAssetType -> securityType
                then item exists
                )

func CheckDenominatedCurrency:
    inputs:
        denominatedCurrency CurrencyCodeEnum (0..1)
        query EligibilityQuery (1..1)
    output:
        isEqual boolean (1..1)

    set isEqual:
        denominatedCurrency is absent
            or denominatedCurrency contains query -> denominatedCurrency

func CheckMaturity:
    inputs:
        maturityRange AssetMaturity (0..1)
        query EligibilityQuery (1..1)
    output:
        isEqual boolean (1..1)

    alias upperBoundCheck:
        if maturityRange -> maturityRange -> upperBound -> period is absent
        then True
        else if maturityRange -> maturityRange -> upperBound -> inclusive or maturityRange -> maturityRange -> upperBound -> inclusive is absent
        then maturityRange -> maturityRange -> upperBound -> period -> periodMultiplier >= query -> maturity
        else maturityRange -> maturityRange -> upperBound -> period -> periodMultiplier > query -> maturity

    alias lowerBoundCheck:
        if maturityRange -> maturityRange -> lowerBound -> period is absent
        then True
        else if maturityRange -> maturityRange -> lowerBound -> inclusive or maturityRange -> maturityRange -> lowerBound -> inclusive is absent
        then maturityRange -> maturityRange -> lowerBound -> period -> periodMultiplier <= query -> maturity
        else maturityRange -> maturityRange -> lowerBound -> period -> periodMultiplier > query -> maturity

    set isEqual: maturityRange is absent or (upperBoundCheck and lowerBoundCheck)

func CheckIssuerName:
    inputs:
        issuerName IssuerName (0..1)
        query EligibilityQuery (1..1)
    output:
        isEqual boolean (1..1)

    set isEqual:
        issuerName is absent or issuerName -> issuerName contains query -> issuerName

func CheckIssuerType:
    inputs:
        issuerType CollateralIssuerType (0..1)
        query EligibilityQuery (1..1)
    output:
        isEqual boolean (1..1)

    set isEqual: issuerType is absent or issuerType contains query -> issuerType

func CriteriaMatchesAssetType:
    inputs:
        inputCriteria CollateralCriteria (0..1)
        assetType InstrumentTypeEnum (0..1)
    output:
        matches boolean (1..1)

    set matches: False

    set matches:
        inputCriteria switch
            AssetType then securityType = assetType,
            AllCriteria then allCriteria extract CriteriaMatchesAssetType(item, assetType) then all = True,
            AnyCriteria then anyCriteria extract CriteriaMatchesAssetType(item, assetType) then any = True,
            NegativeCriteria then CriteriaMatchesAssetType(negativeCriteria, assetType) = False,
            default False


================================================================================
FILE: rosetta-source/src/main/rosetta/product-collateral-type.rosetta
================================================================================

namespace cdm.product.collateral
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.observable.asset.*
import cdm.product.asset.FloatingRateBase
import cdm.product.common.settlement.*

type Collateral: <"A type for defining the obligations of the counterparty subject to credit support requirements.">
    [metadata key]
    independentAmount IndependentAmount (0..1) <"Independent Amount is an amount that usually less creditworthy counterparties are asked to provide. It can either be a fixed amount or a percentage of the Transaction's value. The Independent Amount can be: (i) transferred before any trading between the parties occurs (as a deposit at a third party's account or with the counterparty) or (ii) callable after trading has occurred (typically because a downgrade has occurred). In situation (i), the Independent Amount is not included in the calculation of Exposure, but in situation (ii), it is included in the calculation of Exposure. Thus, for situation (ii), the Independent Amount may be transferred along with any collateral call. Independent Amount is a defined term in the ISDA Credit Support Annex. ('with respect to a party, the amount specified as such for that party in Paragraph 13; if no amount is specified, zero').">
    portfolioIdentifier Identifier (0..*) <"A list of identifiers pointing to the collateral portfolios which contain the collateral which covers a trade.">
    collateralPortfolio CollateralPortfolio (0..*) <"The collateral portfolios which contain the collateral which covers a trade. (NB: this can be provided by reference to a global key for each CollateralPortfolio object)">
        [metadata reference]
    collateralProvisions CollateralProvisions (0..1) <"specifies the collateral provisions of the product.">

    condition CollateralExists: <"Collateral must represent either a simple independent amount or full collateral portfolio.">
        independentAmount exists or collateralPortfolio exists

    condition CollateralProvisions: <"When a collateral portfolio is provided, collateral provisions must exists that govern this collateral.">
        if collateralPortfolio exists then collateralProvisions exists

    condition Collateralchoice:
        optional choice independentAmount, portfolioIdentifier, collateralPortfolio

type CollateralProvisions: <"Contains collateral attributes which can also inherit information from a GMRA">

    collateralType CollateralTypeEnum (1..1) <"Enumerates the collateral types which are accepted by the Seller.">
        [docReference ICMA GMRA namingConvention "marginType"]
    eligibleCollateral EligibleCollateralCriteria (0..*) <"The eligible collateral as specified in relation to the transaction.">
    substitutionProvisions SubstitutionProvisions (0..1) <"The provisions for collateral substitutions such as how many and when they are allowed.">

type SubstitutionProvisions: <"Defines collateral substitution provisions such as how many and with how much notice are substitutions allowed.">

    numberOfSubstitutionsAllowed int (0..1) <"Specifies if 1 or more substitutions are allowed.">
    noticeDeadlinePeriod Period (0..1) <"Defines the min period for notify of a substitution.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">

type IndependentAmount extends PartyReferencePayerReceiver: <"A class specifying the Independent Amount as the combination of a payer/receiver, a payment amount, a payment date and an associated payment calculation rule.">

    paymentDetail PaymentDetail (1..*) <"An attribute that specifies a payment as the combination of a payment amount, a payment date and an associated payment calculation rule.">

type AgencyRatingCriteria: <"Represents a class to specify a credit notation.">

    creditNotation CreditNotation (1..1) <"Indicates the agency rating criteria specified for the asset or issuer.">
    mismatchResolution CreditNotationMismatchResolutionEnum (0..1) <"Indicator for options to be used if several agency ratings (>1) are specified and its necessary to identify specific charateristics. i.e (lowest or highest).">
    referenceAgency CreditRatingAgencyEnum (0..1) <"identifies the dominant reference agency if there is a missmatch and several reference agencies exsist.">
    boundary CreditNotationBoundaryEnum (0..1) <"Indicates the boundary of a credit agency rating i.e minimum or maximum.">

    condition ReferenceAgency: <"If the mismatch resolution is ReferenceAgency, ensure that the reference agency is specified.">
        if mismatchResolution = CreditNotationMismatchResolutionEnum -> ReferenceAgency
        then referenceAgency exists

type CollateralValuationTreatment: <"Specification of the valuation treatment for the specified collateral.">

    haircutPercentage number (0..1) <"Specifies a haircut percentage to be applied to the value of asset and used as a discount factor to the value of the collateral asset,expressed as a percentage in decimal terms. As an example a 0.5% haircut would be represented as a decimal number 0.005.">
        [docReference ICMA GMRA namingConvention "Haircut"
            provision "As defined in GMRA paragraph 2(xx)(B). The haircut for the relevant Securities, if any, as agreed by the parties from time to time, being a discount from the Market Value of the Securities."]
        [docReference ICMA ERCCBestPractice namingConvention "Haircut"
            provision "ERCC Guide 3.1: Initial margins and Haircuts are alternative ways to risk-adjust the value of collateral sold in a repurchase transaction in order to try to anticipate the loss of value that may be experienced if the collateral has to be liquidated following an event of default by the counterparty. Both amounts are therefore used to fix the expected liquidation value of collateral. Annex II  Glossary of repo terminology Haircut: An agreed percentage discount applied to the Market Value of collateral to fix the Purchase Price on the Purchase Date of a repo. A haircut is expressed as the percentage difference between the initial Market Value and the Purchase Price. "]
    marginPercentage number (0..1) <"Specifies a percentage value of transaction needing to be posted as collateral expressed as a valuation. As an example a 104% requirement would be represented as a decimal number 1.04.">
        [docReference ICMA GMRA namingConvention "Margin Ratio"
            provision "As defined in GMRA paragraph 2(bb). Margin Ratio, with respect to a Transaction, the Market Value of the Purchased Securities at the time when the Transaction was entered into divided by the Purchase Price (and so that, where a Transaction relates to Securities of different descriptions and the Purchase Price is apportioned by the parties among Purchased Securities of each such description, a separate Margin Ratio shall apply in respect of Securities of each such description), or such other proportion as the parties may agree with respect to that Transaction;"]
        [docReference ICMA ERCCBestPractice namingConvention "Margin Ratio"
            provision "ERCC Guide 3.1: Initial margins and Haircuts are alternative ways to risk-adjust the value of collateral sold in a repurchase transaction in order to try to anticipate the loss of value that may be experienced if the collateral has to be liquidated following an event of default by the counterparty. Both amounts are therefore used to fix the expected liquidation value of collateral. Annex II  Glossary of repo terminology: Initial margin: An agreed premium applied to the Purchase Price of a repo to determine the required Market Value of the collateral to be delivered on the Purchase Date. It is also applied each day during the term of a repo, as part of the process of Margin Maintenance, to the Repurchase Price on that day to calculate the Market Value of collateral required subsequently in order to maintain adequate collateralisation. Under the GMRA, if there is a material difference between (1) the Repurchase Price of a repo plus any initial margin and (2) the current Market Value of collateral, that repo has a Transaction Exposure. This will go into the calculation of Net Exposure, which determines if either party has the right to call for Margin Maintenance. An initial margin can be expressed either as (1) the Market Value as a percentage of the Purchase Price or (2) a ratio of the two amounts. In the GMRA, an initial margin is called a Margin Ratio and is defined as a ratio but the market tends to quote a percentage. A percentage initial margin of 100% or ratio of one means there is no initial margin. See Guide 3.2"]
    fxHaircutPercentage number (0..1) <"Specifies an FX haircut applied to a specific asset which is agreed between the parties (for example, if pledgor eligible collateral is not denominated in the termination currency or under other specified cases in collateral support documents both for initial margin and variation margin).The percentage value is expressed as the discount haircut to the value of the collateral- as an example an 8% FX haircut would be expressed as 0.08.">
    additionalHaircutPercentage number (0..1) <"Specifies a percentage value of any additional haircut to be applied to a collateral asset,the percentage value is expressed as the discount haircut to the value of the collateral- as an example a 5% haircut would be expressed as 0.05. ">

    condition HaircutPercentage: <"A data rule to validate that if a Valuation Percentage is specified it should be greater than or equal to 0 and less than 1.">
        if haircutPercentage exists
        then haircutPercentage >= 0 and haircutPercentage < 1

    condition MarginPercentage: <"A data rule to validate that if a Margin Percentage is specified it should be greater than 1.">
        if marginPercentage exists then marginPercentage >= 1

    condition FxHaircutPercentage: <"A data rule to validate that if an FX Haircut Percentage is specified it should be between 0 and less than 1.">
        if fxHaircutPercentage exists
        then fxHaircutPercentage > 0 and fxHaircutPercentage < 1

    condition AdditionalHaircutPercentage: <"A data rule to validate that if an FX Haircut Percentage is specified it should be between 0 and  less than 1.">
        if additionalHaircutPercentage exists
        then additionalHaircutPercentage > 0 and additionalHaircutPercentage < 1

    condition HaircutPercentageOrMarginPercentage: <"Choice rule requiring that either a haircut percentage or margin percentage is specified.">
        required choice haircutPercentage, marginPercentage

type EligibleCollateralSpecification: <"Represents a set of criteria used to specify eligible collateral.">
    [rootType]
    [metadata key]

    identifier Identifier (0..*) <"Specifies the identifier(s) to uniquely identify eligible collateral or a set of eligible collateral, such as a schedule or equivalant for an identity issuer.">
    party Party (0..2) <"The parties associated with the specification.">
    counterparty Counterparty (0..2) <"Specification of the roles of the counterparties to the specification.">
    criteria EligibleCollateralCriteria (1..*) <"Represents a set of criteria used to specify eligible collateral.">
    partyRole PartyRole (0..*) <"Specifies the role(s) that each of the party(s) is playing in the context of the specification, eg Payor or Receiver.">

type CollateralCriteriaBase: <"Represents a set of criteria used to specify and describe collateral.">

    collateralCriteria CollateralCriteria (0..1) <"The specific criteria that applies. It can be created using AND, OR and NOT logic, and both asset and issuer characteristics.">
    appliesTo CounterpartyRoleEnum (0..2) <"Specifies which of the two counterparties the criteria applies to (either one or both counterparties). This attribute is optional, in case the applicable party is already specified elsewhere within a party election.">
    restrictTo CollateralMarginTypeEnum (0..1) <"Restrict the criteria to only apply to a specific type of margin, ie IM or VM.">
    ratingPriorityResolution RatingPriorityResolutionEnum (0..1) <"Denotes which Criteria has priority if more than one agency rating applies.">

type EligibleCollateralCriteria extends CollateralCriteriaBase: <"Represents a set of criteria used to specify eligible collateral.">
    override collateralCriteria CollateralCriteria (1..1) <"The specific criteria in an Eligible Collateral Schedule. This is a mandatory attribute of an ECS so an override is required to enforce the cardinality.">
    treatment CollateralTreatment (1..1) <"Identifies the treatment of specified collateral, e.g., haircuts,holding limits or exclusions.">

    condition ConcentrationLimitTypeIssueOSAmountDebtOnly: <"Specifies a condition that concentration limit type 'IssueOutstandingAmount' is restricted to be used only if the asset type is described as 'Security' and 'Debt'.">
        if treatment -> concentrationLimit -> concentrationLimitCriteria -> concentrationLimitType only-element = ConcentrationLimitTypeEnum -> IssueOutstandingAmount
        then CriteriaMatchesAssetType(collateralCriteria, Debt)
                or (treatment -> concentrationLimit
                    extract
                        CriteriaMatchesAssetType(
                                item -> concentrationLimitCriteria -> collateralCriteria,
                                Debt
                            )) all = True

    condition ConcentrationLimitTypeMarketCapEquityOnly: <"Specifies a condition that concentration limit type 'MarketCapitalisation' is restricted to be used only if the asset type is described as 'Security' and 'Equity'.">
        if treatment -> concentrationLimit -> concentrationLimitCriteria -> concentrationLimitType only-element = ConcentrationLimitTypeEnum -> MarketCapitalisation
        then CriteriaMatchesAssetType(collateralCriteria, Equity)
                or (treatment -> concentrationLimit
                    extract
                        CriteriaMatchesAssetType(
                                item -> concentrationLimitCriteria -> collateralCriteria,
                                Equity
                            )) all = True

    condition AverageTradingVolumeEquityOnly: <"Specifies a condition that concentration limit 'AverageTradingVolume' is restricted to be used only if the asset type is described as 'Security' and 'Equity'.">
        if treatment -> concentrationLimit -> concentrationLimitCriteria -> averageTradingVolume exists
        then CriteriaMatchesAssetType(collateralCriteria, Equity)
                or (treatment -> concentrationLimit
                    extract
                        CriteriaMatchesAssetType(
                                item -> concentrationLimitCriteria -> collateralCriteria,
                                Equity
                            )) all = True

type CollateralTreatment: <"Specifies the treatment terms for the eligible collateral criteria specified.">

    valuationTreatment CollateralValuationTreatment (0..1) <"Specification of the valuation treatment for the specified collateral.">
        [docReference ICMA GMRA namingConvention "marginRatio"]
    concentrationLimit ConcentrationLimit (0..*) <"Specification of concentration limits applicable to the collateral criteria.">
    isIncluded boolean (1..1) <"A boolean attribute to specify whether collateral critieria are inclusion (True) or exclusion (False) criteria.">

type ConcentrationLimit: <"Represents a class to describe concentration limits that may be applicable to eligible collateral criteria.">

    concentrationLimitCriteria ConcentrationLimitCriteria (0..1) <"Specifies a set of criteria to describe the assets that the concentration limits apply to.">
    valueLimit MoneyRange (0..1) <"Specifies the value of collateral limit represented as a range.">
    percentageLimit NumberRange (0..1) <"Specifies the perecentage of collateral limit represented as a decimal number - example 25% is 0.25.">

    condition ConcentrationLimitValueChoice: <"Either a value or percentage concentration limit must be specified.">
        required choice valueLimit, percentageLimit

    condition PercentageConcentrationLimit: <"concentration limit must be described as a percentage.">
        if concentrationLimitCriteria -> concentrationLimitType = ConcentrationLimitTypeEnum -> MarketCapitalisation
        then percentageLimit exists

type ConcentrationLimitCriteria extends CollateralCriteriaBase: <"Respresents a class to describe a set of criteria to describe specific assets that the concentration limits apply to.">

    concentrationLimitType ConcentrationLimitTypeEnum (0..1) <"Specifies the type of concentration limit to be applied.">
    averageTradingVolume AverageTradingVolume (0..1) <"Specifies an average trading volume on an exchange in relation to Equity products.">

    condition ConcentrationLimitTypeChoice: <"Either a limit type or limit criteria must be specified.">
        required choice concentrationLimitType, averageTradingVolume, collateralCriteria

type AverageTradingVolume: <"Represents the average trading volume of an Equity product upon an exchange or set of exchanges.">

    period Period (1..1) <"Represents the period of the equities average trading volume on the exchange/s.">
    methodology AverageTradingVolumeMethodologyEnum (1..1) <"Indicates the type of equity average trading volume being stated (single) the highest amount on one exchange, or (consolidated) volumes across multiple exchanges.">

type IssuerCountryOfOrigin:
    issuerCountryOfOrigin ISOCountryCodeEnum (1..1) <"Represents a filter on the issuing entity country of origin based on the ISO Standard 3166, which is the same as filtering by eligible Sovereigns.">

type AssetCountryOfOrigin:
    assetCountryOfOrigin ISOCountryCodeEnum (1..1) <"Represents a filter on the asset country of origin based on the ISO Standard 3166.">

type IssuerName:
    issuerName LegalEntity (1..1) <"Specifies the issuing entity name or LEI.">

type IssuerAgencyRating:
    issuerAgencyRating AgencyRatingCriteria (1..1) <"Represents an agency rating based on default risk and creditors claim in event of default associated with asset issuer.">

type SovereignAgencyRating:
    sovereignAgencyRating AgencyRatingCriteria (1..1) <"Represents an agency rating based on default risk of the country of the issuer.">

type AssetAgencyRating:
    assetAgencyRating AgencyRatingCriteria (1..1) <"Represents an agency rating based on default risk and creditors claim in event of default associated with specific instrument.">

type AssetMaturity:
    maturityType MaturityTypeEnum (1..1) <"Specifies whether the maturity range is the remaining or original maturity.">
    maturityRange PeriodRange (1..1) <"Represents a filter based on the underlying asset maturity.">

type ListingExchange: <"Specifies a filter based on a stock exchange.">
    exchange string (1..*) <"Represents a filter based on the Primary Stock Exchange facilitating the listing of companies, exchange of Stocks, Exchange traded Derivatives, Bonds, and other Securities expressed in ISO standard 10383.">
        [metadata scheme]

type ListingSector: <"Specifies a filter based on an industry sector.">
    sector string (1..*) <"Represents a filter based on an industry sector defined under a system for classifying industry types such as Global Industry Classification Standard (GICS) and North American Industry Classification System (NAICS)">
        [metadata scheme]

type DomesticCurrencyIssued:
    domesticCurrencyIssued boolean (1..1) <"Identifies that the Security must be denominated in the domestic currency of the issuer.">

type CounterpartyOwnIssuePermitted:
    counterpartyOwnIssuePermitted boolean (1..1) <"Represents a filter based on whether it is permitted for the underlying asset to be issued by the posting entity or part of their corporate family.">

choice CollateralCriteria: <"The possible different terms that can be combined, using AND, OR and NOT logic, to define the issuers and/or assets that meet a given criteria for collateral.">
    AllCriteria <"Enables two or more Collateral Criteria to be combined using AND logic.">
    AnyCriteria <"Enables two or more Collateral Criteria to be combined using OR logic.">
    NegativeCriteria <"Enables a single Collateral Criteria to be excluded using NOT logic.">
    CollateralIssuerType <"Criteria is the type of entity issuing the asset.">
    AssetType <"Criteria is the asset type of the collateral.">
    IssuerCountryOfOrigin <"Criteria is the issuing entity country of origin.">
    AssetCountryOfOrigin <"Criteria is the collateral asset country of origin.">
    CurrencyCodeEnum <"Criteria is the denominated currency of the collateral.">
    IssuerName <"Criteria is a specific named issuer entity.">
    IssuerAgencyRating <"Criteria is the agency rating(s) of the issuer.">
    SovereignAgencyRating <"Criteria is the agency rating(s) of the country of the issuer.">
    AssetAgencyRating <"Criteria is the agency rating(s) of the collateral asset.">
    AssetMaturity <"Criteria is the maturity characteristics of the collateral asset.">
    SpecificAsset <"Criteria is a specifically identified asset">
    CollateralTaxonomy <"Criteria is the taxonomy characteristics of an collateral.">
    ListingExchange <"Criteria is that the collateral is listed on a specific exchange.">
    ListingSector <"Criteria is the industry sector of the collateral asset.">
    Index <"Criteria is that the collateral is a constituent of a specific index.">
    CounterpartyOwnIssuePermitted <"Criteria includes collateral issued by the counterparty.">
    DomesticCurrencyIssued <"Criteria is that collateral must be denominated in the domestic currency of the issuer.">

type AllCriteria: <"Used to combine two or more Collateral Criteria using AND logic.">
    allCriteria CollateralCriteria (2..*)

type AnyCriteria: <"Used to combine two or more Collateral Criteria using OR logic.">
    anyCriteria CollateralCriteria (2..*)

type NegativeCriteria: <"Used to apply a NOT logic condition to a single Collateral Criteria.">
    negativeCriteria CollateralCriteria (1..1)

// collateral interest calculation parameters
type DistributionAndInterestPayment: <"A class to specify the Distributions and Interest Payment provisions applicable to the collateral agreement.">
    interestParameters CollateralInterestParameters (0..*) <"Represents the interest parameters for the various currencies, margin types, posting parties.">

type CollateralInterestParameters: <"Represents the floating interest calculation and distribution parameters for a single currency.">
    postingParty CounterpartyRoleEnum (0..1) <"Represents the party to which these parameters apply (the applicable party).  In other words, if the parameters are different depending on which party is posting/holding the collateral, for which party to the Collateral Agreement (Party 1 or Party 2) that is posting the collateral do these parameters apply?">
    marginType CollateralMarginTypeEnum (0..1) <"Specifies the type of margin for which interest is being calculated, if the parameters are different depending on type of margin (initial or variation).">
    currency string (0..1) <"Specifies the currency for which the parameters are captured.">
    interestCalculationParameters CollateralInterestCalculationParameters (0..1) <"Represents the basic interest calculation parameters.">
    interestCalculationFrequency CalculationFrequency (0..1) <"Represents how often and when interest is calculated.">
    interestHandlingParameters CollateralInterestHandlingParameters (0..1) <"Represents the parameters describing how and when interest transfer occurs.">

type CollateralInterestCalculationParameters: <"Represents parameters for calculating the amount the floating interest calculation, e.g.  for a single currency or defaults for all currencies.">
    fixedRate number (0..1) <"Specifies the applicable fixed rate  if used.">
    floatingRate CollateralAgreementFloatingRate (0..1) <"Specifies the floating interest rate to be used.">
    inBaseCurrency boolean (1..1) <"If True, specifies that the interest transfers should be converted to base currency equivalent, or if False specifies that the transfer should be in the currency of the collateral.">
    compoundingType CompoundingTypeEnum (0..1) <"Specifies the type of compounding to be applied (None, Business, Calendar).">
    compoundingBusinessCenter BusinessCenterEnum (0..*) <"Specifies the applicable business centers for compounding.">
    dayCountFraction DayCountFractionEnum (1..1) <"Specifies the day count fraction to use for that currency.">
    rounding Rounding (0..1) <"Specifies the rounding rules for settling in that currency.">
    roundingFrequency RoundingFrequencyEnum (0..1) <"Specifies when/how often is rounding applied?">
    withholdingTaxRate number (0..1) <"Specifies the withholding tax rate if a withholding tax is applicable.">

    condition InterestRate:
        required choice fixedRate, floatingRate

    condition DCF:
        dayCountFraction = DayCountFractionEnum -> ACT_360
            or dayCountFraction = DayCountFractionEnum -> ACT_365_FIXED

    condition CompoundingBC1:
        if compoundingType = CompoundingTypeEnum -> Business
        then compoundingBusinessCenter exists

    condition CompoundingBC2:
        if compoundingType <> CompoundingTypeEnum -> Business
        then compoundingBusinessCenter is absent

type CollateralAgreementFloatingRate extends FloatingRateBase: <"Represents the parameters needed to calculate the floating rate paid on collateral holdings.">
    negativeInterest boolean (1..1) <"Specifies how negative rates should be applied.  If rates go negative, should the payment be reversed (true) or zeroed out (false)?">
    compressibleSpread boolean (1..1) <"Specifies how spreads should be applied in a low/negative rate environment.  If true, spread is applied only if rate is positive.">

/*  Following is a table that shows how to apply the negativeInterest and compressibleSpread indicators
 * Abbreviations:   
 * PP : Posting party
 * HP : Holding Party
 * 	Rate : index rate prior to application of any spread
 * 	Spread : amount of spread added to the rate

 *             Negative Interest / Compressible Spread
 * Rate    Spread  TRUE/TRUE       FALSE/FALSE     TRUE/FALSE      FALSE/TRUE
 *  1.00    0.50   HP Pays 1.5     HP Pays 1.5     HP Pays 1.5     HP Pays 1.5 
 *  1.00    (0.50) HP Pays 0.5     HP Pays 0.5     HP Pays 0.5     HP Pays 0.5 
 *  1.00    (1.00) No Payment      No Payment      No Payment      No Payment  
 *  1.00    (1.25) PP Pays 0.25    No Payment      PP Pays 0.25    No Payment  
 *  -       0.50   HP Pays 0.5     HP Pays 0.5     HP Pays 0.5     HP Pays 0.5 
 *  -       (0.50) PP Pays 0.5     No Payment      PP Pays 0.5     No Payment  
 *  (1.00)  0.50   PP Pays 1.0     No Payment      PP Pays 0.5     No Payment  
 *  (1.00)  (0.50) PP Pays 1.0     No Payment      PP Pays 1.5     No Payment  
 *  (1.00)  (1.00) PP Pays 1.0     No Payment      PP Pays 2.0     No Payment  
 *  (1.00)  1.00   PP Pays 1.0     No Payment      No Payment      No Payment  
 *  (1.00)  1.25   PP Pays 1.0     HP Pays 0.25    HP Pays 0.25    No Payment  
 */
type CollateralInterestHandlingParameters: <"Represents parameters that describe how calculated interest amounts are handled, i.e. are they transferred/distributed, or is the collateral balance adjusted, is netting done, and any other special handling.">
    interestPaymentHandling CollateralInterestHandlingEnum (1..1) <"Specifies how the collateral interest is to be handled.">
    paymentBusinessCenter BusinessCenterEnum (0..*) <"Specifies applicable business centers for payments.">
    netPostedAndHeldInterest boolean (1..1) <"Indicates whether to net Held and Posted Interest Payments (i.e. whether interest payable for a period can be netted with interest receivable).">
    netInterestWithMarginCalls boolean (1..1) <"Indicates whether the interest amount may be offset against any margin call deliver or return amounts?   (aka 'net payments' indicator).">
    includeAccrualInMarginCalc boolean (1..1) <"Indicates whether or not to include the open interest accrual in the margin calculation.">
    accrueInterestOnUnsettledInterest boolean (0..1) <"Indicates whether interest accruing on unsettled interest amount is included (continues to be accrued) in the following period.">
    onFullReturn boolean (1..1) <"Indicates the option that accrued interest should be calculated and distributed when a full return of collateral occurs.">
    onPartialReturn boolean (1..1) <"Indicates the option that accrued interest should be calculated and distributed when a partial return collateral occurs.">
    interestAmountApplication InterestAmountApplication (0..1) <"The application of Interest Amount with respect to the Delivery Amount and the Return Amount.">
    interestRolloverLimit NumberBound (0..1) <"Specifies the level below which the interest will be rolled over.">
    writeoffLimit NumberBound (0..1) <"Specifies the level below which the interest will be written off; if omitted write-off is not applicable.">
    alternativeToInterestAmount AlternativeToInterestAmountEnum (0..1) <"Specifies the alternative to interest amounts.">
    alternativeProvision string (0..1) <"Specifies an alternative to interest amount, when the alternative provision clause is specified.">
    cutoffTime time (0..1) <"Specifies the time of day that interest needs to be confirmed by.">
    notification CollateralInterestNotification (0..1) <"Specifies the terms describing notification requirements.">

    condition Alternative:
        if alternativeToInterestAmount = AlternativeToInterestAmountEnum -> Other
        then alternativeProvision exists

    condition Alternative2:
        if alternativeToInterestAmount <> AlternativeToInterestAmountEnum -> Other
        then alternativeProvision is absent

type CollateralInterestNotification: <"Represents the parameters describing when notifications should be made for required collateral interest transfers.">
    trigger string (1..1) <"Specifies what triggers notification (should be enum) Interest Statement Frequency, Period End Date.">
    offset number (1..1) <"Specifies the number of days before (negative) or after (positive) the trigger event.">
    notificationTime time (1..1) <"Specifies the time of day that the notification should occur.">
    notificationDayType DayTypeEnum (1..1) <"The type of days on which notification should occur.">

type InterestAmountApplication: <"A class to specify the application of Interest Amount with respect to the Delivery Amount and the Return Amount.">

    returnAmount ReturnAmount (1..1) <"The application of Interest Amount with respect the Return Amount.">
    deliveryAmount DeliveryAmount (1..1) <"The application of Interest Amount with respect the Delivery Amount.">

type ReturnAmount: <"A class to specify the application of Interest Amount with respect the Return Amount.">

    includesDefaultLanguage boolean (0..1) <"Default language is included when True, and excluded when False.">
    customElection string (0..1) <"Custom election that might be specified by the parties to the agreement.">

    condition CustomElection: <"A data rule to specify that when a custom election exists then default language should not be included.">
        if customElection exists then includesDefaultLanguage = False

type DeliveryAmount: <"A class to specify the application of Interest Amount with respect the Delivery Amount.">

    standardElection DeliveryAmountElectionEnum (0..1) <"The standard election as specified by an enumeration.">
    customElection string (0..1) <"The custom election that might be specified by the parties to the agreement.">

    condition:
        one-of

type SpecificAsset extends Asset: <"A single, specifically identified Asset chosen from the Asset data type">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-enum.rosetta
================================================================================

namespace cdm.product.common
version "${project.version}"

enum NotionalAdjustmentEnum: <"The enumerated values to specify the conditions that govern the adjustment to the number of units of the return swap.">
    Execution <"The adjustments to the number of units are governed by an execution clause.">
    PortfolioRebalancing <"The adjustments to the number of units are governed by a portfolio rebalancing clause.">
    Standard <"The adjustments to the number of units are not governed by any specific clause.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-func.rosetta
================================================================================

namespace cdm.product.common
version "${project.version}"

import cdm.product.asset.*

func InterestRatePayoutCurrency:
    inputs:
        interestRatePayouts InterestRatePayout (0..*) <"List of interest rate payouts.">
    output:
        currency string (0..*) <"List of currencies collected from the payouts.">

    add currency: <"Adds quantitySchedule -> initialQuantity -> unitOfAmount -> currency to the list.">
        interestRatePayouts -> priceQuantity -> quantitySchedule -> unit -> currency
    add currency: <"Adds fxLinkedNotionalSchedule -> varyingNotionalCurrency to the list.">
        interestRatePayouts -> priceQuantity -> quantityMultiplier -> fxLinkedNotionalSchedule -> varyingNotionalCurrency


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-schedule-enum.rosetta
================================================================================

namespace cdm.product.common.schedule : <"Common product schedule concepts: calculation period, reset, fixing and payment dates, stub, notional schedule, roll convention.">
version "${project.version}"

import cdm.base.datetime.*

enum PayRelativeToEnum: <"The enumerated values to specify whether payments occur relative to the calculation period start date or end date, each reset date, valuation date or the last pricing date.">
    CalculationPeriodStartDate <"Payments will occur relative to the first day of each calculation period.">
    CalculationPeriodEndDate <"Payments will occur relative to the last day of each calculation period.">
    LastPricingDate <"Payments will occur relative to the last Pricing Date of each Calculation Period.">
    ResetDate <"Payments will occur relative to the reset date.">
    ValuationDate <"Payments will occur relative to the valuation date.">

enum ResetRelativeToEnum: <"The enumerated values to specify whether resets occur relative to the first or last day of a calculation period.">
    CalculationPeriodStartDate <"Resets occur relative to the first day of a calculation period.">
    CalculationPeriodEndDate <"Resets occur relative to the last day of a calculation period.">

enum StubPeriodTypeEnum: <"The enumerated values to specify how to deal with a non standard calculation period within a swap stream.">
    ShortInitial <"If there is a non regular period remaining it is left shorter than the streams calculation period frequency and placed at the start of the stream.">
    ShortFinal <"If there is a non regular period remaining it is left shorter than the streams calculation period frequency and placed at the end of the stream.">
    LongInitial <"If there is a non regular period remaining it is placed at the start of the stream and combined with the adjacent calculation period to give a long first calculation period.">
    LongFinal <"If there is a non regular period remaining it is placed at the end of the stream and combined with the adjacent calculation period to give a long last calculation period.">

enum WeeklyRollConventionEnum extends DayOfWeekEnum: <"The enumerated values to specify the weekly roll day.">
    TBILL <"13-week and 26-week U.S. Treasury Bill Auction Dates. Each Monday except for U.S. (New York) holidays when it will occur on a Tuesday">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-schedule-func.rosetta
================================================================================

namespace cdm.product.common.schedule : <"Common product schedule concepts: calculation period, reset, fixing and payment dates, stub, notional schedule, roll convention.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.product.template.*

func PaymentDate:
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        result date (0..1)
    set result:
        economicTerms -> payout -> InterestRatePayout only-element -> paymentDate -> adjustedDate

func PeriodsInYear:
    [codeImplementation]
    inputs:
        frequency CalculationPeriodFrequency (1..1)
    output:
        numberOfPeriods int (1..1)

func CalculationPeriod: <"2006 ISDA Definition Section 4.13. 'Calculation Period' means, in respect of a Swap Transaction and a party, each period from, and including, one Period End Date of that party to, but excluding, the next following applicable Period End Date during the Term of the Swap Transaction, except that (a) the initial Calculation Period for the party will commence on, and include, the Effective Date and (b) the final Calculation Period for the party will end on, but exclude, the Termination Date.">
    [codeImplementation]
    inputs:
        calculationPeriodDates CalculationPeriodDates (1..1)
        date date (1..1)
    output:
        result CalculationPeriodData (1..1)

func CalculationPeriods: <"2006 ISDA Definition Section 4.13. 'Calculation Period' means, in respect of a Swap Transaction and a party, each period from, and including, one Period End Date of that party to, but excluding, the next following applicable Period End Date during the Term of the Swap Transaction, except that (a) the initial Calculation Period for the party will commence on, and include, the Effective Date and (b) the final Calculation Period for the party will end on, but exclude, the Termination Date.">
    [codeImplementation]
    inputs:
        calculationPeriodDates CalculationPeriodDates (1..1)
    output:
        result CalculationPeriodData (0..*)

func CalculationPeriodRange:
    [codeImplementation]
    inputs:
        startDate date (0..1) // should be AdjustableOrRelativeDate
        endDate date (0..1) // should be AdjustableOrRelativeDate
        dateAdjustments BusinessDayAdjustments (0..1)
    output:
        result CalculationPeriodData (1..1)


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-schedule-type.rosetta
================================================================================

namespace cdm.product.common.schedule : <"Common product schedule concepts: calculation period, reset, fixing and payment dates, stub, notional schedule, roll convention.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.observable.event.*
import cdm.product.asset.*

type CalculationPeriodData:
    startDate date (1..1)
    endDate date (1..1)
    daysInPeriod int (1..1)
    daysInLeapYearPeriod int (1..1)
    isFirstPeriod boolean (1..1)
    isLastPeriod boolean (1..1)

type StubPeriod: <" A class defining how the initial or final stub calculation period amounts is calculated. For example, the rate to be applied to the initial or final stub calculation period may be the linear interpolation of two different tenors for the floating rate index specified in the calculation period amount component, e.g. A two month stub period may used the linear interpolation of a one month and three month floating rate. The different rate tenors would be specified in this component. Note that a maximum of two rate tenors can be specified. If a stub period uses a single index tenor and this is the same as that specified in the calculation period amount component then the initial stub or final stub component, as the case may be, must not be included.">

    calculationPeriodDatesReference CalculationPeriodDates (1..1) <"A pointer style reference to the associated calculation period dates component defined elsewhere in the document.">
        [metadata reference]
    initialStub StubValue (0..1) <"Specifies how the initial stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">
    finalStub StubValue (0..1) <"Specifies how the final stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">

type CalculationPeriodBase: <"The calculation period adjusted start and end dates, which are the baseline arguments needed to compute an interest accrual calculation.">
    [metadata key]

    adjustedStartDate date (0..1) <"The calculation period start date, adjusted according to any relevant business day convention.">
    adjustedEndDate date (0..1) <"The calculation period end date, adjusted according to any relevant business day convention.">

type CalculationPeriod extends CalculationPeriodBase: <"A data defining:  the parameters used in the calculation of a fixed or floating rate calculation period amount. This data forms:  part of cashflows representation of a swap stream.">

    unadjustedStartDate date (0..1) <"The calculation start date, unadjusted.">
    unadjustedEndDate date (0..1) <"The calculation end date, unadjusted.">
    calculationPeriodNumberOfDays int (0..1) <"The number of days from the adjusted effective / start date to the adjusted termination / end date calculated in accordance with the applicable day count fraction.">
    notionalAmount number (0..1) <"The amount that a cashflow will accrue interest on.">
    fxLinkedNotionalAmount FxLinkedNotionalAmount (0..1) <"The amount that a cashflow will accrue interest on. This is the calculated amount of the FX linked - i.e. the other currency notional amount multiplied by the appropriate FX spot rate.">
    floatingRateDefinition FloatingRateDefinition (0..1) <"The floating rate reset information for the calculation period.">
    fixedRate number (0..1) <"The calculation period fixed rate. A per annum rate, expressed as a decimal. A fixed rate of 5% would be represented as 0.05.">
    dayCountYearFraction number (0..1) <"The year fraction value of the calculation period, result of applying the ISDA rules for day count fraction defined in the ISDA Annex.">
    forecastAmount Money (0..1) <"The amount representing the forecast of the accrued value of the calculation period. An intermediate value used to generate the forecastPaymentAmount in the PaymentCalculationPeriod.">
    forecastRate number (0..1) <"A value representing the forecast rate used to calculate the forecast future value of the accrual period. This is a calculated rate determined based on averaging the rates in the rateObservation elements, and incorporates all of the rate treatment and averaging rules. A value of 1% should be represented as 0.01.">

    condition NotionalChoice: <"condition to represent an FpML choice construct.">
        required choice notionalAmount, fxLinkedNotionalAmount

    condition RateChoice: <"condition to represent an FpML choice construct.">
        required choice floatingRateDefinition, fixedRate

    condition StartDateChoice: <"FpML validation rule ird-30 - Context: CalculationPeriod (complex type). unadjustedStartDate exists or adjustedStartDate exists.">
        required choice adjustedStartDate, unadjustedStartDate

    condition EndDateChoice: <"FpML validation rule ird-31 - Context: CalculationPeriod (complex type). unadjustedEndDate exists or adjustedEndDate exists.">
        required choice adjustedEndDate, unadjustedEndDate

type CalculationPeriodDates: <"A data for:  defining the parameters used to generate the calculation period dates schedule, including the specification of any initial or final stub calculation periods. A calculation period schedule consists of an optional initial stub calculation period, one or more regular calculation periods and an optional final stub calculation period. In the absence of any initial or final stub calculation periods, the regular part of the calculation period schedule is assumed to be between the effective date and the termination date. No implicit stubs are allowed, i.e. stubs must be explicitly specified using an appropriate combination of firstPeriodStartDate, firstRegularPeriodStartDate and lastRegularPeriodEndDate.">
    [metadata key]

    effectiveDate AdjustableOrRelativeDate (0..1) <"The first day of the terms of the trade. This day may be subject to adjustment in accordance with a business day convention.">
    terminationDate AdjustableOrRelativeDate (0..1) <"The last day of the terms of the trade. This date may be subject to adjustments in accordance with the business day convention. It can also be specified in relation to another scheduled date (e.g. the last payment date).">
    calculationPeriodDatesAdjustments BusinessDayAdjustments (0..1) <"The specification of the business day convention and financial business centers used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
    firstPeriodStartDate AdjustableOrRelativeDate (0..1) <"The start date of the calculation period. FpML specifies that for interest rate swaps this date must only be specified if it is not equal to the effective date. It is always specified in the case of equity swaps and credit default swaps with periodic payments. This date may be subject to adjustment in accordance with a business day convention.">
    firstRegularPeriodStartDate date (0..1) <"The start date of the regular part of the calculation period schedule. It must only be specified if there is an initial stub calculation period. This day may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">
    firstCompoundingPeriodEndDate date (0..1) <"The end date of the initial compounding period when compounding is applicable. It must only be specified when the compoundingMethod element is present and not equal to a value of None. This date may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">
    lastRegularPeriodEndDate date (0..1) <"The end date of the regular part of the calculation period schedule. It must only be specified if there is a final stub calculation period. This day may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">
    stubPeriodType StubPeriodTypeEnum (0..1) <"Method to allocate any irregular period remaining after regular periods have been allocated between the effective and termination date.">
    calculationPeriodFrequency CalculationPeriodFrequency (0..1) <"The frequency at which calculation period end dates occur with the regular part of the calculation period schedule and their roll date convention.">

    condition FpML_ird_16: <"FpML validation rule ird-16 - If firstRegularPeriodStartDate exists within any element of type CalculationPeriodDates, then terminationDate/unadjustedDate must be after firstRegularPeriodStartDate. This data rule applies within a given interest rate payout component.">
        if firstRegularPeriodStartDate exists
        then terminationDate -> adjustableDate -> unadjustedDate > firstRegularPeriodStartDate

    condition FpML_ird_17: <"FpML validation rule ird-17 - If lastRegularPeriodEndDate exists, then terminationDate/unadjustedDate must be after lastRegularPeriodEndDate. This data rule applies within a given interest rate payout component.">
        if lastRegularPeriodEndDate exists
        then terminationDate -> adjustableDate -> unadjustedDate > lastRegularPeriodEndDate

    condition FpML_ird_18: <"FpML validation rule ird-18 - If firstRegularPeriodStartDate exists, and if lastRegularPeriodEndDate exists, then lastRegularPeriodEndDate must be after firstRegularPeriodStartDate. This data rule applies within a given interest rate payout component.">
        if firstRegularPeriodStartDate exists and lastRegularPeriodEndDate exists
        then lastRegularPeriodEndDate > firstRegularPeriodStartDate

    condition FpML_ird_20: <"FpML validation rule ird-20 - If lastRegularPeriodEndDate exists, then lastRegularPeriodEndDate must be after effectiveDate/unadjustedDate. This data rule applies within a given interest rate payout component.">
        if lastRegularPeriodEndDate exists
        then lastRegularPeriodEndDate > effectiveDate -> adjustableDate -> unadjustedDate

    condition FpML_ird_21: <"FpML validation rule ird-21 - If firstPeriodStartDate exists, then firstPeriodStartDate/unadjustedDate must be before effectiveDate/unadjustedDate. This data rule applies within a given interest rate payout component.">
        if firstPeriodStartDate exists and effectiveDate exists
        then firstPeriodStartDate -> adjustableDate -> unadjustedDate < effectiveDate -> adjustableDate -> unadjustedDate

    condition FpML_ird_22: <"FpML validation rule ird-22 - If firstPeriodStartDate exists, and if firstRegularPeriodStartDate exists, then firstPeriodStartDate/unadjustedDate must be before firstRegularPeriodStartDate. This data rule applies within a given interest rate payout component.">
        if firstPeriodStartDate exists and firstRegularPeriodStartDate exists
        then firstPeriodStartDate -> adjustableDate -> unadjustedDate < firstRegularPeriodStartDate

type DateRelativeToCalculationPeriodDates: <"A data to:  provide the ability to point to multiple payment nodes in the document through the unbounded paymentDatesReference.">

    calculationPeriodDatesReference CalculationPeriodDates (1..*) <"A set of href pointers to calculation period dates defined somewhere else in the document.">
        [metadata reference]

type DateRelativeToValuationDates: <"A data to:  provide the ability to point to multiple payment nodes in the document through the unbounded paymentDatesReference.">

    valuationDatesReference PerformanceValuationDates (1..*) <"A set of href pointers to valuation period dates defined somewhere else in the document.">
        [metadata reference]

type DateRelativeToPaymentDates: <"A data to:  provide the ability to point to multiple payment nodes in the document through the unbounded paymentDatesReference.">

    paymentDatesReference PaymentDates (1..*) <"A set of href pointers to payment dates defined somewhere else in the document.">
        [metadata reference]

type FxLinkedNotionalAmount: <"A data to:  describe the cashflow representation for FX linked notionals.">

    resetDate date (0..1) <"The reset date.">
    adjustedFxSpotFixingDate date (0..1) <"The date on which the FX spot rate is observed. This date should already be adjusted for any applicable business day convention.">
    observedFxSpotRate number (0..1) <"The actual observed FX spot rate.">
    notionalAmount number (0..1) <"The calculation period notional amount.">

type FxLinkedNotionalSchedule: <"A data to:  describe a notional schedule where each notional that applies to a calculation period is calculated with reference to a notional amount or notional amount schedule in a different currency by means of a spot currency exchange rate which is normally observed at the beginning of each period.">

    varyingNotionalCurrency string (1..1) <"The currency of the varying notional amount, i.e. the notional amount being determined periodically based on observation of a spot currency exchange rate. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]
    varyingNotionalFixingDates RelativeDateOffset (1..1) <"The dates on which spot currency exchange rates are observed for purposes of determining the varying notional currency amount that will apply to a calculation period.">
    fxSpotRateSource FxSpotRateSource (1..1) <"The information source and time at which the spot currency exchange rate will be observed.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">
    varyingNotionalInterimExchangePaymentDates RelativeDateOffset (1..1) <"The dates on which interim exchanges of notional are paid. Interim exchanges will arise as a result of changes in the spot currency exchange amount or changes in the constant notional schedule (e.g. amortisation).">

type PaymentCalculationPeriod: <"A data defining:  the adjusted payment date and associated calculation period parameters required to calculate the actual or projected payment amount. This data forms:  part of the cashflow representation of a swap stream.">
    [metadata key]

    unadjustedPaymentDate date (0..1) <"The unadjusted payment date.">
    adjustedPaymentDate date (0..1) <"The adjusted payment date. This date should already be adjusted for any applicable business day convention. This component is not intended for use in trade confirmation but may be specified to allow the fee structure to also serve as a cashflow type component.">
    calculationPeriod CalculationPeriod (1..*) <"The parameters used in the calculation of a fixed or floating rate calculation period amount. A list of calculation period elements may be ordered in the document by ascending start date. An FpML document which contains an unordered list of calculation periods is still regarded as a conformant document.">
    fixedPaymentAmount Money (0..1) <"A known fixed payment amount.">
    discountFactor number (0..1) <"A decimal value representing the discount factor used to calculate the present value of cash flow.">
    forecastPaymentAmount Money (0..1) <"A monetary amount representing the forecast of the future value of the payment.">
    presentValueAmount Money (0..1) <"A monetary amount representing the present value of the forecast payment.">

    condition CalculationPeriodNumberOfDays: <"FpML specifies calculationPeriodNumberOfDays as a positive integer.">
        if calculationPeriod -> calculationPeriodNumberOfDays exists
        then calculationPeriod -> calculationPeriodNumberOfDays all >= 0

    condition PaymentCalculationPeriodChoice: <"condition to represent an FpML choice construct.">
        required choice calculationPeriod, fixedPaymentAmount

    condition FpML_ird_34: <"FpML validation rule ird-34 - Either unadjustedPaymentDate or adjustedPaymentDate must exist.">
        unadjustedPaymentDate exists or adjustedPaymentDate exists

type RateSchedule: <"A class defining a schedule of rates or amounts in terms of an initial value and then a series of step date and value pairs. On each step date the rate or amount changes to the new step value. The series of step date and value pairs are optional. If not specified, this implies that the initial value remains unchanged over time.">
    price PriceSchedule (1..1) <"The initial rate. An initial rate of 5% would be represented as 0.05.">
        [metadata address "pointsTo"=PriceQuantity->price]

type ObservationDates: <"Describes date details for a set of observation dates in parametric or non-parametric form.">
    observationSchedule ObservationSchedule (0..1) <"Specifies a schedule of dates (non-parametric) on which market observations take place, and allows for the optional definition of weights where applicable.  When no weight is specified, then weight of each date is assumed to be 1.0">
    periodicSchedule PeriodicDates (0..1) <"Specifies the date range and frequency on which market observations take place.  Weights can be assigned to dates in the schedule by assigning the weight and corresponding observationReference in the observationSchedule.">
    parametricDates ParametricDates (0..1) <"Specifies parametric terms to determine which days within a given calculation period the price would be observed. Typically associated with Commodities. ">

type ObservationSchedule: <"Specifies a single date on which market observations take place and specifies optional associated weighting.">
    observationDate ObservationDate (0..*) <"Specifies an adjusted or unadjusted date for a market observation.">
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business date in the specified business centers.">

    condition AdjustedDate: <"FpML specifies a choice between adjustedDate and [unadjustedDate (required), dateAdjutsments (required), adjustedDate (optional)].">
        if observationDate -> adjustedDate is absent
        then observationDate -> unadjustedDate exists and dateAdjustments exists

type ObservationDate: <"Specifies a single date on which market observations take place and specifies optional associated weighting.">
    [metadata key]
    unadjustedDate date (0..1) <"A date subject to adjustment.">
    adjustedDate date (0..1) <"The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).">
    weight number (0..1) <"Specifies the degree of importance of the observation.">
    observationReference string (0..1) <"Specifies an identification key for the market observation. This attribute can be used as a reference to assign weights to a series of dates defined in a parametricSchedule.">

    condition ObservationDate: <"Either an unadjusted date or an adjusted date needs to be specified.">
        required choice unadjustedDate, adjustedDate

type ObservationTerms: <"Class containing terms that are associated with observing a price/benchmark/index across either single or multiple observations. ">

    observationTime BusinessCenterTime (0..1) <"Defines time in respect to a business calendar location that the price/benchmark/index is observed">
    observationTimeType TimeTypeEnum (0..1) <"The enumerated values to specify points in the day when option exercise and valuation can occur.">
    informationSource FxSpotRateSource (0..1) <"The information source where a published or displayed market rate will be obtained, e.g. Telerate Page 3750.">
    precision Rounding (0..1) <"Defines rounding rules and precision to be used in the rounding of observations.">
    calculationPeriodDates CalculationPeriodDates (0..1) <"Defines parameters used to generate the calculation period dates schedule, including the specification of any initial or final stub calculation periods. A calculation period schedule consists of an optional initial stub calculation period, one or more regular calculation periods and an optional final stub calculation period. In the absence of any initial or final stub calculation periods, the regular part of the calculation period schedule is assumed to be between the effective date and the termination date. No implicit stubs are allowed, i.e. stubs must be explicitly specified using an appropriate combination of firstPeriodStartDate, firstRegularPeriodStartDate and lastRegularPeriodEndDate.">
    observationDates ObservationDates (1..1) <"Describes date details for a set of observation dates in parametric or non-parametric form.">
    numberOfObservationDates int (0..1) <"The number of observation dates between observation start date and observation end date.">

    condition ObservationTime: <"Checks that an observation time is specified either explicitly (through the observation time) or implicitly (through a observation time type different to Specific Time). If Specific Time is defined as observation time type (i.e. no implicit time value), the condition checks that an explicit observation time is provided.">
        if observationTimeType = TimeTypeEnum -> SpecificTime
        then observationTime exists

type ParametricDates: <"Defines rules for the dates on which the price will be determined.">
    dayType DayTypeEnum (1..1) <"Denotes the enumerated values to specify the day type classification used in counting the number of days between two dates.">
    dayDistribution DayDistributionEnum (0..1) <"Denotes the method by which the pricing days are distributed across the pricing period.">
    dayOfWeek DayOfWeekEnum (0..7) <"Indicates the days of the week on which the price will be determined.">
    dayFrequency number (0..1) <"Defines the occurrence of the dayOfWeek within the pricing period on which pricing will take place, e.g. the 3rd Friday within each Calculation Period. If omitted, every dayOfWeek will be a pricing day.">
    lag Lag (0..1) <"The pricing period per calculation period if the pricing days do not wholly fall within the respective calculation period.">
    businessCenters BusinessCenters (1..1) <"The enumerated values to specify the business centers.">

    condition ParametricDatesChoice:
        required choice dayDistribution, dayOfWeek

    condition DayOfWeekMethod:
        if dayOfWeek exists then dayFrequency exists

type Lag: <"The pricing period per calculation period if the pricing days do not wholly fall within the respective calculation period.">
    lagDuration Offset (1..1) <"Defines the offset of the series of pricing dates relative to the calculation period.">
    firstObservationDateOffset Offset (0..1) <"Defines the offset of the series of pricing dates relative to the calculation period.">

type ResetDates: <"A data defining:  the parameters used to generate the reset dates schedule and associated fixing dates. The reset dates are the dates on which the new index value (which is observed on the fixing date) is applied for each period and on which the interest rate hence begins to accrue.">
    [metadata key]

    calculationPeriodDatesReference CalculationPeriodDates (0..1) <"A pointer style reference to the associated calculation period dates component defined elsewhere in the document.">
        [metadata reference]
    resetRelativeTo ResetRelativeToEnum (0..1) <"Specifies whether the reset dates are determined with respect to each adjusted calculation period start date or adjusted calculation period end date. If the reset frequency is specified as daily this element must not be included.">
    initialFixingDate InitialFixingDate (0..1) <"The initial fixing date.">
    fixingDates RelativeDateOffset (0..1) <"The fixing dates are the dates on which the index values are observed. The fixing dates are specified by reference to the reset date through business days offset and an associated set of financial business centers. Normally these offset calculation rules will be those specified in the ISDA definition for the relevant floating rate index (ISDA's Floating Rate Option). However, non-standard offset calculation rules may apply for a trade if mutually agreed by the principal parties to the transaction.">
    finalFixingDate AdjustableDate (0..1) <"This attribute is not part of the FpML ResetDate, and has been added as part of the CDM to support the credit derivatives final fixing date.">
    rateCutOffDaysOffset Offset (0..1) <"Specifies the number of business days before the period end date when the rate cut-off date is assumed to apply. The financial business centers associated with determining the rate cut-off date are those specified in the reset dates adjustments. The rate cut-off number of days must be a negative integer (a value of zero would imply no rate cut off applies in which case the rateCutOffDaysOffset element should not be included). The relevant rate for each reset date in the period from, and including, a rate cut-off date to, but excluding, the next applicable period end date (or, in the case of the last calculation period, the termination date) will (solely for purposes of calculating the floating amount payable on the next applicable payment date) be deemed to be the relevant rate in effect on that rate cut-off date. For example, if rate cut-off days for a daily averaging deal is -2 business days, then the refix rate applied on (period end date - 2 days) will also be applied as the reset on (period end date - 1 day), i.e. the actual number of reset dates remains the same but from the rate cut-off date until the period end date, the same refix rate is applied. Note that in the case of several calculation periods contributing to a single payment, the rate cut-off is assumed only to apply to the final calculation period contributing to that payment. The day type associated with the offset must imply a business days offset.">
    resetFrequency ResetFrequency (0..1) <"The frequency at which the reset dates occur. In the case of a weekly reset frequency, also specifies the day of the week that the reset occurs. If the reset frequency is greater than the calculation period frequency then this implies that more than one reset is established for each calculation period and some form of rate averaging is applicable.">
    resetDatesAdjustments BusinessDayAdjustments (0..1) <"The definition of the business day convention and financial business centers used for adjusting the reset date if it would otherwise fall on a day that is not a business day in the specified business center.">

    condition RateCutOffDaysOffset: <"FpML specifies that the rate cut-off number of days must be a negative integer with a value of zero would implying that no rate cut off applies, in which case the rateCutOffDaysOffset element should not be included.">
        if rateCutOffDaysOffset exists
        then rateCutOffDaysOffset -> periodMultiplier < 0

    condition WeeklyPeriod: <"FpML specifies that the weeklyRollConvention must be specified as part of the reset frequency if and only if the reset frequency is defined as weekly. This data rule is focused on the first part of the assertion.">
        if resetFrequency -> period = PeriodExtendedEnum -> W
        then resetFrequency -> weeklyRollConvention exists

    condition NonWeeklyPeriod: <"FpML specifies that the weeklyRollConvention must be specified as part of the reset frequency if and only if the reset frequency is defined as weekly. This data rule is focused on the latter part of the assertion.">
        if resetFrequency -> period <> PeriodExtendedEnum -> W
        then resetFrequency -> weeklyRollConvention is absent

type StubCalculationPeriodAmount: <"A data defining:  how the initial or final stub calculation period amounts is calculated. For example, the rate to be applied to the initial or final stub calculation period may be the linear interpolation of two different tenors for the floating rate index specified in the calculation period amount component, e.g. A two month stub period may used the linear interpolation of a one month and three month floating rate. The different rate tenors would be specified in this component. Note that a maximum of two rate tenors can be specified. If a stub period uses a single index tenor and this is the same as that specified in the calculation period amount component then the initial stub or final stub component, as the case may be, must not be included.">

    calculationPeriodDatesReference CalculationPeriodDates (1..1) <"A pointer style reference to the associated calculation period dates component defined elsewhere in the document.">
        [metadata reference]
    initialStub StubValue (0..1) <"Specifies how the initial stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">
    finalStub StubValue (0..1) <"Specifies how the final stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">

type AveragingObservationList: <"An unordered list of weighted averaging observations.">

    averagingObservation WeightedAveragingObservation (1..*) <"A single weighted averaging observation.">

type AveragingPeriod: <"Period over which an average value is taken.">

    schedule AveragingSchedule (0..*) <"A schedule for generating averaging observation dates.">
    averagingDateTimes DateTimeList (0..1) <"An unweighted list of averaging observation date and times.">
    averagingObservations AveragingObservationList (0..1) <"A weighted list of averaging observation date and times.">
    marketDisruption MarketDisruptionEnum (0..1) <"The market disruption event as defined by ISDA 2002 Definitions.">
        [metadata scheme]

    condition AveragingPeriodChoice: <" Choice rule to represent an FpML choice construct between unweighted and weighted averaging date and times.">
        optional choice averagingDateTimes, averagingObservations

type WeightedAveragingObservation: <"A single weighted averaging observation.">

    dateTime zonedDateTime (0..1) <"Observation date time, which should be used when literal observation dates are required. The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">
    observationNumber int (0..1) <"Observation number, which should be unique, within a series generated by a date schedule.">
    weight number (1..1) <"Observation weight, which is used as a multiplier for the observation value.">

    condition WeightedAveragingObservationChoice: <" Choice rule to represent an FpML choice construct between date times for literal date values, and observation numbers for schedule generated observations.">
        required choice dateTime, observationNumber

    condition PositiveObservationNumber: <" FpML specifies observationNumber as a positive integer.">
        if observationNumber exists then observationNumber >= 0

    condition PositiveWeight: <" FpML specifies observationNumber as a non-negative decimal.">
        weight >= 0.0

type AmountSchedule extends Schedule: <"A class to specify a currency amount or a currency amount schedule.">

    currency string (1..*) <"The currency in which the amount schedule is denominated. The currency is specified outside of the actual schedule in order to be applied uniformly to it. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]

type InitialFixingDate: <"A CDM class which purpose is to specify the initial fixing date either alongside the FpML interest rate specification as an offset of another date, or alongside the credit derivative specification as an unadjusted date.">

    relativeDateOffset RelativeDateOffset (0..1)
    initialFixingDate date (0..1)

    condition:
        one-of

type PaymentDates: <"Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.">
    [metadata key]

    paymentFrequency Frequency (0..1) <"The frequency at which regular payment dates occur. If the payment frequency is equal to the frequency defined in the calculation period dates component then one calculation period contributes to each payment amount. If the payment frequency is less frequent than the frequency defined in the calculation period dates component then more than one calculation period will contribute to the payment amount. A payment frequency more frequent than the calculation period frequency or one that is not a multiple of the calculation period frequency is invalid. If the payment frequency is of value T (term), the period is defined by the effectiveDate and the terminationDate.">
    firstPaymentDate date (0..1) <"The first unadjusted payment date. This day may be subject to adjustment in accordance with any business day convention specified in paymentDatesAdjustments. This element must only be included if there is an initial stub. This date will normally correspond to an unadjusted calculation period start or end date. This is true even if early or delayed payment is specified to be applicable since the actual first payment date will be the specified number of days before or after the applicable adjusted calculation period start or end date with the resulting payment date then being adjusted in accordance with any business day convention specified in paymentDatesAdjustments.">
    lastRegularPaymentDate date (0..1) <"The last regular payment date when specified as a date, as in the FpML interest rate construct. FpML specifies that this date may be subject to adjustment in accordance with any business day convention specified in the paymentDatesAdjustments attribute.">
    paymentDateSchedule PaymentDateSchedule (0..1) <"The payment dates when specified as relative to a set of dates specified somewhere else in the instance document/transaction, e.g. the valuation dates as typically the case for equity swaps, or when specified as a calculation period schedule.">
    payRelativeTo PayRelativeToEnum (0..1) <"Specifies whether the payments occur relative to each adjusted calculation period start date or end date, each reset date, valuation date or the last pricing date. Calculation period start date means relative to the start of the first calculation period contributing to a given payment. Similarly, calculation period end date means the end of the last calculation period contributing to a given payment. The valuation date is applicable for Brazilian-CDI and equity swaps.">
    paymentDaysOffset Offset (0..1) <"If early payment or delayed payment is required, specifies the number of days offset that the payment occurs relative to what would otherwise be the unadjusted payment date. The offset can be specified in terms of either calendar or business days. Even in the case of a calendar days offset, the resulting payment date, adjusted for the specified calendar days offset, will still be adjusted in accordance with the specified payment dates adjustments. This element should only be included if early or delayed payment is applicable, i.e. if the periodMultiplier element value is not equal to zero. An early payment would be indicated by a negative periodMultiplier element value and a delayed payment (or payment lag) would be indicated by a positive periodMultiplier element value.">
    paymentDatesAdjustments BusinessDayAdjustments (0..1) <"The definition of the business day convention and financial business centers used for adjusting the payment date if it would otherwise fall on a day that is not a business day in the specified business center.">

    condition FpML_ird_35_cd_31: <"FpML validation rule ird-35 & cd-31- If firstPaymentDate exists, and if lastRegularPaymentDate exists, then firstPaymentDate must be before lastRegularPaymentDate.">
        if firstPaymentDate exists and lastRegularPaymentDate exists
        then firstPaymentDate < lastRegularPaymentDate

    condition NonZeroPeriodMultiplier: <"FpML specifies that paymentDaysOffset should only be included if early or delayed payment is applicable, i.e. if the periodMultiplier element value is not equal to zero.">
        if paymentDaysOffset exists
        then paymentDaysOffset -> periodMultiplier <> 0

type PaymentDateSchedule: <"The payment dates when specified as relative to a set of dates specified somewhere else in the instance document/transaction, e.g. the valuation dates as typically the case for equity swaps, or when specified as a calculation period schedule.">

    interimPaymentDates AdjustableRelativeOrPeriodicDates (0..*)
    finalPaymentDate AdjustableOrRelativeDate (0..1) <"The last payment when specified as an adjustable or relative date, as in the FpML total return construct.">

type ResetFrequency extends Frequency: <"A class defining the reset frequency. In the case of a weekly reset, also specifies the day of the week that the reset occurs. If the reset frequency is greater than the calculation period frequency the this implies that more or more reset dates is established for each calculation period and some form of rate averaging is applicable. The specific averaging method of calculation is specified in FloatingRateCalculation. In case the reset frequency is of value T (term), the period is defined by the swap/swapStream/calculationPerioDates/effectiveDate and the swap/swapStream/calculationPerioDates/terminationDate.">

    weeklyRollConvention WeeklyRollConventionEnum (0..1) <"The day of the week on which a weekly reset date occurs. This element must be included if the reset frequency is defined as weekly and not otherwise.">

    condition FpML_ird_49: <"FpML validation rule ird-49 - WeeklyRollConvention should exist if and only if the period is 'W'.">
        if weeklyRollConvention exists
        then period = PeriodExtendedEnum -> W

type FinalCalculationPeriodDateAdjustment: <"A data to:  define business date convention adjustment to final payment period per leg.">

    relevantUnderlyingDateReference AdjustableOrRelativeDates (1..1) <"Reference to the unadjusted cancellation effective dates.">
        [metadata reference]
    swapStreamReference InterestRatePayout (1..1) <"Reference to the leg, where date adjustments may apply.">
        [metadata reference]
    businessDayConvention BusinessDayConventionEnum (1..1) <"Override business date convention. This takes precedence over leg level information.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-settlement-enum.rosetta
================================================================================

namespace cdm.product.common.settlement : <"Common product settlement concepts: cash vs physical, non-deliverable, money and cashflow, delivery vs payment.">
version "${project.version}"

enum DeliveryMethodEnum: <"Specifies delivery methods for securities transactions. This coding-scheme defines the possible delivery methods for securities.">
    DeliveryVersusPayment <"Indicates that a securities delivery must be made against payment in simultaneous transmissions and stipulate each other.">
    FreeOfPayment <"Indicates that a securities delivery can be made without a simultaneous cash payment in exchange and not depending on if payment obligations are fulfilled or not and vice versa.">
    PreDelivery <"Indicates that a securities delivery must be made in full before the payment for the securities; fulfillment of payment obligations depends on securities delivery obligations fulfillment.">
    PrePayment <"Indicates that a payment in full amount must be made before the securities delivery; fulfillment of securities delivery obligations depends on payment obligations fulfillment.">

enum ScheduledTransferEnum: <"The qualification of the type of cash flows associated with OTC derivatives contracts and their lifecycle events.">
    CorporateAction <"A cash flow corresponding to a corporate action event.">
    Coupon <"A cash flow corresponding to the periodic accrued interests.">
    CreditEvent <"A cashflow resulting from a credit event.">
    DividendReturn <"A cash flow corresponding to the synthetic dividend of an equity underlier asset traded through a derivative instrument.">
    Exercise <"A cash flow associated with an exercise lifecycle event.">
    FixedRateReturn <"A cash flow corresponding to the return of the fixed interest rate portion of a derivative instrument that has different types of underlying assets, such as a total return swap.">
    FloatingRateReturn <"A cash flow corresponding to the return of the floating interest rate portion of a derivative instrument that has different types of underlying assets, such as a total return swap.">
    FractionalAmount <"A cash flow corresponding to the compensation for missing assets due to the rounding of digits in the original number of assets to be delivered as per payout calculation.">
    InterestReturn <"A cash flow corresponding to the return of the interest rate portion of a derivative instrument that has different types of underlying assets, such as a total return swap.">
    NetInterest <"Net interest across payout components. Applicable to products such as interest rate swaps.">
    Performance <"A cash flow corresponding to a performance return.  The settlementOrigin attribute on the Transfer should point to the relevant Payout defining the performance calculation.">
    PrincipalPayment <"A cashflow which amount typically corresponds to the notional amount of the contract for various business reasons e.g. PhysicalSettlement, PrincipalExchange etc. else to a portion of the notional amount interim payments e.g. for the purpose of resetting the Notional Amount of a Cross Currency Swap variying leg, as part of a final Principal Exchange related to a Non-Deliverable currency leg, etc.">

enum SettlementTypeEnum: <"The enumeration values to specify how the option is to be settled when exercised.">
    Cash <"The intrinsic value of the option will be delivered by way of a cash settlement amount determined, (i) by reference to the differential between the strike price and the settlement price; or (ii) in accordance with a bilateral agreement between the parties.">
    Physical <"The securities underlying the transaction will be delivered by (i) in the case of a call, the seller to the buyer, or (ii) in the case of a put, the buyer to the seller versus a settlement amount equivalent to the strike price per share.">
    Election <"Allow Election of either Cash or Physical settlement.">
    CashOrPhysical <"Allow use of either Cash or Physical settlement without prior Election.">

enum TransferSettlementEnum: <"The enumeration values to specify how the transfer will settle, e.g. DvP.">
    DeliveryVersusDelivery <"Simultaneous transfer of two assets, typically securities, as a way to avoid settlement risk.">
    DeliveryVersusPayment <"Settlement in which the transfer of the asset and the cash settlement are simultaneous.">
    PaymentVersusPayment <"Simultaneous transfer of cashflows.">
    NotCentralSettlement <"No central settlement.">

enum StandardSettlementStyleEnum: <"The enumerated values to specify whether a trade is settling using standard settlement instructions as well as whether it is a candidate for settlement netting.">
    Standard <"This trade will settle using standard predetermined funds settlement instructions.">
    Net <"This trade is a candidate for settlement netting.">
    StandardAndNet <"This trade will settle using standard predetermined funds settlement instructions and is a candidate for settlement netting.">
    PairAndNet <"These trades have been paired and are a candidate for settlement netting.">

enum CashSettlementMethodEnum: <"Defines the different cash settlement methods for a product where cash settlement is applicable.">
    CashPriceMethod <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2006 ISDA Definitions, Section 18.3. Cash Settlement Methods, paragraph (a).">
    CashPriceAlternateMethod <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2006 ISDA Definitions, Section 18.3. Cash Settlement Methods, paragraph (b).">
    ParYieldCurveAdjustedMethod <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2006 ISDA Definitions, Section 18.3. Cash Settlement Methods, paragraph (c).">
    ZeroCouponYieldAdjustedMethod <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2006 ISDA Definitions, Section 18.3. Cash Settlement Methods, paragraph (d).">
    ParYieldCurveUnadjustedMethod <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2006 ISDA Definitions, Section 18.3. Cash Settlement Methods, paragraph (e).">
    CrossCurrencyMethod <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2006 ISDA Definitions, Section 18.3. Cash Settlement Methods, paragraph (f) (published in Supplement number 23).">
    CollateralizedCashPriceMethod <"An ISDA defined cash settlement method (yield curve) used for the determination of the applicable cash settlement amount. The method is defined in the 2006 ISDA Definitions, Section 18.3. Cash Settlement Methods, paragraph (g) (published in Supplement number 28). The method is defined in the 2021 ISDA Definitions, section 18.2.6.">
    MidMarketIndicativeQuotations <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2021 ISDA Definitions, Section 18.2.1.">
    MidMarketIndicativeQuotationsAlternate <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2021 ISDA Definitions, Section 18.2.2.">
    MidMarketCalculationAgentDetermination <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2021 ISDA Definitions, Section 18.2.3.">
    ReplacementValueFirmQuotations <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2021 ISDA Definitions, Section 18.2.4.">
    ReplacementValueCalculationAgentDetermination <"An ISDA defined cash settlement method used for the determination of the applicable cash settlement amount. The method is defined in the 2021 ISDA Definitions, Section 18.2.5">

enum SettlementCentreEnum: <"Defines the settlement centre for a securities transaction.">
    EuroclearBank <"Euroclear Bank">
    ClearstreamBankingLuxembourg <"ClearStream Banking Luxembourg">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-settlement-func.rosetta
================================================================================

namespace cdm.product.common.settlement : <"Common product settlement concepts: cash vs physical, non-deliverable, money and cashflow, delivery vs payment.">
version "${project.version}"

import cdm.base.math.*
import cdm.observable.asset.*

func UpdateAmountForEachQuantity: <"Updates all quantities on each price quantity with the new amount.">
    [codeImplementation]
    inputs:
        priceQuantity PriceQuantity (0..*) <"List of price quantities to update.">
        amount number (1..1) <"The new amount.">
    output:
        updatedPriceQuantity PriceQuantity (0..*) <"List of price quantities with all quantity amounts updated.">

func UpdateAmountForEachMatchingQuantity: <"Updates any quantity from the list of new quantities if the unit of amount matches.">
    [codeImplementation]
    inputs:
        priceQuantity PriceQuantity (1..*) <"List of price quantities to update.">
        change PriceQuantity (1..*)
        direction QuantityChangeDirectionEnum (1..1)
    output:
        updatedPriceQuantity PriceQuantity (1..*) <"List of price quantities with quantity amounts updated.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-settlement-type.rosetta
================================================================================

namespace cdm.product.common.settlement : <"Common product settlement concepts: cash vs physical, non-deliverable, money and cashflow, delivery vs payment.">
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.credit.*
import cdm.base.staticdata.party.*
import cdm.observable.asset.*
import cdm.product.asset.*
import cdm.product.common.schedule.*

type ComputedAmount: <"A class to specify the outcome of a computed amount, for testing purposes.">

    callFunction calculation (1..1)
    amount number (1..1)
    currency string (0..1) <"The currency in which the computed amount is denominated. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]

type AssetFlowBase: <"Defines the basic parameters of an asset transfer, e.g. a cashflow: what (the asset), how much (the quantity) and when (the settlement date).">
    quantity NonNegativeQuantity (1..1) <"Represents the amount of the asset to be transferred. The cashflow amount is always a positive number, as the cashflow direction is implied by the payer/receiver attribute.">
    asset Asset (1..1) <"Represents the object that is subject to the transfer, it could be an asset or a reference.">
    settlementDate AdjustableOrAdjustedOrRelativeDate (1..1) <"Represents the date on which the transfer to due.">

    condition QuantityUnitExists: <"Aligns the type of unit and the type of asset.">
        if asset -> Cash exists
        then quantity -> unit -> currency exists
        else if asset -> Commodity exists
        then quantity -> unit -> capacityUnit exists
        else if asset -> Instrument exists
        then quantity -> unit -> financialUnit exists

type Cashflow extends AssetFlowBase: <"Class to specify a cashflow, i.e. the outcome of either of computation (e.g. interest accrual) or an assessment of some sort (e.g. a fee). The cashflow can then be turned into a cash transfer, artefact to be used as the input to a payment system or the outcome of it. The associated globalKey denotes the ability to associate a hash value to the Cashflow instantiations for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    payerReceiver PayerReceiver (1..1) <"Specifies who pays / receives the cashflow, though a normalised Party1 / Party2 enumerator.">
    cashflowType CashflowType (1..1) <"The qualification of the type of cashflow, e.g. brokerage fee, premium, upfront fee etc. Particularly relevant when it cannot be inferred directly through lineage.">
    paymentDiscounting PaymentDiscounting (0..1) <"FpML specifies the FpML PaymentDiscounting.model group for representing the discounting elements that can be associated with a payment.">

type CashflowType: <"Characterises the type of cashflow, which can result from either a scheduled or a non-scheduled lifecycle event.">
    cashflowType ScheduledTransferEnum (0..1) <"Type of cashflow corresponding to a scheduled event.">
    cashPrice CashPrice (0..1) <"Type of cashflow corresponding to a non-scheduled event, where a price must be agreed between the parties.">
    priceExpression PriceExpressionEnum (0..1)

    condition: <"A cashflow is either specified as a type of scheduled cashflow, or as a price agreed between parties in case of a non-scheduled cashflow.">
        required choice cashflowType, cashPrice

type QuantityMultiplier: <" Class to specify a mechanism for a quantity to be set as a multiplier to another (reference) quantity, based on a price observation. At the moment this class only supports FX or Equity-linked notional and re-uses existing building blocks for those 2 cases, until such time when component can be made more generic. This captures the case of resetting cross-currency swaps and resetting equity swaps.">

    fxLinkedNotionalSchedule FxLinkedNotionalSchedule (0..1) <"Multiplier specified as an FX-linked schedule, e.g. for a resetting cross-currency swap..">
    multiplierValue number (0..1)

    condition:
        one-of

type ResolvablePriceQuantity: <"Generic class to specify the quantity for different payout legs in a contractual product, when that quantity can vary across payout legs or across time. A resolvable quantity can always be resolved into a single quantity from the quantity notation which has a corresponding asset identifier. In addition to the base case, where quantity is directly specified as a number as part of the quantity notation, the other use cases are: (i) quantity based on some pre-defined schedule (eg amortising notional), (ii) quantity based on some pre-defined events (eg resetting cross-currency notional), or quantity set as reference to another quantity (eg equity notional as no. securities x price).">
    [metadata key]

    resolvedQuantity Quantity (0..1) <"A product's quantity as a single, non-negative amount.  When specified as part of a product definition, this quantity attribute would not be set.  Instead it is specified on the quantity notation along with an asset identifier matching this payout's asset identifier.  This allows the quantity to be resolved for a payout leg, which can then be specified here for convenience during data processing.  There needs to be at least one resolvable quantity across payout legs of a product to define an anchor that other payout quantities can refer to.  This attribute is ignored when mapping existing FpML messages.">
    quantitySchedule NonNegativeQuantitySchedule (0..1) <"A payout's quantity specified as a schedule, which may also contain a single value if that quantity is constant. There can only be a single quantity schedule applicable to a payout: e.g. the notional for an interest rate leg. The quantity must be specified outside of the payout in a PriceQuantity object and only referenced inside the payout using an address.">
        [metadata address "pointsTo"=PriceQuantity->quantity]
    quantityReference ResolvablePriceQuantity (0..1) <"Reference quantity when resolvable quantity is defined as relative to another (resolvable) quantity. A resolvable quantity needs to contain either an absolute quantity or a reference to another (resolvable) quantity. This requirement is captured by a choice rule on the class.">
        [metadata reference]
    quantityMultiplier QuantityMultiplier (0..1) <"Quantity multiplier is specified on top of a reference quantity and is used as a multiplying factor when resolving the quantity. A quantity multiplier can only exist when the resolvable quantity specifies a reference quantity.">
    reset boolean (0..1) <"Whether the quantity is resettable">
    futureValueNotional FutureValueAmount (0..1) <"The future value notional is specific to BRL CDI swaps, and is specified alongside the notional amount. The value is calculated as follows: Future Value Notional = Notional Amount * (1 + Fixed Rate) ^ (Fixed Rate Day Count Fraction). The currency should always match that expressed in the notional schedule. The value date should match the adjusted termination date.">
    priceSchedule PriceSchedule (0..*) <"A payout's price specified as a schedule, which may also contain a single value if that price is constant. There may be multiple prices specified for a single payout: e.g. a floating interest rate leg may specify a spread, a cap and/or floor and a multiplier. The price must be specified outside of the payout in a PriceQuantity object and only referenced inside the payout using an address.">
        [metadata address "pointsTo"=PriceQuantity->price]

    condition QuantityMultiplier: <"A quantity reference must exist when there is a quantity multiplier on a resolvable quantity.">
        if quantityMultiplier exists
        then quantityReference -> reference exists

type PayoutBase: <"A data type that contains the common attributes (e.g. payer and receiver parties) and validation conditions that apply across all payout types">

    payerReceiver PayerReceiver (1..1) <"Canonical representation of the payer and receiver parties applicable to each payout leg.">
    priceQuantity ResolvablePriceQuantity (0..1) <"Each payout leg must implement the quantity concept as a 'resolvable' type, which allows for different payout legs to be linked to each other (e.g. in the case of cross-curreny products).">
    principalPayment PrincipalPayments (0..1) <"The specification of the principal exchange. Optional as only applicable in the case of cross-currency or zero-coupon swaps with a final payment.">
    settlementTerms SettlementTerms (0..1) <"Each payout leg must specifies its settlement terms, including the delivery type (i.e. cash vs physical, and their respective terms), the transfer type (DvP etc.) and settlement date, if any.">

    condition FinalPrincipalAmountExists: <"When a final principal payment is specified, and as long as the quantity is not resettable, the amount of that principal payment (or its present value) must be provided. This condition is implemented at the Payout level and not on PrincipalPayment, because it needs to check whether the quantity may be resettable.">
        if principalPayment -> principalPaymentSchedule -> finalPrincipalPayment exists
                and priceQuantity -> quantitySchedule exists
                and priceQuantity -> reset is absent
        then principalPayment -> principalPaymentSchedule -> finalPrincipalPayment -> principalAmount exists
                or principalPayment -> principalPaymentSchedule -> finalPrincipalPayment -> presentValuePrincipalAmount exists

type CommodityPriceReturnTerms: <"Defines parameters in which the commodity price is assessed.">
    rounding Rounding (0..1) <"Defines rounding rules and precision to be used in the rounding of a number.">
    spread SpreadSchedule (0..1) <"Defines a spread value for one or more defined dates.">
    rollFeature RollFeature (0..1) <"Used in conjunction with an exchange-based pricing source. Identifies a way in which the futures contracts referenced will roll between periods. ">
    conversionFactor number (0..1) <"Defines the conversion applied if the quantity unit on contract is different from unit on referenced underlier.">

type RollFeature: <"Used in conjunction with an exchange-based pricing source. Identifies a way in which the futures contracts referenced will roll between periods. ">
    rollSourceCalendar RollSourceCalendarEnum (0..1) <"Used in conjunction with an exchange-based pricing source. Identifies a date source calendar from which the pricing dates and thus roll to the next contract will be based off (e.g. pricing is based on the NYMEX WTI First Nearby Futures Contract, if Future is chosen, the pricing will roll to the next futures contract on expiration, if ListedOption is chosen, the pricing will roll to the next futures contract on the Option expiration date which is three business days before the expiration of the NYMEX WTI futures contract.) Omitting this element will result in the default behavior expected with the pricing source described within the commodity element.">
    deliveryDateRollConvention Offset (0..1) <"Specifies, for a Commodity Transaction that references a delivery date for a listed future, the day on which the specified future will roll to the next nearby month prior to the expiration of the referenced future. If the future will not roll at all - i.e. the price will be taken from the expiring contract, 0 should be specified here. If the future will roll to the next nearby on the last trading day - i.e. the price will be taken from the next nearby on the last trading day, then 1 should be specified and so on.">

type PricingDates: <"Specifies specific dates or parametric rules for the dates on which the price will be determined">
    specifiedDates AdjustableDates (0..*) <"Defines specified dates on which the price will be determined.">
    parametricDates ParametricDates (0..1) <"Defines rules for the dates on which the price will be determined.">

    condition:
        one-of

type ValuationDate: <"A single object that represents the different methods to specify a valuation date, as used for cash settlement. The Single / Multiple ValuationDate is used for the determination of recovery in a credit event, the RelativeDateOffset is used for cash-settled option, and FxFixingDate is used for cross-currency settlement.">

    singleValuationDate SingleValuationDate (0..1) <"Where single valuation date is specified as being applicable for cash settlement, this element specifies the number of business days after satisfaction of all conditions to settlement when such valuation date occurs. ISDA 2003 Term: Single Valuation Date.">
    multipleValuationDates MultipleValuationDates (0..1) <"Where multiple valuation dates are specified as being applicable for cash settlement, this element specifies (a) the number of applicable valuation dates, and (b) the number of business days after satisfaction of all conditions to settlement when the first such valuation date occurs, and (c) the number of business days thereafter of each successive valuation date. ISDA 2003 Term: Multiple Valuation Dates.">
    valuationDate RelativeDateOffset (0..1) <"The date on which the cash settlement amount will be determined according to the cash settlement method if the parties have not otherwise been able to agree the cash settlement amount. This attribute was formerly part of 'OptionCashSettlement', which is now being harmonised into a common 'CashSettlementTerms' that includes a 'ValuationDate'.">
    fxFixingDate FxFixingDate (0..1) <"The date on which the currency rate will be determined for the purpose of specifying the amount in deliverable currency. This attribute was formerly part of 'NonDeliverableSettlement', which is now being harmonised into a common 'CashSettlementTerms' that includes a 'ValuationDate'.">
    fxFixingSchedule AdjustableDates (0..1) <"The date, when expressed as a schedule of date(s), on which the currency rate will be determined for the purpose of specifying the amount in deliverable currency. This attribute was formerly part of 'NonDeliverableSettlement', which is now being harmonised into a common 'CashSettlementTerms' that includes a 'ValuationDate'.">

    condition:
        one-of

type CashSettlementTerms: <"Defines the terms required to compute and settle a cash settlement amount according to a fixing value, including the fixing source, fixing method and fixing date. In FpML, PhysicalSettlementTerms and CashSettlementTerms extend SettlementTerms. In the CDM, this extension paradigm has not been used because SettlementTerms class has been used for purposes related to securities transactions, while it is not used as such in the FpML standard (i.e. only as an abstract construct.">
    [metadata key]

    cashSettlementMethod CashSettlementMethodEnum (0..1) <"Specifies the type of cash settlement method: cash price, yield curve etc.">
    valuationMethod ValuationMethod (0..1) <"Specifies the parameters required to obtain a valuation, including the source, quotation method (bid, mid etc.) and any applicable quotation amount.">
    valuationDate ValuationDate (0..1) <"Defines the different methods to specify a valuation date, as used for cash settlement. The Single / Multiple ValuationDate is used for the determination of recovery in a credit event, the RelativeDateOffset is used for cash-settled option, and FxFixingDate is used for cross-currency settlement.">
    valuationTime BusinessCenterTime (0..1) <"The time of the cash settlement valuation date when the cash settlement amount will be determined according to the cash settlement method, if the parties have not otherwise been able to agree the cash settlement amount. When using quations, this is the time of day in the specified business center when the calculation agent seeks quotations for an amount of the reference obligation for purposes of cash settlement. ISDA 2003 Term: Valuation Time.">
    cashSettlementAmount Money (0..1) <"The amount paid by the seller to the buyer for cash settlement on the cash settlement date. If not otherwise specified, would typically be calculated as 100 (or the Reference Price) minus the price of the Reference Obligation (all expressed as a percentage) times Floating Rate Payer Calculation Amount. ISDA 2003 Term: Cash Settlement Amount.">
    recoveryFactor number (0..1) <"Used for fixed recovery, specifies the recovery level, determined at contract formation, to be applied on a default. Used to calculate the amount paid by the seller to the buyer for cash settlement on the cash settlement date. Amount calculation is (1 minus the Recovery Factor) multiplied by the Floating Rate Payer Calculation Amount. The currency will be derived from the Floating Rate Payer Calculation Amount.">
    fixedSettlement boolean (0..1) <"Used for Recovery Lock, to indicate whether fixed Settlement is Applicable or Not Applicable. If Buyer fails to deliver an effective Notice of Physical Settlement on or before the Buyer NOPS Cut-off Date, and if Seller fails to deliver an effective Seller NOPS on or before the Seller NOPS Cut-off Date, then either: (a) if Fixed Settlement is specified in the related Confirmation as not applicable, then the Seller NOPS Cut-off Date shall be the Termination Date; or (b) if Fixed Settlement is specified in the related Confirmation as applicable, then: (i) if the Fixed Settlement Amount is a positive number, Seller shall, subject to Section 3.1 (except for the requirement of satisfaction of the Notice of Physical Settlement Condition to Settlement), pay the Fixed Settlement Amount to Buyer on the Fixed Settlement Payment Date; and (ii) if the Fixed Settlement Amount is a negative number, Buyer shall, subject to Section 3.1 (except for the requirement of satisfaction of the Notice of Physical Settlement Condition to Settlement), pay the absolute value of the Fixed Settlement Amount to Seller on the Fixed Settlement Payment Date.">
    accruedInterest boolean (0..1) <"Indicates whether accrued interest is included (true) or not (false). For cash settlement this specifies whether quotations should be obtained inclusive or not of accrued interest. For physical settlement this specifies whether the buyer should deliver the obligation with an outstanding principal balance that includes or excludes accrued interest. ISDA 2003 Term: Include/Exclude Accrued Interest.">

    condition CashSettlementTermsChoice: <"Choice rule to represent an FpML choice construct.">
        optional choice cashSettlementAmount, recoveryFactor

    condition RecoveryFactor: <"FpML specifies recoveryFactor as a RestrictedPercentage, meaning that it is a decimal which value is restricted between 0 and 1.">
        if recoveryFactor exists
        then recoveryFactor >= 0.0 and recoveryFactor <= 1.0

    condition CashCollateralMethod: <"The cash collateral valuation method only applies to mid-market and replacement value methods.">
        if valuationMethod -> cashCollateralValuationMethod exists
        then cashSettlementMethod = CashSettlementMethodEnum -> MidMarketIndicativeQuotations
                or cashSettlementMethod = CashSettlementMethodEnum -> MidMarketIndicativeQuotationsAlternate
                or cashSettlementMethod = CashSettlementMethodEnum -> MidMarketCalculationAgentDetermination
                or cashSettlementMethod = CashSettlementMethodEnum -> ReplacementValueFirmQuotations
                or cashSettlementMethod = CashSettlementMethodEnum -> ReplacementValueCalculationAgentDetermination

    condition MidMarketValuationMethod: <"Certain cash collateral valuation parameters only apply to the mid-market valuation methods.">
        if (valuationMethod -> cashCollateralValuationMethod -> applicableCsa exists
                or valuationMethod -> cashCollateralValuationMethod -> agreedDiscountRate exists
                or valuationMethod -> cashCollateralValuationMethod -> cashCollateralInterestRate exists)
        then cashSettlementMethod = CashSettlementMethodEnum -> MidMarketIndicativeQuotations
                or cashSettlementMethod = CashSettlementMethodEnum -> MidMarketIndicativeQuotationsAlternate
                or cashSettlementMethod = CashSettlementMethodEnum -> MidMarketCalculationAgentDetermination

    condition ReplacementValueMethod: <"Protected party can only be specified for replacement value methods.">
        if valuationMethod -> cashCollateralValuationMethod -> protectedParty exists
        then cashSettlementMethod = CashSettlementMethodEnum -> ReplacementValueFirmQuotations
                or cashSettlementMethod = CashSettlementMethodEnum -> ReplacementValueCalculationAgentDetermination

    condition FirmQuotationMethod: <"Prescribed documentation adjustment can only be specified for firm quotations method.">
        if valuationMethod -> cashCollateralValuationMethod -> prescribedDocumentationAdjustment exists
        then cashSettlementMethod = CashSettlementMethodEnum -> ReplacementValueFirmQuotations

type DeliverableObligations: <"A class to specify all the ISDA terms relevant to defining the deliverable obligations.">

    accruedInterest boolean (0..1) <"Indicates whether accrued interest is included (true) or not (false). For cash settlement this specifies whether quotations should be obtained inclusive or not of accrued interest. For physical settlement this specifies whether the buyer should deliver the obligation with an outstanding principal balance that includes or excludes accrued interest. ISDA 2003 Term: Include/Exclude Accrued Interest.">
    category ObligationCategoryEnum (0..1) <"Used in both obligations and deliverable obligations to represent a class or type of securities which apply. ISDA 2003 Term: Obligation Category/Deliverable Obligation Category.">
    notSubordinated boolean (0..1) <"An obligation and deliverable obligation characteristic. An obligation that ranks at least equal with the most senior Reference Obligation in priority of payment or, if no Reference Obligation is specified in the related Confirmation, the obligations of the Reference Entity that are senior. ISDA 2003 Term: Not Subordinated.">
    specifiedCurrency SpecifiedCurrency (0..1) <"An obligation and deliverable obligation characteristic. The currency or currencies in which an obligation or deliverable obligation must be payable. ISDA 2003 Term: Specified Currency.">
    notSovereignLender boolean (0..1) <"An obligation and deliverable obligation characteristic. Any obligation that is not primarily (majority) owed to a Sovereign or Supranational Organisation. ISDA 2003 Term: Not Sovereign Lender.">
    notDomesticCurrency NotDomesticCurrency (0..1) <"An obligation and deliverable obligation characteristic. Any obligation that is payable in any currency other than the domestic currency. Domestic currency is either the currency so specified or, if no currency is specified, the currency of (a) the reference entity, if the reference entity is a sovereign, or (b) the jurisdiction in which the relevant reference entity is organised, if the reference entity is not a sovereign. ISDA 2003 Term: Not Domestic Currency.">
    notDomesticLaw boolean (0..1) <"An obligation and deliverable obligation characteristic. If the reference entity is a Sovereign, this means any obligation that is not subject to the laws of the reference entity. If the reference entity is not a sovereign, this means any obligation that is not subject to the laws of the jurisdiction of the reference entity. ISDA 2003 Term: Not Domestic Law.">
    listed boolean (0..1) <"An obligation and deliverable obligation characteristic. Indicates whether or not the obligation is quoted, listed or ordinarily purchased and sold on an exchange. ISDA 2003 Term: Listed.">
    notContingent boolean (0..1) <"A deliverable obligation characteristic. In essence Not Contingent means the repayment of principal cannot be dependant on a formula/index, i.e. to prevent the risk of being delivered an instrument that may never pay any element of principal, and to ensure that the obligation is interest bearing (on a regular schedule). ISDA 2003 Term: Not Contingent.">
    notDomesticIssuance boolean (0..1) <"An obligation and deliverable obligation characteristic. Any obligation other than an obligation that was intended to be offered for sale primarily in the domestic market of the relevant Reference Entity. This specifies that the obligation must be an internationally recognised bond. ISDA 2003 Term: Not Domestic Issuance.">
    assignableLoan PCDeliverableObligationCharac (0..1) <"A deliverable obligation characteristic. A loan that is freely assignable to a bank or financial institution without the consent of the Reference Entity or the guarantor, if any, of the loan (or the consent of the applicable borrower if a Reference Entity is guaranteeing the loan) or any agent. ISDA 2003 Term: Assignable Loan.">
    consentRequiredLoan PCDeliverableObligationCharac (0..1) <"A deliverable obligation characteristic. A loan that is capable of being assigned with the consent of the Reference Entity or the guarantor, if any, of the loan or any agent. ISDA 2003 Term: Consent Required Loan.">
    directLoanParticipation LoanParticipation (0..1) <"A deliverable obligation characteristic. A loan with a participation agreement whereby the buyer is capable of creating, or procuring the creation of, a contractual right in favour of the seller that provides the seller with recourse to the participation seller for a specified share in any payments due under the relevant loan which are received by the participation seller. ISDA 2003 Term: Direct Loan Participation.">
    transferable boolean (0..1) <"A deliverable obligation characteristic. An obligation that is transferable to institutional investors without any contractual, statutory or regulatory restrictions. ISDA 2003 Term: Transferable.">
    maximumMaturity Period (0..1) <"A deliverable obligation characteristic. An obligation that has a remaining maturity from the Physical Settlement Date of not greater than the period specified. ISDA 2003 Term: Maximum Maturity.">
    acceleratedOrMatured boolean (0..1) <"A deliverable obligation characteristic. An obligation at time of default is due to mature and due to be repaid, or as a result of downgrade/bankruptcy is due to be repaid as a result of an acceleration clause. ISDA 2003 Term: Accelerated or Matured.">
    notBearer boolean (0..1) <"A deliverable obligation characteristic. Any obligation that is not a bearer instrument. This applies to Bonds only and is meant to avoid tax, fraud and security/delivery provisions that can potentially be associated with Bearer Bonds. ISDA 2003 Term: Not Bearer.">
    fullFaithAndCreditObLiability boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S. Municipal as Reference Entity. ISDA 2003 Term: Full Faith and Credit Obligation Liability.">
    generalFundObligationLiability boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S. Municipal as Reference Entity. ISDA 2003 Term: General Fund Obligation Liability.">
    revenueObligationLiability boolean (0..1) <"An obligation and deliverable obligation characteristic. Defined in the ISDA published additional provisions for U.S. Municipal as Reference Entity. ISDA 2003 Term: Revenue Obligation Liability.">
    indirectLoanParticipation LoanParticipation (0..1) <"ISDA 1999 Term: Indirect Loan Participation. NOTE: Only applicable as a deliverable obligation under ISDA Credit 1999.">
    excluded string (0..1) <"A free format string to specify any excluded obligations or deliverable obligations, as the case may be, of the reference entity or excluded types of obligations or deliverable obligations. ISDA 2003 Term: Excluded Obligations/Excluded Deliverable Obligations.">
    othReferenceEntityObligations string (0..1) <"This element is used to specify any other obligations of a reference entity in both obligations and deliverable obligations. The obligations can be specified free-form. ISDA 2003 Term: Other Obligations of a Reference Entity.">

    condition DeliverableObligationsChoice: <"Choice rule to represent an FpML choice construct.">
        optional choice fullFaithAndCreditObLiability, generalFundObligationLiability, revenueObligationLiability

    condition FpML_cd_34: <"FpML validation rule cd-34 - Context: DeliverableObligations. If category is equal to 'ReferenceObligationsOnly', then no other elements may be contained in the deliverable obligations element.">
        if category exists and category = ObligationCategoryEnum -> ReferenceObligationsOnly
        then acceleratedOrMatured is absent
                and accruedInterest is absent
                and assignableLoan is absent
                and consentRequiredLoan is absent
                and directLoanParticipation is absent
                and excluded is absent
                and fullFaithAndCreditObLiability is absent
                and generalFundObligationLiability is absent
                and indirectLoanParticipation is absent
                and listed is absent
                and maximumMaturity is absent
                and notBearer is absent
                and notContingent is absent
                and notDomesticCurrency is absent
                and notDomesticIssuance is absent
                and notDomesticLaw is absent
                and notSovereignLender is absent
                and notSubordinated is absent
                and othReferenceEntityObligations is absent
                and revenueObligationLiability is absent
                and specifiedCurrency is absent
                and transferable is absent

type LoanParticipation extends PCDeliverableObligationCharac: <"A class to specify loan with a participation agreement whereby the buyer is capable of creating, or procuring the creation of, a contractual right in favour of the seller that provides the seller with recourse to the participation seller for a specified share in any payments due under the relevant loan which are received by the participation seller. ISDA 2003 Term: Direct Loan Participation.">

    qualifyingParticipationSeller string (0..1) <"If Direct Loan Participation is specified as a deliverable obligation characteristic, this specifies any requirements for the Qualifying Participation Seller. The requirements may be listed free-form. ISDA 2003 Term: Qualifying Participation Seller.">

type PCDeliverableObligationCharac: <"A class to specify the Partial Cash Deliverable Obligation Characteristic.">

    applicable boolean (1..1) <"Indicates whether the provision is applicable.">
    partialCashSettlement boolean (0..1) <"Specifies whether either 'Partial Cash Settlement of Assignable Loans', 'Partial Cash Settlement of Consent Required Loans' or 'Partial Cash Settlement of Participations' is applicable. If this element is specified and Assignable Loan is a Deliverable Obligation Characteristic, any Assignable Loan that is deliverable, but where a non-receipt of Consent by the Physical Settlement Date has occurred, the Loan can be cash settled rather than physically delivered. If this element is specified and Consent Required Loan is a Deliverable Obligation Characteristic, any Consent Required Loan that is deliverable, but where a non-receipt of Consent by the Physical Settlement Date has occurred, the Loan can be cash settled rather than physically delivered. If this element is specified and Direct Loan Participation is a Deliverable Obligation Characteristic, any Participation that is deliverable, but where this participation has not been effected (has not come into effect) by the Physical Settlement Date, the participation can be cash settled rather than physically delivered.">

type PhysicalSettlementPeriod:

    businessDaysNotSpecified boolean (0..1) <"An explicit indication that a number of business days are not specified and therefore ISDA fallback provisions should apply.">
    businessDays int (0..1) <"A number of business days. Its precise meaning is dependant on the context in which this element is used. ISDA 2003 Term: Business Day.">
    maximumBusinessDays int (0..1) <"A maximum number of business days. Its precise meaning is dependant on the context in which this element is used. Intended to be used to limit a particular ISDA fallback provision.">
    condition:
        one-of

    condition BusinessDays: <"FpML specifies businessDays as a NonNegativeInteger.">
        if businessDays exists then businessDays >= 0

    condition MaximumBusinessDays: <"FpML specifies maximumBusinessDays as a NonNegativeInteger.">
        if maximumBusinessDays exists then maximumBusinessDays >= 0

type PhysicalSettlementTerms: <"Specifies Physical Settlement Terms characteristics for the settlement of a Credit Default Swap or Option.">
    [metadata key]

    clearedPhysicalSettlement boolean (0..1) <"Specifies whether the swap resulting from physical settlement of the swaption transaction will clear through a clearing house. The meaning of Cleared Physical Settlement is defined in the 2006 ISDA Definitions, Section 15.2 (published in Supplement number 28).">
    predeterminedClearingOrganizationParty AncillaryRoleEnum (0..1) <"Specifies the clearing organization (CCP, DCO) to which the trade should be cleared.">
    physicalSettlementPeriod PhysicalSettlementPeriod (0..1) <"The number of business days used in the determination of the physical settlement date. The physical settlement date is this number of business days after all applicable conditions to settlement are satisfied. If a number of business days is not specified fallback provisions apply for determining the number of business days. If Section 8.5/8.6 of the 1999/2003 ISDA Definitions are to apply the businessDaysNotSpecified element should be included. If a specified number of business days are to apply these should be specified in the businessDays element. If Section 8.5/8.6 of the 1999/2003 ISDA Definitions are to apply but capped at a maximum number of business days then the maximum number should be specified in the maximumBusinessDays element. ISDA 2003 Term: Physical Settlement Period.">
    deliverableObligations DeliverableObligations (0..1) <"This element contains all the ISDA terms relevant to defining the deliverable obligations.">
    escrow boolean (0..1) <"If this element is specified and set to 'true', indicates that physical settlement must take place through the use of an escrow agent. (For Canadian counterparties this is always 'Not Applicable'. ISDA 2003 Term: Escrow.">
    sixtyBusinessDaySettlementCap boolean (0..1) <"If this element is specified and set to 'true', for a transaction documented under the 2003 ISDA Credit Derivatives Definitions, has the effect of incorporating the language set forth below into the confirmation. The section references are to the 2003 ISDA Credit Derivatives Definitions. Notwithstanding Section 1.7 or any provisions of Sections 9.9 or 9.10 to the contrary, but without prejudice to Section 9.3 and (where applicable) Sections 9.4, 9.5 and 9.6, if the Termination Date has not occurred on or prior to the date that is 60 Business Days following the Physical Settlement Date, such 60th Business Day shall be deemed to be the Termination Date with respect to this Transaction except in relation to any portion of the Transaction (an 'Affected Portion') in respect of which: (1) a valid notice of Buy-in Price has been delivered that is effective fewer than three Business Days prior to such 60th Business Day, in which case the Termination Date for that Affected Portion shall be the third Business Day following the date on which such notice is effective; or (2) Buyer has purchased but not Delivered Deliverable Obligations validly specified by Seller pursuant to Section 9.10(b), in which case the Termination Date for that Affected Portion shall be the tenth Business Day following the date on which Seller validly specified such Deliverable Obligations to Buyer.">

    condition PredeterminedClearingOrganizationParty:
        if predeterminedClearingOrganizationParty exists
        then predeterminedClearingOrganizationParty = AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

type PercentageRule: <"A class defining a content model for a calculation rule defined as percentage of the notional amount.">

    paymentPercent number (1..1) <"A percentage of the notional amount.">
    notionalAmountReference Money (1..1) <"A reference to the notional amount.">
        [metadata reference]

type SettlementDate: <"A data defining the settlement date(s) for cash or physical settlement as either a set of explicit dates, together with applicable adjustments, or as a date relative to some other (anchor) date, or as any date in a range of contiguous business days. This data type provides a level of abstraction on top of the different legacy methods used to specify a settlement / payment date, which vary across product types, asset classes and delivery types.">
    [metadata key]

    adjustableOrRelativeDate AdjustableOrAdjustedOrRelativeDate (0..1) <"A single settlement date subject to adjustment or specified as relative to another date (e.g. the trade date). This attribute was formerly part of 'SettlementTerms', which is now being harmonised to include a common 'SettlementDate', as inherited from 'SettlementBase'.">
    valueDate date (0..1) <"The settlement date for a forward settling product. For Foreign Exchange contracts, this represents a common settlement date between both currency legs. To specify different settlement dates for each currency leg, see the ForeignExchange class. This attribute was formerly part of 'SettlementTerms', which is now being harmonised to include a common 'SettlementDate', as inherited from 'SettlementBase'.">
    adjustableDates AdjustableDates (0..1) <"A series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date. This attributes was formerly part of 'CashSettlementPaymentDate' as included into 'OptionCashSettlement' (which is now merged into a unique 'CashSettlementTerms' data type.">
    businessDateRange BusinessDateRange (0..1) <"A range of contiguous business days. This attribute is meant to be merged with the 'settlementDate' at some future point once we refactor 'Date' to use a single complex type across the model. This attributes was formerly part of 'CashSettlementPaymentDate', as included into 'OptionCashSettlement' (which is now merged into a unique 'CashSettlementTerms' data type.">
    cashSettlementBusinessDays int (0..1) <"The number of business days used in the determination of the cash settlement payment date. If a cash settlement amount is specified, the cash settlement payment date will be this number of business days following the calculation of the final price. If a cash settlement amount is not specified, the cash settlement payment date will be this number of business days after all conditions to settlement are satisfied. ISDA 2003 Term: Cash Settlement Date. This attribute was formerly part of 'CashSettlementTerms' as used for credit event settlement, which now includes a common 'SettlementDate' attribute.">
    paymentDelay boolean (0..1) <"Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a payment delay of 5 days between the coupon date of the reference obligation and the payment date of the synthetic swap. CMBS do not, on the other hand, with both payment dates being on the 25th of each month.">

    condition BusinessDays: <"FpML specifies cashSettlementBusinessDays as a nonNegativeInteger. If cashSettlementBusinessDays is not specified, then another settlement date method must be specified.">
        if cashSettlementBusinessDays exists
        then cashSettlementBusinessDays >= 0
        else adjustableOrRelativeDate exists
            or valueDate exists
            or adjustableDates exists
            or businessDateRange exists

    condition DateChoice: <"Settlement date must be specified either throught the 'settlementDate' or 'valueDate' attribute. This is a temporary work-around until such time when we can retire the 'valueDate' attribute.">
        optional choice adjustableOrRelativeDate, valueDate, adjustableDates, businessDateRange

type FxFixingDate extends Offset: <"Extends the Offset structure to specify an FX fixing date as an offset to dates specified somewhere else in the document.">

    businessDayConvention BusinessDayConventionEnum (0..1) <"The convention for adjusting a date if it would otherwise fall on a day that is not a business day, as specified by an ISDA convention (e.g. Following, Precedent).">
    businessCenters BusinessCenters (0..1)
    businessCentersReference BusinessCenters (0..1) <"A reference to a set of financial business centers defined elsewhere in the document. This set of business centers is used to determine whether a particular day is a business day or not.">
        [metadata reference]
    dateRelativeToPaymentDates DateRelativeToPaymentDates (0..1) <"The payment date references on which settlements in non-deliverable currency are due and will then have to be converted according to the terms specified through the other parts of the nonDeliverableSettlement structure.">
    dateRelativeToCalculationPeriodDates DateRelativeToCalculationPeriodDates (0..1) <"The calculation period references on which settlements in non-deliverable currency are due and will then have to be converted according to the terms specified through the other parts of the nonDeliverableSettlement structure. Implemented for Brazilian-CDI swaps where it will refer to the termination date of the appropriate leg.">
    dateRelativeToValuationDates DateRelativeToValuationDates (0..1) <"The calculation period references on which settlements in non-deliverable currency are due and will then have to be converted according to the terms specified through the other parts of the nonDeliverableSettlement structure. Implemented for Brazilian-CDI swaps where it will refer to the termination date of the appropriate leg.">
    fxFixingDate AdjustableOrRelativeDate (0..1) <"Describes the specific date when a non-deliverable forward or cash-settled option will 'fix' against a particular rate, which will be used to compute the ultimate cash settlement. This element should be omitted where a single, discrete fixing date cannot be identified e.g. on an american option, where fixing may occur at any date on a continuous range.  This attribute was formerly part of 'fxSettlementTerms', which is now being harmonised into a common 'CashSettlementTerms' that includes a 'ValuationDate'.">

    condition BusinessCentersChoice: <"condition to represent an FpML choice construct.">
        optional choice businessCenters, businessCentersReference

    condition DateChoice: <"condition to represent an FpML choice construct.">
        required choice dateRelativeToPaymentDates, dateRelativeToCalculationPeriodDates, dateRelativeToValuationDates, fxFixingDate

type SettlementTerms extends SettlementBase: <"Specifies the settlement terms, which can either be cash, physical, or fx-based cash-settlement. This class can be used for the settlement of options and forwards, cash transactions (e.g. securities or foreign exchange), or in case of credit event.">
    cashSettlementTerms CashSettlementTerms (0..*) <"Specifies the parameters associated with the cash settlement procedure.">
    physicalSettlementTerms PhysicalSettlementTerms (0..1) <"Specifies the physical settlement terms which apply to the transaction.">

    condition OptionSettlementChoice: <"The option settlement cannot combine both physical and cash terms specification.">
        if cashSettlementTerms exists and physicalSettlementTerms exists
        then settlementType = SettlementTypeEnum -> Election
                or settlementType = SettlementTypeEnum -> CashOrPhysical

    condition CashSettlementTerms: <"If the cash settlement terms are specified, then the settlementType can either be Cash, Election or CashOrPhysical">
        if cashSettlementTerms exists
        then settlementType <> SettlementTypeEnum -> Physical

    condition PhysicalSettlementTerms: <"If the physical settlement terms are specified, then the settlementType can either be Physical, Election or CashOrPhysical">
        if physicalSettlementTerms exists /* or fxSettlementTerms exists*/
        then settlementType <> SettlementTypeEnum -> Cash

type FixedPrice: <"A predefined price accorded by the counterparties.">

    price PriceSchedule (0..1) <"Fixed price step schedule, including an initial price specified as an absolute number.">
        [metadata address "pointsTo"=PriceQuantity->price]

    condition NonNegativePrice_amount: <"For a non-negative price, the amount attribute must be positive.">
        if price -> value exists
        then price -> value >= 0.0 and if price -> datedValue exists
                then price -> datedValue -> value all >= 0.0

type PaymentDetail:
    [metadata key]

    paymentDate AdjustableOrRelativeDate (0..1)
    paymentRule PaymentRule (1..1) <"The calculation rule.">
    paymentAmount Money (0..1) <"A fixed payment amount.">

type PaymentDiscounting: <"This class corresponds to the FpML PaymentDiscounting.model group for representing the discounting elements that can be associated with a payment.">
    discountFactor number (0..1) <"The value representing the discount factor used to calculate the present value of the cash flow.">
    presentValueAmount Money (0..1) <"The amount representing the present value of the forecast payment.">

type PaymentRule: <"A class defining the payment calculation rule. As of FpML 5.10, percentage rule is the only calculation rule that has been specified as part of the standard.">

    percentageRule PercentageRule (0..1) <"This attribute is not present as part of the FpML construct, as the payment rule is specialised by means of runtime type extension through the xsi:type.">

type PrincipalPayments: <"A class defining which principal exchanges occur for the stream.">
    [metadata key]

    initialPayment boolean (1..1) <"A true/false flag to indicate whether there is an initial exchange of principal on the effective date.">
    finalPayment boolean (1..1) <"A true/false flag to indicate whether there is a final exchange of principal on the termination date.">
    intermediatePayment boolean (1..1) <"A true/false flag to indicate whether there are intermediate or interim exchanges of principal during the term of the swap.">
    varyingLegNotionalCurrency string (0..*) <"Indicate the Payout legs which nominal amount may vary in regards of FX Fixing dates as determined in the product terms.">
    principalPaymentSchedule PrincipalPaymentSchedule (0..1) <"Describe dates schedules for Principal Exchanges and related role of the parties when known.">

type PrincipalPaymentSchedule: <"Describe dates schedules for Principal Exchanges and related role of the parties when known.">
    initialPrincipalPayment PrincipalPayment (0..1) <"Principal Payment made at Trade inception.">
    intermediatePrincipalPayment AdjustableRelativeOrPeriodicDates (0..1) <"Principal Payment as part of the Trade lifecycle e.g. as part of notional reset adjustements in a Cross Currency Swap with a varying notional leg.">
    finalPrincipalPayment PrincipalPayment (0..1) <"Principal Payment at Trade maturity">

    condition InitialPrincipalAmountExists: <"When an initial principal payment is specified, the amount of that principal payment (or its present value) must be provided. This condition is implemented at the PrincipalPaymentSchedule level and not on PrincipalPayment, because it only applies to the initial principal payment.">
        if initialPrincipalPayment exists
        then initialPrincipalPayment -> principalAmount exists
                or initialPrincipalPayment -> presentValuePrincipalAmount exists

type PrincipalPayment: <"Any kind of principal payments when the amount is known and thus fixed.">
    [metadata key]
    principalPaymentDate AdjustableDate (0..1) <"The date where the PrincipalPayment shall be settled.">
    payerReceiver PayerReceiver (0..1) <"Specifies the parties responsible for making and receiving payments defined by this structure.">
    principalAmount Money (0..1) <"When known at the time the transaction is made, the cash amount to be paid.">
    discountFactor number (0..1) <"The value representing the discount factor used to calculate the present value of the principal payment amount.">
    presentValuePrincipalAmount Money (0..1) <"The amount representing the present value of the principal payment.">

    condition PrincipalAmount:
        optional choice principalAmount, presentValuePrincipalAmount

    condition DiscountFactor:
        if presentValuePrincipalAmount exists
        then discountFactor exists

type SettlementBase: <"A base class to be extended by the SettlementTerms class.">
    [metadata key]

    settlementType SettlementTypeEnum (1..1) <"Whether the settlement will be cash, physical, by election, ...">
    transferSettlementType TransferSettlementEnum (0..1) <"The qualification as to how the transfer will settle, e.g. a DvP settlement.">
    settlementCurrency string (0..1) <"The settlement currency is to be specified when the Settlement Amount cannot be known in advance. The list of valid currencies is not presently positioned as an enumeration as part of the CDM because that scope is limited to the values specified by ISDA and FpML. As a result, implementers have to make reference to the relevant standard, such as the ISO 4217 standard for currency codes.">
        [metadata scheme]
        [docReference ICMA GMRA namingConvention "Contractual Currency"
            provision "As defined in GMRA paragraph 2(k)/ paragraph 7(a) All the payments made in respect of the Purchase Price or the Repurchase Price of any Transaction shall be made in the currency of the Purchase Price (the Contractual Currency) save as provided in paragraph 10(d)(ii). Notwithstanding the foregoing, the payee of any money may, at its option, accept tender thereof in any other currency, provided, however, that, to the extent permitted by applicable law, the obligation of the payer to pay such money will be discharged only to the extent of the amount of the Contractual Currency that such payee may, consistent with normal banking procedures, purchase with such other currency (after deduction of any premium and costs of exchange) for delivery within the customary delivery period for spot transactions in respect of the relevant currency."]
    settlementDate SettlementDate (0..1) <"The date on which the settlement amount will be paid, subject to adjustment in accordance with any applicable business day convention. This component would not be present for a mandatory early termination provision where the cash settlement payment date is the mandatory early termination date.">
    settlementCentre SettlementCentreEnum (0..1) <"Optional settlement centre as an enumerated list: Euroclear, Clearstream.">
    settlementProvision SettlementProvision (0..1) <"Optionally defines the parameters that regulate a settlement.">
    standardSettlementStyle StandardSettlementStyleEnum (0..1) <"Settlement Style.">

//ICMA-P2
type SettlementProvision: <"Defines parameters that regulate a settlement, for instance whether this settlement should be netted with other ones or broken-down into smaller amounts.">
    shapingProvisions ShapingProvision (0..1) <"Defines the parameters that are necessary to 'shape' a settlement, i.e. break it down into smaller amounts.">

type ShapingProvision: <"Defines the applicable settlement limits that may require a settlement to be 'shaped', i.e. broken-down into smaller amounts.">
    shapeSchedule Money (1..*) <"Defines applicable settlement limits in each currency.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-common-type.rosetta
================================================================================

namespace cdm.product.common
version "${project.version}"


================================================================================
FILE: rosetta-source/src/main/rosetta/product-desc.rosetta
================================================================================

namespace cdm.product : <"Generic product concepts: quantity, price, economic terms and payout, that are built using template features.">
version "${project.version}"


================================================================================
FILE: rosetta-source/src/main/rosetta/product-qualification-func.rosetta
================================================================================

namespace cdm.product.qualification
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.mapping.config.*
import cdm.observable.asset.*
import cdm.product.common.settlement.*
import cdm.product.template.*

isProduct root EconomicTerms;

func UnderlierQualification: <"Identifies whether the underlier(s) have either the specified securityType or assetClass.">
    inputs:
        underlier Underlier (1..1) <"An Underlier is an Observable (eg Asset, Basket or Index) or a Product.">
        securityType InstrumentTypeEnum (0..1)
        assetClass AssetClassEnum (0..1)
    output:
        qualifies boolean (1..1)

    set qualifies:
        ObservableQualification(underlier -> Observable, securityType, assetClass)
            or underlier -> Product -> TransferableProduct -> Instrument -> Security -> instrumentType = securityType

// The EconomicTerms of any TransferableProduct or a NonTransferableProduct should be checked outside this function.
func ObservableQualification: <"Identifies whether the observable(s) have either the specified securityType or assetClass.">
    inputs:
        observable Observable (0..1) <"An Observable is an Asset, Basket or Index.">
        securityType InstrumentTypeEnum (0..1)
        assetClass AssetClassEnum (0..1)
    output:
        qualifies boolean (1..1)

    set qualifies:
        observable -> Asset -> Instrument -> Security -> instrumentType = securityType
            or observable -> Index ->> assetClass = assetClass
            or if observable -> Basket exists
                then observable -> Basket -> basketConstituent
                        extract [ ObservableQualification(item, securityType, assetClass) ]
                    all = True
                else False

/*
 * COMPOSABLE PRODUCT QUALIFICATION based on ISDA Taxonomy v2
 * AssetClass - BaseProduct - SubProduct - TransactionType

 * Level 1 - ASSETCLASS:
 *  - InterestRate : Qualify_AssetClass_InsterestRate
 *  - ForeignExchange: Qualify_AssetClass_ForeignExchange
 *  - Credit: Qualify_AssetClass_Credit
 *  - Equity: Qualify_AssetClass_Equity
 *  - Commodity: Qualify_AssetClass_Commodity
 */
func Qualify_AssetClass_InterestRate: <"Qualifies a product as having the Asset Class classification Interest Rate.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias optionUnderlier: economicTerms -> payout -> OptionPayout only-element -> underlier
    alias settlementUnderlier:
        economicTerms -> payout -> SettlementPayout only-element -> underlier

    set is_product:
        InterestRatePayoutOnlyExists(economicTerms -> payout)
            or (economicTerms -> payout only-element -> OptionPayout exists
                and (ObservableQualification(
                        optionUnderlier -> Observable,
                        InstrumentTypeEnum -> Debt,
                        AssetClassEnum -> InterestRate
                    )
                    or optionUnderlier -> Product -> TransferableProduct -> Instrument ->> instrumentType = InstrumentTypeEnum -> Debt
                    or if optionUnderlier -> Product exists
                        then Qualify_AssetClass_InterestRate(
                                    optionUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))
            or (economicTerms -> payout only-element -> SettlementPayout exists
                and (UnderlierQualification(
                        settlementUnderlier,
                        InstrumentTypeEnum -> Debt,
                        AssetClassEnum -> InterestRate
                    )
                    or if settlementUnderlier -> Product ->> economicTerms exists
                        then Qualify_AssetClass_InterestRate(
                                    settlementUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))

func Qualify_AssetClass_Credit: <"Qualifies a product as having the Asset Class classification Credit Default.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias optionUnderlier: economicTerms -> payout -> OptionPayout only-element -> underlier
    alias settlementUnderlier:
        economicTerms -> payout -> SettlementPayout only-element -> underlier
    alias performanceUnderlier:
        economicTerms -> payout -> PerformancePayout only-element -> underlier

    set is_product:
        economicTerms -> payout only-element -> CreditDefaultPayout exists
            or (economicTerms -> payout count = 2
                and economicTerms -> payout -> CreditDefaultPayout exists
                and economicTerms -> payout -> InterestRatePayout exists)
            or (economicTerms -> payout only-element -> OptionPayout exists
                and (ObservableQualification(
                        optionUnderlier -> Observable,
                        empty,
                        AssetClassEnum -> Credit
                    )
                    or if optionUnderlier -> Product exists
                        then Qualify_AssetClass_Credit(
                                    optionUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))
            or (economicTerms -> payout only-element -> SettlementPayout exists
                and (UnderlierQualification(
                        settlementUnderlier,
                        empty,
                        AssetClassEnum -> Credit
                    )
                    or if settlementUnderlier -> Product ->> economicTerms exists
                        then Qualify_AssetClass_Credit(
                                    settlementUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))
                    // Interest Rate Payout + Performance Payout (Total Return Swap with a debt instrument as underlier)
            or ((economicTerms -> payout count = 2
                and economicTerms -> payout -> CreditDefaultPayout exists
                and economicTerms -> payout -> PerformancePayout exists)
                and if performanceUnderlier exists
                    then (performanceUnderlier -> Observable -> Asset -> Instrument ->> instrumentType = InstrumentTypeEnum -> Debt))

func Qualify_AssetClass_ForeignExchange: <"Qualifies a product as having the Asset Class classification Foreign Exchange">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias optionUnderlier: economicTerms -> payout -> OptionPayout only-element -> underlier
    alias settlementUnderliers: economicTerms -> payout -> SettlementPayout -> underlier

    set is_product:
        (SettlementPayoutOnlyExists(economicTerms -> payout)
                and (settlementUnderliers extract [ Observable -> Asset -> Cash exists ]
                    all = True
                    or settlementUnderliers
                        extract [
                            UnderlierQualification(
                                    item,
                                    empty,
                                    AssetClassEnum -> ForeignExchange
                                )
                        ] all = True))
            or economicTerms -> payout -> PerformancePayout -> underlier -> Observable -> Index -> ForeignExchangeRateIndex exists
            or (economicTerms -> payout only-element -> OptionPayout exists
                and (optionUnderlier -> Observable -> Asset -> Cash exists
                    or if optionUnderlier -> Product exists
                        then Qualify_AssetClass_ForeignExchange(
                                    optionUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))

func Qualify_AssetClass_Equity:
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias optionUnderlier: economicTerms -> payout -> OptionPayout only-element -> underlier
    alias settlementUnderlier:
        economicTerms -> payout -> SettlementPayout only-element -> underlier

    set is_product:
        (economicTerms -> payout -> PerformancePayout exists
                and economicTerms -> payout -> PerformancePayout -> underlier -> Observable
                    extract [ Qualify_UnderlierObservable_Equity ]
                all = True)
            or (economicTerms -> payout only-element -> OptionPayout exists
                and (Qualify_UnderlierObservable_Equity(optionUnderlier -> Observable)
                    or if optionUnderlier -> Product exists
                        then Qualify_AssetClass_Equity(
                                    optionUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))
            or (economicTerms -> payout only-element -> SettlementPayout exists
                and (Qualify_UnderlierObservable_Equity(settlementUnderlier -> Observable)
                    or if settlementUnderlier -> Product ->> economicTerms exists
                        then Qualify_AssetClass_Equity(
                                    settlementUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))

func Qualify_AssetClass_Commodity: <"Qualifies a product as having the Asset Class classification Commodity">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias optionUnderlier: economicTerms -> payout -> OptionPayout only-element -> underlier

    alias settlementUnderlier:
        economicTerms -> payout -> SettlementPayout only-element -> underlier

    set is_product:
        // Regular Commodity Swap
        (economicTerms -> payout count = 2
                and economicTerms -> payout -> CommodityPayout exists
                and economicTerms -> payout -> FixedPricePayout exists)
                    // Commodity Basis Swap
            or (economicTerms -> payout -> CommodityPayout count = 2
                and CommodityPayoutOnlyExists(economicTerms -> payout))
                    // Commodity Option
            or (economicTerms -> payout only-element -> OptionPayout exists
                and (optionUnderlier -> Observable -> Asset -> Commodity exists
                    or optionUnderlier -> Product -> TransferableProduct -> Commodity exists
                    or if optionUnderlier -> Product exists
                        then Qualify_AssetClass_Commodity(
                                    optionUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))
                    // Commodity Spot or Forward
            or (((economicTerms -> payout count = 2
                        and economicTerms -> payout -> SettlementPayout exists
                        and economicTerms -> payout -> FixedPricePayout exists)
                    or (economicTerms -> payout count = 2
                        and economicTerms -> payout -> SettlementPayout exists
                        and economicTerms -> payout -> CommodityPayout exists)
                    or economicTerms -> payout only-element -> SettlementPayout exists)
                and (economicTerms -> payout -> SettlementPayout -> underlier -> Observable -> Asset -> Commodity exists
                    or settlementUnderlier -> Product -> TransferableProduct -> Commodity exists
                    or if settlementUnderlier -> Product ->> economicTerms exists
                        then Qualify_AssetClass_Commodity(
                                    settlementUnderlier -> Product ->> economicTerms
                                ) = True
                        else False))

/*
 * ENDOF Qualification of ISDA Taxonomy V2 Level 1 - ASSETCLASS:
 */
func Qualify_CreditDefaultSwap_SingleName: <"Qualifies a product as a Credit Default Swap which provides protection relative to defaults of a reference entity that could be a corporate, municipal, sovereign, or special purpose vehicle issuer of publicly traded debt.  The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit default leg and one interest leg, 2) the reference entity is corporate, municipal, or sovereign issuer of debt, 3) the reference obligation is not a loan, and 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_Credit(economicTerms) = True
                // qualifies the Credit Default Swap as having a single name underlyer that is not a loan
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan is absent

func Qualify_CreditDefaultSwap_Index: <"Qualifies a product as a Credit Default Swap which provides protection relative to the performance of an index. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit default leg and one interest leg, 2) the reference entity is an index, and 3) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_Credit(economicTerms) = True
                // qualifies the Credit Default Swap as having a single name underlyer that is not a loan
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation exists
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation -> tranche is absent

func Qualify_CreditDefaultSwap_IndexTranche: <"Qualifies a product as a Credit Default Swap which provides protection relative to the performance of an index. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit default leg and one interest leg, 2) the reference entity is an index, and 3) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_Credit(economicTerms) = True
                // qualifies the Credit Default Swap as having a single name underlyer that is not a loan
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation exists
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation -> tranche exists

func Qualify_CreditDefaultSwap_Loan: <"Qualifies a product as a Credit Default Swap which provides protection relative to defaults of a reference entity that is a loan. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit default leg and one interest leg, 2) the reference entity is a loan, and there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_Credit(economicTerms) = True
                // qualifies the Credit Default Swap as having a single name underlyer that is not a loan
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation exists
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan exists

func Qualify_CreditDefaultSwap_Basket: <"Qualifies a product as a Credit Default Swap which provides protection relative to defaults of a reference entity that is a loan. The determination of the qualification is based on the economic terms and the following criteria: 1) A product with one credit default leg and one interest leg, 2) the reference entity is a loan, and there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_Credit(economicTerms) = True
                // qualifies the Credit Default Swap as having a single name underlyer that is not a loan
            and economicTerms -> payout -> CreditDefaultPayout -> generalTerms -> basketReferenceInformation exists

func Qualify_CreditDefaultSwaption: <"This product qualification is temporary until such time that the ISDA Credit Group specifies a proper taxonomy for credit derivatives that is based upon economic terms.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout only-element -> OptionPayout exists
            and Qualify_AssetClass_Credit(
                    economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms
                ) = True

func Qualify_UnderlierObservable_Equity: <"Qualifies an Observable as having the Asset Class classification Equity.">
    inputs:
        observable Observable (1..1)
    output:
        is_product boolean (1..1)

    set is_product:
        Qualify_InstrumentTypeEquity(observable -> Asset -> Instrument)
            or observable -> Index ->> assetClass = AssetClassEnum -> Equity
                // Qualifies that the underlier is a basket composed of equity products only
            or (observable -> Basket exists
                and observable -> Basket -> basketConstituent
                    extract [ Qualify_UnderlierObservable_Equity ]
                any = True)

func Qualify_InstrumentTypeEquity: <"Qualifies that the security type, for all of the provided securities, is Equity-related.">
    inputs:
        instrument Instrument (1..1)
    output:
        is_equity boolean (1..1)

    alias instrumentType: instrument ->> instrumentType

    set is_equity:
        instrumentType = InstrumentTypeEnum -> Equity
            or (instrumentType = InstrumentTypeEnum -> Fund
                and instrument -> Security -> fundType = FundProductTypeEnum -> ExchangeTradedFund)
            or (instrumentType = InstrumentTypeEnum -> Fund
                and instrument -> Security -> fundType = FundProductTypeEnum -> MutualFund)
            or instrumentType = InstrumentTypeEnum -> Warrant

func Qualify_BaseProduct_EquitySwap: <"Qualifies a product as having the Asset Class classification Equity and Base Product Classification Swap.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    set is_product:
        // all underliers must be equity asset class
        Qualify_AssetClass_Equity(economicTerms) = True
            and ( // Interest Rate Payout + Performance Payout (Price Return Swap, Total Return Swap)
            PerformancePayoutAndInterestRatePayoutOnlyExists(economicTerms -> payout)
                // Performance Payout + Fixed Price Payout (Dividend Swap)
                or PerformancePayoutAndFixedPricePayoutOnlyExists(economicTerms -> payout)
                    // Performance Payout only (Variance, Volatility and Correlation Swap)
                or (PerformancePayoutOnlyExists(economicTerms -> payout)))

func Qualify_EquitySwap_PriceReturnBasicPerformance_SingleName: <"Qualifies a product as an Equity Swap for which the performance is based on the price change on a single stock.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one performance leg and one interest leg 2) with the former featuring priceReturnTerms, 3) the underlier is an equity security, a fund, an exchange traded fund, mutual fund, or warrant, and 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_PriceReturnBasicPerformance_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_PriceReturnBasicPerformance_SingleName"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is exactly one performance leg, one interest rate leg and no legs of other types
            (economicTerms -> payout count = 2
                and economicTerms -> payout -> InterestRatePayout exists
                and economicTerms -> payout -> PerformancePayout exists)
            and // qualifies that the performance leg has priceReturnTerms
            performancePayout -> returnTerms -> priceReturnTerms only exists
            and // qualifies that underlier is a security (single name)
            performancePayout -> underlier -> Observable -> Asset -> Instrument -> Security exists

func Qualify_EquitySwap_TotalReturnBasicPerformance_SingleName: <"Qualifies a product as an Equity Swap for which the performance is based on the price changes and dividend returns on a single stock.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one performance leg and one interest leg 2) with the former featuring priceReturnTerms and dividendReturnTerms, 3) the underlier is an equity security, a fund, an exchange traded fund, mutual fund, or warrant, and 4) there are no option features">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that underlier is a security (single name)
            economicTerms -> payout -> PerformancePayout -> underlier -> Observable -> Asset -> Instrument -> Security exists
            and ( // Intended final payout structure
            // qualifies that there is exactly two performance legs, one interest rate leg and no legs of other types
            (economicTerms -> payout count = 3
                    and economicTerms -> payout -> InterestRatePayout count = 1
                    and economicTerms -> payout -> PerformancePayout count = 2)
                or // Provisional payout structure
                // qualifies that there is 1 performance leg, 1 interest rate leg and no legs of other types
                (economicTerms -> payout count = 2
                    and economicTerms -> payout -> InterestRatePayout exists
                    and economicTerms -> payout -> PerformancePayout exists))
            and // qualifies that there is a performancePayout with dividendReturnTerms and another with priceReturnTerms
            economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists
            and economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms exists

func Qualify_EquitySwap_PriceReturnBasicPerformance_Index: <"Qualifies a product as an Equity Swap for which the performance is based on the price change on an index.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one performance leg and one interest leg 2) with the former featuring priceReturnTerms, 3) the underlier is an index, and 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_PriceReturnBasicPerformance_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_PriceReturnBasicPerformance_SingleIndex"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is exactly one performance leg, one interest rate leg and no legs of other types
            economicTerms -> payout count = 2
            and economicTerms -> payout -> InterestRatePayout exists
            and economicTerms -> payout -> PerformancePayout exists
            and // qualifies that the performance leg has priceReturnTerms
            performancePayout -> returnTerms -> priceReturnTerms only exists
            and // qualifies that underlier is an index
            performancePayout -> underlier -> Observable -> Index exists

func Qualify_EquitySwap_TotalReturnBasicPerformance_Index: <"Qualifies a product as an Equity Swap for which the performance is based on the price changes and dividend returns on an index.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one performance leg and one interest leg 2) with the former featuring priceReturnTerms and dividendReturnTerms, 3) the underlier is an index, and 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that underlier is an index
            economicTerms -> payout -> PerformancePayout -> underlier -> Observable -> Index exists
            and ( // Intended final payout structure
            // qualifies that there is exactly two performance legs, one interest rate leg and no legs of other types
            (economicTerms -> payout count = 3
                    and economicTerms -> payout -> InterestRatePayout count = 1
                    and economicTerms -> payout -> PerformancePayout count = 2)
                or // Provisional payout structure
                // qualifies that there is 1 performance leg, 1 interest rate leg and no legs of other types
                (economicTerms -> payout count = 2
                    and economicTerms -> payout -> InterestRatePayout exists
                    and economicTerms -> payout -> PerformancePayout exists))
            and // qualifies that there is a performancePayout with dividendReturnTerms and another with priceReturnTerms
            economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists
            and economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms exists

func Qualify_EquitySwap_PriceReturnBasicPerformance_Basket: <"Qualifies a product as an Equity Swap for which the performance is based on the price change on a basket.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one performance leg and one interest leg 2) with the former featuring priceReturnTerms, 3) the underlier is a basket and 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_PriceReturnBasicPerformance_Basket"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_PriceReturnBasicPerformance_Basket"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is exactly one performance leg, one interest rate leg and no legs of other types
            economicTerms -> payout count = 2
            and economicTerms -> payout -> InterestRatePayout exists
            and economicTerms -> payout -> PerformancePayout exists
            and // qualifies that underlier is a basket
            performancePayout -> underlier -> Observable -> Basket exists
            and // qualifies that the performance leg has priceReturnTerms
            performancePayout -> returnTerms -> priceReturnTerms only exists

func Qualify_EquitySwap_TotalReturnBasicPerformance_Basket: <"Qualifies a product as an Equity Swap for which the performance is based on the price changes and dividend returns on a basket.  The determination of the qualification is based on the economic terms and the following criteria: 1) An equity product with one performance leg and one interest leg 2) with the former featuring priceReturnTerms and dividendReturnTerms, 3) the underlier is a basket and 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that underlier is a basket
            economicTerms -> payout -> PerformancePayout -> underlier -> Observable -> Basket exists
            and ( // Intended final payout structure
            // qualifies that there is exactly two performance legs, one interest rate leg and no legs of other types
            (PerformancePayoutAndInterestRatePayoutOnlyExists(economicTerms -> payout)
                    and economicTerms -> payout -> InterestRatePayout count = 1
                    and economicTerms -> payout -> PerformancePayout count = 2)
                or // Provisional payout structure
                // qualifies that there is 1 performance leg, 1 interest rate leg and no legs of other types
                (economicTerms -> payout count = 2
                    and economicTerms -> payout -> InterestRatePayout exists
                    and economicTerms -> payout -> PerformancePayout exists))
            and // qualifies that there is a performancePayout with dividendReturnTerms and another with priceReturnTerms
            economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists
            and economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms exists

func Qualify_EquitySwap_ParameterReturnVariance_SingleName: <"Qualifies a product as an Equity Swap for which the performance is based on the variance changes on a single stock.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with a single performance leg, 4) which has variance return terms, 4) the underlier is a single stock, and 5) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnVariance_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnVariance_SingleName"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the only leg has varianceReturnTerms
            performancePayout -> returnTerms -> varianceReturnTerms only exists
            and // qualifies that underlier is a security (single name)
            performancePayout -> underlier -> Observable -> Asset -> Instrument -> Security exists

func Qualify_EquitySwap_ParameterReturnVariance_Index: <"Qualifies a product as an Equity Swap for which the performance is based on the variance changes on an index.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with a single performance leg, 4) which has variance return terms, 5) the underlier is an index, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnVariance_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnVariance_SingleIndex"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the only leg has varianceReturnTerms
            performancePayout -> returnTerms -> varianceReturnTerms only exists
            and // qualifies that underlier is an index
            performancePayout -> underlier -> Observable -> Index exists

func Qualify_EquitySwap_ParameterReturnVariance_Basket: <"Qualifies a product as an Equity Swap for which the performance is based on the variance changes on a basket.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with a single performance leg, 4) which has variance return terms, 5) the underlier is a basket, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnVariance_Basket"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnVariance_Basket"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the only leg has varianceReturnTerms
            performancePayout -> returnTerms -> varianceReturnTerms only exists
            and // qualifies that underlier is a basket
            performancePayout -> underlier -> Observable -> Basket exists

func Qualify_EquitySwap_ParameterReturnDispersion: <"Qualifies a product as an Equity Swap for which the performance is based on the variance changes in several legs.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) more than one performance leg, 4) all of which have variance return terms, and 5) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is more than one leg of performance type
            PerformancePayoutOnlyExists(economicTerms -> payout)
            and economicTerms -> payout -> PerformancePayout count > 1
            and // qualifies that all legs have varianceReturnTerms
            economicTerms -> payout -> PerformancePayout -> returnTerms -> varianceReturnTerms count > 1
            and economicTerms -> payout -> PerformancePayout -> returnTerms -> volatilityReturnTerms is absent
            and economicTerms -> payout -> PerformancePayout -> returnTerms -> correlationReturnTerms is absent
            and economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms is absent
            and economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms is absent

func Qualify_EquitySwap_ParameterReturnVolatility_SingleName: <"Qualifies a product as an Equity Swap for which the performance is based on the volatility changes on a single stock.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with a single performance leg, 4) which has volatility return terms, 5) the underlier is a single stock, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnVolatility_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnVolatility_SingleName"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the only leg has volatilityReturnTerms
            performancePayout -> returnTerms -> volatilityReturnTerms only exists
            and // qualifies that underlier is a security (single name)
            performancePayout -> underlier -> Observable -> Asset -> Instrument -> Security exists

func Qualify_EquitySwap_ParameterReturnVolatility_Index: <"Qualifies a product as an Equity Swap for which the performance is based on the volatility changes on an index.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with a single performance leg, 4) which has volatility return terms, 5) the underlier is an index, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnVolatility_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnVolatility_SingleIndex"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the only leg has volatilityReturnTerms
            performancePayout -> returnTerms -> volatilityReturnTerms only exists
            and // qualifies that underlier is an index
            performancePayout -> underlier -> Observable -> Index exists

func Qualify_EquitySwap_ParameterReturnVolatility_Basket: <"Qualifies a product as an Equity Swap for which the performance is based on the volatility changes on a basket.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with a single performance leg, 4) which has volatility return terms, 5) the underlier is a basket, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnVolatility_Basket"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnVolatility_Basket"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the only leg has varianceReturnTerms
            performancePayout -> returnTerms -> volatilityReturnTerms only exists
            and // qualifies that underlier is a basket
            performancePayout -> underlier -> Observable -> Basket exists

func Qualify_EquitySwap_ParameterReturnCorrelation_Basket: <"Qualifies a product as an Equity Swap for which the performance is based on changes in the correlation between the constituents of a basket.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with a single performance leg, 4) which has correlation return terms, 5) the underlier is a basket, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the only leg has varianceReturnTerms
            performancePayout -> returnTerms -> correlationReturnTerms only exists
            and // qualifies that underlier is a basket
            performancePayout -> underlier -> Observable -> Basket exists

func Qualify_EquitySwap_ParameterReturnDividend_SingleName: <"Qualifies a product as an Equity Swap for which the performance is based on the dividend returns of a single stock.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with one fixed price leg and one performance leg 4) which has dividend return terms, 5) the underlier is a single stock, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnDividend_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnDividend_SingleName"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is one fixed price and one performance payout
            PerformancePayoutAndFixedPricePayoutOnlyExists(economicTerms -> payout)
            and economicTerms -> payout -> PerformancePayout count = 1
            and // qualifies that the performance Payout has dividendReturnTerms
            performancePayout -> returnTerms -> dividendReturnTerms only exists
            and // qualifies that underlier is a security (single name)
            performancePayout -> underlier -> Observable -> Asset -> Instrument -> Security exists

func Qualify_EquitySwap_ParameterReturnDividend_Index: <"Qualifies a product as an Equity Swap for which the performance is based on the dividend returns of an index.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with one fixed price leg and one performance leg 4) which has dividend return terms, 5) the underlier is an index, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnDividend_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnDividend_SingleIndex"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is one fixed price and one performance payout
            PerformancePayoutAndFixedPricePayoutOnlyExists(economicTerms -> payout)
            and economicTerms -> payout -> PerformancePayout count = 1
            and // qualifies that the performance Payout has dividendReturnTerms
            performancePayout -> returnTerms -> dividendReturnTerms only exists
            and // qualifies that underlier is an index
            performancePayout -> underlier -> Observable -> Index exists

func Qualify_EquitySwap_ParameterReturnDividend_Basket: <"Qualifies a product as an Equity Swap for which the performance is based on the dividend returns of a basket.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is an equity product 2) of swap type, 3) with one fixed price leg and one performance leg 4) which has dividend return terms, 5) the underlier is a basket, and 6) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquitySwap_ParameterReturnDividend_Basket"]
            [synonym ISDA_Taxonomy_v2 value "EquitySwap_ParameterReturnDividend_Basket"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        // qualifies that the Base Product is an Equity Swap (i.e.: only performance, interest rate or fixed price payouts)
        Qualify_BaseProduct_EquitySwap(economicTerms) = True
            and // qualifies that there is one fixed price and one performance payout
            PerformancePayoutAndFixedPricePayoutOnlyExists(economicTerms -> payout)
            and economicTerms -> payout -> PerformancePayout count = 1
            and // qualifies that the performance Payout has dividendReturnTerms
            performancePayout -> returnTerms -> dividendReturnTerms only exists
            and // qualifies that underlier is a security (single name)
            performancePayout -> underlier -> Observable -> Basket exists

func Qualify_BaseProduct_EquityForward: <"Qualifies a product as having the Asset Class classification Equity and Base Product Classification Forward.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_Equity(economicTerms) = True
            and economicTerms -> payout only-element -> SettlementPayout exists

func Qualify_EquityOption_PriceReturnBasicPerformance_SingleName: <"Qualifies a product as a plain vanilla Equity Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) An option product  for which the underlier is a single stock and 2) No special option feature exists other than option averaging."> //
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquityOption_PriceReturnBasicPerformance_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "EquityOption_PriceReturnBasicPerformance_SingleName"]
    alias optionPayout: economicTerms -> payout only-element -> OptionPayout
    alias optionUnderlier: optionPayout -> underlier
    set is_product:
        Qualify_AssetClass_Equity(economicTerms)
            // qualifies that only the option payout exist and all other payouts are absent
            and optionPayout exists
                // qualifies that the underlier is an asset
            and optionUnderlier -> Observable -> Asset exists
                // qualifies that the underlier is a security (already verified as equity)
            and optionUnderlier -> Observable -> Asset -> Instrument -> Security exists
                // qualifies that no feature other than averaging exists
            and (optionPayout -> feature is absent
                or optionPayout -> feature -> averagingFeature only exists
                or optionPayout -> feature -> fxFeature only-element -> quanto exists
                or optionPayout -> feature -> fxFeature only-element -> composite exists)
            and (if economicTerms -> nonStandardisedTerms exists then economicTerms -> nonStandardisedTerms = False else True)

func Qualify_EquityOption_PriceReturnBasicPerformance_Index: <"Qualifies a product as an Equity Option with an index as underlier.  The determination of the qualification is based on the economic terms and the following criteria: 1) An option product  for which the underlier is an index and 2) No special option feature exists other than option averaging.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquityOption_PriceReturnBasicPerformance_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "EquityOption_PriceReturnBasicPerformance_SingleIndex"]
    alias optionPayout: economicTerms -> payout only-element -> OptionPayout
    set is_product:
        Qualify_AssetClass_Equity(economicTerms)
            // qualifies that only the option payout exist and all other payouts are absent
            and optionPayout exists
                // qualifies that the underlier is an equity index
            and optionPayout -> underlier -> Observable -> Index -> EquityIndex exists
                // qualifies that no feature other than averaging exists
            and (optionPayout -> feature is absent
                or optionPayout -> feature -> averagingFeature only exists
                or optionPayout -> feature -> fxFeature only-element -> quanto exists
                or optionPayout -> feature -> fxFeature only-element -> composite exists)
            and (if economicTerms -> nonStandardisedTerms exists then economicTerms -> nonStandardisedTerms = False else True)

func Qualify_EquityOption_PriceReturnBasicPerformance_Basket: <"Qualifies a product as an Equity Option with a basket underlier.  The determination of the qualification is based on the economic terms and the following criteria: 1) An option product  for which the underlier is a basket and 2) No special option feature exists other than option averaging.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquityOption_PriceReturnBasicPerformance_Basket"]
            [synonym ISDA_Taxonomy_v2 value "EquityOption_PriceReturnBasicPerformance_Basket"]
    alias optionPayout: economicTerms -> payout only-element -> OptionPayout
    set is_product:
        Qualify_AssetClass_Equity(economicTerms) = True
                // qualifies that only the option payout exist and all other payouts are absent
            and optionPayout exists
                // qualifies that the underlier is an equity basket
            and optionPayout -> underlier -> Observable -> Basket exists
                // qualifies that no feature other than averaging exists
            and (optionPayout -> feature is absent
                or optionPayout -> feature -> averagingFeature only exists
                or optionPayout -> feature -> fxFeature only-element -> quanto exists
                or optionPayout -> feature -> fxFeature only-element -> composite exists)
            and (if economicTerms -> nonStandardisedTerms exists then economicTerms -> nonStandardisedTerms = False else True)

func Qualify_EquityOption_ParameterReturnVariance_SingleName: <"Qualifies a product as an Equity Variance Single Name Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is a Single Name Equity Variance Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquityOption_ParameterReturnVariance_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "EquityOption_ParameterReturnVariance_SingleName"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a single name variance swap
            and Qualify_EquitySwap_ParameterReturnVariance_SingleName(
                    underlierEconomicTerms
                ) = True

func Qualify_EquityOption_ParameterReturnVariance_Index: <"Qualifies a product as an Equity Variance Index Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is aan Index Equity Variance Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquityOption_ParameterReturnVariance_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "EquityOption_ParameterReturnVariance_SingleIndex"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is an index variance swap
            and Qualify_EquitySwap_ParameterReturnVariance_Index(underlierEconomicTerms) = True

// and Qualify_EquitySwap_ParameterReturnVariance_Index (economicTerms -> payout -> OptionPayout -> underlier -> contractualProduct -> economicTerms only-element) = True
func Qualify_EquityOption_ParameterReturnVariance_Basket: <"Qualifies a product as an Equity Variance Basket Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is a Basket Equity Variance Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Qualify_EquityOption_ParameterReturnVariance_Basket"]
            [synonym ISDA_Taxonomy_v2 value "Qualify_EquityOption_ParameterReturnVariance_Basket"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a basket variance swap
            and Qualify_EquitySwap_ParameterReturnVariance_Basket(underlierEconomicTerms) = True

func Qualify_EquityOption_ParameterReturnVolatility_SingleName: <"Qualifies a product as an Equity Volatility Single Name Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is a Single Name Equity Volatility Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquityOption_ParameterReturnVolatility_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "EquityOption_ParameterReturnVolatility_SingleName"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a single name volatility swap
            and Qualify_EquitySwap_ParameterReturnVolatility_SingleName(
                    underlierEconomicTerms
                ) = True

func Qualify_EquityOption_ParameterReturnVolatility_Index: <"Qualifies a product as an Equity Volatility Index Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is aan Index Equity Volatility Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "EquityOption_ParameterReturnVolatility_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "EquityOption_ParameterReturnVolatility_SingleIndex"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is an index volatility swap
            and Qualify_EquitySwap_ParameterReturnVolatility_Index(underlierEconomicTerms) = True

func Qualify_EquityOption_ParameterReturnVolatility_Basket: <"Qualifies a product as an Equity Volatility Basket Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is a Basket Equity Volatility Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Qualify_EquityOption_ParameterReturnVolatility_Basket"]
            [synonym ISDA_Taxonomy_v2 value "Qualify_EquityOption_ParameterReturnVaolatility_Basket"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a basket volatility swap
            and Qualify_EquitySwap_ParameterReturnVolatility_Basket(underlierEconomicTerms) = True

func Qualify_EquityOption_ParameterReturnCorrelation_Basket: <"Qualifies a product as an Equity Correlation Basket Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is a Basket Equity Correlation Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a basket correlation swap
            and Qualify_EquitySwap_ParameterReturnCorrelation_Basket(underlierEconomicTerms) = True

func Qualify_EquityOption_ParameterReturnDividend_SingleName: <"Qualifies a product as an Equity Dividend Single Name Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is a Single Name Equity Dividend Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Qualify_EquityOption_ParameterReturnDividend_SingleName"]
            [synonym ISDA_Taxonomy_v2 value "Qualify_EquityOption_ParameterReturnDividend_SingleName"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a single name dividend swap
            and Qualify_EquitySwap_ParameterReturnDividend_SingleName(
                    underlierEconomicTerms
                ) = True

func Qualify_EquityOption_ParameterReturnDividend_Index: <"Qualifies a product as an Equity Dividend Index Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is an Index Equity Dividend Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Qualify_EquityOption_ParameterReturnDividend_SingleIndex"]
            [synonym ISDA_Taxonomy_v2 value "Qualify_EquityOption_ParameterReturnDividend_SingleIndex"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a single name dividend swap
            and Qualify_EquitySwap_ParameterReturnDividend_Index(underlierEconomicTerms) = True

func Qualify_EquityOption_ParameterReturnDividend_Basket: <"Qualifies a product as an Equity Dividend Basket Option.  The determination of the qualification is based on the economic terms and the following criteria: 1) The product contains a single option payout and 2) the underlying product is a Basket Equity Dividend Swap">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Qualify_EquityOption_ParameterReturnDividend_Basket"]
            [synonym ISDA_Taxonomy_v2 value "Qualify_EquityOption_ParameterReturnDividend_Basket"]

    alias underlierEconomicTerms:
        economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
            only-element
    set is_product:
        // qualifies that only the option payout exist and all other payouts are absent
        economicTerms -> payout only-element -> OptionPayout exists
            // qualifies that the underlier is a single name dividend swap
            and Qualify_EquitySwap_ParameterReturnDividend_Basket(underlierEconomicTerms) = True

func Qualify_Equity_OtherOption: <"Qualifies a product with properties of an Exotic Option as Equity Option (Other)">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Qualify_EquityOther"]
            [synonym ISDA_Taxonomy_v2 value "Qualify_EquityOther"]
    set is_product:
        Qualify_AssetClass_Equity(economicTerms) = True
            and economicTerms -> payout only-element -> OptionPayout exists
            and economicTerms -> nonStandardisedTerms = True

func Qualify_BaseProduct_IRSwap: <"Qualifies a product as having the Base Product classification Interest Rate Swap.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
            and economicTerms -> payout -> InterestRatePayout count = 2
            and economicTerms -> payout -> InterestRatePayout -> paymentDates count = 2
            and Qualify_BaseProduct_CrossCurrency(economicTerms) = False
            and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> InflationRateSpecification is absent

func Qualify_BaseProduct_CrossCurrency: <"Qualifies a product as having the Base Product classification Cross Currency.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
            and economicTerms -> payout -> InterestRatePayout count = 2
            and (economicTerms -> payout -> InterestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency
                    distinct
                    count = 2
                or (economicTerms -> payout -> InterestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency exists
                    and economicTerms -> payout -> InterestRatePayout -> priceQuantity -> quantityMultiplier -> fxLinkedNotionalSchedule -> varyingNotionalCurrency exists
                    and economicTerms -> payout -> InterestRatePayout -> priceQuantity -> quantitySchedule -> unit -> currency <> economicTerms -> payout -> InterestRatePayout -> priceQuantity -> quantityMultiplier -> fxLinkedNotionalSchedule -> varyingNotionalCurrency))

func Qualify_BaseProduct_Fra: <"Qualifies a product as having the Base Product classification Forward Rate Agreement">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
            and economicTerms -> payout -> InterestRatePayout count = 2
            and economicTerms -> payout -> InterestRatePayout -> paymentDate count = 2
            and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> InflationRateSpecification is absent

func Qualify_BaseProduct_Inflation: <"Qualifies a product as having the Base Product classification Inflation Swap">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
            and economicTerms -> payout -> InterestRatePayout count = 2
            and economicTerms -> payout -> InterestRatePayout -> paymentDates count = 2
            and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> InflationRateSpecification exists

func Qualify_SubProduct_FixedFloat: <"Qualifies a product as having the Sub Product classification Fixed Float">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    set is_product:
        (economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FixedRateSpecification count = 1
                and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification count = 1)
            or (economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FixedRateSpecification count = 1
                and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> InflationRateSpecification count = 1)
            or ((economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification count = 1
                    or economicTerms -> payout -> InterestRatePayout -> rateSpecification -> InflationRateSpecification count = 1)
                and (economicTerms -> payout -> InterestRatePayout
                    filter rateSpecification is absent and priceQuantity exists
                    then count = 1
                    ))

func Qualify_SubProduct_FixedFixed: <"Qualifies a product as having the Sub Product classification Fixed Fixed">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FixedRateSpecification count = 2

func Qualify_SubProduct_Basis: <"Qualifies a product as having the Sub Product classification Basis">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification count = 2
            or (economicTerms -> payout -> InterestRatePayout -> rateSpecification -> InflationRateSpecification count = 1
                and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification count = 1)
            or economicTerms -> payout -> InterestRatePayout -> rateSpecification -> InflationRateSpecification count = 2

func Qualify_Transaction_ZeroCoupon: <"Qualifies a product as having the Transaction classification Zero Coupon">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout -> InterestRatePayout -> paymentDates -> paymentFrequency
            filter item -> periodMultiplier = 1 and item -> period = PeriodExtendedEnum -> T
            then exists

func Qualify_Transaction_ZeroCoupon_KnownAmount: <"Qualifies a product as having the Transaction classification Zero Coupon with a Known Amount. This category applies to a Zero Coupon Swap in which the fixed leg pays a known amount at maturity.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_SubProduct_FixedFloat(economicTerms) = True
            and Qualify_Transaction_ZeroCoupon(economicTerms) = True
            and (economicTerms -> payout -> InterestRatePayout
                filter
                    item -> priceQuantity exists
                        and rateSpecification is absent
                        and paymentDates -> paymentFrequency -> periodMultiplier = 1
                        and paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T
                then exists
                )

func Qualify_Transaction_YoY: <"Qualifies a product as having the Transaction classification Year on Year">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout -> InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier all = 1
            and economicTerms -> payout -> InterestRatePayout -> paymentDates -> paymentFrequency -> period all = PeriodExtendedEnum -> Y

func Qualify_Transaction_OIS: <"Qualifies a product as having the Transaction classification OIS">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias floatingRateIndex:
        economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification -> rateOption -> FloatingRateIndex -> floatingRateIndex

    set is_product:
        floatingRateIndex any = FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> AUD_AONIA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND_SwapMarker
            or floatingRateIndex any = FloatingRateIndexEnum -> CAD_CORRA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> CAD_CORRA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> CHF_OIS_11_00_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> CHF_SARON_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> CHF_SARON_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> CHF_TOIS_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> CNY_SHIBOR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> CNY_Shibor_OIS_Compounding
            or floatingRateIndex any = FloatingRateIndexEnum -> COP_IBR_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> COP_IBR_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> CZK_CZEONIA_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> DKK_DESTR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> DKK_DKKOIS_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> DKK_Tom_Next_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_BGCANTOR
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_11_00_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_4_15_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND_Bloomberg
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EURONIA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EURONIA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> EUR_EuroSTR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_RONIA_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_SONIA_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_SONIA_OIS_4_15_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_SONIA_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_WMBA_RONIA_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> GBP_WMBA_SONIA_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> HKD_HONIA_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> HKD_HONIX_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> HUF_HUFONIA_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> ILS_SHIR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> INR_FBIL_MIBOR_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> INR_MIBOR_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> INR_MIBOR_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> INR_MIOIS
            or floatingRateIndex any = FloatingRateIndexEnum -> INR_MITOR_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> JPY_OIS_11_00_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> JPY_OIS_11_00_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> JPY_OIS_3_00_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> JPY_TONA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> JPY_TONA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> KRW_KOFR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> MXN_TIIE_ON_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> MYR_MYOR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> NOK_NOWA_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> NZD_NZIONA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> NZD_NZIONA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> PLN_POLONIA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> PLN_POLONIA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> PLN_WIRON_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> REPOFUNDS_RATE_ITALY_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> RUB_RUONIA_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> RUB_RUONIA_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> SEK_SIOR_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> SEK_STIBOR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> SEK_SWESTR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> SGD_SONAR_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> SGD_SONAR_OIS_VWAP_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> SGD_SORA_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> SGD_SORA_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> THB_THOR_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> THB_THOR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> TRY_TLREF_OIS_Compound_1
            or floatingRateIndex any = FloatingRateIndexEnum -> TRY_TLREF_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_Federal_Funds_H_15_OIS_COMPOUND
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_Federal_Funds_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_OIS_11_00_BGCANTOR
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_OIS_11_00_LON_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_OIS_11_00_NY_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_OIS_11_00_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_OIS_3_00_BGCANTOR
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_OIS_3_00_NY_ICAP
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_OIS_4_00_TRADITION
            or floatingRateIndex any = FloatingRateIndexEnum -> USD_SOFR_OIS_Compound
            or floatingRateIndex any = FloatingRateIndexEnum -> ZAR_ZARONIA_OIS_Compound

func Qualify_InterestRate_IRSwap_FixedFloat: <"Qualifies a product as a Fixed-Float Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg and more than one payment, 2) without inflation features or cross-currency features or 'zero coupon' features, and 3) where the floating leg is not based on an OIS index.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFloat"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFloat"]

    set is_product:
        Qualify_BaseProduct_IRSwap(economicTerms) = True
            and Qualify_SubProduct_FixedFloat(economicTerms) = True
            and Qualify_Transaction_ZeroCoupon(economicTerms) = False
            and Qualify_Transaction_OIS(economicTerms) = False

func Qualify_InterestRate_IRSwap_FixedFixed: <"Qualifies a product as a Fixed-Fixed Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two fixed legs and more than one payment and 2) without inflation features or cross-currency features but could have 'zero coupon' features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_FixedFixed"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFixed"]
    set is_product:
        Qualify_BaseProduct_IRSwap(economicTerms) = True
            and Qualify_SubProduct_FixedFixed(economicTerms) = True

func Qualify_InterestRate_IRSwap_Basis: <"Qualifies a product as a Basis (Float-Float) Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two floating legs and more than one payment, 2) without inflation features or cross-currency features but could have 'zero coupon' features, and 3) where neither floating leg is  based on an OIS index.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Basis"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Basis"]

    set is_product:
        Qualify_BaseProduct_IRSwap(economicTerms) = True
            and Qualify_SubProduct_Basis(economicTerms) = True
            and Qualify_Transaction_OIS(economicTerms) = False

func Qualify_InterestRate_IRSwap_FixedFloat_ZeroCoupon: <"Qualifies a product as a Fixed-Float Zero Coupon Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg, 2) where the fixed leg represents one singular payment agreed upon execution and to be made at maturity, 3) where the floating leg is not based on an OIS index and 4) without any inflation features or cross-currency features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFloat_ZeroCoupon"]

    set is_product:
        Qualify_BaseProduct_IRSwap(economicTerms) = True
            and Qualify_SubProduct_FixedFloat(economicTerms) = True
            and Qualify_Transaction_ZeroCoupon(economicTerms) = True
            and Qualify_Transaction_OIS(economicTerms) = False

func Qualify_InterestRate_IRSwap_FixedFloat_OIS: <"Qualifies a product as a Fixed-Float OIS Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg and more than one payment and where the floating leg is based on an OIS index, 2) without inflation features or cross-currency features, and 3) could include 'zero coupon' features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_FixedFloat_OIS"]

    set is_product:
        Qualify_BaseProduct_IRSwap(economicTerms) = True
            and Qualify_SubProduct_FixedFloat(economicTerms) = True
            and Qualify_Transaction_OIS(economicTerms) = True

func Qualify_InterestRate_IRSwap_Basis_OIS: <"Qualifies a product as a Basis (Fixed-Float) OIS Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two floating legs and more than one payment and where one or both the floating leg is based on an OIS index, 2) without inflation features or cross-currency features, and 3) could include 'zero coupon' features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Basis"]

    set is_product:
        Qualify_BaseProduct_IRSwap(economicTerms) = True
            and Qualify_SubProduct_Basis(economicTerms) = True
            and Qualify_Transaction_OIS(economicTerms) = True

func Qualify_InterestRate_CrossCurrency_FixedFloat: <"Qualifies a product as a Fixed-Float Cross-Currency Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg and a cross-currency feature and more than one payment, 2) without inflation features and 3) could be a 'zero coupon' and the floating leg index could be OIS or non-OIS.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFloat"]

    set is_product:
        Qualify_BaseProduct_CrossCurrency(economicTerms) = True
            and Qualify_SubProduct_FixedFloat(economicTerms) = True

func Qualify_InterestRate_CrossCurrency_Basis: <"Qualifies a product as a Basis (Float-Float) Cross Currency Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two floating legs, a cross-currency feature in one or both legs, and more than one payment, 2) but without inflation features, and 3) could be a 'zero coupon' and floating leg index could be OIS or non-OIS.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_Basis"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_CrossCurrency_Basis"]

    set is_product:
        Qualify_BaseProduct_CrossCurrency(economicTerms) = True
            and Qualify_SubProduct_Basis(economicTerms) = True

func Qualify_InterestRate_CrossCurrency_FixedFixed: <"Qualifies a product as a Fixed-Fixed Cross-Currency Interest Rate Swap based on the economic terms and the following criteria: 1) An interest rate product with two fixed legs and a cross-currency feature and more than one payment, 2) without inflation features and 3) could be a 'zero coupon'">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_CrossCurrency_FixedFixed"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_CrossCurrency_FixedFixed"]

    set is_product:
        Qualify_BaseProduct_CrossCurrency(economicTerms) = True
            and Qualify_SubProduct_FixedFixed(economicTerms) = True

func Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year: <"Qualifies a product as a Fixed-Float Annual Reset Inflation Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one inflation rate leg and more than one payment, and 2) without cross-currency features or 'zero coupon' features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Inflation"]

    set is_product:
        Qualify_BaseProduct_Inflation(economicTerms) = True
            and Qualify_BaseProduct_CrossCurrency(economicTerms) = False
            and Qualify_SubProduct_FixedFloat(economicTerms) = True
            and Qualify_Transaction_YoY(economicTerms) = True

//TH Review -> This product exists at ISDA Taxonomy V2 but has no match in CDM yet. The proposal needs to be completed adding the composable utility functions to improve qualification for IR inflation products
/*func Qualify_InterestRate_Inflation: <"Qualifies a product as a Fixed-Float Inflation Swap with a single accrual period based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one inflation rate leg and more than one payment, and 2) without cross-currency features.">
 *     [qualification Product]

 *     inputs: economicTerms EconomicTerms (1..1)
 *     output: is_product boolean (1..1)
 *         [synonym ISDA_Taxonomy_v2 value "InterestRate_Inflation"]
 * 
 *     set is_product:
 *         Qualify_BaseProduct_Inflation(economicTerms) = True
 *         and Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon (economicTerms) = False
 *         and Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year (economicTerms) = False
 *         and Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon (economicTerms) = False
 *         and Qualify_InterestRate_InflationSwap_Basis_YearOn_Year (economicTerms) = False
 */
func Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon: <"Qualifies a product as a Fixed-Float Inflation Swap based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one inflation rate leg, 2) where the fixed leg represents one singular payment agreed upon execution and to be made at maturity, 3) where the inflation leg features an inflation floating rate and 4) without cross-currency features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v2 value "InterestRate_IRSwap_Inflation"]

    set is_product:
        Qualify_BaseProduct_Inflation(economicTerms) = True
            and Qualify_BaseProduct_CrossCurrency(economicTerms) = False
            and Qualify_SubProduct_FixedFloat(economicTerms) = True
            and Qualify_Transaction_ZeroCoupon(economicTerms) = True

func Qualify_InterestRate_InflationSwap_Basis_YearOn_Year: <"Qualifies a product as a Basis (Float-Float) Annual Reset Inflation Swap based on the economic terms and the following criteria: 1) An interest rate product with one floating interest rate leg and one inflation rate leg and more than one payment, and 2) without cross-currency features or 'zero coupon' features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]

    set is_product:
        Qualify_BaseProduct_Inflation(economicTerms) = True
            and Qualify_BaseProduct_CrossCurrency(economicTerms) = False
            and Qualify_SubProduct_Basis(economicTerms) = True
            and Qualify_Transaction_YoY(economicTerms) = True

func Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon: <"Qualifies a product as a Basis (Float-Float) Inflation Swap based on the economic terms and the following criteria: 1) An interest rate product with one floating interest rate leg and one inflation interest rate leg, 2) where the floating leg is not based on an OIS index, 3) where the inflation leg features an inflation floating rate, 4) where an interest rate payout is made at maturity into a singular payment and 5) without cross-currency features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_IRSwap_Inflation"]

    set is_product:
        Qualify_BaseProduct_Inflation(economicTerms) = True
            and Qualify_BaseProduct_CrossCurrency(economicTerms) = False
            and Qualify_SubProduct_Basis(economicTerms) = True
            and Qualify_Transaction_ZeroCoupon(economicTerms) = True

func Qualify_InterestRate_Fra: <"Qualifies the product as a Floating Rate Agreement based on the economic terms and the following criteria: 1) An interest rate product with one fixed and one floating leg, each of which has a single payment, and 2) could include a cross-currency feature, and the floating rate leg could be based OIS index.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_Fra"]
            [synonym ISDA_Taxonomy_v1 value "InterestRate_Fra"]

    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
            and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FixedRateSpecification count = 1
            and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification count = 1
            and economicTerms -> payout -> InterestRatePayout -> paymentDate count = 2

func Qualify_InterestRate_CapFloor: <"Qualifies a product as an interest rate cap, interest rate floor, or an interest rate collar based on the economic terms and the following criteria: 1) An interest rate product with one one leg that includes a cap and/or a floor.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_CapFloor"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_CapFloor"]

    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
                and economicTerms -> payout -> InterestRatePayout count = 1
                    // qualifies the product as having a cap and/or floor in the interestRatePayout
                and economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification -> capRateSchedule exists
            or economicTerms -> payout -> InterestRatePayout -> rateSpecification -> FloatingRateSpecification -> floorRateSchedule exists

func Qualify_InterestRate_Option_Swaption: <"Qualifies a product as a Swaption that can be exercised into an Interest Rate Swap, which could be any type of interest rate product with two legs based on the economic terms.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_Option_Swaption"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_Option_Swaption"]
    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
                // qualifies that only the option payout exists and all other payouts are absent
            and economicTerms -> payout only-element -> OptionPayout exists
            and Qualify_AssetClass_InterestRate(
                    economicTerms -> payout -> OptionPayout -> underlier -> Product ->> economicTerms
                        only-element
                ) = True

func Qualify_InterestRate_Option_DebtOption: <"Qualifies a product as a Option that can be exercised into an Debt Product based on the economic terms.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_Option_DebtOption"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_Option_DebtOption"]
    alias optionPayout: economicTerms -> payout -> OptionPayout
    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
                // qualifies that only the option payout exists and all other payouts are absent
            and economicTerms -> payout only-element -> OptionPayout exists
                // qualifies the underlyer of the option as a debt security
            and optionPayout -> underlier -> Observable
                extract [ ObservableQualification(item, InstrumentTypeEnum -> Debt, empty) ]
            all = True

func Qualify_InterestRate_Forward_Debt: <"Qualifies a product as Interest Rate Bond Forward based on economic terms, which is defined as a transaction in which one party agrees to pay an agreed price for a specified amount of a bond of an issuer or a basket of bonds of several issuers at a future date and the other party agrees to pay a price for the same amount of the same bond to be set on a specified date in the future.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "InterestRate_Forward_Debt"]
            [synonym ISDA_Taxonomy_v2 value "InterestRate_Forward_Debt"]
    alias forwardPayout: economicTerms -> payout -> SettlementPayout only-element
    set is_product:
        Qualify_AssetClass_InterestRate(economicTerms) = True
            and (forwardPayout -> underlier -> Observable -> Asset -> Instrument -> Security exists
                or forwardPayout -> underlier -> Product -> TransferableProduct -> Instrument -> Security exists)

func Qualify_ForeignExchange_Spot_Forward: <"Qualifies a product as Foreign Exchange based on economic terms, which is defined as an agreement to buy one currency against the delivery of another currency at a rate set on the trade date for settlement on a specified date in the future.  Dependent on conventions specific to local markets the product could be considered either Spot or Forward.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "ForeignExchange_Forward"]
            [synonym ISDA_Taxonomy_v1 value "ForeignExchange_Spot"]
            [synonym ISDA_Taxonomy_v2 value "ForeignExchange_Forward"]
            [synonym ISDA_Taxonomy_v2 value "ForeignExchange_Spot"]
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms) = True
                // only FX transactions result in the buyer receiving only cash
                // other products result in a cash receipt, but not in as a single SettlementPayout
            and economicTerms -> payout only-element -> SettlementPayout exists
            and economicTerms -> payout -> SettlementPayout -> settlementTerms -> cashSettlementTerms is absent

func Qualify_ForeignExchange_Swap: <"Qualifies a product as Foreign Exchange Swap based on economic terms, which is defined as a contract in which one party borrows one currency from, and simultaneously lends another to, the second party. Each party uses the repayment obligation to its counterparty as collateral and the amount of repayment is fixed at the FX forward rate as of the start of the contract.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms) = True
            and SettlementPayoutOnlyExists(economicTerms -> payout)
            and economicTerms -> payout -> SettlementPayout count = 2
            and economicTerms -> payout -> SettlementPayout -> settlementTerms -> cashSettlementTerms is absent

func Qualify_ForeignExchange_NDF: <"Qualifies a product as Foreign Exchange Non-Deliverable Forward based on economic terms, which is defined as a Forward transaction where the notional amount of one of the currencies (the reference currency) is converted into the other currency (the settlement currency) at a spot foreign exchange rate that is observed on a valuation date prior to the settlement date, and a single net payment in the settlement currency is made on the settlement date. No payment or account transfer takes place in the reference currency.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "ForeignExchange_NDF"]
            [synonym ISDA_Taxonomy_v2 value "ForeignExchange_NDF"]
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms) = True
                // only FX transactions result in the buyer receiving only cash
                // other products result in a cash receipt, but not in as a single SettlementPayout
            and economicTerms -> payout only-element -> SettlementPayout exists
            and economicTerms -> payout -> SettlementPayout -> settlementTerms -> cashSettlementTerms exists

func Qualify_ForeignExchange_NDS: <"Qualifies a product as Foreign Exchange NDS based on economic terms, which is defined as a contract in which one party borrows one currency from, and simultaneously lends another to, the second party. Each party uses the repayment obligation to its counterparty as collateral and the amount of repayment is fixed at the FX forward rate as of the start of the contract.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms) = True
            and SettlementPayoutOnlyExists(economicTerms -> payout)
            and economicTerms -> payout -> SettlementPayout count = 2
            and economicTerms -> payout -> SettlementPayout -> settlementTerms -> cashSettlementTerms exists

func Qualify_ForeignExchange_ParameterReturnVariance: <"Qualifies a product as Foreign Exchange Swap for which the performance is based on the variance of a foreign exhange underlier.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is a Foreign Exchange product (the underlier is foreign exchange) 2) with only one performance leg 3) which has variance return terms, 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "ForeignExchange_SimpleExotic_Vol/Var"]
            [synonym ISDA_Taxonomy_v2 value "ForeignExchange_SimpleExotic_Vol/Var"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms) = True
                // qualifies that the product is FX (i.e.: has only foreign Exchange underliers)
            and performancePayout -> underlier -> Observable -> Index -> ForeignExchangeRateIndex exists
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the performance leg has varianceReturnTerms
            performancePayout -> returnTerms -> varianceReturnTerms only exists

func Qualify_ForeignExchange_ParameterReturnVolatility: <"Qualifies a product as Foreign Exchange Swap for which the performance is based on the volatility of a foreign exchange underlier.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is a Foreign Exchange product (the underlier is foreign exchange) 2) with only one performance leg 3) which has volatility return terms, 4) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "ForeignExchange_SimpleExotic_Vol/Var"]
            [synonym ISDA_Taxonomy_v2 value "ForeignExchange_SimpleExotic_Vol/Var"]

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms) = True
                // qualifies that the product is FX (i.e.: has only foreign Exchange underliers)
            and performancePayout -> underlier -> Observable -> Index -> ForeignExchangeRateIndex exists
            and // qualifies that there is a single leg of performance type
            economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the performance leg has volatilityReturnTerms
            performancePayout -> returnTerms -> volatilityReturnTerms only exists

func Qualify_ForeignExchange_ParameterReturnCorrelation: <"Qualifies a product as Foreign Exchange Swap for which the performance is based on the correlation changes between the constituents of a basket.  The determination of the qualification is based on the economic terms and the following criteria: 1) Is a product with with only one performance leg 2) which has correlation return terms, 3) with a basket underlier 4) which is exclusively constituted by foreign exchange constituents and 5) there are no option features.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)

    alias performancePayout: economicTerms -> payout -> PerformancePayout only-element
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms) = True
                // qualifies that there is a single leg of performance type
            and economicTerms -> payout only-element -> PerformancePayout exists
            and // qualifies that the performance leg has correlationReturnTerms
            performancePayout -> returnTerms -> correlationReturnTerms only exists
            and // qualifies that the underlier is a basket
            performancePayout -> underlier -> Observable -> Basket exists
            and // qualifies that the product is FX (i.e.: the basket is constituted by foreign exchange constituents)
            performancePayout -> underlier -> Observable -> Basket -> basketConstituent
                extract [ Index -> ForeignExchangeRateIndex exists ]
            all = True

func Qualify_ForeignExchange_VanillaOption: <"Qualifies a product as FX Plain Vanilla Option based on economic terms, which is defined as one where 1) exercise style is American or European style only, and 2) does not contain any feature like Forward Starting Strike or Performance payout.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "ForeignExchange_VanillaOption"]
            [synonym ISDA_Taxonomy_v2 value "ForeignExchange_VanillaOption"]
    alias optionPayout: economicTerms -> payout only-element -> OptionPayout
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms)
            and optionPayout exists
            and (optionPayout -> exerciseTerms -> style <> OptionExerciseStyleEnum -> Bermuda)
            and (optionPayout -> feature is absent
                or optionPayout -> feature -> averagingFeature only exists)
            and optionPayout -> settlementTerms -> cashSettlementTerms is absent

func Qualify_ForeignExchange_NDO: <"Qualifies a product as FX Non Deliverable Option based on economic terms, which is defined as one where exercise style is European only.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "ForeignExchange_NDO"]
            [synonym ISDA_Taxonomy_v2 value "ForeignExchange_NDO"]
    alias optionPayout: economicTerms -> payout only-element -> OptionPayout
    set is_product:
        Qualify_AssetClass_ForeignExchange(economicTerms)
            and optionPayout exists
            and (optionPayout -> exerciseTerms -> style = OptionExerciseStyleEnum -> European)
            and optionPayout -> settlementTerms -> cashSettlementTerms exists

func Qualify_RepurchaseAgreement: <"Qualifies a product as a Repurchase Agreement based on the repo trate of the trade (ie the interest charges) being defined in an InterestRatePayout and the asset that is bought and sold being defined in an AssetPayout in a CollateralPosition.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout only-element -> InterestRatePayout exists
            and economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout exists
            and economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout -> tradeType all <> BuySellBack

func Qualify_BuySellBack: <"Qualifies a product as a Buy/Sell Back based on the repo trate of the trade (ie the interest charges) being defined in an InterestRatePayout and the asset that is bought and sold being defined in an AssetPayout in a CollateralPosition, along with an enumerator to distinguish ths product type from a traditional repurchase ageement.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout only-element -> InterestRatePayout exists
            and economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout exists
            and economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product ->> economicTerms -> payout -> AssetPayout -> tradeType any = BuySellBack

func Qualify_SecurityLending: <"Qualifies a product as Securities Lending based on the asset to be lent (usually a security) being defined in a singular AssetPayout, with the collateral, which can be an asset (usually cash or securities), defined in a CollateralPosition.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
    set is_product:
        economicTerms -> payout only-element -> AssetPayout exists
            and economicTerms -> collateral -> collateralPortfolio -> collateralPosition -> product -> TransferableProduct exists

func Qualify_Commodity_Swap_FixedFloat: <"Qualifies a product as a Fixed Float Commodity Swap.  The determination of the qualification is based on the economic terms and the following criteria: 1) One Floating Leg represented by the CommodityPayout, with an underlier that is a commodity, 2) One Fixed Leg represented by the FixedPricePayout, and 3) there are no other payout types.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Commodity_Swap_FixedFloat"]
            [synonym ISDA_Taxonomy_v2 value "Commodity_Swap_FixedFloat"]
    set is_product:
        Qualify_AssetClass_Commodity(economicTerms) = True
            and economicTerms -> payout count = 2
            and economicTerms -> payout -> CommodityPayout exists
            and economicTerms -> payout -> FixedPricePayout exists

func Qualify_Commodity_Swap_Basis: <"Qualifies a product as a Basis Commodity Swap.  The determination of the qualification is based on the economic terms and the following criteria: 1) Two Floating Legs represented by the CommodityPayout, with an underlier that is a commodity, and 2) there are no other payout types.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Commodity_Swap_Basis"]
            [synonym ISDA_Taxonomy_v2 value "Commodity_Swap_Basis"]
    set is_product:
        Qualify_AssetClass_Commodity(economicTerms) = True
            and CommodityPayoutOnlyExists(economicTerms -> payout)
            and economicTerms -> payout -> CommodityPayout count = 2

func Qualify_Commodity_Option: <"Qualifies a product as a Option that can be exercised into an Commodity.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Commodity_Option"]
            [synonym ISDA_Taxonomy_v2 value "Commodity_Option"]
    set is_product:
        Qualify_AssetClass_Commodity(economicTerms) = True
            and economicTerms -> payout only-element -> OptionPayout exists
            and (economicTerms -> payout -> OptionPayout -> underlier -> Observable -> Asset -> Commodity exists
                or economicTerms -> payout -> OptionPayout -> underlier -> Product -> TransferableProduct -> Commodity exists)

func Qualify_Commodity_Option_Cash: <"Qualifies a product as a Option that can be exercised into an Commodity.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Commodity_Option_Cash"]
            [synonym ISDA_Taxonomy_v2 value "Commodity_Option_Cash"]
    set is_product:
        Qualify_Commodity_Option(economicTerms) = True
            and economicTerms -> payout -> OptionPayout only-element -> settlementTerms -> settlementType = SettlementTypeEnum -> Cash

func Qualify_Commodity_Option_Physical: <"Qualifies a product as a Option that can be exercised into an Commodity.">
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Commodity_Option_Physical"]
            [synonym ISDA_Taxonomy_v2 value "Commodity_Option_Physical"]
    set is_product:
        Qualify_Commodity_Option(economicTerms) = True
            and economicTerms -> payout -> OptionPayout only-element -> settlementTerms -> settlementType = SettlementTypeEnum -> Physical

func Qualify_Commodity_Swaption: <"Qualifies a product as a Swaption that can be exercised into a Commodity Swap, which could be any type of interest rate product with two legs based on the economic terms.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Commodity_Swaption"]
            [synonym ISDA_Taxonomy_v2 value "Commodity_Swaption"]
    set is_product:
        economicTerms -> payout only-element -> OptionPayout exists
            and (Qualify_Commodity_Swap_Basis(
                        economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms
                    ) = True
                or Qualify_Commodity_Swap_FixedFloat(
                        economicTerms -> payout -> OptionPayout only-element -> underlier -> Product ->> economicTerms
                    ) = True)

func Qualify_Commodity_Forward: <"Qualifies a product as a Forward that will be settled with the physical delivery of a Commodity. The determination of the qualification is based on the economic terms and the following criteria: 1) One pricing Leg represented by either the FixedPricePayout or the CommodityPayout, 2) One physical Leg represented by the ForwardPayout, with an underlier that is a commodity, and 3) there are no other payout types.">
    [qualification Product]
    inputs:
        economicTerms EconomicTerms (1..1)
    output:
        is_product boolean (1..1)
            [synonym ISDA_Taxonomy_v1 value "Commodity_Spot_Fwd"]
            [synonym ISDA_Taxonomy_v2 value "Commodity_Forward"]
    set is_product:
        Qualify_AssetClass_Commodity(economicTerms) = True
            and economicTerms -> payout count = 2
            and ((economicTerms -> payout -> SettlementPayout exists and economicTerms -> payout -> FixedPricePayout exists) // Fixed Price Forward
                or (economicTerms -> payout -> SettlementPayout exists and economicTerms -> payout -> CommodityPayout exists) // Floating Price Forward
                or economicTerms -> payout only-element -> SettlementPayout exists) // Price Return Vanilla Forward

func InterestRatePayoutOnlyExists: <"At least one InterestRatePayout exists and no other payouts exist.">
    inputs:
        payouts Payout (0..*)
    output:
        result boolean (1..1)

    set result:
        payouts
            extract InterestRatePayout exists
            then all = True
            then default False

func SettlementPayoutOnlyExists: <"At least one SettlementPayout exists and no other payouts exist.">
    inputs:
        payouts Payout (0..*)
    output:
        result boolean (1..1)

    set result:
        payouts
            extract SettlementPayout exists
            then all = True
            then default False

func PerformancePayoutOnlyExists: <"At least one PerformancePayout exists and no other payouts exist.">
    inputs:
        payouts Payout (0..*)
    output:
        result boolean (1..1)

    set result:
        payouts
            extract PerformancePayout exists
            then all = True
            then default False

func CommodityPayoutOnlyExists: <"At least one CommodityPayout exists and no other payouts exist.">
    inputs:
        payouts Payout (0..*)
    output:
        result boolean (1..1)

    set result:
        payouts
            extract CommodityPayout exists
            then all = True
            then default False

func PerformancePayoutAndFixedPricePayoutOnlyExists: <"At least one PerformancePayout exists, and at least one FixedPricePayout exists, and no other payouts exist.">
    inputs:
        payouts Payout (0..*)
    output:
        result boolean (1..1)

    set result:
        payouts -> PerformancePayout exists
            and payouts -> FixedPricePayout exists
                // check no other payouts exist
            and payouts extract [ PerformancePayout exists or FixedPricePayout exists ]
            all = True

func PerformancePayoutAndInterestRatePayoutOnlyExists: <"At least one PerformancePayout exists, and at least one InterestRatePayout exists, and no other payouts exist.">
    inputs:
        payouts Payout (0..*)
    output:
        result boolean (1..1)

    set result:
        payouts -> PerformancePayout exists
            and payouts -> InterestRatePayout exists
                // check no other payouts exist
            and payouts extract [ PerformancePayout exists or InterestRatePayout exists ]
            all = True


================================================================================
FILE: rosetta-source/src/main/rosetta/product-template-enum.rosetta
================================================================================

namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.staticdata.asset.common.*

enum AveragingInOutEnum: <"The enumerated values to specify the type of averaging used in an Asian option.">
    In <"The average price is used to derive the strike price. Also known as 'Asian strike' style option.">
    Out <"The average price is used to derive the expiration price. Also known as 'Asian price' style option.">
    Both <"The average price is used to derive both the strike and the expiration price.">

enum OptionTypeEnum extends PutCallEnum: <"The enumerated values to specify the type or strategy of the option.">
    Payer <"A 'payer' option: If you buy a 'payer' option you have the right but not the obligation to enter into the underlying swap transaction as the 'fixed' rate/price payer and receive float.">
    Receiver <"A 'receiver' option: If you buy a 'receiver' option you have the right but not the obligation to enter into the underlying swap transaction as the 'fixed' rate/price receiver and pay float.">
    Straddle <"A straddle strategy, which involves the simultaneous buying of a put and a call of the same underlier, at the same strike and same expiration date">

enum OptionExerciseStyleEnum: <"The enumerated values to specify the option exercise style. i.e., European, Bermuda or American.">
    European <"Single Exercise">
    Bermuda <"Multiple specified exercise dates">
    American <"Continuous exercise over a range of dates">

enum CallingPartyEnum: <"Identifies a party to the on-demand repo transaction that has a right to demand for termination of the Security Finance transaction.">
    InitialBuyer <"Initial buyer to the repo transaction.">
    InitialSeller <"Initial seller to the repo transaction.">
    Either <"Either, Buyer or Seller to the repo transaction.">
    AsDefinedInMasterAgreement <"As defined in Master Agreement.">

enum ExerciseNoticeGiverEnum: <"Defines the principal party to the trade that has the right to exercise.">
    Buyer <"Specifies that only the option buyer has the right to exercise.">
    Seller <"Specifies that only the option seller has the right to exercise.">
    Both <"Specifies that both the option buyer and option seller has the right to exercise.">
    AsSpecifiedInMasterAgreement <"Specifies that the Master Agreement defines the principal party to the trade that has the right to exercise.">

enum MarginTypeEnum: <"This indicator defines which type of assets (cash or securities) is specified to apply as margin to the repo transaction.">
    // [deprecated]
    Cash <"When the margin type is Cash, the margin factor is applied to the cash value of the transaction.">
    Instrument <"When the margin type is Instrument, the margin factor is applied to the instrument value for the transaction. In the 'instrument' case, the haircut would be applied to the securities.">

enum RepoDurationEnum: <"A duration code for a Repo (or Securities Lending) transaction. There are many business and market rules that are derived from the duration of the transaction.">
    // [deprecated]
    Overnight <"Indicates that a contract is classified as overnight, meaning that there is one business day difference between the start and end date of the contract. Business rule: When the repo is overnight, the number of business days between the spot and forward value dates must be one. Forward leg must be specified.">
    Term <"Indicates that a contract is a regular term contract, with a start date and an end date. Business rule: When the repo is 'Term', both spot and forward legs must be specified.">

enum AssetPayoutTradeTypeEnum: <"An enumerator to differentiate the different trade types used in securities finance and modelled on an AssetPayout.">
    Repo <"In the case of a repurchase transaction, an immediate and equal income payment (often call a manufactured payment) is made by the buyer to the seller.">
    BuySellBack displayName "Buy/Sell-Back" <"In the case of a buy/sell-back, there is no income payment between buyer and seller. Instead, the repurchase price to be paid on the repurchase date is reduced by the amount of the income payment on the collateral plus some extra interest to compensate the seller for the delay between the income payment date on the collateral and the repurchase date of the repo.">

enum ExpirationTimeTypeEnum: <"The time of day at which the equity option expires, for example the official closing time of the exchange."> // OPTION GENERAL
    Close <"The official closing time of the exchange on the valuation date.">
    Open <"The official opening time of the exchange on the valuation date.">
    OSP <"The time at which the official settlement price is determined.">
    SpecificTime <"The time specified in the element equityExpirationTime or valuationTime (as appropriate)">
    XETRA <"The time at which the official settlement price (following the auction by the exchange) is determined by the exchange.">
    DerivativesClose <"The official closing time of the derivatives exchange on which a derivative contract is listed on that security underlyer.">
    AsSpecifiedInMasterConfirmation <"The time is determined as provided in the relevant Master Confirmation.">


================================================================================
FILE: rosetta-source/src/main/rosetta/product-template-func.rosetta
================================================================================

namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*

func FilterTradeLot: <"Filter list of TradeLot based on TradeLot->lotIdentifier.">
    inputs:
        tradeLots TradeLot (0..*) <"List of TradeLots to filter.">
        lotIdentifier Identifier (0..*) <"The lot Identifiers to filter by.">
    output:
        filteredTradeLots TradeLot (0..*)

    add filteredTradeLots: tradeLots filter item -> lotIdentifier = lotIdentifier

func AddTradeLot: <"Add a TradeLot to an existing list of TradeLots.">
    inputs:
        tradableProduct TradableProduct (1..1) <"Input list of TradeLots.">
        newTradeLot TradeLot (1..1) <"The TradeLot to append to the list.">
    output:
        updatedTradableProduct TradableProduct (1..1)

    set updatedTradableProduct: tradableProduct
    add updatedTradableProduct -> tradeLot: newTradeLot

func ReplaceTradeLot: <"Replace TradeLot in with matching TradeLot->lotIdentifier.">
    inputs:
        tradeLots TradeLot (0..*) <"Input list of TradeLots.">
        newTradeLot TradeLot (1..1) <"The TradeLot to replace a matching TradeLot in the list.">
    output:
        mergedTradeLots TradeLot (0..*)

    add mergedTradeLots: <"Where the lot identifier matches, replace the existing TradeLot with the new TradeLot.">
        tradeLots
            extract
                if item -> lotIdentifier = newTradeLot -> lotIdentifier
                        or (item -> lotIdentifier is absent and newTradeLot -> lotIdentifier is absent)
                then newTradeLot
                else item

func CompareTradeLot: <"Compare the Quantity in TradeLot 1 to the Quantity (with the same unit of amount) in TradeLot 2, based on the CompareOp enum.">
    inputs:
        tradeLot1 TradeLot (1..1)
        op CompareOp (1..1)
        tradeLot2 TradeLot (1..1)
    output:
        result boolean (1..1)

    alias unitOfAmounts: tradeLot2 -> priceQuantity -> quantity -> unit distinct

    set result:
        unitOfAmounts
            extract unitOfAmount [
                CompareQuantityByUnitOfAmount(
                        tradeLot1 -> priceQuantity -> quantity
                            extract
                                NonNegativeQuantity {
                                    value: item -> value,
                                    unit: item -> unit,
                                    ...
                                },
                        op,
                        tradeLot2 -> priceQuantity -> quantity
                            extract
                                NonNegativeQuantity {
                                    value: item -> value,
                                    unit: item -> unit,
                                    ...
                                },
                        unitOfAmount
                    )
            ] all = True

func CompareTradeLotToAmount: <"Compare the Quantity amount in TradeLot to the given amount (regardless of unit of amount), based on the CompareOp enum.">
    inputs:
        tradeLot TradeLot (1..1)
        op CompareOp (1..1)
        amount number (1..1)
    output:
        result boolean (1..1)

    set result:
        tradeLot -> priceQuantity -> quantity
            filter item -> value exists
            then extract [ CompareNumbers(item -> value, op, amount) ]
                all = True

func PriceQuantityTriangulation: <"Defines all the scenarios which triangulation can be helpful validation between Prices and Quantities.">
    inputs:
        tradeLots TradeLot (0..*)
    output:
        success boolean (1..1)

    set success:
        if tradeLots count > 0
        then tradeLots
                extract [
                    if item -> priceQuantity -> price -> priceType contains PriceTypeEnum -> CashPrice
                    then CashPriceQuantityNoOfUnitsTriangulation(
                                item -> priceQuantity -> quantity,
                                item -> priceQuantity -> price
                            )
                    else True
                ] all = True
        else True

func FpmlIrd8: <"FpML validation rule ird-8 - If the same party is specified as the payer and receiver, then different accounts must be specified.">
    [codeImplementation]
    inputs:
        trade Trade (1..1)
        accounts Account (0..*)
    output:
        success boolean (1..1) <"Validation result">

func Create_CashflowFromSettlementPayout: <"Generates two opposite cashflows that correspond to a settlement payout. One leg is the asset leg, that settles the asset according to the quantity, direction and date defined in the settlement payout. The other is the price leg, that settles the price as a currency amount going in the opposite direction. The function's applicability is limited on purpose to a single asset with a single price and quantity specified.">
    inputs:
        payout SettlementPayout (1..1) <"The settlement payout from which the cashflows are generated.">
    output:
        cashflows Cashflow (2..2) <"The two generated cashflows (asset leg and price leg) going in opposite directions.">

    alias assetLeg: <"The asset leg consists in a cashflow which has the same attributes (asset, quantity, date and direction) as the settlement payout that generates it.">
        Cashflow {
            quantity: NonNegativeQuantity {
                value: payout -> priceQuantity -> quantitySchedule -> value,
                unit: payout -> priceQuantity -> quantitySchedule -> unit,
                ...
            },
            asset: payout -> underlier -> Observable -> Asset,
            settlementDate: payout -> settlementTerms -> settlementDate -> adjustableOrRelativeDate,
            payerReceiver: payout -> payerReceiver,
            cashflowType: CashflowType {
                cashflowType: PrincipalPayment,
                ...
            },
            ...
        }

    alias priceLegAmount: <"The amount (in cash) of the price leg is computed as: quantity (asset) x price. When a monetary amount is specified in the trade's PriceQuantity attribute, e.g. in the case of an FX transaction, a validation rule already ensures than this monetary amount is consistent with quantity x price.">
        payout -> priceQuantity -> quantitySchedule -> value * payout -> priceQuantity -> priceSchedule only-element -> value

    alias priceLegCurrency: <"The currency of the price leg is the currency in which the price is expressed.">
        payout -> priceQuantity -> priceSchedule only-element -> unit -> currency

    alias priceLegPayerReceiver: <"The payer / receiver direction of the price leg must be flipped compared to the settlement payout.">
        PayerReceiver {
            payer: payout -> payerReceiver -> receiver,
            receiver: payout -> payerReceiver -> payer
        }

    alias priceLeg: <"The price leg consists in a cashflow whose attributes (asset, quantity, date and direction) are inferred from the settlement payout. The quantity / unit is the currency amount to pay for the asset and the payer/receiver direction is flipped.">
        Cashflow {
            quantity: NonNegativeQuantity {
                value: priceLegAmount,
                unit: UnitType {
                    currency: priceLegCurrency,
                    ...
                },
                ...
            },
            asset: Asset {
                Cash: Cash {
                    identifier: AssetIdentifier {
                        identifier: priceLegCurrency,
                        identifierType: CurrencyCode
                    },
                    ...
                },
                ...
            },
            settlementDate: payout -> settlementTerms -> settlementDate -> adjustableOrRelativeDate,
            payerReceiver: priceLegPayerReceiver,
            cashflowType: CashflowType {
                cashflowType: PrincipalPayment,
                ...
            },
            ...
        }

    condition Asset: <"Restricts the function's applicability to a single asset for the underlier.">
        payout -> underlier -> Observable -> Asset exists

    condition SettlementDate: <"Restricts the function's applicability to the adjustable or relative date for the settlement date.">
        payout -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists

    condition SinglePriceAndQuantity: <"Restricts the function's applicability to a single quantity and price.">
        payout -> priceQuantity -> quantitySchedule -> value exists
            and payout -> priceQuantity -> priceSchedule only-element -> value exists

    set cashflows: [assetLeg, priceLeg]

func UnderlierForOptionOrForwardProduct: <"Extracts the underlier from an option or a forward.">
    inputs:
        product NonTransferableProduct (1..1)
    output:
        underlierProduct Underlier (1..1)
    set underlierProduct:
        if product -> economicTerms -> payout -> OptionPayout exists
        then product -> economicTerms -> payout -> OptionPayout only-element -> underlier
        else if product -> economicTerms -> payout -> SettlementPayout exists
        then product -> economicTerms -> payout -> SettlementPayout only-element -> underlier

func FXFarLeg: <"Extracts the far leg of an FX swap (deliverable or not) based on two criteria: the forward payout with the latest value date or the forward payout with the latest settlement date.">
    inputs:
        product NonTransferableProduct (1..1)
    output:
        nearLegPayout SettlementPayout (0..1)
    alias settlementPayout: product -> economicTerms -> payout -> SettlementPayout
    set nearLegPayout:
        // value date
        if (Qualify_ForeignExchange_Swap(product -> economicTerms) or Qualify_ForeignExchange_NDS(product -> economicTerms))
                and settlementPayout -> settlementTerms -> settlementDate -> valueDate exists
        then settlementPayout max [ item -> settlementTerms -> settlementDate -> valueDate ]
        // adjustable or relative date
        else if (Qualify_ForeignExchange_Swap(product -> economicTerms) or Qualify_ForeignExchange_NDS(product -> economicTerms))
                and settlementPayout -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then settlementPayout
            max [
                AdjustableOrAdjustedOrRelativeDateResolution(
                        item -> settlementTerms -> settlementDate -> adjustableOrRelativeDate
                    )
            ]


================================================================================
FILE: rosetta-source/src/main/rosetta/product-template-type.rosetta
================================================================================

namespace cdm.product.template : <"Template feature concepts to define payouts.">
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.mapping.config.*
import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.observable.event.*
import cdm.product.asset.*
import cdm.product.collateral.*
import cdm.product.common.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*

type TransferableProduct extends Asset: <"A TransferableProduct is a type of financial product which can be held or transferred, represented as an Asset with the addition of specific EconomicTerms.">
    economicTerms EconomicTerms (1..1) <"The price forming features, including payouts and provisions.">

type EconomicTerms: <" This class represents the full set of price-forming features associated with a contractual product: the payout component, the notional/quantity, the effective and termination date and the date adjustment provisions when applying uniformily across the payout components. This class also includes the legal provisions which have valuation implications: cancelable provision, extendible provision, early termination provision and extraordinary events specification.">

    effectiveDate AdjustableOrRelativeDate (0..1) <"The first day of the terms of the trade. This day may be subject to adjustment in accordance with a business day convention.">
        [docReference ICMA GMRA namingConvention "Purchase Date"
            provision "As defined in GMRA paragraph 2(mm) The date on which Purchased Securities are sold or are to be sold by Seller to Buyer."]
        [docReference ICMA ERCCBestPractice namingConvention "Purchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the value date of a repo."]
    terminationDate AdjustableOrRelativeDate (0..1) <"The last day of the terms of the trade. This date may be subject to adjustments in accordance with the business day convention. It can also be specified in relation to another scheduled date (e.g. the last payment date).">
        [docReference ICMA GMRA namingConvention "Repurchase Date"
            provision "As defined in GMRA paragraph 2(qq) The date on which Buyer is to sell Equivalent Securities to Seller."]
        [docReference ICMA ERCCBestPractice namingConvention "Repurchase Date"
            provision "ERCC Guide: Annex II  Glossary of repo terminology. The term for the maturity date of a repo."]
    dateAdjustments BusinessDayAdjustments (0..1) <"The business day adjustment convention when it applies across all the payout components. This specification of the business day convention and financial business centers is used for adjusting any calculation period date if it would otherwise fall on a day that is not a business day in the specified business center.">
    payout Payout (1..*) <"The payout specifies the future cashflow computation methodology which characterizes a financial product.">
    terminationProvision TerminationProvision (0..1) <"Contains optional provisions pertaining to the termination characteristics of a contract.">
    calculationAgent CalculationAgent (0..1) <"The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.">
    nonStandardisedTerms boolean (0..1) <"Specifies, when boolean value is True, that additional economic terms exist that have not been included in the product representation.">
    collateral Collateral (0..1) <"Represents the collateral obligations of a party.">

    condition ReturnType_Total_Requires_Dividends: <"A total return implies both a price and a dividend return">
        if payout -> PerformancePayout -> returnTerms -> priceReturnTerms -> returnType all = ReturnTypeEnum -> Total
        then payout -> PerformancePayout -> returnTerms -> dividendReturnTerms exists

    condition LastRegularPaymentDate: <"FpML specifies that lastRegularPaymentDate must only be included if there is a final stub. As part of the CDM, this data rule has been adjusted to specify that it only applies to interest rate swaps, as the credit derivatives products can have a specified lastRegularPaymentDate while the stub is typically not applicable to those.">
        if payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and payout -> InterestRatePayout -> stubPeriod -> finalStub exists
        then payout -> InterestRatePayout count = 2

    condition PayRelativeTo: <"FpML specifies a required payRelativeTo element as part of the PaymentDates. As standardized CDS don't have such payRelativeTo provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
                and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> payRelativeTo exists

    condition PaymentDatesAdjustments: <"FpML specifies a required paymentDatesAdjustments element as part of the PaymentDates. As standardized CDS don't have such paymentDatesAdjustments provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
                and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> paymentDatesAdjustments exists

    condition PaymentFrequency: <"FpML specifies a required paymentFrequency element as part of the PaymentDates. As standardized CDS may not have such paymentFrequency provision, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
                and payout -> InterestRatePayout -> paymentDates exists
        then payout -> InterestRatePayout -> paymentDates -> paymentFrequency exists

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        if payout -> OptionPayout exists
        then payout -> OptionPayout -> priceQuantity exists
                or payout -> OptionPayout -> underlier -> Product ->> economicTerms -> payout -> InterestRatePayout count = 2

    condition DayCountFraction: <"FpML specifies a required dayCountFraction element as part of the swapStream/calculationPeriodAmount/calculation. As standardized CDS don't have such specified day count fraction, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
        then payout -> InterestRatePayout -> dayCountFraction exists

    condition PaymentDates: <"FpML specifies a required paymentDates element as part of the swapStream. As standardized CDS may not have specified payment dates, the cardinality has been relaxed as part of the CDM. This data rule specifies that if the product has two interest rate streams, this provision must exist.">
        if payout -> InterestRatePayout count = 2
        then payout -> InterestRatePayout -> dayCountFraction exists

    condition MarketPrice: <"FpML specifies that marketFixedRate and marketPrice only have meaning in a credit index trade">
        if payout -> CreditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
        then payout -> CreditDefaultPayout -> transactedPrice -> marketFixedRate is absent
                and payout -> CreditDefaultPayout -> transactedPrice -> marketPrice is absent

    condition NotionalResetOnPerformancePayout: <"Notional reset only applies to return swaps, and therefore can only exist on an performancePayout or interestRatePayouts that are associated with it.">
        payout -> CreditDefaultPayout -> priceQuantity -> reset is absent
            and payout -> AssetPayout -> priceQuantity -> reset is absent
            and payout -> CommodityPayout -> priceQuantity -> reset is absent
            and payout -> FixedPricePayout -> priceQuantity -> reset is absent
            and payout -> SettlementPayout -> priceQuantity -> reset is absent
            and payout -> OptionPayout -> priceQuantity -> reset is absent

    condition NotionalResetInterestRatePayoutExists: <"As the performancePayout->payoutQuantity->reset attribute applies to return swaps, the interestRatePayout needs to be present alongside it.">
        if payout -> PerformancePayout -> priceQuantity -> reset contains True
        then payout -> InterestRatePayout exists

    condition FpML_cd_26_28: <"FpML validation rule cd-26 - If feeLeg/singlePayment/adjustablePaymentDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be after generalTerms/effectiveDate/unadjustedDate. FpML validation rule cd-28 - If feeLeg/periodicPayment/firstPaymentDate exists, then feeLeg/periodicPayment/firstPaymentDate must be after generalTerms/effectiveDate/unadjustedDate. This data rule tackles those two FpML validation rules at once, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute.">
        // Cashflow is no longer part of the product so this condition cannot be tested at the economic terms level.
        // Consider adding a generic validation at the trade state level that any cashflow must be between effective and termination dates.
        True

    condition FpML_cd_27: <"FpML validation rule cd-27 - If feeLeg/singlePayment/adjustablePaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        // Cashflow is no longer part of the product so this condition cannot be tested at the economic terms level.
        // Consider adding a generic validation at the trade state level that any cashflow must be between effective and termination dates.
        True

    condition FpML_cd_30: <"FpML validation rule cd-30 - If feeLeg/periodicPayment/lastRegularPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/lastRegularPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
        if payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate exists
                and terminationDate exists
        then payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> unadjustedDate or payout -> InterestRatePayout -> paymentDates -> lastRegularPaymentDate all < terminationDate -> adjustableDate -> adjustedDate

    condition IndependentCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentIndependent

    condition AssetPayoutDividendTermsValidation: <"Validates that if the transaction has Dividend Terms specified then it should be a Term trade.">
        if payout -> AssetPayout -> dividendTerms exists
        then terminationDate exists

type OptionPayout extends PayoutBase: <" The option payout specification terms. The associated globalKey denotes the ability to associate a hash value to the respective OptionPayout instantiation for the purpose of model cross-referencing, in support of functionality such as the event effect and the lineage.">
    buyerSeller BuyerSeller (1..1)
    feature OptionFeature (0..1) <"The option feature, such as quanto, Asian, barrier, knock.">
    observationTerms ObservationTerms (0..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. To be used for option contracts that reference a benchmark price.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    underlier Underlier (1..1) <"The financial product underlying the option, which can be of any type including an Asset, Basket, Index or a NonTransferableProduct.">
    optionType OptionTypeEnum (0..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">
    exerciseTerms ExerciseTerms (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">
    strike OptionStrike (0..1) <"Specifies the strike of the option">

    condition AsianOptionChoice: <"Choice rule between AveragingFeature and AveragingStrikeFeature.">
        (if strike->averagingStrikeFeature exists then feature->averagingFeature is absent) and (if feature->averagingFeature exists then strike->averagingStrikeFeature is absent)

    condition ClearedPhysicalSettlementExists:
        if settlementTerms -> physicalSettlementTerms exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout exists
                and underlier -> Product ->> economicTerms -> payout -> InterestRatePayout count = 2
        then settlementTerms -> physicalSettlementTerms -> clearedPhysicalSettlement exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

    condition OptionStylePresent: <"This condition ensures that an optionPayout contains the style of option within its exercise terms.">
        exerciseTerms -> style exists

    condition OptionTypePresent: <"This condition ensures that an option type is set when the underlier is not a non-transferable product.">
        if underlier -> Product -> NonTransferableProduct is absent
        then optionType exists

type ReturnTerms: <"Specifies the type of return of a performance payout.">

    priceReturnTerms PriceReturnTerms (0..1) <"Return terms based upon the underlier's observed price.">
    dividendReturnTerms DividendReturnTerms (0..1) <"Return terms based upon dividend payments associated to the underlier.">
    varianceReturnTerms VarianceReturnTerms (0..1) <"Return terms based upon the observed variance of the underlier's price.">
    volatilityReturnTerms VolatilityReturnTerms (0..1) <"Return terms based upon the observed volatility of the underlier's price.">
    correlationReturnTerms CorrelationReturnTerms (0..1) <"Return terms based upon the observed correlation between the components of the underlying basket.">

    condition ReturnTermsExists: <"Checks that the return type label matches the actual return terms structure of the product.">
        if priceReturnTerms -> returnType = ReturnTypeEnum -> Total
        then (priceReturnTerms, dividendReturnTerms) only exists
        else if priceReturnTerms -> returnType = ReturnTypeEnum -> Price
        then priceReturnTerms only exists
        else priceReturnTerms only exists
            or dividendReturnTerms only exists
            or varianceReturnTerms only exists
            or volatilityReturnTerms only exists
            or correlationReturnTerms only exists

type PerformancePayout extends PayoutBase: <"Contains the necessary specifications for all performance payouts, encompassing equity return, dividend, variance, volatility and correlation products.">
    observationTerms ObservationTerms (0..1) <"Defines how and when a performance type option or performance type swap is to be observed.">
    valuationDates ValuationDates (1..1) <"Defines how and when a performance type option or performance type swap is to be valued, including both interim and final valuation.">
    paymentDates PaymentDates (1..1) <"Defines the payment date schedule, as defined by the parameters that are needed to specify it, either in a parametric way or by reference to another schedule of dates (e.g. the valuation dates).">
    underlier Underlier (0..1) <"Identifies the underlying product that is referenced for pricing of the applicable leg in a swap.  Referenced in the '2018 ISDA CDM Equity Confirmation for Security Equity Swap' as Security.">
    fxFeature FxFeature (0..*) <"Defines quanto or composite FX features that are included in the swap leg.">
    returnTerms ReturnTerms (0..1) <"Specifies the type of return of a performance payout.">
    portfolioReturnTerms PortfolioReturnTerms (0..*) <"Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, at Performance Payout level">
    initialValuationPrice PriceSchedule (0..*) <"Specifies the net initial valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies the net initial valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"Specifies the net final valuation price(s) of the underlier at Performance Payout level. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]

    condition Underlier: <"The underlier on a performance payout can only be an observable.">
        underlier -> Observable exists

    condition PortfolioOrStraightReturn:
        required choice returnTerms, portfolioReturnTerms

    condition PortfolioReturnIsMultipleReturns: <"No single portfolioReturnTerms instance shall exist because it would be a duplicate of straight returnTerms.">
        if portfolioReturnTerms exists
        then portfolioReturnTerms count > 1

    condition UnderlierOfPortfolioIsBasket: <"A portfolio made of multiple individual legs in portfolio, is a strategy that consider the Basket in transparency, thus having a Basket as an underlier of the PerformancePayout that is aggregation level and multiple individual legs in portfolio, each with an underlier to correspond to each Basket consituent. This is particular usage of portfolio attribute, hence the condition, being aknowledged that other usages would not require Basket to exist at this level, for instance a dispersion strategy where 'N+1' multiple portfolio return legs would exist, '1' with underlier->Basket, other 'N' ones with single underliers, where the Basket is at same level as the other legs (therefore no aggregation shall exist via Basket at PerformancePayout level.">
        if portfolioReturnTerms -> priceReturnTerms exists
        then underlier -> Observable -> Basket exists

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition NoSharePriceDividendAdjustmentIndex: <"If the underlier is an index, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> Observable -> Index exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition NoSharePriceDividendAdjustmentForeignExchange: <"If the underlier is an foreign exchange, sharePriceAdjustment and sharePriceDividendAdjustment cannot exist.">
        if underlier -> Observable -> Index -> ForeignExchangeRateIndex exists
        then returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent

    condition CorrelationUnderlierOnlyBasket: <"Correlation Return Terms can only have a basket as underlier, since it needs to compute the correlation between two or more products.">
        if returnTerms -> correlationReturnTerms exists
        then underlier -> Observable -> Basket exists

    condition EquitySpecificAttributes: <"Equity specific attributes cannot be present in non-equity products.">
        if Qualify_UnderlierObservable_Equity(underlier -> Observable) = False
        then returnTerms -> varianceReturnTerms -> dividendApplicability is absent
                and returnTerms -> varianceReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> varianceReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> volatilityReturnTerms -> dividendApplicability is absent
                and returnTerms -> volatilityReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> volatilityReturnTerms -> sharePriceDividendAdjustment is absent
                and returnTerms -> correlationReturnTerms -> dividendApplicability is absent
                and returnTerms -> correlationReturnTerms -> equityUnderlierProvisions is absent
                and returnTerms -> correlationReturnTerms -> sharePriceDividendAdjustment is absent

type PortfolioReturnTerms extends ReturnTerms: <"Specifies an individual type of return of a Performance Payout, when such individual return is part of an aggregation of multiple similar returns, at Performance Payout level.">
    [metadata key]

    payerReceiver PayerReceiver (1..1) <"Canonical representation of the payer and receiver parties applicable to each individual return leg.">
    underlier Observable (1..1) <"Defines the product that is the subject of a tradable product definition, an underlying product definition, a physical exercise, a position, or other purposes.">
        [metadata address "pointsTo"=PriceQuantity->observable]
    quantity NonNegativeQuantitySchedule (0..1) <"Specifies a quantity schedule for the underlier, which applies to each individual return leg.">
        [metadata address "pointsTo"=PriceQuantity->quantity]
    initialValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    interimValuationPrice PriceSchedule (0..*) <"Specifies the initial valuation price(s) of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]
    finalValuationPrice PriceSchedule (0..*) <"2018 ISDA CDM Equity Confirmation for Security Equity Swap: Final Price | Specifies the final valuation price of the underlier. This price can be expressed either as an actual amount/currency, as a determination method, or by reference to another value specified in the swap document.">
        [metadata address "pointsTo"=PriceQuantity->price]

choice Payout: <"Represents the set of future cashflow methodologies in the form of specific payout data type(s) which result from the financial product.  Examples: a trade in a cash asset will use only a settlement payout; for derivatives, two interest rate payouts can be combined to specify an interest rate swap; one interest rate payout can be combined with a credit default payout to specify a credit default swap.">
    [metadata key]

    AssetPayout <"Defines the assets and movements in a security financing transaction.">
    CommodityPayout <"Defines the payout for the floating leg of a Commodity Swap.">
    CreditDefaultPayout <"The credit default payout, which provides the details necessary for determining when a credit payout will be triggered as well as the parameters for calculating the payout and the settlement terms.">
    FixedPricePayout <"Defines a payout in which one or more payouts are defined as a fixed price.">
    InterestRatePayout <"All of the terms necessary to define and calculate a cash flow based on a fixed, a floating or an inflation index rate. The interest rate payout can be applied to interest rate swaps and FRA (which both have two associated interest rate payouts), credit default swaps (to represent the fee leg when subject to periodic payments) and equity swaps (to represent the funding leg).">
    OptionPayout <"The option payout.">
    PerformancePayout <"The performance payout, which encompasses the equity price returns, dividend returns, volatility return, variance return and correlation provisions.">
    SettlementPayout <"Represents a forward settling payout. The 'Underlier' attribute captures the underlying payout, which is settled according to the 'SettlementTerms' attribute. Both FX Spot and FX Forward should use this component.">

choice Underlier: <"The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such as cash or a security, a product, or the cash settlement of an index rate.  Conditions are usually applied when used in a data type, such as a payout, to ensure this aligns with the use case.">
    Observable <"Specifies the object to be observed for a price, it could be an asset or a reference.">
        [metadata address "pointsTo"=PriceQuantity->observable]
    Product <"Enables either a TransferableProduct or a NonTransferableProduct to be used in an underlier.">

choice Product: <"Enables either a TransferableProduct or a NonTransferableProduct to be used in an underlier.">
    TransferableProduct <"A TransferableProduct is a type of financial product which can be held or transferred, represented as an Asset with the addition of specific EconomicTerms.">
    NonTransferableProduct <"The non-transferable product data type represents a product that can be traded (as part of a TradableProduct) but cannot be transferred to others.">

type NonTransferableProduct: <"A data type to specify the financial product's economic terms, alongside the product identification and product taxonomy. The non-transferable product data type represents a product that can be traded (as part of a TradableProduct) but cannot be transferred to others.  It is meant to be used across the pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">
    [metadata key]
    identifier ProductIdentifier (0..*) <"Comprises a identifier and a source to uniquely identify the nonTransferableProduct. ">
    taxonomy ProductTaxonomy (0..*) <"Specifies the product taxonomy, which is composed of a taxonomy value and a taxonomy source.">
    economicTerms EconomicTerms (1..1) <"The price forming features, including payouts and provisions.">

    condition PrimaryAssetClass: <"Specifies that when nonStandardisedTerms are True that a primary asset class must be specified.">
        if economicTerms -> nonStandardisedTerms = True
        then taxonomy -> primaryAssetClass exists

type TradeLot: <"Specifies the price and quantity of a trade lot, where the same product could be traded multiple times with the same counterparty but in different lots (at a different date, in a different quantity and at a different price). One trade lot combined with a product definition specifies the entire economics of a trade. The lifecycle mechanics of each such trade lot (e.g. cashflow payments) is independent of the other lots.">
    lotIdentifier Identifier (0..*) <"Specifies one or more identifiers for the lot, if any.">
    priceQuantity PriceQuantity (1..*) <"Specifies the settlement characteristics of a trade lot: price, quantity, observable (optionally) and the settlement terms. This attribute has a multiple cardinality to allow to specify the price, quantity and observable of different legs in a single, composite product (e.g. a Swap).">

type TradableProduct: <"Definition of a product as ready to be traded, i.e. included in an execution or contract, by associating a specific price and quantity to this product plus an (optional) mechanism for any potential future quantity adjustment.">

    product NonTransferableProduct (1..1) <"The underlying product to be included in a contract or execution.">
    tradeLot TradeLot (1..*) <"Specifies the price, quantity and effective date of each trade lot, when the same product may be traded multiple times in different lots with the same counterparty. In a trade increase, a new trade lot is added to the list, with the corresponding effective date. In a trade decrease, the existing trade lot(s) are decreased of the corresponding quantity (and an unwind fee may have to be settled). The multiple cardinality and the ability to increase existing trades is used for Equity Swaps in particular.">
    counterparty Counterparty (2..2) <"Specifies the parties which are the two counterparties to the transaction.  The product is agnostic to the actual parties to the transaction, with the party references abstracted away from the product definition and replaced by the counterparty enum (e.g. CounterpartyEnum values Party1 or Party2). The counterparty enum can then be positioned in the product (e.g. to specify which counterparty is the payer, receiver etc) and this counterparties attribute, which is positioned outside of the product definition, allows the counterparty enum to be associated with an actual party reference.">
        [docReference ICMA GMRA namingConvention "Party"
            provision "Parties entering into GMRA, as specified on page 1 of the GMRA and under 1. (a)."]
    ancillaryParty AncillaryParty (0..*) <"Specifies the parties with ancillary roles in the transaction. The product is agnostic to the actual parties involved in the transaction, with the party references abstracted away from the product definition and replaced by the AncillaryRoleEnum. The AncillaryRoleEnum can then be positioned in the product and this AncillaryParty type, which is positioned outside of the product definition, allows the AncillaryRoleEnum to be associated with an actual party reference.">
    adjustment NotionalAdjustmentEnum (0..1) <"Specifies the conditions that govern the adjustment to the quantity of a product being traded: e.g. execution, portfolio rebalancing etc. It is typically used in the context of Equity Swaps.">

    condition PriceQuantityTriangulation: <"Check PriceQuantity triangulation for each TradeLot.">
        PriceQuantityTriangulation(tradeLot) = True

    condition NotionalAdjustment: <"As the adjustment attribute applies to return swaps, the equity payout needs to be present alongside it.">
        if adjustment exists
        then product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> priceReturnTerms exists
                or product -> economicTerms -> payout -> PerformancePayout exists

    condition PerformancePayout_ExtraordinaryDividendsParty:
        if product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExtraordinaryDividendsParty
                    then product -> economicTerms -> payout -> PerformancePayout -> returnTerms -> dividendReturnTerms -> extraordinaryDividendsParty exists

    condition OptionPayout_PredeterminedClearingOrganizationParty:
        if product -> economicTerms -> payout -> OptionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition ForwardPayout_PredeterminedClearingOrganizationParty:
        if product -> economicTerms -> payout -> SettlementPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty

    condition PredeterminedClearingOrganizationParty:
        if ancillaryParty -> role contains AncillaryRoleEnum -> PredeterminedClearingOrganizationParty
        then product -> economicTerms -> payout -> SettlementPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists
                or product -> economicTerms -> payout -> OptionPayout -> settlementTerms -> physicalSettlementTerms -> predeterminedClearingOrganizationParty exists

    condition ExerciseNoticeReceiverPartyManual:
        if product -> economicTerms -> payout -> OptionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual
                    then product -> economicTerms -> payout -> OptionPayout -> exerciseTerms -> exerciseProcedure -> manualExercise -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyOptionalEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyCancelableProvision:
        if product -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision
                    then product -> economicTerms -> terminationProvision -> cancelableProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition ExerciseNoticeReceiverPartyExtendibleProvision:
        if product -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                and if ancillaryParty -> role contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision
                    then product -> economicTerms -> terminationProvision -> extendibleProvision -> exerciseNotice -> exerciseNoticeReceiver exists

    condition CalculationAgentIndependent:
        if product -> economicTerms -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentIndependent
                    then product -> economicTerms -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentOptionalEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> optionalEarlyTermination -> calculationAgent -> calculationAgentParty exists

    condition CalculationAgentMandatoryEarlyTermination:
        if product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists
        then ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                and if ancillaryParty -> role contains AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination
                    then product -> economicTerms -> terminationProvision -> earlyTerminationProvision -> mandatoryEarlyTermination -> calculationAgent -> calculationAgentParty exists

type ConstituentWeight: <"A class describing the weight of each of the underlier constituent within the basket, either in absolute or relative terms.">

    openUnits number (0..1) <"The number of units (index or securities) that constitute the underlier of the swap. In the case of a basket swap, this element is used to reference both the number of basket units, and the number of each asset components of the basket when these are expressed in absolute terms.">
    basketPercentage number (0..1) <"The relative weight of each respective basket constituent, expressed in percentage. A basket percentage of 5% would be represented as 0.05.">

    condition BasketPercentage: <"FpML specifies basketPercentage as a RestrictedPercentage type, meaning that the value needs to be comprised between 0 and 1.">
        if basketPercentage exists
        then basketPercentage >= 0.0 and basketPercentage <= 1.0

type SettlementPayout extends PayoutBase: <"Represents a forward settling payout. The underlier attribute captures the underlying payout, which is settled according to the settlementTerms attribute (which is part of PayoutBase). Both FX Spot and FX Forward should use this component.">
    underlier Underlier (1..1) <"The underlying financial product that will be physically or cash settled, which can be of any type, eg an asset such as cash or a security, or the cash settlement of an index rate.">
    deliveryTerm string (0..1) <"Also called contract month or delivery month. However, it's not always a month. It is usually expressed using a code, e.g. Z23 would be the Dec 2023 contract, (Z = December). For crude oil, the corresponding contract might be called CLZ23.">
    delivery AssetDeliveryInformation (0..1) <"Contains the information relative to the delivery of the asset.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Underlier: <"The underlier for a settlement payout cannot be a NonTransferableProduct.">
        underlier -> Product -> NonTransferableProduct is absent

    condition Basket: <"If the underlier is a basket, it must contain only transferable assets.">
        if underlier -> Observable -> Basket exists
        then (underlier -> Observable -> Basket -> basketConstituent
                extract Asset exists
                ) all = True

    condition Index: <"If the underlier is an Index, then it can only be cash settled.">
        if underlier -> Observable -> Index exists
        then settlementTerms -> cashSettlementTerms exists

    condition SettlementTerms: <"Settlement Terms should be defined except for cash.">
        if underlier -> Observable -> Asset -> Cash exists
        then settlementTerms exists

    condition DeliveryCapacity: <"Checks that only one of the representations of delivery capacity is present simultaneously.">
        if delivery -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if delivery -> periods -> profile -> block -> deliveryCapacity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> deliveryCapacity exists
        then delivery -> deliveryCapacity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> deliveryCapacity is absent
                and delivery -> periods -> profile -> block -> deliveryCapacity is absent

    condition PriceTimeIntervalQuantity: <"Checks that only one of the representations of price time interval quantity is present simultaneously.">
        if schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
        then delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if delivery -> periods -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity is absent
        else if schedule -> schedulePeriod -> deliveryPeriod -> profile -> block -> priceTimeIntervalQuantity exists
        then schedule -> schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity is absent
                and delivery -> periods -> profile -> block -> priceTimeIntervalQuantity is absent

type CalculationSchedule: <"A class that allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">
    schedulePeriod SchedulePeriod (1..*) <"Defines a period of a calculation schedule structure.">

type SchedulePeriod: <"A class that defines the period of a schedule. The period contains a set of start and end dates, quantities, fixing, and pricing data.">
    calculationPeriod DateRange (1..1) <"Period for which the payment is generated.">
    paymentDate date (1..1) <"Adjusted payment date.">
    fixingPeriod DateRange (1..1) <"Period over which the underlying price is observed.">
    deliveryPeriod CalculationScheduleDeliveryPeriods (0..1) <"Period and time profile over which the delivery takes place.">

type FixedPricePayout extends PayoutBase: <"Represents a fixed price payout. There is no underlier associated with this payout type and is based on fixed pricing per a given unit (e.g. in commodities price per barrel)">
    paymentDates PaymentDates (1..1) <"Specifies the parameters to generate the payment date schedule, either through a parametric representation or by reference to specified dates.">
    fixedPrice FixedPrice (1..1) <"Specifies the fixed price on which fixed forward payments are based.">
    schedule CalculationSchedule (0..1) <"Allows the full representation of a payout by defining a set of schedule periods. It supports standard schedule customization by expressing all the dates, quantities, and pricing data in a non-parametric way.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

type CancelableProvision extends BuyerSeller: <"A data defining:  the right of a party to cancel a swap transaction on the specified exercise dates. The provision is for 'walk-away' cancellation (i.e. the fair value of the swap is not paid). A fee payable on exercise can be specified. As a difference from the FpML construct, the canonical model extends the BuyerSeller class.">
    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    cancelableProvisionAdjustedDates CancelableProvisionAdjustedDates (0..1) <"The adjusted dates associated with a cancelable provision. These dates have been adjusted for any applicable business day convention.">
    finalCalculationPeriodDateAdjustment FinalCalculationPeriodDateAdjustment (0..*) <"Business date convention adjustment to final payment period per leg (swapStream) upon exercise event. The adjustments can be made in-line with leg level BDC's or they can be specified separately.">
    initialFee Transfer (0..1) <"An initial fee for the cancelable option.">
    callingParty CallingPartyEnum (0..1) <"The party with right to exercise a cancellation. Allows for buyer, seller or either.">
    earliestDate AdjustableOrRelativeDate (0..1) <"The first day when cancelation is permitted to take effect. A party may give notice prior to this date and taken together with the effective period would be necessary to cancel on this date.">
    expirationDate AdjustableOrRelativeDate (0..1) <"The last day within the term of the contract that cancelation is allowed.">
    effectiveDate AdjustableOrRelativeDates (0..1) <"The effective date if cancelation is invoked otherwise the cancellation period defines the cancellation date.">
    effectivePeriod Period (0..1) <"Effective period for cancelation when notice is given. This is the period after notice is given that cancellation becomes effecticve.">
    earliestCancellationTime BusinessCenterTime (0..1) <"The earliest time in a business day that notice of cancelation can be given.">
    latestCancelationTime BusinessCenterTime (0..1) <"The latest time at which notice of cancelation can be given.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the cancelable provision, including details such as exercise style, exercise fees, and any other relevant conditions or terms governing the cancellation of the swap transaction.">

    condition EffectiveDate: <"Must select one of predefined cancellation types of effectiveDate or effectivePeriod.">
        optional choice effectiveDate, effectivePeriod

    condition CancelableProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyCancelableProvision

type CancelableProvisionAdjustedDates: <"A data to:  define the adjusted dates for a cancelable provision on a swap transaction.">

    cancellationEvent CancellationEvent (1..*) <"The adjusted dates for an individual cancellation date.">

type CancellationEvent: <"The adjusted dates for a specific cancellation date, including the adjusted exercise date and adjusted termination date.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">

type EarlyTerminationEvent: <"A data to:  define the adjusted dates associated with an early termination provision.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">
    adjustedExerciseFeePaymentDate date (0..1) <"The date on which the exercise fee amount is paid. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_39: <"FpML validation rule ird-39 - AdjustedExerciseDate must be before or equal to adjustedEarlyTerminationDate.">
        adjustedExerciseDate <= adjustedEarlyTerminationDate

    condition FpML_ird_40: <"FpML validation rule ird-40 - AdjustedExerciseDate must be before or equal to adjustedCashSettlementValuationDate.">
        adjustedExerciseDate <= adjustedCashSettlementValuationDate

    condition FpML_ird_41: <"FpML validation rule ird-41 - AdjustedCashSettlementValuationDate must be before or equal to adjustedCashSettlementPaymentDate.">
        adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type EarlyTerminationProvision: <"A data defining:  an early termination provision for a swap. This early termination is at fair value, i.e. on termination the fair value of the product must be settled between the parties.">
    [metadata key]

    mandatoryEarlyTermination MandatoryEarlyTermination (0..1) <"A mandatory early termination provision to terminate the swap at fair value.">
    mandatoryEarlyTerminationDateTenor Period (0..1) <"Period after trade date of the mandatory early termination date.">
    optionalEarlyTermination OptionalEarlyTermination (0..1) <"An option for either or both parties to terminate the swap at fair value.">
    optionalEarlyTerminationParameters ExercisePeriod (0..1) <"Definition of the first early termination date and the frequency of the termination dates subsequent to that. American exercise is defined by having a frequency of one day.">

    condition MandatoryEarlyTermination: <"The FpML MandatoryEarlyTermination.model specifies a required choice node. The choice node associated with the FpML EarlyTerminationProvision is quite complex and using the data rule provides a more flexible approach than adding complexity to the condition grammar.">
        (mandatoryEarlyTermination exists or optionalEarlyTermination exists)
            or (mandatoryEarlyTermination exists and optionalEarlyTermination exists)

type ExercisePeriod: <"This defines the time interval to the start of the exercise period, i.e. the earliest exercise date, and the frequency of subsequent exercise dates (if any).">
    [metadata key]

    earliestExerciseDateTenor Period (1..1) <"The time interval to the first (and possibly only) exercise date in the exercise period.">
    exerciseFrequency Period (0..1) <"The frequency of subsequent exercise dates in the exercise period following the earliest exercise date. An interval of 1 day should be used to indicate an American style exercise period.">

type ExtendibleProvision extends BuyerSeller: <"A data defining:  an option to extend an existing swap transaction on the specified exercise dates for a term ending on the specified new termination date. As a difference from FpML, it extends the BuyerSeller class, which represents the BuyerSeller.model.">

    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    extendibleProvisionAdjustedDates ExtendibleProvisionAdjustedDates (0..1) <"The adjusted dates associated with an extendible provision. These dates have been adjusted for any applicable business day convention.">
    callingParty CallingPartyEnum (0..1)
    singlePartyOption PartyRole (0..1) <"If the ability to extend the contract is not available to both parties then this component specifies the buyer and seller of the option.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before a contract is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionTerm RelativeDateOffset (0..1) <"The length of each extension period relative to the effective date of the preceding contract.">
    extensionPeriod AdjustableRelativeOrPeriodicDates (0..1) <"The period within which notice can be given that the contract will be extended.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the extendible provision, including details such as exercise style, exercise fees, and any other relevant conditions or terms governing the extension of the swap transaction.">

    condition ExtendibleProvisionExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyExtendibleProvision

type ExtendibleProvisionAdjustedDates: <"A data defining:  the adjusted dates associated with a provision to extend a swap.">

    extensionEvent ExtensionEvent (1..*) <"The adjusted dates associated with a single extendible exercise date.">

type ExtensionEvent: <"A data to:  define the adjusted dates associated with an individual extension event.">
    [metadata key]

    adjustedExerciseDate date (1..1) <"The date on which option exercise takes place. This date should already be adjusted for any applicable business day convention.">
    adjustedExtendedTerminationDate date (1..1) <"The termination date if an extendible provision is exercised. This date should already be adjusted for any applicable business day convention.">

    condition FpML_ird_42: <"FpML validation rule ird-42 - adjustedExerciseDate must be before adjustedExtendedTerminationDate.">
        adjustedExerciseDate < adjustedExtendedTerminationDate

type MandatoryEarlyTermination: <"A data to:  define an early termination provision for which exercise is mandatory.">
    [metadata key]

    mandatoryEarlyTerminationDate AdjustableDate (1..1) <"The early termination date associated with a mandatory early termination of a swap.">
    calculationAgent CalculationAgent (1..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (1..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    mandatoryEarlyTerminationAdjustedDates MandatoryEarlyTerminationAdjustedDates (0..1) <"The adjusted dates associated with a mandatory early termination provision. These dates have been adjusted for any applicable business day convention.">

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentMandatoryEarlyTermination

type MandatoryEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with a mandatory early termination provision.">

    adjustedEarlyTerminationDate date (1..1) <"The early termination date that is applicable if an early termination provision is exercised. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementValuationDate date (1..1) <"The date by which the cash settlement amount must be agreed. This date should already be adjusted for any applicable business day convention.">
    adjustedCashSettlementPaymentDate date (1..1) <"The date on which the cash settlement amount is paid. This date should already be adjusted for any applicable business date convention.">

    condition FpML_ird_44: <"FpML validation rule ird-44 - AdjustedEarlyTerminationDate must be before or equal to adjustedCashSettlementValuationDate must be before or the same as adjustedCashSettlementPaymentDate">
        adjustedEarlyTerminationDate <= adjustedCashSettlementValuationDate and adjustedCashSettlementValuationDate <= adjustedCashSettlementPaymentDate

type OptionalEarlyTermination: <"A data defining:  an early termination provision where either or both parties have the right to exercise.">

    singlePartyOption BuyerSeller (0..1) <"If optional early termination is not available to both parties then this component specifies the buyer and seller of the option. In FpML, this attribute is of type SinglePsrtyOption, which actually consists of the BuyerSeller.model.">
    mutualEarlyTermination boolean (0..1) <"Used for specifying whether the Mutual Early Termination Right that is detailed in the Master Confirmation will apply.">
    exerciseNotice ExerciseNotice (0..*) <"Definition of the party to whom notice of exercise should be given.">
    followUpConfirmation boolean (0..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    calculationAgent CalculationAgent (0..1) <"The ISDA Calculation Agent responsible for performing duties associated with an optional early termination.">
    cashSettlement SettlementTerms (0..1) <"If specified, this means that cash settlement is applicable to the transaction and defines the parameters associated with the cash settlement procedure. If not specified, then physical settlement is applicable.">
    optionalEarlyTerminationAdjustedDates OptionalEarlyTerminationAdjustedDates (0..1) <"An early termination provision to terminate the trade at fair value where one or both parties have the right to decide on termination.">
    exerciseTerms ExerciseTerms (1..1) <"The exercise terms associated with the optional early termination, including details such as exercise style, exercise fees, and any other relevant conditions or terms.">

    condition OptionalEarlyTerminationExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver contains AncillaryRoleEnum -> ExerciseNoticeReceiverPartyOptionalEarlyTermination

    condition MandatoryEarlyTerminationCalculationAgent:
        if calculationAgent -> calculationAgentParty exists
        then calculationAgent -> calculationAgentParty = AncillaryRoleEnum -> CalculationAgentOptionalEarlyTermination

type OptionalEarlyTerminationAdjustedDates: <"A data defining:  the adjusted dates associated with an optional early termination provision.">

    earlyTerminationEvent EarlyTerminationEvent (1..*) <"The adjusted dates associated with an individual early termination date.">

type AveragingFeature: <"As per ISDA 2002 Definitions.">
    averagingCalculation AveragingCalculation (1..1) <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    averagingInOut AveragingInOutEnum (1..1)
    strikeFactor number (0..1) <"The factor of strike.">
    averagingPeriodIn AveragingPeriod (0..1) <"The averaging in period.">
    averagingPeriodOut AveragingPeriod (0..1) <"The averaging out period.">

type AveragingCalculation: <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    averagingMethod AveragingCalculationMethod (1..1) <"Specifies enumerations for the type of averaging calculation.">
    precision Rounding (1..1) <"Rounding applied to the average calculation. ">

type AveragingStrikeFeature: <"Defines the terms required to calculate the average observations associated with an averaging strike.">
    averagingCalculation AveragingCalculation (1..1) <"Defines parameters for use in cases when a valuation or other term is based on an average of market observations.">
    observationTerms ObservationTerms (1..1) <"Class containing terms that are associated with observing a price/benchmark/index across either single or multple observations. ">

type Barrier: <"As per ISDA 2002 Definitions.">

    barrierCap TriggerEvent (0..1) <"A trigger level approached from beneath.">
    barrierFloor TriggerEvent (0..1) <"A trigger level approached from above.">

type CalendarSpread: <"A type for defining a calendar spread feature.">

    expirationDateTwo AdjustableOrRelativeDate (1..1)

type Composite: <"Specifies the conditions to be applied for converting into a reference currency when the actual currency rate is not determined upfront.">

    determinationMethod DeterminationMethodEnum (0..1) <"Specifies the method according to which an amount or a date is determined.">
    relativeDate RelativeDateOffset (0..1) <"A date specified as some offset to another date (the anchor date).">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type FxFeature: <"A type for defining FX Features.">

    referenceCurrency string (1..1) <"Specifies the reference currency of the trade.">
        [metadata id]
        [metadata scheme]
    composite Composite (0..1) <"If 'Composite' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price – Strike Price) / (Strike Price – Settlement Price) x Multiplier provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    quanto Quanto (0..1) <"If 'Quanto' is specified as the Settlement Type in the relevant Transaction Supplement, an amount, as determined by the Calculation Agent in accordance with the Section 8.2 of the Equity Definitions.">
    crossCurrency Composite (0..1) <"If 'Cross-Currency' is specified as the Settlement Type in the relevant Transaction Supplement, an amount in the Settlement Currency, determined by the Calculation Agent as being equal to the number of Options exercised or deemed exercised, multiplied by: (Settlement Price – Strike Price) / (Strike Price – Settlement Price) x Multiplier x one unit of the Reference Currency converted into an amount in the Settlement Currency using the rate of exchange of the Settlement Currency as quoted on the Reference Price Source on the Valuation Date, provided that if the above is equal to a negative amount the Option Cash Settlement Amount shall be deemed to be zero.">
    condition FxFeatureChoice: <" Choice rule to represent an FpML choice construct.">
        required choice composite, quanto, crossCurrency

type Knock: <"Knock In means option to exercise comes into existence. Knock Out means option to exercise goes out of existence.">

    knockIn TriggerEvent (0..1) <"The knock in.">
    knockOut TriggerEvent (0..1) <"The knock out.">

type OptionFeature: <"Defines additional optional features that can be included in an option contract.">

    fxFeature FxFeature (0..*) <"Describes a quanto or composite FX feature.">
    strategyFeature StrategyFeature (0..1) <"Defines a simple strategy feature.">
    averagingFeature AveragingFeature (0..1) <"Defines an option feature in which an average market observation price is determined on valuation and compared to the strike to determine a settlement amount.">
    barrier Barrier (0..1) <"Specifies a barrier feature.">
    knock Knock (0..1) <"Specifies a knock in or knock out feature.">
    passThrough PassThrough (0..1) <"Specifies the rules for pass-through payments from the underlier, such as dividends.">

type TerminationProvision: <"A class for defining option provisions.">
    cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">
    earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">
    evergreenProvision EvergreenProvision (0..1) <"A data defining: the right of a party to exercise an Evergreen option">
    extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">

    condition TerminationProvisionChoice:
        required choice cancelableProvision, extendibleProvision, evergreenProvision, earlyTerminationProvision

type OptionStrike: <"Defines the strike price of an option.">

    strikePrice Price (0..1) <"Defines the strike of an option in the form of a price that could be a cash price, interestRate, or other types.">
    strikeReference FixedRateSpecification (0..1) <"Defines the strike of an option in reference to the spread of the underlying swap (typical practice in the case of an option on a credit single name swaps).">
        [metadata reference]
    referenceSwapCurve ReferenceSwapCurve (0..1) <"Defines the strike of an option when expressed by reference to a swap curve (Typically the case for a convertible bond option).">
    averagingStrikeFeature AveragingStrikeFeature (0..1) <"Defines an  option strike that is calculated from an average of observed market prices.">

    condition:
        one-of

type PassThrough: <"Type which contains pass through payments.">

    passThroughItem PassThroughItem (1..*) <"One to many pass through payment items.">

type PassThroughItem: <"Class to represent a single pass through payment.">

    payerReceiver PayerReceiver (1..1) <"This attribute doesn't exists in the FpML construct, which makes use of the PayerReceiver.model group.">
    passThroughPercentage number (1..1) <"Percentage of payments from the underlier which are passed through.">

type Quanto: <"Determines the currency rate that the seller of the equity amounts will apply at each valuation date for converting the respective amounts into a currency that is different from the currency denomination of the underlier.">

    fxRate FxRate (0..*) <"Specifies a currency conversion rate.">
    fxSpotRateSource FxSpotRateSource (0..1) <"Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.">
    fixingTime BusinessCenterTime (0..1) <"The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.">

type StrategyFeature: <"A class for defining option strategy features.">

    strikeSpread StrikeSpread (0..1) <"Definition of the upper strike in a strike spread.">
    calendarSpread CalendarSpread (0..1) <"Definition of the later expiration date in a calendar spread.">

type StrikeSpread: <"A class for defining a strike spread feature.">

    upperStrike OptionStrike (1..1) <"Upper strike in a strike spread.">
    upperStrikeNumberOfOptions number (1..1) <"Number of options at the upper strike price in a strike spread.">

type ExerciseTerms: <"A class defining the exercise period for an option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.">
    [metadata key]

    style OptionExerciseStyleEnum (0..1) <"Whether the option has a single exercise (european), multiple exercise dates (bermuda), or a continuous range of exercise (american).">
    commencementDate AdjustableOrRelativeDate (0..1) <"The first day of the exercise period for an American style option.">
    exerciseDates AdjustableOrRelativeDates (0..1) <"The dates that define the Bermuda option exercise dates and the expiration date. The last specified date is assumed to be the expiration date. The dates can either be specified as a series of explicit dates and associated adjustments or as a series of dates defined relative to another schedule of dates, for example, the calculation period start dates. Where a relative series of dates are defined the first and last possible exercise dates can be separately specified.">
    expirationDate AdjustableOrRelativeDate (0..*) <"The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.">
    relevantUnderlyingDate AdjustableOrRelativeDates (0..1) <"The effective date on the underlying product if the option is exercised.  For example, for a swaption it is the swap effective date, for an option on an FX spot or forward it is the value date for settlement, and in an extendible/cancelable provision it is the swap termination date, which is the date on which the termination is effective.'">
    earliestExerciseTime BusinessCenterTime (0..1) <"The earliest time at which notice of exercise can be given by the buyer to the seller (or seller's agent) to, and including, the expiration date.">
    latestExerciseTime BusinessCenterTime (0..1) <"For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller's agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.">
    expirationTime BusinessCenterTime (0..1) <"The latest time for exercise on expirationDate. It is made mandatory given that for all option styles, this field is required.">
    expirationTimeType ExpirationTimeTypeEnum (1..1) <"The time of day at which the equity option expires, for example the official closing time of the exchange.">
    multipleExercise MultipleExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">
    exerciseFeeSchedule ExerciseFeeSchedule (0..1) <"The fees associated with an exercise date. The fees are conditional on the exercise occurring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.">
    exerciseProcedure ExerciseProcedure (0..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">
    exerciseFee ExerciseFee (0..1) <"A fee to be paid on exercise. This could be represented as an amount or a rate and notional reference on which to apply the rate.">
    partialExercise PartialExercise (0..1) <"As defined in the 2000 ISDA Definitions, Section 12.3. Partial Exercise, the buyer of the option has the right to exercise all or less than all the notional amount of the underlying swap on the expiration date, but may not exercise less than the minimum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.">

    condition ExerciseDateExpirationDateChoice: <"Required choice rule between exercise dates and expiration date. The exerciseDates field can be used to extract the expiration date of a bermuda option, while the expirationDate field refers to the expiration date of an american or european option.">
        required choice exerciseDates, expirationDate

    condition CommencementAndExpirationDate: <"Condition to check that expiration date is present when commencement date is present.">
        if commencementDate exists then expirationDate exists

    condition AmericanExercise: <"Condition to check that only fields expected for an american option are present.">
        if style = OptionExerciseStyleEnum -> American
        then commencementDate exists
                and exerciseFee is absent
                and partialExercise is absent
                and expirationDate count = 1

    condition EuropeanExercise: <"Condition to check that only fields expected for a european option are present.">
        if style = OptionExerciseStyleEnum -> European
        then expirationDate exists
                and exerciseFeeSchedule is absent
                and multipleExercise is absent
                and latestExerciseTime is absent
                and commencementDate is absent

    condition BermudaExercise: <"Condition to check that only fields expected for a bermuda option are present.">
        if style = OptionExerciseStyleEnum -> Bermuda
        then exerciseDates exists
                and earliestExerciseTime exists
                and partialExercise is absent
                and exerciseFee is absent

    condition ExpirationTimeChoice: <"Condition to validate the correlation between expirationTime and expirationTimeType">
        (if expirationTime exists
        then expirationTimeType = ExpirationTimeTypeEnum -> SpecificTime
                and if expirationTimeType = ExpirationTimeTypeEnum -> SpecificTime
                    then expirationTime exists)

type AutomaticExercise: <"A type to define automatic exercise of a swaption. With automatic exercise the option is deemed to have exercised if it is in the money by more than the threshold amount on the exercise date.">

    thresholdRate number (0..1) <"A threshold rate. The threshold of 0.10% would be represented as 0.001">
    isApplicable boolean (0..1) <"Boolean that indicates if it has an automaticExercise">

type ExerciseFee extends PayerReceiver: <"A class defining the fee payable on exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmount number (0..1) <"The amount of fee to be paid on exercise. The fee currency is that of the referenced notional.">
    feeRate number (0..1) <"A fee represented as a percentage of some referenced notional. A percentage of 5% would be represented as 0.05.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmount, feeRate

type ExerciseFeeSchedule extends PayerReceiver: <"A class to define a fee or schedule of fees to be payable on the exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised. As a difference with FpML, it extends the BuyerSeller class.">

    notionalReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document.">
        [metadata reference]
    feeAmountSchedule AmountSchedule (0..1) <"The exercise fee amount schedule. The fees are expressed as currency amounts. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feeRateSchedule Schedule (0..1) <"The exercise free rate schedule. The fees are expressed as percentage rates of the notional being exercised. The currency of the fee is assumed to be that of the notional schedule referenced.">
    feePaymentDate RelativeDateOffset (1..1) <"The date on which exercise fee(s) will be paid. It is specified as a relative date.">

    condition ExerciseFeeScheduleChoice: <"Choice rule to represent an FpML choice construct.">
        required choice feeAmountSchedule, feeRateSchedule

type ExerciseNotice: <"Defines to whom and where notice of execution should be given. The exerciseNoticeGiver refers to one or both of the principal parties of the trade. If present the exerciseNoticeReceiver refers to a party, other than the principal party, to whom notice should be given.">

    exerciseNoticeGiver ExerciseNoticeGiverEnum (1..1) <"Specifies the principal party of the trade that has the right to exercise.">
    exerciseNoticeReceiver AncillaryRoleEnum (0..1) <"Specifies the party to which notice of exercise should be given, e.g. by the buyer of the option. Although in many cases it is the buyer of the option who sends the exercise notice to the seller of the option, this component is reused, e.g. in case of OptionEarlyTermination, either or both parties have the right to exercise.">
    businessCenter BusinessCenterEnum (1..1) <"Specifies the location where the exercise must be reported, e.g. where the exercise notice receiver is based.">
        [metadata scheme]

type ExerciseProcedure: <"A class describing how notice of exercise should be given. This can be either manual or automatic.">

    manualExercise ManualExercise (0..1) <"Specifies that the notice of exercise must be given by the buyer to the seller or seller's agent.">
    automaticExercise AutomaticExercise (0..1) <"If automatic is specified, then the notional amount of the underlying swap not previously exercised under the swaption will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than the specified threshold rate. The term in-the-money is assumed to have the meaning defining in the 2000 ISDA Definitions, Section 17.4 In-the-money.">
    followUpConfirmation boolean (1..1) <"A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller's agent.">
    limitedRightToConfirm boolean (0..1) <"Has the meaning defined as part of the 1997 ISDA Government Bond Option Definitions, section 4.5 Limited Right to Confirm Exercise. If present, (i) the Seller may request the Buyer to confirm its intent if not done on or before the expiration time on the Expiration date (ii) specific rules will apply in relation to the settlement mode.">
    splitTicket boolean (0..1) <"Typically applicable to the physical settlement of bond and convertible bond options. If present, means that the party required to deliver the bonds will divide those to be delivered as notifying party desires to facilitate delivery obligations.">

    condition ExerciseProcedureChoice: <"Choice rule to represent an FpML choice construct.">
        required choice manualExercise, automaticExercise

type ManualExercise: <"A class defining manual exercise, i.e. that the option buyer counterparty must give notice to the option seller of exercise.">

    exerciseNotice ExerciseNotice (0..1) <"Definition of the party to whom notice of exercise should be given.">
    fallbackExercise boolean (0..1) <"If fallback exercise is specified then the notional amount of the underlying swap, not previously exercised under the swaption, will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than one tenth of a percentage point (0.10% or 0.001). The term in-the-money is assumed to have the meaning defined in the 2000 ISDA Definitions, Section 17.4. In-the-money.">

    condition ManualExerciseNoticeReceiverParty:
        if exerciseNotice -> exerciseNoticeReceiver exists
        then exerciseNotice -> exerciseNoticeReceiver = AncillaryRoleEnum -> ExerciseNoticeReceiverPartyManual

type MultipleExercise extends PartialExercise: <"A class defining multiple exercises. As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more than the maximum notional amount, and if an integral multiple amount is specified, the notional exercised must be equal to or, be an integral multiple of, the integral multiple amount. In FpML, MultipleExercise is built upon the PartialExercise.model.">

    maximumNotionalAmount number (0..1) <"The maximum notional amount that can be exercised on a given exercise date.">
    maximumNumberOfOptions int (0..1) <"The maximum number of options that can be exercised on a given exercise date. If the number is not specified, it means that the maximum number of options corresponds to the remaining unexercised options.">

    condition MaximumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice maximumNotionalAmount, maximumNumberOfOptions

    condition MaximumNumberOfOptions: <"FpML MultipleExercise construct specifies the maximumNumberOfOptions as a positive integer.">
        if maximumNumberOfOptions exists
        then maximumNotionalAmount >= 0

    condition MinimumNumberOfOptions: <"FpML MultipleExercise construct specifies the minimumNumberOfOptions as a positive integer.">
        if minimumNumberOfOptions exists
        then minimumNumberOfOptions >= 0

type PartialExercise: <"A class defining partial exercise. As defined in the 2000 ISDA Definitions, Section 12.3 Partial Exercise, the buyer of the option may exercise all or less than all the notional amount of the underlying swap but may not be less than the minimum notional amount (if specified) and must be an integral multiple of the integral multiple amount if specified.">

    notionaReference Money (1..1) <"A pointer style reference to the associated notional schedule defined elsewhere in the document. This element has been made optional as part of its integration in the OptionBaseExtended, because not required for the options on securities.">
        [metadata reference]
    integralMultipleAmount number (0..1) <"A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exercise is applicable. The integral multiple amount defines a lower limit of notional that can be exercised and also defines a unit multiple of notional that can be exercised, i.e. only integer multiples of this amount can be exercised.">
    minimumNotionalAmount number (0..1) <"The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.">
    minimumNumberOfOptions int (0..1) <"The minimum number of options that can be exercised on a given exercise date.">

    condition MinimumChoice: <"Choice rule to represent an FpML choice construct.">
        required choice minimumNotionalAmount, minimumNumberOfOptions

type Strike: <"A class describing a single cap or floor rate.">
    [metadata key]

    strikeRate number (1..1) <"The rate for a cap or floor.">
        [synonym FIX_5_0_SP2 value "StrikePrice" tag 202]
    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type StrikeSchedule extends RateSchedule: <"A class describing a schedule of cap or floor rates.">

    buyer PayerReceiverEnum (0..1) <"The buyer of the option.">
    seller PayerReceiverEnum (0..1) <"The party that has sold.">

type AssetPayout extends PayoutBase: <"Security finance payout specification in case the product payout involves some form of security collateral, as in a securities financing transaction. Plus additional description for ICMA.">
    assetLeg AssetLeg (1..*) <"Defines each asset movement as a buy/sell at different dates, typically 1 near leg and 1 far leg in a securities financing transaction.">
    underlier Asset (1..1) <"Specifies the Purchased Asset, usually a Security.">
    // [metadata address "pointsTo"=PriceQuantity->observable->Asset->Instrument->Security]
    minimumFee Money (0..1) <"A contractual minimum amount which the borrower will pay, regardless of the duration of the loan. A mechanism for making sure that a trade generates enough income.">
    dividendTerms DividendTerms (0..1) <"Specifies the terms under which dividends received by the borrower are passed through to the lender.">
    tradeType AssetPayoutTradeTypeEnum (0..1) <"The trade type, eg repurchase transaction or buy/sell-back.">

    condition Quantity: <"When there is an OptionPayout the quantity can be expressed as part of the payoutQuantity, or as part of the underlier in the case of a Swaption.  For all other payouts that extend PayoutBase the payoutQuantity is a mandatory attribute.">
        priceQuantity exists

    condition UnderlierNotCash: <"The purchased asset in an assetPayout should not be cash.">
        underlier -> Cash is absent

type DividendTerms: <"Information related to dividends and payments.">
    manufacturedIncomeRequirement DividendPayoutRatio (1..1) <"Specifies the proportion of the value of the dividend on the borrowed shares that the borrower is legally obligated to return to the lender.">
    dividendEntitlement DividendEntitlementEnum (0..1) <"Defines the date on which the receiver of the equity return is entitled to the dividend.">
    minimumBillingAmount Money (0..1) <"daily fee increments accrue until a threshold is crossed, at which point payment becomes due)">

type AssetLeg: <"Defines each asset movement of an asset payout.">
    settlementDate AdjustableOrRelativeDate (1..1) <"Specifies the settlement date of securities.  In a repo transaction the purchase date would always be the effective date as specified under Economic Terms, the repurchase date would always be the termination date as specified under Economic Terms.">
    deliveryMethod DeliveryMethodEnum (1..1) <"Specifies a delivery method for the security transaction.">

type EvergreenProvision: <"Specifies a transaction which automatically extends for a specified timeframe until the exercise of an embedded option.">
    singlePartyOption PartyRole (0..1) <"If evergreen termination is not available to both parties then this component specifies the buyer and seller of the option.">
    noticePeriod RelativeDateOffset (1..1) <"The length of each evergreen extension period relative to the effective date of the preceding contract.">
    noticeDeadlinePeriod RelativeDateOffset (0..1) <"Defines the minimum period before an evergreen is scheduled to terminate that notice can be given that it will terminate beyond the scheduled termination date.">
    noticeDeadlineDateTime zonedDateTime (0..1) <"A specific date and time for the notice deadline">
    extensionFrequency AdjustableRelativeOrPeriodicDates (1..1) <"The frequency with which the evergreen contract will be extended if notice is not given.">
    finalPeriodFeeAdjustment Price (0..1) <"An optional adjustment to the rate for the last period of the evergreen i.e. the period from when notice is given to stop rolling the contract through to the termination date.">


================================================================================
FILE: rosetta-source/src/main/rosetta/regulation-type.rosetta
================================================================================

namespace cdm.regulation : <"Regulatory reporting concepts: regulatory rules, report definitions, reporting formats.">
version "${project.version}"

import cdm.mapping.config.*

type Document:

    finInstrmRptgTxRpt FinInstrmRptgTxRpt (1..1)
        [synonym ISO20022 value "FinInstrmRptgTxRpt"]

type FinInstrmRptgTxRpt:

    tx Tx (1..1)
        [synonym ISO20022 value "Tx"]

type Tx:

    newTx New (1..1)
        [synonym ISO20022 value "New"]
    tradDt string (1..1)
        [synonym ISO20022 value "TradDt"]
    tradgCpcty string (1..1)
        [synonym ISO20022 value "TradgCpcty"]
    qty Qty (1..1)
        [synonym ISO20022 value "Qty"]
    pric Pric (1..1)
        [synonym ISO20022 value "Pric"]
    tradVn string (1..1)
        [synonym ISO20022 value "TradVn"]
    ctryOfBrnch string (1..1)
        [synonym ISO20022 value "CtryOfBrnch"]

type New:

    txId string (1..1)
        [synonym ISO20022 value "TxId"]
    exctgPty string (1..1)
        [synonym ISO20022 value "ExctgPty"]
    invstmtPtyInd string (1..1)
        [synonym ISO20022 value "InvstmtPtyInd"]
    submitgPty string (1..1)
        [synonym ISO20022 value "SubmitgPty"]
    buyr Buyr (1..1)
        [synonym ISO20022 value "Buyr"]
    sellr Sellr (1..1)
        [synonym ISO20022 value "Sellr"]
    ordrTrnsmssn OrdrTrnsmssn (1..1)
        [synonym ISO20022 value "OrdrTrnsmssn"]
    tx Tx (1..1)
        [synonym ISO20022 value "Tx"]
    finInstrm FinInstrm (1..1)
        [synonym ISO20022 value "FinInstrm"]
    invstmtDcsnPrsn InvstmtDcsnPrsn (1..1)
        [synonym ISO20022 value "InvstmtDcsnPrsn"]
    exctgPrsn ExctgPrsn (1..1)
        [synonym ISO20022 value "ExctgPrsn"]
    addtlAttrbts AddtlAttrbts (1..1)
        [synonym ISO20022 value "AddtlAttrbts"]

type Sellr:

    acctOwnr AcctOwnr (1..1)
        [synonym ISO20022 value "AcctOwnr"]

type Sngl:

    isin string (1..1)
        [synonym ISO20022 value "ISIN"]
    indx Indx (1..1)
        [synonym ISO20022 value "Indx"]

type OrdrTrnsmssn:

    trnsmssnInd string (1..1)
        [synonym ISO20022 value "TrnsmssnInd"]

type DerivInstrmAttrbts:

    xpryDt string (1..1)
        [synonym ISO20022 value "XpryDt"]
    pricMltplr string (1..1)
        [synonym ISO20022 value "PricMltplr"]
    undrlygInstrm UndrlygInstrm (1..1)
        [synonym ISO20022 value "UndrlygInstrm"]
    dlvryTp string (1..1)
        [synonym ISO20022 value "DlvryTp"]

type UndrlygInstrm:

    swp Swp (1..1)
        [synonym ISO20022 value "Swp"]

type AcctOwnr:

    id Id (1..1)
        [synonym ISO20022 value "Id"]

type InvstmtDcsnPrsn:

    prsn Prsn (1..1)
        [synonym ISO20022 value "Prsn"]

type Buyr:

    acctOwnr AcctOwnr (1..1)
        [synonym ISO20022 value "AcctOwnr"]

type Qty:

    unit string (1..1)
        [synonym ISO20022 value "Unit"]

type FinInstrm:

    othr Othr (1..1)
        [synonym ISO20022 value "Othr"]

type Pric:

    pric Pric (1..1)
        [synonym ISO20022 value "Pric"]
    bsisPts string (1..1)
        [synonym ISO20022 value "BsisPts"]

type Prsn:

    ctryOfBrnch string (1..1)
        [synonym ISO20022 value "CtryOfBrnch"]
    othr Othr (1..1)
        [synonym ISO20022 value "Othr"]

type FinInstrmGnlAttrbts:

    fullNm string (1..1)
        [synonym ISO20022 value "FullNm"]
    clssfctnTp string (1..1)
        [synonym ISO20022 value "ClssfctnTp"]
    ntnlCcy string (1..1)
        [synonym ISO20022 value "NtnlCcy"]

type Nm:

    refRate RefRate (1..1)
        [synonym ISO20022 value "RefRate"]
    term Term (1..1)
        [synonym ISO20022 value "Term"]

type SwpOut:

    sngl Sngl (1..1)
        [synonym ISO20022 value "Sngl"]

type Othr:

    finInstrmGnlAttrbts FinInstrmGnlAttrbts (1..1)
        [synonym ISO20022 value "FinInstrmGnlAttrbts"]
    derivInstrmAttrbts DerivInstrmAttrbts (1..1)
        [synonym ISO20022 value "DerivInstrmAttrbts"]
    id string (1..1)
        [synonym ISO20022 value "Id"]
    schmeNm SchmeNm (1..1)
        [synonym ISO20022 value "SchmeNm"]

type ExctgPrsn:

    prsn Prsn (1..1)
        [synonym ISO20022 value "Prsn"]

type Term:

    unit string (1..1)
        [synonym ISO20022 value "Unit"]
    val string (1..1)
        [synonym ISO20022 value "Val"]

type Swp:

    swpIn SwpIn (1..1)
        [synonym ISO20022 value "SwpIn"]
    swpOut SwpOut (1..1)
        [synonym ISO20022 value "SwpOut"]

type SchmeNm:

    prtry string (1..1)
        [synonym ISO20022 value "Prtry"]

type RefRate:

    indx string (1..1)
        [synonym ISO20022 value "Indx"]
    nm string (1..1)
        [synonym ISO20022 value "Nm"]

type AddtlAttrbts:

    rskRdcgTx string (1..1)
        [synonym ISO20022 value "RskRdcgTx"]
    sctiesFincgTxInd string (1..1)
        [synonym ISO20022 value "SctiesFincgTxInd"]

type SwpIn:

    sngl Sngl (1..1)
        [synonym ISO20022 value "Sngl"]

type Indx:

    nm Nm (1..1)
        [synonym ISO20022 value "Nm"]

type Id:

    lei string (1..1)
        [synonym ISO20022 value "LEI"]
